

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overview of Embedded Boundary Description &mdash; amrex 20.01-dev documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="GPU" href="GPU_Chapter.html" />
    <link rel="prev" title="Embedded Boundaries" href="EB_Chapter.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                20.01-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics_Chapter.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particle_Chapter.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Overview of Embedded Boundary Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#finite-volume-discretizations">Finite Volume Discretizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#small-cells-and-stability">Small Cells And Stability</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-the-geometric-database">Initializing the Geometric Database</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implicit-function">Implicit Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eb2-geometryshop"><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#eb2-indexspace"><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ebfarrayboxfactory">EBFArrayBoxFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#eb-data">EB Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ebcellflagfab"><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linear-solvers">Linear Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorials">Tutorials</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="EB_Chapter.html">Embedded Boundaries</a> &raquo;</li>
        
      <li>Overview of Embedded Boundary Description</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/EB.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overview-of-embedded-boundary-description">
<span id="sec-eb-eboverview"></span><h1>Overview of Embedded Boundary Description<a class="headerlink" href="#overview-of-embedded-boundary-description" title="Permalink to this headline">¶</a></h1>
<p>For computations with complex geometries, AMReX provides data structures and
algorithms to employ an embedded boundary (EB) approach to PDE discretizations.
In this approach, the underlying computational mesh is uniform and
block-structured, but the boundary of the irregular-shaped computational domain
conceptually cuts through this mesh. Each cell in the mesh becomes labeled as
regular, cut or covered, and the finite-volume based discretization methods
traditionally used in AMReX applications can be modified to incorporate these
cell shapes. See <a class="reference internal" href="#fig-ebexample"><span class="std std-numref">Fig. 13</span></a> for an illustration.</p>
<div class="figure align-default" id="id1">
<span id="fig-ebexample"></span><a class="reference internal image-reference" href="_images/EB_example.png"><img alt="_images/EB_example.png" src="_images/EB_example.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">: In the embedded boundary approach to discretizing PDEs, the (uniform)
rectangular mesh is cut by the irregular shape of the computational domain.
The cells in the mesh are label as regular, cut or covered.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>Because this is a relatively simple grid generation technique, computational
meshes for rather complex geometries can be generated quickly and robustly.
However, the technique can produce arbitrarily small cut cells in the domain.
In practice such small cells can have significant impact on the robustness and
stability of traditional finite volume methods. In this chapter we overview a
class of approaches to deal with this “small cell” problem in a robust and
efficient way, and discuss the tools and data that AMReX provides in order to
implement them.</p>
<p>Note that in a completely general implementation of the EB approach, there
would be no restrictions on the shape or complexity of the EB surface.  With
this generality comes the possibility that the process of “cutting” the cells
results in a single <span class="math notranslate nohighlight">\((i,j,k)\)</span> cell being broken into multiple cell
fragments.  The current release of AMReX does not support multi-valued cells,
thus there is a practical restriction on the complexity of domains (and
numerical algorithms) supported.</p>
<p>This chapter discusses the EB tools, data structures and algorithms currently
supported by AMReX to enable the construction of discretizations of
conservation law systems. The discussion will focus on general requirements
associated with building fluxes and taking divergences of them to advance such
systems. We also give examples of how to initialize the geometry data
structures and access them to build the numerical difference
operators.  Finally we present EB support of linear solvers.</p>
<div class="section" id="finite-volume-discretizations">
<h2>Finite Volume Discretizations<a class="headerlink" href="#finite-volume-discretizations" title="Permalink to this headline">¶</a></h2>
<p>Consider a system of PDEs to advance a conserved quantity <span class="math notranslate nohighlight">\(U\)</span> with fluxes
<span class="math notranslate nohighlight">\(F\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eqn-hypsys">
<span class="eqno">(2)<a class="headerlink" href="#equation-eqn-hypsys" title="Permalink to this equation">¶</a></span>\[\frac{\partial U}{\partial t} + \nabla \cdot F = 0.\]</div>
<p>A conservative, finite volume discretization starts with the divergence theorm</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot F dV = \int_{\partial V} F \cdot n dA.\]</div>
<p>In an embedded boundary cell, the “conservative divergence” is discretized (as
<span class="math notranslate nohighlight">\(D^c(F)\)</span>) as follows</p>
<div class="math notranslate nohighlight" id="equation-eqn-ebdiv">
<span class="eqno">(3)<a class="headerlink" href="#equation-eqn-ebdiv" title="Permalink to this equation">¶</a></span>\[ D^c(F) = \frac{1}{\kappa h} \left( \sum^D_{d = 1}
   (F_{d, \mathrm{hi}} \, \alpha_{d, \mathrm{hi}} - F_{d, \mathrm{lo}}\, \alpha_{d, \mathrm{lo}})
   + F^{EB} \alpha^{EB} \right).\]</div>
<p>Geometry is discretely represented by volumes (<span class="math notranslate nohighlight">\(V = \kappa h^d\)</span>) and
apertures (<span class="math notranslate nohighlight">\(A= \alpha h^{d-1}\)</span>), where <span class="math notranslate nohighlight">\(h\)</span> is the (uniform) mesh
spacing at that AMR level, <span class="math notranslate nohighlight">\(\kappa\)</span> is the volume fraction and
<span class="math notranslate nohighlight">\(\alpha\)</span> are the area fractions. Without multivalued cells the volume
fractions, area fractions and cell and face centroids (see
<a class="reference internal" href="#fig-volume"><span class="std std-numref">Table 10</span></a>) are the only geometric information needed to compute
second-order fluxes centered at the face centroids, and to infer the
connectivity of the cells. Cells are connected if adjacent on the Cartesian
mesh, and only via coordinate-aligned faces on the mesh. If an aperture,
<span class="math notranslate nohighlight">\(\alpha = 0\)</span>, between two cells, they are not directly connected to each
other.</p>
<span id="fig-volume"></span><table class="docutils align-center" id="id2">
<caption><span class="caption-number">Table 10 </span><span class="caption-text">Illustration of embedded boundary cutting a two-dimensional cell.</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="_images/areas_and_volumes.png"><img alt="a" src="_images/areas_and_volumes.png" style="width: 100%;" /></a></p></td>
<td><p><a class="reference internal" href="_images/eb_fluxes.png"><img alt="b" src="_images/eb_fluxes.png" style="width: 100%;" /></a></p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">A typical two-dimensional uniform cell that is</div>
<div class="line">cut by the embedded boundary. The grey area</div>
<div class="line">represents the region excluded from the</div>
<div class="line">calculation. The portion of the cell faces</div>
<div class="line">faces (labelled with A) through which fluxes</div>
<div class="line">flow are the “uncovered” regions of the full</div>
<div class="line">cell faces. The volume (labelled V) is the</div>
<div class="line">uncovered region of the interior.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Fluxes in a cut cell.</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="small-cells-and-stability">
<h2>Small Cells And Stability<a class="headerlink" href="#small-cells-and-stability" title="Permalink to this headline">¶</a></h2>
<p>In the context of time-explicit advance methods for, say hyperbolic
conservation laws, a naive discretization in time of <a class="reference internal" href="#equation-eqn-hypsys">(2)</a> using
<a class="reference internal" href="#equation-eqn-ebdiv">(3)</a>,</p>
<div class="math notranslate nohighlight">
\[U^{n+1} = U^{n} - \delta t D^c(F)\]</div>
<p>would have a time step constraint <span class="math notranslate nohighlight">\(\delta t \sim h \kappa^{1/D}/V_m\)</span>,
which goes to zero as the size of the smallest volume fraction <span class="math notranslate nohighlight">\(\kappa\)</span> in
the calculation. Since EB volume fractions can be arbitrarily small, this is an
unacceptable constraint. One way to remedy this is to create “non-conservative”
approximation to the divergence <span class="math notranslate nohighlight">\(D^{nc}\)</span>, which at a cell <span class="math notranslate nohighlight">\({\bf i}\)</span>,
can be formed as an average of the conservative divergences in the neighborhood,
<span class="math notranslate nohighlight">\(N_{\bf i}\)</span>, of <span class="math notranslate nohighlight">\({\bf i}\)</span>.</p>
<div class="math notranslate nohighlight">
\[D^{nc}(F)_{\bf i}= \frac{\sum_{{\bf j}\in N_{\bf i}}\kappa_{\bf j}D(F)_{\bf j}}{\sum_{{\bf j}\in N_{\bf i}}\kappa_{\bf j}}\]</div>
<p>Incorporating this form, the solution can be updated using a <em>hybrid
divergence</em>, <span class="math notranslate nohighlight">\(D^H(F) = \kappa D^c(F) + (1-\kappa)D^{nc}\)</span>:</p>
<div class="math notranslate nohighlight">
\[U^{n+1,*} = U^n - \delta t D^H(F)\]</div>
<p>However, we would like our finite-volume scheme to strictly conserve the field
quantities over the domain. To enforce this, we calculate <span class="math notranslate nohighlight">\(\delta M\)</span>, the
mass gained or lost by not using <span class="math notranslate nohighlight">\(D^c\)</span> directly,</p>
<div class="math notranslate nohighlight">
\[\delta M_{\bf i}= \kappa (1-\kappa)(D^c(F)_{\bf i}- D^{nc}(F)_{\bf i})\]</div>
<p>This “excess material” (mass, if <span class="math notranslate nohighlight">\(U=\rho\)</span>) can be <em>redistributed</em> in a
time-explicit fashion to neighboring cells, <span class="math notranslate nohighlight">\({\bf j}\in N_{\bf i}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\delta M_{\bf i}= \sum_{{\bf j}\in N_{\bf i}} \delta M_{{\bf j}, {\bf i}}.\]</div>
<p>in order to preserve strict conservation over <span class="math notranslate nohighlight">\(N_{\bf i}\)</span>.</p>
<p>Note that the physics at hand may impact the optimal choice of precisely how the
excess mass is distributed in this fashion. We introduce a weighting for
redistribution, <span class="math notranslate nohighlight">\(W\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-eqn-massweight">
<span class="eqno">(4)<a class="headerlink" href="#equation-eqn-massweight" title="Permalink to this equation">¶</a></span>\[ \delta M_{{\bf j}, {\bf i}} =  \frac{\delta M_{\bf i}\kappa_{\bf j}
   W_{\bf j}}{\sum_{{\bf k}\in N_{\bf i}} \kappa_{\bf k}W_{\bf k}}\]</div>
<p>For all <span class="math notranslate nohighlight">\({\bf j}\in N_{\bf i}\)</span>,</p>
<div class="math notranslate nohighlight">
\[U^{n+1}_{\bf j}= U^{n+1,*}_{\bf j}+
 \frac{\delta M_{\bf i}
  W_{\bf j}}{\sum_{{\bf k}\in N_{\bf i}} \kappa_{\bf k}W_{\bf k}}.\]</div>
<p>Typically, the redistribution neighborhood for each cell is one that can be
reached via a monotonic path in each coordinate direction of unit length (see,
e.g., <a class="reference internal" href="#fig-redistribution"><span class="std std-numref">Fig. 14</span></a>)</p>
<div class="figure align-default" id="id3">
<span id="fig-redistribution"></span><a class="reference internal image-reference" href="_images/redist.png"><img alt="_images/redist.png" src="_images/redist.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">: Redistribution illustration. Excess mass due to using a hybrid divergence
<span class="math notranslate nohighlight">\(D^H\)</span> instead of the conservative divergence <span class="math notranslate nohighlight">\(D^C\)</span> is
distributed to neighbor cells.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="initializing-the-geometric-database">
<span id="sec-eb-ebinit"></span><h1>Initializing the Geometric Database<a class="headerlink" href="#initializing-the-geometric-database" title="Permalink to this headline">¶</a></h1>
<p>In AMReX geometric information is stored in a distributed database
class that must be initialized at the start of the calculation. The
procedure for this goes as follows:</p>
<ul class="simple">
<li><p>Define an implicit function of position which describes the surface of the
embedded object. Specifically, the function class must have a public member
function that takes a position and returns a negative value if that position
is inside the fluid, a positive value in the body, and identically zero at the
embedded boundary.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Make a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code> object using the implicit function.</p></li>
<li><p>Build an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> with the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code> object and a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> object that contains the information about the domain and the
mesh.</p></li>
</ul>
<p>Here is a simple example of initialize the database for an embedded sphere.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">center</span><span class="p">{</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">};</span> <span class="c1">//Center of the sphere</span>
<span class="kt">bool</span> <span class="n">inside</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// Is the fluid inside the sphere?</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span> <span class="n">sphere</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">inside</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">shop</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeShop</span><span class="p">(</span><span class="n">sphere</span><span class="p">);</span>

<span class="n">Geometry</span> <span class="nf">geom</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">Build</span><span class="p">(</span><span class="n">shop</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="implicit-function">
<span id="sec-eb-ebinit-if"></span><h2>Implicit Function<a class="headerlink" href="#implicit-function" title="Permalink to this headline">¶</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">amrex/Src/EB/</span></code>, there are a number of predefined implicit function classes
for basic shapes. One can use these directly or as template for their own
classes.</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AllRegularIF</span></span></code>:  No embedded boundaries at all.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxIF</span></span></code>: Box.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">CylinderIF</span></span></code>: Cylinder.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EllipsoidIF</span></span></code>: Ellipsoid.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">PlaneIF</span></span></code>: Half-space plane.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">SphereIF</span></span></code>: Sphere.</p></li>
</ul>
<p>AMReX also provides a number of transformation operations to apply to an object.</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">makeComplement</span></span></code>: Complement of an object. E.g. a sphere with fluid on
outside becomes a sphere with fluid inside.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">makeIntersection</span></span></code>: Intersection of two or more objects.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">makeUnion</span></span></code>: Union of two or more objects.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Translate</span></span></code>: Translates an object.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">scale</span></span></code>: Scales an object.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">rotate</span></span></code>: Rotates an object.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">lathe</span></span></code>: Creates a surface of revolution by rotating a 2D object around an axis.</p></li>
</ul>
<p>Here are some examples of using these functions.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span> <span class="n">sphere1</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span> <span class="n">sphere2</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">BoxIF</span> <span class="n">box</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span> <span class="n">cylinder</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">PlaneIF</span> <span class="n">plane</span><span class="p">(...);</span>

<span class="c1">// union of two spheres</span>
<span class="k">auto</span> <span class="n">twospheres</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeUnion</span><span class="p">(</span><span class="n">sphere1</span><span class="p">,</span> <span class="n">sphere2</span><span class="p">);</span>

<span class="c1">// intersection of a rotated box, a plane and the union of two spheres</span>
<span class="k">auto</span> <span class="n">box_plane</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeIntersection</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">box</span><span class="p">,...),</span>
                                       <span class="n">plane</span><span class="p">,</span>
                                       <span class="n">twospheres</span><span class="p">);</span>

<span class="c1">// scale a cylinder by a factor of 2 in x and y directions, and 3 in z-direction.</span>
<span class="k">auto</span> <span class="n">scylinder</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">cylinder</span><span class="p">,</span> <span class="p">{</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="eb2-geometryshop">
<h2><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code><a class="headerlink" href="#eb2-geometryshop" title="Permalink to this headline">¶</a></h2>
<p>Given an implicit function object, say <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">f</span></span></code>, we can make a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GeometryShop</span></span></code> object with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">shop</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeShop</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="eb2-indexspace">
<h2><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code><a class="headerlink" href="#eb2-indexspace" title="Permalink to this headline">¶</a></h2>
<p>We build <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> with a template function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">G</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">EB2</span><span class="o">::</span><span class="n">Build</span> <span class="p">(</span><span class="k">const</span> <span class="n">G</span><span class="o">&amp;</span> <span class="n">gshop</span><span class="p">,</span> <span class="k">const</span> <span class="n">Geometry</span><span class="o">&amp;</span> <span class="n">geom</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">required_coarsening_level</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">max_coarsening_level</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the template parameter is a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code>. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> (see
section <a class="reference internal" href="Basics.html#sec-basics-geom"><span class="std std-ref">RealBox and Geometry</span></a>) describes the rectangular problem domain and the
mesh on the finest AMR level. Coarse level EB data is generated from coarsening
the original fine data. The <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">required_coarsening_level</span></span></code> parameter
specifies the number of coarsening levels required. This is usually set to
<span class="math notranslate nohighlight">\(N-1\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the total number of AMR levels. The <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span>
<span class="name"><span class="pre">max_coarsening_levels</span></span></code> parameter specifies the number of coarsening levels AMReX
should try to have. This is usually set to a big number, say 20 if multigrid
solvers are used. This essentially tells the build to coarsen as much as it can.
If there are no multigrid solvers, the parameter should be set to the same as
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">required_coarsening_level</span></span></code>. It should be noted that coarsening could
create multi-valued cells even if the fine level does not have any multi-valued
cells. This occurs when the embedded boundary cuts a cell in such a way that
there is fluid on multiple sides of the boundary within that cell. Because
multi-valued cells are not supported, it will cause a runtime error if the
required coarsening level generates multi-valued cells. The optional <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span>
<span class="name"><span class="pre">ngrow</span></span></code> parameter specifies the number of ghost cells outside the domain on
required levels. For levels coarser than the required level, no EB data are
generated for ghost cells outside the domain.</p>
<p>The newly built <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> is pushed on to a stack. Static function
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">top</span></span><span class="punctuation"><span class="pre">()</span></span></code> returns a <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">const</span></span> <span class="operator"><span class="pre">&amp;</span></span></code> to the new
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> object. We usually only need to build one
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> object. However, if your application needs multiple
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> objects, you can save the pointers for later use. For
simplicity, we assume there is only one <cite>EB2::IndexSpace</cite> object for the rest of
this chapter.</p>
</div>
</div>
<div class="section" id="ebfarrayboxfactory">
<h1>EBFArrayBoxFactory<a class="headerlink" href="#ebfarrayboxfactory" title="Permalink to this headline">¶</a></h1>
<p>After the EB database is initialized, the next thing we build is
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code>. This object provides access to the EB database in the
format of basic AMReX objects such as <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>. We can construct it with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBFArrayBoxFactory</span> <span class="p">(</span><span class="k">const</span> <span class="n">Geometry</span><span class="o">&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">a_ba</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">DistributionMapping</span><span class="o">&amp;</span> <span class="n">a_dm</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a_ngrow</span><span class="p">,</span>
                    <span class="n">EBSupport</span> <span class="n">a_support</span><span class="p">);</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span><span class="o">&gt;</span>
<span class="n">makeEBFabFactory</span> <span class="p">(</span><span class="k">const</span> <span class="n">Geometry</span><span class="o">&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">a_ba</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">DistributionMapping</span><span class="o">&amp;</span> <span class="n">a_dm</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a_ngrow</span><span class="p">,</span>
                  <span class="n">EBSupport</span> <span class="n">a_support</span><span class="p">);</span>
</pre></div>
</div>
<p>Argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword type"><span class="pre">int</span></span><span class="operator"><span class="pre">&gt;</span></span> <span class="keyword"><span class="pre">const</span></span><span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">a_ngrow</span></span></code> specifies the number of
ghost cells we need for EB data at various <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBSupport</span></span></code> levels,
and argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBSupport</span></span> <span class="name"><span class="pre">a_support</span></span></code> specifies the level of support
needed.</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name label"><span class="pre">EBSupport</span></span><span class="punctuation"><span class="pre">:</span></span><span class="name"><span class="pre">basic</span></span></code>:  basic flags for cell types</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name label"><span class="pre">EBSupport</span></span><span class="punctuation"><span class="pre">:</span></span><span class="name"><span class="pre">volume</span></span></code>: basic plus volume fraction and centroid</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name label"><span class="pre">EBSupport</span></span><span class="punctuation"><span class="pre">:</span></span><span class="name"><span class="pre">full</span></span></code>: volume plus area fraction, boundary centroid
and face centroid</p></li>
</ul>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> is derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabFactory</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">FArrayBox</span></span><span class="operator"><span class="pre">&gt;</span></span></code>.
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> constructors have an optional argument <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">const</span></span>
<span class="name"><span class="pre">FabFactory</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">FArrayBox</span></span><span class="operator"><span class="pre">&gt;&amp;</span></span></code>.  We can use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> to
build <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>s that carry EB data.  Member function of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FAB</span><span class="o">&gt;&amp;</span> <span class="n">Factory</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>can then be used to return a reference to the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> used for
building the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>. Using <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">dynamic_cast</span></span></code>, we can test whether a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> is built with an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">Factory</span><span class="p">()));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">factory</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this is EBFArrayBoxFactory</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// regular FabFactory&lt;FArrayBox&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="eb-data">
<h1>EB Data<a class="headerlink" href="#eb-data" title="Permalink to this headline">¶</a></h1>
<p>Through member functions of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code>, we have access to the
following data:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// see section on EBCellFlagFab</span>
<span class="k">const</span> <span class="n">FabArray</span><span class="o">&lt;</span><span class="n">EBCellFlagFab</span><span class="o">&gt;&amp;</span> <span class="n">getMultiEBCellFlagFab</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// volume fraction</span>
<span class="k">const</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">getVolFrac</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// volume centroid</span>
<span class="k">const</span> <span class="n">MultiCutFab</span><span class="o">&amp;</span> <span class="n">getCentroid</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// embedded boundary centroid</span>
<span class="k">const</span> <span class="n">MultiCutFab</span><span class="o">&amp;</span> <span class="n">getBndryCent</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// area fractions</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MultiCutFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">getAreaFrac</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// face centroid</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MultiCutFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">getFaceCent</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Volume fraction is in a single-component <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>, and it is zero for
covered cells, one for regular cells, and in between for cut cells. Centroid is
in a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> with <code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> components with each component
of the data is in the range of <span class="math notranslate nohighlight">\([-0.5,0.5]\)</span>. The centroid is based on each
cell’s local coordinates with respect to the embedded boundary. A
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> is very similar to a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>. Its data can be
accessed with subscript operator</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">CutFab</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">MFIter</span><span class="o">&amp;</span> <span class="n">mfi</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">CutFab</span></span></code> is derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> and can be passed to Fortran
just like <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>. The difference between <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> is that to save memory <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> only has data on boxes
that contain cut cells. It is an error to call <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code> if that box
does not have cut cells. Thus the call must be in a <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">if</span></span></code> test block (see
section <a class="reference internal" href="#sec-eb-flag"><span class="std std-ref">EBCellFlagFab</span></a>). Boundary centroid is also a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> with
<code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> components, and it uses each cell’s local coordinates. Area
fractions and face centroids are returned in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array</span></span></code> of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code>
pointers. For each direction, area fraction is for the face of that direction.
As for face centroids, there are two components for each direction and the
ordering is always the same as the original ordering of the coordinates. For
example, for <span class="math notranslate nohighlight">\(y\)</span> face, the component 0 is for <span class="math notranslate nohighlight">\(x\)</span> coordinate and 1
for <span class="math notranslate nohighlight">\(z\)</span>. The coordinates are in each face’s local frame normalized to the
range of <span class="math notranslate nohighlight">\([-0.5,0.5]\)</span>.</p>
<div class="section" id="ebcellflagfab">
<span id="sec-eb-flag"></span><h2><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code><a class="headerlink" href="#ebcellflagfab" title="Permalink to this headline">¶</a></h2>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code> contains information on cell types.  We can use
it to determine if a box contains cut cells.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">getMultiEBCellFlagFab</span><span class="p">();</span>
<span class="n">MultiCutFab</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">centroid</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>
    <span class="n">FabType</span> <span class="n">t</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="n">mfi</span><span class="p">].</span><span class="n">getType</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">regular</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// This box is regular</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">covered</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// This box is covered</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">singlevalued</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// This box has cut cells</span>
        <span class="c1">// Getting cutfab is safe</span>
        <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">centroid_fab</span> <span class="o">=</span> <span class="n">centroid</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code> is derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code>. Its data are stored in an
array of 32-bit integers, and can be used in C++ or passed to Fortran just like
an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IArrayBox</span></span></code> (section <a class="reference internal" href="Basics.html#sec-basics-fab"><span class="std std-ref">BaseFab, FArrayBox, IArrayBox, and Array4</span></a>). AMReX provides a Fortran
module called <code class="docutils literal notranslate"><span class="pre">amrex_ebcellflag_module</span></code>. This module contains procedures for
testing cell types and getting neighbor information. For example</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_ebcellflag_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">is_regular_cell</span><span class="p">,</span> <span class="n">is_single_valued_cell</span><span class="p">,</span> <span class="n">is_covered_cell</span>

<span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">flags</span><span class="p">(...)</span>

<span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span>

<span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="p">...</span>
    <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="p">...</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="p">...</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_covered_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="k">then</span>
                <span class="c">! this is a completely covered cells</span>
            <span class="k">else if</span> <span class="p">(</span><span class="n">is_regular_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="k">then</span>
                <span class="c">! this is a regular cell</span>
            <span class="k">else if</span> <span class="p">(</span><span class="n">is_single_valued_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="k">then</span>
                <span class="c">! this is a cut cell</span>
            <span class="k">end if</span>
<span class="k">        end do</span>
<span class="k">    end do</span>
<span class="k">end do</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="linear-solvers">
<h1>Linear Solvers<a class="headerlink" href="#linear-solvers" title="Permalink to this headline">¶</a></h1>
<p>Linear solvers for the canonical form (equation <a class="reference internal" href="LinearSolvers_Chapter.html#equation-eqn-abeclap">(1)</a>)
have been discussed in chapter <a class="reference internal" href="LinearSolvers_Chapter.html#chap-linearsolvers"><span class="std std-ref">Linear Solvers</span></a>.</p>
<p>AMReX supports multi-level
1) cell-centered solvers with homogeneous Neumann, homogeneous Dirichlet,
or inhomogeneous Dirichlet boundary conditions on the EB faces, and
2) nodal solvers with homogeneous Neumann boundary conditions on the EB faces.</p>
<p>To use a cell-centered solver with EB, one builds a linear operator
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLEBABecLap</span></span></code> with <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> (instead of a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code>)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLEBABecLap</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span> <span class="n">a_grids</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span> <span class="n">a_dmap</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">LPInfo</span><span class="o">&amp;</span> <span class="n">a_info</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_factory</span><span class="p">);</span>
</pre></div>
</div>
<p>The usage of this EB-specific class is essentially the same as
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code>.</p>
<p>The default boundary condition on EB faces is homogeneous Neumann.</p>
<p>To set homogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBHomogDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">coeff</span><span class="p">);</span>
</pre></div>
</div>
<p>where coeff can be a real number (i.e. the value is the same at every cell)
or is the MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>To set inhomogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">phi_on_eb</span><span class="p">,</span> <span class="n">coeff</span><span class="p">);</span>
</pre></div>
</div>
<p>where phi_on_eb is the MultiFab holding the Dirichlet values in every cut cell,
and coeff again is a real number (i.e. the value is the same at every cell)
or a MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>Currently there are options to define the face-based coefficients on
face centers vs face centroids, and to interpret the solution variable
as being defined on cell centers vs cell centroids.</p>
<p>The default is for the solution variable to be defined at cell centers;
to tell the solver to interpret the solution variable as living
at cell centroids, you must set</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setPhiOnCentroid</span><span class="p">();</span>
</pre></div>
</div>
<p>The default is for the face-based coefficients to be defined at face centers;
to tell the that the face-based coefficients should be interpreted
as living at face centroids, modify the setBCoeffs command to be</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setBCoeffs</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">MLMG</span><span class="o">::</span><span class="n">Location</span><span class="o">::</span><span class="n">FaceCentroid</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorials">
<h1>Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/EB/CNS</span></code> is an AMR code for solving compressible
Navier-Stokes equations with the embedded boundary approach.</p>
<p><code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/EB/Poisson</span></code> is a single-level code that is a proxy for
solving the electrostatic Poisson equation for a grounded sphere with a point
charge inside.</p>
<p><code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/EB/MacProj</span></code> is a single-level code that computes a divergence-free
flow field around a sphere.  A MAC projection is performed on an initial velocity
field of (1,0,0).</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="GPU_Chapter.html" class="btn btn-neutral float-right" title="GPU" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="EB_Chapter.html" class="btn btn-neutral float-left" title="Embedded Boundaries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2018, AMReX Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>