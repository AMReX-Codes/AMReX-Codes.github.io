

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Dimensionality &mdash; amrex 20.01-dev documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Gridding and Load Balancing" href="ManagingGridHierarchy_Chapter.html" />
    <link rel="prev" title="Basics" href="Basics_Chapter.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                20.01-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Basics_Chapter.html">Basics</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Dimensionality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vector-array-gpuarray-array1d-array2d-and-array3d">Vector, Array, GpuArray, Array1D, Array2D, and Array3D</a></li>
<li class="toctree-l2"><a class="reference internal" href="#real">Real</a></li>
<li class="toctree-l2"><a class="reference internal" href="#long">Long</a></li>
<li class="toctree-l2"><a class="reference internal" href="#paralleldescriptor">ParallelDescriptor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parallelcontext">ParallelContext</a></li>
<li class="toctree-l2"><a class="reference internal" href="#print">Print</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parmparse">ParmParse</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initialize-and-finalize">Initialize and Finalize</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sharing-the-command-line">Sharing the Command Line</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-amr-grids">Example of AMR Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="#box-intvect-and-indextype">Box, IntVect and IndexType</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#intvect">IntVect</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indextype">IndexType</a></li>
<li class="toctree-l3"><a class="reference internal" href="#box">Box</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dim3-and-xdim3">Dim3 and XDim3</a></li>
<li class="toctree-l2"><a class="reference internal" href="#realbox-and-geometry">RealBox and Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boxarray">BoxArray</a></li>
<li class="toctree-l2"><a class="reference internal" href="#distributionmapping">DistributionMapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basefab-farraybox-iarraybox-and-array4">BaseFab, FArrayBox, IArrayBox, and Array4</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fabarray-multifab-and-imultifab">FabArray, MultiFab and iMultiFab</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mfiter-and-tiling">MFIter and Tiling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mfiter-without-tiling">MFIter without Tiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mfiter-with-tiling">MFIter with Tiling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fortran-and-c-kernels">Fortran and C++ Kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parallelfor">ParallelFor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ghost-cells">Ghost Cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-conditions">Boundary Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-allocation">Memory Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#abort-assertion-and-backtrace">Abort, Assertion and Backtrace</a></li>
<li class="toctree-l2"><a class="reference internal" href="#debugging">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-heatequation-ex1-c">Example: HeatEquation_EX1_C</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particle_Chapter.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="Basics_Chapter.html">Basics</a> &raquo;</li>
        
      <li>Dimensionality</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Basics.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dimensionality">
<span id="sec-basics-dim"></span><h1>Dimensionality<a class="headerlink" href="#dimensionality" title="Permalink to this headline">Â¶</a></h1>
<p>As we have mentioned in <a class="reference internal" href="BuildingAMReX_Chapter.html#chap-buildingamrex"><span class="std std-ref">Building AMReX</span></a>, the dimensionality of
AMReX must be set at compile time. A macro, <code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code>, is defined to
be the number of spatial dimensions. C++ codes can also use the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">SpaceDim</span></span></code> variable. Fortran codes can use either the macro and
preprocessing or do</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_spacedim</span>
</pre></div>
</div>
<p>The coordinate directions are zero based.</p>
</div>
<div class="section" id="vector-array-gpuarray-array1d-array2d-and-array3d">
<span id="sec-basics-vecandarr"></span><h1>Vector, Array, GpuArray, Array1D, Array2D, and Array3D<a class="headerlink" href="#vector-array-gpuarray-array1d-array2d-and-array3d" title="Permalink to this headline">Â¶</a></h1>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span></code> class in <code class="docutils literal notranslate"><span class="pre">AMReX_Vector.H</span></code> is derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">vector</span></span></code>. The
main difference between <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">vector</span></span></code> is that
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">::</span></span><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code> provides bound checking when compiled with
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DEBUG</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">TRUE</span></span></code>.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array</span></span></code> class in <code class="docutils literal notranslate"><span class="pre">AMReX_Array.H</span></code> is simply an alias to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">array</span></span></code>.
It is used throughout AMReX, however its functions are not defined
for device code. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GpuArray</span></span></code> is AMReXâs built-in alternative.  It
is a trivial type that works on both host and device.  It also works
when compiled just for CPU.  Besides <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GpuArray</span></span></code>, AMReX also
provides GPU safe <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array1D</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array2D</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array3D</span></span></code> that are
1, 2 and 3-dimensional fixed size arrays, respectively.  These three
class templates can have non-zero based indexing.</p>
</div>
<div class="section" id="real">
<h1>Real<a class="headerlink" href="#real" title="Permalink to this headline">Â¶</a></h1>
<p>AMReX can be compiled to use either double precision (which is the default) or
single precision. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Real</span></span></code> is typedefâd to either <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">double</span></span></code> or
<code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">float</span></span></code>. C codes can use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex_real</span></span></code>. They are defined in
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AMReX_REAL</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">H</span></span></code>. The data type is accessible in Fortran codes via</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
</pre></div>
</div>
<p>In C++, AMReX also provides a user literal <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">_rt</span></span></code> so that one can
have a proper type for constants (e.g., <code class="code cpp c++ docutils literal notranslate"><span class="literal number float"><span class="pre">2.7</span></span><span class="name"><span class="pre">_rt</span></span></code>).</p>
</div>
<div class="section" id="long">
<h1>Long<a class="headerlink" href="#long" title="Permalink to this headline">Â¶</a></h1>
<p>AMReX defines a 64 bit integer type <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Long</span></span></code> that is an alias to
<code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">long</span></span></code> on Unix-like systems and <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">long</span></span> <span class="keyword type"><span class="pre">long</span></span></code> on Windows.  In
C, the type alias is <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex_long</span></span></code>.  In Fortran, one can use
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex_long</span></span></code> defined in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex_fort_module</span></span></code>.</p>
</div>
<div class="section" id="paralleldescriptor">
<span id="sec-basics-paralleldescriptor"></span><h1>ParallelDescriptor<a class="headerlink" href="#paralleldescriptor" title="Permalink to this headline">Â¶</a></h1>
<p>AMReX users do not need to use MPI directly. Parallel communication is often
handled by the data abstraction classes (e.g.,MultiFab; section on
<a class="reference internal" href="#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a>). In addition, AMReX has provided namespace
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelDescriptor</span></span></code> in <code class="docutils literal notranslate"><span class="pre">AMReX_ParallelDescriptor.H.</span></code> The frequently
used functions are</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">myproc</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">MyProc</span><span class="p">();</span>  <span class="c1">// Return the rank</span>

<span class="kt">int</span> <span class="n">nprocs</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">NProcs</span><span class="p">();</span>  <span class="c1">// Return the number of processes</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">IOProcessor</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Only the I/O process executes this</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">ioproc</span> <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">IOProcessorNumber</span><span class="p">();</span>  <span class="c1">// I/O rank</span>

<span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">Barrier</span><span class="p">();</span>

<span class="c1">// Broadcast 100 ints from the I/O Processor</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">Bcast</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
                    <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">IOProcessorNumber</span><span class="p">())</span>

<span class="c1">// See AMReX_ParallelDescriptor.H for many other Reduce functions</span>
<span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">ReduceRealSum</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>Additionally, <code class="docutils literal notranslate"><span class="pre">amrex_paralleldescriptor_module</span></code> in
<code class="docutils literal notranslate"><span class="pre">Src/Base/AMReX_ParallelDescriptor_F.F90</span></code> provides a number of
functions for Fortran.</p>
</div>
<div class="section" id="parallelcontext">
<h1>ParallelContext<a class="headerlink" href="#parallelcontext" title="Permalink to this headline">Â¶</a></h1>
<p>Users can also use groups of MPI subcommunicators to perform
simultaneous physics calculations.  These comms are managed by AMReXâs
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelContext</span></span></code> in <code class="docutils literal notranslate"><span class="pre">AMReX_ParallelContext.H.</span></code>  It maintains a
stack of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MPI_Comm</span></span></code> handlers. A global comm is placed in the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelContext</span></span></code> stack during AMReXâs initialization and
additional subcommunicators can be handled by adding comms with
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">push</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">MPI_Comm</span></span><span class="punctuation"><span class="pre">)</span></span></code> and removed using <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">pop</span></span><span class="punctuation"><span class="pre">()</span></span></code>.  This creates a
hierarchy of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MPI_Comm</span></span></code> objects that can be used to split work as
the user sees fit.   Note that <code class="docutils literal notranslate"><span class="pre">ParallelDescriptor</span></code> by default uses
AMReXâs base comm, independent of the status of the
<code class="docutils literal notranslate"><span class="pre">ParallelContext</span></code> stack.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelContext</span></span></code> also tracks and returns information about the
local (most recently added) and global <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MPI_Comm</span></span></code>.  The most common
access functions are given below.  See <code class="docutils literal notranslate"><span class="pre">AMReX_ParallelContext.H.</span></code> for
a full listing of the available functions.</p>
<blockquote>
<div></div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MPI_Comm</span> <span class="n">subCommA</span> <span class="o">=</span> <span class="p">....;</span>
<span class="n">MPI_Comm</span> <span class="n">subCommB</span> <span class="o">=</span> <span class="p">....;</span>
<span class="c1">// Add a communicator to ParallelContext.</span>
<span class="c1">// After these pushes, subCommB becomes the</span>
<span class="c1">//     &quot;local&quot; communicator.</span>
<span class="n">ParallelContext</span><span class="o">::</span><span class="n">push</span><span class="p">(</span><span class="n">subCommA</span><span class="p">);</span>
<span class="n">ParallelContext</span><span class="o">::</span><span class="n">push</span><span class="p">(</span><span class="n">subCommB</span><span class="p">);</span>

<span class="c1">// Get Global and Local communicator (subCommB).</span>
<span class="n">MPI_Comm</span> <span class="n">globalComm</span> <span class="o">=</span> <span class="n">ParallelContext</span><span class="o">::</span><span class="n">CommunicatorAll</span><span class="p">();</span>
<span class="n">MPI_Comm</span> <span class="n">localComm</span>  <span class="o">=</span> <span class="n">ParallelContext</span><span class="o">::</span><span class="n">CommunicatorSub</span><span class="p">();</span>

<span class="c1">// Get local number of ranks and global IO Processor Number.</span>
<span class="kt">int</span> <span class="n">localRanks</span> <span class="o">=</span> <span class="n">ParallelContext</span><span class="o">::</span><span class="n">NProcsSub</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">globalIO</span>     <span class="o">=</span> <span class="n">ParallelContext</span><span class="o">::</span><span class="n">IOProcessorNumberAll</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ParallelContext</span><span class="o">::</span><span class="n">IOProcessorSub</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Only the local I/O process executes this</span>
<span class="p">}</span>

<span class="c1">// Translation of global rank to local communicator rank.</span>
<span class="c1">// Returns MPI_UNDEFINED if comms do not overlap.</span>
<span class="kt">int</span> <span class="n">localRank</span> <span class="o">=</span> <span class="n">ParallelContext</span><span class="o">::</span><span class="n">global_to_local_rank</span><span class="p">(</span><span class="n">globalrank</span><span class="p">);</span>

<span class="c1">// Translations of MPI rank IDs using integer arrays.</span>
<span class="c1">// Returns MPI_UNDEFINED if comms do not overlap.</span>
<span class="n">ParallelContext</span><span class="o">::</span><span class="n">global_to_local_rank</span><span class="p">(</span><span class="n">local_array</span><span class="p">,</span> <span class="n">global_array</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="n">ParallelContext</span><span class="o">::</span><span class="n">local_to_global_rank</span><span class="p">(</span><span class="n">global_array</span><span class="p">,</span> <span class="n">local_array</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

<span class="c1">// Remove the last added subcommunicator.</span>
<span class="c1">// This would make &quot;subCommA&quot; the new local communicator.</span>
<span class="c1">// Note: The user still needs to free &quot;subCommB&quot;.</span>
<span class="n">ParallelContext</span><span class="o">::</span><span class="n">pop</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="print">
<span id="sec-basics-print"></span><h1>Print<a class="headerlink" href="#print" title="Permalink to this headline">Â¶</a></h1>
<p>AMReX provides classes in <code class="docutils literal notranslate"><span class="pre">AMReX_Print.H</span></code> for printing messages to standard
output or any C++ <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ostream</span></span></code>. The main reason one should use them instead
of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">cout</span></span></code> is that messages from multiple processes or threads do not
get mixed up. Below are some examples.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span>  <span class="s">&quot;x = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="c1">// Print on I/O processor</span>

<span class="n">Real</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atan</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="mf">4.0</span><span class="p">;</span>
<span class="c1">// Print on rank 3 with precision of 17 digits</span>
<span class="c1">// SetPrecision does not modify cout&#39;s floating-point decimal precision setting.</span>
<span class="n">Print</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">SetPrecision</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">oldprec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// Print with 10 digits</span>

<span class="n">AllPrint</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Every process prints</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// Print on every process</span>

<span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">ofs</span><span class="p">(</span><span class="s">&quot;my.txt&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
<span class="n">Print</span><span class="p">(</span><span class="n">ofs</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Print to a file&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">ofs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

<span class="n">AllPrintToFile</span><span class="p">(</span><span class="s">&quot;file.&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Each process appends to its own file (e.g., file.3)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>It should be emphasized that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Print</span></span><span class="punctuation"><span class="pre">()</span></span></code> without any argument only
prints on the I/O process.  A common mistake in using it for debug
printing is one forgets that for non-I/O processes to print we should
use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AllPrint</span></span><span class="punctuation"><span class="pre">()</span></span></code> or <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Print</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">rank</span></span><span class="punctuation"><span class="pre">)</span></span></code>.</p>
</div>
<div class="section" id="parmparse">
<span id="sec-basics-parmparse"></span><h1>ParmParse<a class="headerlink" href="#parmparse" title="Permalink to this headline">Â¶</a></h1>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> in AMReX_ParmParse.H is a class providing a database for the
storage and retrieval of command-line and input-file arguments. When
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Initialize</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">argc</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="keyword type"><span class="pre">char</span></span><span class="operator"><span class="pre">**&amp;</span></span> <span class="name"><span class="pre">argv</span></span><span class="punctuation"><span class="pre">)</span></span></code> is called, the first command-line argument after the
executable name (if there is one and it does not contain character =) is taken
to be the inputs file, and the contents in the file are used to initialize the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> database. The rest of the command-line arguments are also
parsed by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code>. The format of the inputs file is a series of
definitions in the form of <code class="docutils literal notranslate"><span class="pre">prefix.name</span> <span class="pre">=</span> <span class="pre">value</span> <span class="pre">value</span> <span class="pre">....</span></code> For each line,
text after # are comments. Here is an example inputs file.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nsteps</span>    <span class="o">=</span> <span class="mi">100</span>               <span class="c1"># integer</span>
<span class="n">nsteps</span>    <span class="o">=</span> <span class="mi">1000</span>              <span class="c1"># nsteps appears a second time</span>
<span class="n">dt</span>        <span class="o">=</span> <span class="mf">0.03</span>              <span class="c1"># floating point number</span>
<span class="n">ncells</span>    <span class="o">=</span> <span class="mi">128</span> <span class="mi">64</span> <span class="mi">32</span>         <span class="c1"># a list of 3 ints</span>
<span class="n">xrange</span>    <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="mf">0.5</span>          <span class="c1"># a list of 2 reals</span>
<span class="n">title</span>     <span class="o">=</span> <span class="s2">&quot;Three Kingdoms&quot;</span>  <span class="c1"># a string</span>
<span class="n">hydro</span><span class="o">.</span><span class="n">cfl</span> <span class="o">=</span> <span class="mf">0.8</span>               <span class="c1"># with prefix, hydro</span>
</pre></div>
</div>
</div></blockquote>
<p>The following code shows how to use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> to get/query the values.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParmParse</span> <span class="n">pp</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">nsteps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pp</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;nsteps&quot;</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">);</span>
<span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nsteps</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// 1000</span>

<span class="n">Real</span> <span class="n">dt</span><span class="p">;</span>
<span class="n">pp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;dt&quot;</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>  <span class="c1">// runtime error if dt is not in inputs</span>

<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numcells</span><span class="p">;</span>
<span class="c1">// The variable name &#39;numcells&#39; can be different from parameter name &#39;ncells&#39;.</span>
<span class="n">pp</span><span class="p">.</span><span class="n">getarr</span><span class="p">(</span><span class="s">&quot;ncells&quot;</span><span class="p">,</span> <span class="n">numcells</span><span class="p">);</span>
<span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">numcells</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// 3</span>

<span class="n">Vector</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="n">xr</span> <span class="p">{</span><span class="mf">-1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queryarr</span><span class="p">(</span><span class="s">&quot;xrange&quot;</span><span class="p">,</span> <span class="n">xr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cannot find xrange in inputs, &quot;</span>
                   <span class="o">&lt;&lt;</span> <span class="s">&quot;so the default {-1.0,1.0} will be used</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">;</span>
<span class="n">pp</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">,</span> <span class="n">title</span><span class="p">);</span>  <span class="c1">// query string</span>

<span class="n">ParmParse</span> <span class="nf">pph</span><span class="p">(</span><span class="s">&quot;hydro&quot;</span><span class="p">);</span>  <span class="c1">// with prefix &#39;hydro&#39;</span>
<span class="n">Real</span> <span class="n">cfl</span><span class="p">;</span>
<span class="n">pph</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;cfl&quot;</span><span class="p">,</span> <span class="n">cfl</span><span class="p">);</span>    <span class="c1">// get parameter with prefix</span>
</pre></div>
</div>
<p>Note that when there are multiple definitions for a parameter <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code>
by default returns the last one. The difference between <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">query</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">get</span></span></code> should also be noted. It is a runtime error if <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">get</span></span></code> fails to
get the value, whereas <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">query</span></span></code> returns an error code without generating a
runtime error that will abort the run.  It is sometimes convenient to
override parameters with command-line arguments without modifying the inputs
file. The command-line arguments after the inputs file are added later than the
file to the database and are therefore used by default. For example, one can
run with</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">myexecutable myinputsfile ncells=&quot;64 32 16&quot; hydro.cfl=0.9</span>
</pre></div>
</div>
<p>to change the value of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ncells</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hydro</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">cfl</span></span></code>.</p>
<p>Sometimes an application code may want to set a default that differs from the
default in AMReX.  In this case, it is often convenient to define a function that
sets the variable(s), and pass the name of that function to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Initialize</span></span></code>.
As an example, we may define <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">add_par</span></span></code> to set <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">extend_domain_face</span></span></code>
to false if it hasnât already been set in the inputs file.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">add_par</span> <span class="p">()</span> <span class="p">{</span>
   <span class="n">ParmParse</span> <span class="n">pp</span><span class="p">(</span><span class="s">&quot;eb2&quot;</span><span class="p">);</span>
   <span class="k">if</span><span class="p">(</span><span class="n">not</span> <span class="n">pp</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s">&quot;extend_domain_face&quot;</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">pp</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;extend_domain_face&quot;</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Then we would pass <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">add_par</span></span></code> into <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Initialize</span></span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">amrex</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="n">add_par</span><span class="p">);</span>
</pre></div>
</div>
<p>This value replaces the current default value of true in AMReX itself, but
can still be over-written by setting a value in the inputs file.</p>
</div>
<div class="section" id="initialize-and-finalize">
<span id="sec-basics-initialize"></span><h1>Initialize and Finalize<a class="headerlink" href="#initialize-and-finalize" title="Permalink to this headline">Â¶</a></h1>
<p>As we have mentioned, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Initialize</span></span></code> must be called to initialize
the execution environment for AMReX and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Finalize</span></span></code> must be paired
with <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Initialize</span></span></code> to release the resources used by AMReX.  There
are two versions of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Initialize</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Initialize</span> <span class="p">(</span><span class="n">MPI_Comm</span> <span class="n">mpi_comm</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">a_osout</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">a_oserr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">,</span>
                 <span class="n">ErrorHandler</span> <span class="n">a_errhandler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">Initialize</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**&amp;</span> <span class="n">argv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">build_parm_parse</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span>
                 <span class="n">MPI_Comm</span> <span class="n">mpi_comm</span> <span class="o">=</span> <span class="n">MPI_COMM_WORLD</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&amp;</span> <span class="n">func_parm_parse</span> <span class="o">=</span> <span class="p">{},</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">a_osout</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">a_oserr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">,</span>
                 <span class="n">ErrorHandler</span> <span class="n">a_errhandler</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Initialize</span></span></code> tests if MPI has been initialized.  If MPI has been
initialized, AMReX will duplicate the <code class="docutils literal notranslate"><span class="pre">MPI_Comm</span></code> argument.  If not,
AMReX will initialize MPI and ignore the <code class="docutils literal notranslate"><span class="pre">MPI_Comm</span></code> argument.</p>
<p>Both versions have two optional <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ostream</span></span></code> parameters, one
for standard output in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Print</span></span></code> (section <a class="reference internal" href="#sec-basics-print"><span class="std std-ref">Print</span></a>)
and the other for standard error, and they can be accessed with
functions <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">OutStream</span></span><span class="punctuation"><span class="pre">()</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ErrorStream</span></span><span class="punctuation"><span class="pre">()</span></span></code>.  Both versions
can also take an optional error handler function.  If it is provided
by the user, AMReX will use it to handle errors and signals.
Otherwise, AMReX will use its own function for error and signal
handling.</p>
<p>The first version of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Initialize</span></span></code> does not parse the command line
options, whereas the second version will build ParmParse database
(section <a class="reference internal" href="#sec-basics-parmparse"><span class="std std-ref">ParmParse</span></a>) unless <code class="docutils literal notranslate"><span class="pre">build_parm_parse</span></code>
parameter is <code class="code cpp c++ docutils literal notranslate"><span class="name builtin"><span class="pre">false</span></span></code>.  In the second version, one can pass a
function that adds ParmParse parameters to the database instead of
reading from command line or input file.</p>
<p>Because many AMReX classes and functions (including destructors
inserted by the compiler) do not function properly after
<code class="code cpp c++ docutils literal notranslate"><span class="name label"><span class="pre">amrex</span></span><span class="punctuation"><span class="pre">:</span></span><span class="name"><span class="pre">Finalize</span></span></code> is called, itâs best to put the codes between
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Initialize</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Finalize</span></span></code> into its scope
(e.g., a pair of curly braces or a separate function) to make sure
resources are properly freed.</p>
<div class="section" id="sharing-the-command-line">
<h2>Sharing the Command Line<a class="headerlink" href="#sharing-the-command-line" title="Permalink to this headline">Â¶</a></h2>
<p>In some cases we want AMReX to only read part of the command line â this happens, for example, when we
are going to use AMReX in cooperation with another code package and that code also takes command-line
arguments.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">main2d*.exe inputs amrex.v=1 amrex.fpe_trap_invalid=1 -- -tao_monitor</span>
</pre></div>
</div>
<p>then AMReX will parse the inputs file and the optional AMReXâs command
line arguments, but will ignore everything after the double dashes.</p>
</div>
</div>
<div class="section" id="example-of-amr-grids">
<span id="sec-basics-amrgrids"></span><h1>Example of AMR Grids<a class="headerlink" href="#example-of-amr-grids" title="Permalink to this headline">Â¶</a></h1>
<p>In block-structured AMR, there is a hierarchy of logically rectangular grids.
The computational domain on each AMR level is decomposed into a union of
rectangular domains. <a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 1</span></a> below shows an example of
AMR with three total levels.  In the AMReX numbering convention, the coarsest
level is level 0. The coarsest grid (<em>black</em>) covers the domain with
<span class="math notranslate nohighlight">\(16^2\)</span> cells. Bold lines represent grid boundaries. There are two
intermediate resolution grids (<em>blue</em>) at level 1 and the cells are a factor of
two finer than those at level 0. The two finest grids (<em>red</em>) are at level 2
and the cells are a factor of two finer than the level 1 cells. There are 1, 2
and 2 Boxes on levels 0, 1, and 2, respectively. Note that there is no direct
parent-child connection. In this chapter, we will focus on single levels.</p>
<div class="figure align-default" id="id1">
<span id="fig-basics-amrgrids"></span><a class="reference internal image-reference" href="_images/amrgrids.png"><img alt="_images/amrgrids.png" src="_images/amrgrids.png" style="width: 3in;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Example of AMR grids. There are three levels in total.
There are 1, 2 and 2 Boxes on levels 0, 1, and 2, respectively.</span><a class="headerlink" href="#id1" title="Permalink to this image">Â¶</a></p>
</div>
</div>
<div class="section" id="box-intvect-and-indextype">
<span id="sec-basics-box"></span><h1>Box, IntVect and IndexType<a class="headerlink" href="#box-intvect-and-indextype" title="Permalink to this headline">Â¶</a></h1>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> in AMReX_Box.H is the data structure for representing a rectangular
domain in indexing space.  In <a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 1</span></a>, there are 1, 2 and
2 Boxes on levels 0, 1 and 2, respectively.  <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> is a
dimension-dependent class. It has lower and upper corners (represented by
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code>) and an index type (represented by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IndexType</span></span></code>). A
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> contains no floating-point data.</p>
<div class="section" id="intvect">
<h2>IntVect<a class="headerlink" href="#intvect" title="Permalink to this headline">Â¶</a></h2>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVec</span></span></code> is a dimension-dependent class representing an integer vector in
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AMREX_SPACEDIM</span></span></code>-dimensional space. An <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code> can be constructed
as follows,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AMREX_D_DECL</span></span></code> is a macro that expands <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AMREX_D_DECL</span></span><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">19</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">5</span></span><span class="punctuation"><span class="pre">)</span></span></code> to
either <code class="code cpp c++ docutils literal notranslate"><span class="literal number integer"><span class="pre">19</span></span></code> or <code class="code cpp c++ docutils literal notranslate"><span class="literal number integer"><span class="pre">19</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="literal number integer"><span class="pre">0</span></span></code> or <code class="code cpp c++ docutils literal notranslate"><span class="literal number integer"><span class="pre">19</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="literal number integer"><span class="pre">5</span></span></code> depending on the number of
dimensions. The data can be accessed via <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code>, and the internal
data pointer can be returned by function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">getVect</span></span></code>. For example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idim</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="o">++</span><span class="n">idim</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;iv[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">idim</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">iv</span><span class="p">.</span><span class="n">getVect</span><span class="p">();</span>  <span class="c1">// This can be passed to Fortran/C as an array</span>
</pre></div>
</div>
<p>The class has a static function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">TheZeroVector</span></span><span class="punctuation"><span class="pre">()</span></span></code> returning the zero
vector, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">TheUnitVector</span></span><span class="punctuation"><span class="pre">()</span></span></code> returning the unit vector, and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">TheDimensionVector</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">dir</span></span><span class="punctuation"><span class="pre">)</span></span></code> returning a reference to a constant
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code> that is zero except in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">dir</span></span></code>-direction. Note the
direction is zero-based. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code> has a number of relational operators,
<code class="code cpp c++ docutils literal notranslate"><span class="operator"><span class="pre">==</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="operator"><span class="pre">!=</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="operator"><span class="pre">&lt;</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="operator"><span class="pre">&lt;=</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="operator"><span class="pre">&gt;</span></span></code> , and <code class="code cpp c++ docutils literal notranslate"><span class="operator"><span class="pre">&gt;=</span></span></code> that can be
used for lexicographical comparison (e.g., key of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">map</span></span></code>), and a class
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">shift_hasher</span></span></code> that can be used as a hash function (e.g., for
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">unordered_map</span></span></code>). It also has various arithmetic operators. For
example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="nf">iv2</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="n">iv</span> <span class="o">+=</span> <span class="n">iv2</span><span class="p">;</span>  <span class="c1">// iv is now (23,8,5)</span>
<span class="n">iv</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">// iv is now (46,16,10);</span>
</pre></div>
</div>
<p>In AMR codes, one often needs to do refinement and coarsening on
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code>. The refinement operation can be done with the multiplication
operation. However, the coarsening requires care because of the rounding
towards zero behavior of integer division in Fortran, C and C++. For example
<code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">i</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">-1</span></span><span class="operator"><span class="pre">/</span></span><span class="literal number integer"><span class="pre">2</span></span></code> gives <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">i</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">0</span></span></code>, and what we want is usually <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">i</span></span> <span class="operator"><span class="pre">=</span></span>
<span class="literal number integer"><span class="pre">-1</span></span></code>. Thus, one should use the coarsen functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">iv</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="nf">coarsening_ratio</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
<span class="n">iv</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>                 <span class="c1">// Coarsen each component by 2</span>
<span class="n">iv</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="n">coarsening_ratio</span><span class="p">);</span>  <span class="c1">// Component-wise coarsening</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">iv2</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">coarsen</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Return an IntVect w/o modifying iv</span>
<span class="n">IntVect</span> <span class="n">iv3</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">coarsen</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">coarsening_ratio</span><span class="p">);</span> <span class="c1">// iv not modified</span>
</pre></div>
</div>
<p>Finally, we note that <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="operator"><span class="pre">&lt;&lt;</span></span></code> is overloaded for <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code> and
therefore one can call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">amrex</span><span class="o">::</span><span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iv</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="indextype">
<h2>IndexType<a class="headerlink" href="#indextype" title="Permalink to this headline">Â¶</a></h2>
<p>This class defines an index as being cell based or node based in each
dimension. The default constructor defines a cell based type in all directions.
One can also construct an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IndexType</span></span></code> with an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code> with zero and
one representing cell and node, respectively.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Node in x-direction and cell based in y and z-directions</span>
<span class="c1">// (i.e., x-face of numerical cells)</span>
<span class="n">IndexType</span> <span class="nf">xface</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)});</span>
</pre></div>
</div>
<p>The class provides various functions including</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// True if the IndexType is cell based in all directions.</span>
<span class="kt">bool</span> <span class="nf">cellCentered</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// True if the IndexType is cell based in dir-direction.</span>
<span class="kt">bool</span> <span class="nf">cellCentered</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dir</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// True if the IndexType is node based in all directions.</span>
<span class="kt">bool</span> <span class="nf">nodeCentered</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// True if the IndexType is node based in dir-direction.</span>
<span class="kt">bool</span> <span class="nf">nodeCentered</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dir</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Index type is a very important concept in AMReX. It is a way of representing
the notion of indices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(i+1/2\)</span>.</p>
</div>
<div class="section" id="box">
<h2>Box<a class="headerlink" href="#box" title="Permalink to this headline">Â¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">Box</span></code> is an abstraction for defining discrete regions of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AMREX_SPACEDIM</span></span></code>-dimensional indexing space. Boxes have an
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IndexType</span></span></code> and two <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code>s representing the lower and upper
corners. Boxes can exist in positive and negative indexing space. Typical ways
of defining a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> are</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">lo</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">));</span>
<span class="n">IntVect</span> <span class="nf">hi</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">));</span>
<span class="n">IndexType</span> <span class="nf">typ</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)});</span>
<span class="n">Box</span> <span class="nf">cc</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="p">);</span>        <span class="c1">// By default, Box is cell based.</span>
<span class="n">Box</span> <span class="nf">nd</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">typ</span><span class="p">);</span>  <span class="c1">// Construct a nodal Box.</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;A cell-centered Box &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cc</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;An all nodal Box    &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nd</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Depending the dimensionality, the output of the code above is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">cell</span><span class="o">-</span><span class="n">centered</span> <span class="n">Box</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">An</span> <span class="n">all</span> <span class="n">nodal</span> <span class="n">Box</span>    <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>For simplicity, we will assume it is 3D for the rest of this section.  In the
output, three integer tuples for each box are the lower corner indices, upper
corner indices, and the index types. Note that 0 and 1 denote cell and node,
respectively. For each tuple like <code class="code cpp c++ docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">)</span></span></code>, the 3 numbers are for 3
directions. The two Boxes in the code above represent different indexing views
of the same domain of <span class="math notranslate nohighlight">\(64^3\)</span> cells. Note that in AMReX convention, the
lower side of a cell has the same integer value as the cell centered index.
That is if we consider a cell based index represent <span class="math notranslate nohighlight">\(i\)</span>, the nodal index
with the same integer value represents <span class="math notranslate nohighlight">\(i-1/2\)</span>.
<a class="reference internal" href="#fig-basics-indextypes"><span class="std std-numref">Fig. 2</span></a> shows some of the different index types for 2D.</p>
<div class="figure align-default" id="id2">
<span id="fig-basics-indextypes"></span><a class="reference internal image-reference" href="_images/indextypes.png"><img alt="_images/indextypes.png" src="_images/indextypes.png" style="width: 5in;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Some of the different index types in two dimensions: (a) cell-centered, (b) <span class="math notranslate nohighlight">\(x\)</span>-face-centered
(i.e., nodal in <span class="math notranslate nohighlight">\(x\)</span>-direction only), and (c) corner/nodal,
i.e., nodal in all dimensions.</span><a class="headerlink" href="#id2" title="Permalink to this image">Â¶</a></p>
</div>
<p>There are a number of ways of converting a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> from one type to another.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">b0</span> <span class="p">({</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">},</span> <span class="p">{</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">});</span> <span class="c1">// Index type: (cell, cell, cell)</span>

<span class="n">Box</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">surroundingNodes</span><span class="p">(</span><span class="n">b0</span><span class="p">);</span>  <span class="c1">// A new Box with type (node, node, node)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b1</span><span class="p">;</span>                  <span class="c1">// ((64,64,64) (128,128,128) (1,1,1))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b0</span><span class="p">;</span>                  <span class="c1">// Still ((64,64,64) (127,127,127) (0,0,0))</span>

<span class="n">Box</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">enclosedCells</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>     <span class="c1">// A new Box with type (cell, cell, cell)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">b2</span> <span class="o">==</span> <span class="n">b0</span><span class="p">)</span> <span class="p">{</span>                 <span class="c1">// Yes, they are identical.</span>
   <span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;b0 and b2 are identical!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Box</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>  <span class="c1">// A new Box with type (cell, node, cell)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b3</span><span class="p">;</span>                  <span class="c1">// ((64,64,64) (127,128,127) (0,1,0))</span>

<span class="n">b3</span><span class="p">.</span><span class="n">convert</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>            <span class="c1">// Convert b0 to type (cell, cell, node)</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b3</span><span class="p">;</span>                  <span class="c1">// ((64,64,64) (127,127,128) (0,0,1))</span>

<span class="n">b3</span><span class="p">.</span><span class="n">surroundingNodes</span><span class="p">();</span>          <span class="c1">//  Exercise for you</span>
<span class="n">b3</span><span class="p">.</span><span class="n">enclosedCells</span><span class="p">();</span>             <span class="c1">//  Exercise for you</span>
</pre></div>
</div>
<p>The internal data of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> can be accessed via various member functions.
Examples are</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">smallEnd</span> <span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>  <span class="c1">// Get the small end of the Box</span>
<span class="kt">int</span> <span class="nf">bigEnd</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dir</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>         <span class="c1">// Get the big end in dir direction</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">loVect</span> <span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>        <span class="c1">// Get a const pointer to the lower end</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">hiVect</span> <span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>        <span class="c1">// Get a const pointer to the upper end</span>
</pre></div>
</div>
<p>Boxes can be refined and coarsened. Refinement or coarsening does not change
the index type. Some examples are shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">ccbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">});</span>
<span class="n">ccbx</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ccbx</span><span class="p">;</span>                   <span class="c1">// ((32,32,32) (63,63,63) (0,0,0))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ccbx</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>        <span class="c1">// ((16,16,16) (31,31,31) (0,0,0))</span>

<span class="n">Box</span> <span class="nf">ndbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">ndbx</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ndbx</span><span class="p">;</span>                   <span class="c1">// ((32,32,32) (64,64,64) (1,1,1))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ndbx</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>        <span class="c1">// ((16,16,16) (32,32,32) (1,1,1))</span>

<span class="n">Box</span> <span class="nf">facebx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>
<span class="n">facebx</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">facebx</span><span class="p">;</span>                 <span class="c1">// ((32,32,32) (64,63,63) (1,0,0))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">facebx</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>      <span class="c1">// ((16,16,16) (32,31,31) (1,0,0))</span>

<span class="n">Box</span> <span class="nf">uncoarsenable</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">});</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">uncoarsenable</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// ((8,8,8), (15,15,15));</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">uncoarsenable</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// ((16,16,16), (31,31,31));</span>
                                     <span class="c1">// Different from the original!</span>
</pre></div>
</div>
<p>Note that the behavior of refinement and coarsening depends on the
index type.  A refined <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> covers the same physical domain as
the original <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>, and a coarsened <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> also covers the
same physical domain if the original <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> is coarsenable.
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span> <span class="name"><span class="pre">uncoarsenable</span></span></code> in the example above is considered
uncoarsenable because its coarsened version does not cover the same
physical domain in the AMR context.</p>
<p>Boxes can grow in one or all directions.  There are a number of grow functions.
Some are member functions of the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> class and others are free
functions in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span></code> namespace.</p>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> class provides the following member functions testing if a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> or <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code> is contained within this <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>. Note that it
is a runtime error if the two Boxes have different types.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">contains</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">strictly_contains</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">contains</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">strictly_contains</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Another very common operation is the intersection of two Boxes like in the
following examples.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">b0</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">});</span>
<span class="n">Box</span> <span class="nf">b1</span> <span class="p">({</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">},</span> <span class="p">{</span><span class="mi">23</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">63</span><span class="p">});</span>
<span class="k">if</span> <span class="p">(</span><span class="n">b0</span><span class="p">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span> <span class="p">{</span>                  <span class="c1">// true</span>
    <span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;b0 and b1 intersect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Box</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">&amp;</span> <span class="n">b1</span><span class="p">;</span>     <span class="c1">// b0 and b1 unchanged</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b2</span><span class="p">;</span>        <span class="c1">// ((16,16,30) (23,23,31) (0,0,0))</span>

<span class="n">Box</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">surroundingNodes</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">surroundingNodes</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span> <span class="c1">// b0 and b1 unchanged</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b3</span><span class="p">;</span>        <span class="c1">// ((16,16,30) (24,24,32) (1,1,1))</span>

<span class="n">b0</span> <span class="o">&amp;=</span> <span class="n">b2</span><span class="p">;</span>             <span class="c1">// b2 unchanged</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">b0</span><span class="p">;</span>        <span class="c1">// ((16,16,30) (23,23,31) (0,0,0))</span>

<span class="n">b0</span> <span class="o">&amp;=</span> <span class="n">b3</span><span class="p">;</span>             <span class="c1">// Runtime error because of type mismatch!</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dim3-and-xdim3">
<span id="sec-basics-dim3"></span><h1>Dim3 and XDim3<a class="headerlink" href="#dim3-and-xdim3" title="Permalink to this headline">Â¶</a></h1>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Dim3</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">XDim3</span></span></code> are plain structs with three fields,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Dim3</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span> <span class="kt">int</span> <span class="n">z</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">XDim3</span> <span class="p">{</span> <span class="n">Real</span> <span class="n">x</span><span class="p">;</span> <span class="n">Real</span> <span class="n">y</span><span class="p">;</span> <span class="n">Real</span> <span class="n">z</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
</div>
<p>One can covert an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code> to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Dim3</span></span></code>,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">IntVect</span> <span class="nf">iv</span><span class="p">(...);</span>
<span class="n">Dim3</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">iv</span><span class="p">.</span><span class="n">dim3</span><span class="p">();</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Dim3</span></span></code> always has three fields even when AMReX is built for 1D or
2D.  For the example above, the extra fields are set to zero.  Given a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>, one can get its lower and upper bounds and use them to
write dimension agnostic loops.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">bx</span><span class="p">(...);</span>
<span class="n">Dim3</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">lbound</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
<span class="n">Dim3</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ubound</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
<span class="k">for</span>     <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span>   <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One can also call function <code class="docutils literal notranslate"><span class="pre">Dim3</span> <span class="pre">length(Box</span> <span class="pre">const&amp;)</span></code> to return the length of a Box.</p>
</div>
<div class="section" id="realbox-and-geometry">
<span id="sec-basics-geom"></span><h1>RealBox and Geometry<a class="headerlink" href="#realbox-and-geometry" title="Permalink to this headline">Â¶</a></h1>
<p>A <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">RealBox</span></span></code> stores the physical location in floating-point numbers of the
lower and upper corners of a rectangular domain.</p>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> class in AMReX_Geometry.H describes problem domain and
coordinate system for rectangular problem domains. A <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> object can
be constructed with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">explicit</span> <span class="nf">Geometry</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span>     <span class="n">dom</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">RealBox</span><span class="o">*</span> <span class="n">rb</span>     <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span>
                   <span class="kt">int</span>            <span class="n">coord</span>  <span class="o">=</span> <span class="mi">-1</span><span class="p">,</span>
                   <span class="kt">int</span><span class="o">*</span>           <span class="n">is_per</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="n">Geometry</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">dom</span><span class="p">,</span> <span class="k">const</span> <span class="n">RealBox</span><span class="o">&amp;</span> <span class="n">rb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">coord</span><span class="p">,</span>
          <span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">is_per</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>Here the constructors take a cell-centered <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> specifying the indexing
space domain, a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">RealBox</span></span></code> specifying the
physical domain, an <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span></code> specifying coordinate system type, and
an <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span></code> pointer or array specifying periodicity. If a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">RealBox</span></span></code> is not
given in the first constructor, AMReX  will construct one based on <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> parameters,
<code class="docutils literal notranslate"><span class="pre">geometry.prob_lo</span></code> and <code class="docutils literal notranslate"><span class="pre">geometry.prob_hi</span></code>, where each of the parameter is
an array of <code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> real numbers. Itâs a runtime error if this
fails. The argument for coordinate system is an integer type with
valid values being 0 (Cartesian), or 1 (cylindrical), or 2 (spherical). If it
is invalid as in the case of the default argument value of the first constructor, AMReX will query the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> database for <code class="docutils literal notranslate"><span class="pre">geometry.coord_sys</span></code> and use it if one is
found. If it cannot find the parameter, the coordinate system is set to 0
(i.e., Cartesian coordinates). The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> class has the concept of
periodicity.  An argument can be passed specifying periodicity in each
dimension. If it is not given in the first constructor, the domain is assumed to be non-periodic unless
there is the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> integer array parameter <code class="docutils literal notranslate"><span class="pre">geometry.is_periodic</span></code>
with 0 denoting non-periodic and 1 denoting periodic. Below is an example of
defining a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> for a periodic rectangular domain of
<span class="math notranslate nohighlight">\([-1.0,1.0]\)</span> in each direction discretized with <span class="math notranslate nohighlight">\(64\)</span> numerical
cells in each direction.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">n_cell</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="c1">// This defines a Box with n_cell cells in each direction.</span>
<span class="n">Box</span> <span class="nf">domain</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span>       <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">)},</span>
           <span class="n">IntVect</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="n">n_cell</span><span class="mi">-1</span><span class="p">,</span> <span class="n">n_cell</span><span class="mi">-1</span><span class="p">,</span> <span class="n">n_cell</span><span class="mi">-1</span><span class="p">)});</span>

<span class="c1">// This defines the physical box, [-1,1] in each direction.</span>
<span class="n">RealBox</span> <span class="nf">real_box</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mf">-1.0</span><span class="p">,</span><span class="mf">-1.0</span><span class="p">,</span><span class="mf">-1.0</span><span class="p">)},</span>
                 <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)});</span>

<span class="c1">// This says we are using Cartesian coordinates</span>
<span class="kt">int</span> <span class="n">coord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// This sets the boundary conditions to be doubly or triply periodic</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">is_periodic</span> <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)};</span>

<span class="c1">// This defines a Geometry object</span>
<span class="n">Geometry</span> <span class="nf">geom</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">real_box</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">is_periodic</span><span class="p">);</span>
</pre></div>
</div>
<p>A <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> object can return various information of the physical domain
and the indexing space domain. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">problo</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">ProbLoArray</span><span class="p">();</span> <span class="c1">// Lower corner of the physical</span>
                                        <span class="c1">// domain.  The return type is</span>
                                        <span class="c1">// GpuArray&lt;Real,AMREX_SPACEDIM&gt;.</span>
<span class="n">Real</span> <span class="n">yhi</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">ProbHi</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>              <span class="c1">// y-direction upper corner</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">CellSizeArray</span><span class="p">();</span>   <span class="c1">// Cell size for each direction.</span>
<span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">Domain</span><span class="p">();</span>      <span class="c1">// Index domain</span>
<span class="kt">bool</span> <span class="n">is_per</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">isPeriodic</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>       <span class="c1">// Is periodic in x-direction?</span>
<span class="k">if</span> <span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">isAllPeriodic</span><span class="p">())</span> <span class="p">{}</span>            <span class="c1">// Periodic in all direction?</span>
<span class="k">if</span> <span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">isAnyPeriodic</span><span class="p">())</span> <span class="p">{}</span>            <span class="c1">// Periodic in any direction?</span>
</pre></div>
</div>
</div>
<div class="section" id="boxarray">
<span id="sec-basics-ba"></span><h1>BoxArray<a class="headerlink" href="#boxarray" title="Permalink to this headline">Â¶</a></h1>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> is a class in <code class="docutils literal notranslate"><span class="pre">AMReX_BoxArray.H</span></code> for storing a collection of
Boxes on a single AMR level. One can make a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> out of a single
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> and then chop it into multiple Boxes.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">domain</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">});</span>
<span class="n">BoxArray</span> <span class="nf">ba</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>  <span class="c1">// Make a new BoxArray out of a single Box</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;BoxArray size is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ba</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// 1</span>
<span class="n">ba</span><span class="p">.</span><span class="n">maxSize</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>       <span class="c1">// Chop into boxes of 64^3 cells</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ba</span><span class="p">;</span>
</pre></div>
</div>
<p>The output is like below,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">BoxArray</span> <span class="n">maxbox</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
       <span class="n">m_ref</span><span class="o">-&gt;</span><span class="n">m_hash_sig</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</div>
<p>It shows that <code class="docutils literal notranslate"><span class="pre">ba</span></code> now has 8 Boxes, and it also prints out each Box.</p>
<p>In AMReX, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> is a global data structure. It holds all the Boxes in
a collection, even though a single process in a parallel run only owns some of
the Boxes via domain decomposition. In the example above, a 4-process run may
divide the work and each process owns say 2 Boxes (see section
on <a class="reference internal" href="#sec-basics-dm"><span class="std std-ref">DistributionMapping</span></a>). Each process can then allocate memory for the
floating point data on the Boxes it owns (see sections
on <a class="reference internal" href="#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a> &amp; <a class="reference internal" href="#sec-basics-fab"><span class="std std-ref">BaseFab, FArrayBox, IArrayBox, and Array4</span></a>).</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> has an indexing type, just like <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>. Each Box in a
BoxArray has the same type as the BoxArray itself. In the following example, we
show how one can convert BoxArray to a different type.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BoxArray</span> <span class="nf">cellba</span><span class="p">(</span><span class="n">Box</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">63</span><span class="p">,</span><span class="mi">127</span><span class="p">,</span><span class="mi">127</span><span class="p">}));</span>
<span class="n">cellba</span><span class="p">.</span><span class="n">maxSize</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="n">BoxArray</span> <span class="n">faceba</span> <span class="o">=</span> <span class="n">cellba</span><span class="p">;</span>       <span class="c1">// Make a copy</span>
<span class="n">faceba</span><span class="p">.</span><span class="n">convert</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span> <span class="c1">// convert to index type (cell, cell, node)</span>
<span class="c1">// Return an all node BoxArray</span>
<span class="k">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">nodeba</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">faceba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">cellba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// ((0,0,0) (63,63,63) (0,0,0))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">faceba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// ((0,0,0) (63,63,64) (0,0,1))</span>
<span class="n">Print</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nodeba</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>  <span class="c1">// ((0,0,0) (64,64,64) (1,1,1))</span>
</pre></div>
</div>
<p>As shown in the example above, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> has an <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code> that
returns a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> given an index. It should be emphasized that there is a
difference between its behavior and the usual behavior of an subscript operator
one might expect. The subscript operator in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> returns by <strong>value
instead of reference</strong>. This means code like below is meaningless because it
modifies a temporary return value.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ba</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">// DO NOT DO THIS!  Doesn&#39;t do what one might expect.</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> has a number of member functions that allow the Boxes to be
modified. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BoxArray</span><span class="o">&amp;</span> <span class="nf">refine</span> <span class="p">(</span><span class="kt">int</span> <span class="n">refinement_ratio</span><span class="p">);</span>   <span class="c1">// Refine each Box in BoxArray</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="nf">refine</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">refinement_ratio</span><span class="p">);</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="nf">coarsen</span> <span class="p">(</span><span class="kt">int</span> <span class="n">refinement_ratio</span><span class="p">);</span>  <span class="c1">// Coarsen each Box in BoxArray</span>
<span class="n">BoxArray</span><span class="o">&amp;</span> <span class="nf">coarsen</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">refinement_ratio</span><span class="p">);</span>
</pre></div>
</div>
<p>We have mentioned at the beginning of this section that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> is a
global data structure storing Boxes shared by all processes.  The operation of
a deep copy is thus undesirable because it is expensive and the extra copy
wastes memory. The implementation of the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> class uses
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">shared_ptr</span></span></code> to an internal container holding the actual Box data.
Thus making a copy of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> is a quite cheap operation. The
conversion of types and coarsening are also cheap because they can share the
internal data with the original <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>. In our implementation,
function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">refine</span></span></code> does create a new deep copy of the original data. Also
note that a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> and its variant with a different type share the
same internal data is an implementation detail.  We discuss this so that the
users are aware of the performance and resource cost. Conceptually we can think
of them as completely independent of each other.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BoxArray</span> <span class="nf">ba</span><span class="p">(...);</span>  <span class="c1">// original BoxArray</span>
<span class="n">BoxArray</span> <span class="n">ba2</span> <span class="o">=</span> <span class="n">ba</span><span class="p">;</span> <span class="c1">// a copy that shares the internal data with the original</span>
<span class="n">ba2</span><span class="p">.</span><span class="n">coarsen</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>    <span class="c1">// Modify the copy</span>
<span class="c1">// The original copy is unmodified even though they share internal data.</span>
</pre></div>
</div>
<p>For advanced users, AMReX provides functions performing the intersection of a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> and a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>. These functions are much faster than a naive
implementation of performing intersection of the Box with each Box in the
BoxArray. If one needs to perform those intersections, functions
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">intersect</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">intersects</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">intersections</span></span></code> should be used.</p>
</div>
<div class="section" id="distributionmapping">
<span id="sec-basics-dm"></span><h1>DistributionMapping<a class="headerlink" href="#distributionmapping" title="Permalink to this headline">Â¶</a></h1>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> is a class in <code class="docutils literal notranslate"><span class="pre">AMReX_DistributionMapping.H</span></code> that
describes which process owns the data living on the domains specified by the
Boxes in a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>. Like <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>, there is an element for each
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>, including the ones owned by other
parallel processes. One can construct a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> object given
a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span> <span class="p">{</span><span class="n">ba</span><span class="p">};</span>
</pre></div>
</div>
<p>or by simply making a copy,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span> <span class="p">{</span><span class="n">another_dm</span><span class="p">};</span>
</pre></div>
</div>
<p>Note that this class is built using <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">std</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">shared_ptr</span></span></code>. Thus making a copy
is relatively cheap in terms of performance and memory resources. This class
has a subscript operator that returns the process ID at a given index.</p>
<p>By default, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> uses an algorithm based on space filling
curve to determine the distribution. One can change the default via the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> parameter <code class="docutils literal notranslate"><span class="pre">DistributionMapping.strategy</span></code>.  <code class="docutils literal notranslate"><span class="pre">KNAPSACK</span></code> is a
common choice that is optimized for load balance.  One can also explicitly
construct a distribution.  The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> class allows the user
to have complete control by passing an array of integers that represent the
mapping of grids to processes.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DistributionMapping</span> <span class="n">dm</span><span class="p">;</span>   <span class="c1">// empty object</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pmap</span> <span class="p">{...};</span>
<span class="c1">// The user fills the pmap array with the values specifying owner processes</span>
<span class="n">dm</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="n">pmap</span><span class="p">);</span>  <span class="c1">// Build DistributionMapping given an array of process IDs.</span>
</pre></div>
</div>
</div>
<div class="section" id="basefab-farraybox-iarraybox-and-array4">
<span id="sec-basics-fab"></span><h1>BaseFab, FArrayBox, IArrayBox, and Array4<a class="headerlink" href="#basefab-farraybox-iarraybox-and-array4" title="Permalink to this headline">Â¶</a></h1>
<p>AMReX is a block-structured AMR framework. Although AMR introduces irregularity
to the data and algorithms, there is regularity at the block/Box level because
each is still logically rectangular, and the data structure at the Box level is
conceptually simple. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> is a class template for multi-dimensional
array-like data structure on a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>. The template parameter is typically
basic types such as <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Real</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span></code> or <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">char</span></span></code>. The dimensionality
of the array is <code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> <em>plus one</em>. The additional dimension is for
the number of components. The data are internally stored in a contiguous block
of memory in Fortran array order (i.e., column-major order) for
<span class="math notranslate nohighlight">\((x,y,z,\mathrm{component})\)</span>, and each component also occupies a
contiguous block of memory because of the ordering. For example, a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">Real</span></span><span class="operator"><span class="pre">&gt;</span></span></code> with 4 components defined on a three-dimensional
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">IntVect</span></span><span class="punctuation"><span class="pre">{</span></span><span class="literal number integer"><span class="pre">-4</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">32</span></span><span class="punctuation"><span class="pre">},</span></span><span class="name"><span class="pre">IntVect</span></span><span class="punctuation"><span class="pre">{</span></span><span class="literal number integer"><span class="pre">32</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">48</span></span><span class="punctuation"><span class="pre">})</span></span></code> is like a Fortran array of
<code class="code fortran docutils literal notranslate"><span class="keyword type"><span class="pre">real</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">amrex_real</span></span><span class="punctuation"><span class="pre">),</span></span> <span class="keyword"><span class="pre">dimension</span></span><span class="punctuation"><span class="pre">(</span></span><span class="operator"><span class="pre">-</span></span><span class="literal number integer"><span class="pre">4</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">32</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">64</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">32</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">48</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">3</span></span><span class="punctuation"><span class="pre">)</span></span></code>.  Note that the
convention in C++ part of AMReX is the component index is zero based. The code
for constructing such an object is as follows,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">bx</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">-4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">48</span><span class="p">});</span>
<span class="kt">int</span> <span class="n">numcomps</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="n">fab</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span><span class="n">numcomps</span><span class="p">);</span>
</pre></div>
</div>
<p>Most applications do not use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> directly, but utilize specialized
classes derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code>. The most common types are <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>
in AMReX_FArrayBox.H derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">Real</span></span><span class="operator"><span class="pre">&gt;</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IArrayBox</span></span></code> in
AMReX_IArrayBox.H derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword type"><span class="pre">int</span></span><span class="operator"><span class="pre">&gt;</span></span></code>.</p>
<p>These derived classes also obtain many <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> member functions via
inheritance. We now show some common usages of these functions.  To get the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> where a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> or its derived object is defined, one can
call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>To the number of component, one can call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">nComp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>To get a pointer to the array data, one can call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">*</span> <span class="nf">dataPtr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>     <span class="c1">// Data pointer to the nth component</span>
                         <span class="c1">// T is template parameter (e.g., Real)</span>
<span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">dataPtr</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// const version</span>
</pre></div>
</div>
<p>The typical usage of the returned pointer is then to pass it to a Fortran or C
function that works on the array data (see the section on
<a class="reference internal" href="#sec-basics-fortran"><span class="std std-ref">Fortran and C++ Kernels</span></a>).  <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> has several functions that set the
array data to a constant value. Two examples are as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">);</span>        <span class="c1">// Set all data to x</span>
<span class="c1">// Set the sub-region specified by bx to value x starting from component</span>
<span class="c1">// nstart.  ncomp is the total number of component to be set.</span>
<span class="kt">void</span> <span class="nf">setVal</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nstart</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">);</span>
</pre></div>
</div>
<p>One can copy data from one <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> to another.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">copy</span> <span class="p">(</span><span class="k">const</span> <span class="n">BaseFab</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">srcbox</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srccomp</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">destbox</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destcomp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numcomp</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the function copies the data from the region specified by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">srcbox</span></span></code> in
the source <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span> <span class="name"><span class="pre">src</span></span></code> into the region specified by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">destbox</span></span></code> in
the destination BaseFab that invokes the function call. Note that although
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">srcbox</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">destbox</span></span></code> may be different, they must be the same size,
shape and index type, otherwise a runtime error occurs. The user also specifies
how many components (<code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">numcomp</span></span></code>) are copied starting at component
srccomp in src and stored starting at component destcomp. BaseFab has functions
returning the minimum or maximum value.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="nf">min</span> <span class="p">(</span><span class="kt">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// Minimum value of given component.</span>
<span class="n">T</span> <span class="nf">min</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">subbox</span><span class="p">,</span> <span class="kt">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// Minimum value of given</span>
                                             <span class="c1">// component in given subbox.</span>
<span class="n">T</span> <span class="nf">max</span> <span class="p">(</span><span class="kt">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// Maximum value of given component.</span>
<span class="n">T</span> <span class="nf">max</span> <span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">subbox</span><span class="p">,</span> <span class="kt">int</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// Maximum value of given</span>
                                             <span class="c1">// component in given subbox.</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> also has many arithmetic functions. Here are some examples using
FArrayBox.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">box</span><span class="p">(</span><span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">,</span><span class="mi">63</span><span class="p">});</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">FArrayBox</span> <span class="nf">fab1</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">);</span>
<span class="n">FArrayBox</span> <span class="nf">fab2</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">);</span>
<span class="n">fab1</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>    <span class="c1">// Fill fab1 with 1.0</span>
<span class="n">fab1</span><span class="p">.</span><span class="n">mult</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// Multiply component 0 by 10.0</span>
<span class="n">fab2</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>    <span class="c1">// Fill fab2 with 2.0</span>
<span class="n">Real</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
<span class="n">fab2</span><span class="p">.</span><span class="n">saxpy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fab1</span><span class="p">);</span> <span class="c1">// For both components, fab2 &lt;- a * fab1 + fab2</span>
</pre></div>
</div>
<p>These floating point operation functions are templated with parameter
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">RunOn</span></span></code> specifying where they run, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">RunOn</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Host</span></span></code> or
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">RunOn</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Device</span></span></code>.  When AMReX is built just for CPU, the
template parameter has a default value of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">RunOn</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Host</span></span></code> so that
the user does not need to specify it for backward compatibility,
and if <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">RunOn</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Device</span></span></code> is provided it will be ignored.
However, when AMReX is built with GPU support, one must specify where
to run for these <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> functions.  For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">fab1</span><span class="p">.</span><span class="n">setVal</span><span class="o">&lt;</span><span class="n">RunOn</span><span class="o">::</span><span class="n">Host</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>    <span class="c1">// Fill fab1 with 1.0</span>
<span class="n">fab1</span><span class="p">.</span><span class="n">mult</span><span class="o">&lt;</span><span class="n">RunOn</span><span class="o">::</span><span class="n">Device</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// Multiply component 0 by 10.0</span>
</pre></div>
</div>
<p id="sec-basics-array4">For more complicated expressions that are not supported, one can write
Fortran or C/C++ functions for those (see the section
on <a class="reference internal" href="#sec-basics-fortran"><span class="std std-ref">Fortran and C++ Kernels</span></a>).  In C++, one can use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code>,
which is a class template for accessing <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> data in a more
array like manner using <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">()</span></span></code>.  Below is an example of
using <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">FArrayBox</span> <span class="nf">afab</span><span class="p">(...),</span> <span class="n">bfab</span><span class="p">(...);</span>
<span class="n">IArrayBox</span> <span class="nf">ifab</span><span class="p">(...);</span>
<span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">afab</span><span class="p">.</span><span class="n">array</span><span class="p">();</span>
<span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bfab</span><span class="p">.</span><span class="n">const_array</span><span class="p">();</span>
<span class="n">Array4</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">ifab</span><span class="p">.</span><span class="n">array</span><span class="p">();</span>
<span class="n">Dim3</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">lbound</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">Dim3</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ubound</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nc</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span>     <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span>   <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">*=</span> <span class="mf">2.0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">()</span></span></code> of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code> takes either three or
four arguments.  The optional fourth argument has a default value of
zero.  The two <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">const</span></span></code>s in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">Real</span></span> <span class="keyword"><span class="pre">const</span></span><span class="operator"><span class="pre">&gt;</span></span> <span class="keyword"><span class="pre">const</span></span><span class="operator"><span class="pre">&amp;</span></span></code>
have different meaning.  The first <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">const</span></span></code> inside <code class="code cpp c++ docutils literal notranslate"><span class="operator"><span class="pre">&lt;&gt;</span></span></code> means
the data accessed via <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code> is read-only, whereas the second
<code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">const</span></span></code> means the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code> object itself cannot be modified
to point to other data.  In the example above, neither <code class="docutils literal notranslate"><span class="pre">m(i,j,k)</span> <span class="pre">=</span>
<span class="pre">0</span></code> nor <code class="docutils literal notranslate"><span class="pre">b(i,j,k)</span> <span class="pre">=</span> <span class="pre">0.0</span></code> is allowed.  However one is allowed to do
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">ifab2.array()</span></code> to assign <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> again, but not to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code>.
The behavior is in some sense similar to <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">p</span></code>.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> and its derived classes are containers for data on <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>.
Recall that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> has various types (see the section on <a class="reference internal" href="#sec-basics-box"><span class="std std-ref">Box, IntVect and IndexType</span></a>).
The examples in this section so far use the default cell based type.  However,
some functions will result in a runtime error if the types mismatch.  For
example.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">ccbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">});</span>           <span class="c1">// cell centered box</span>
<span class="n">Box</span> <span class="nf">ndbx</span> <span class="p">({</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>  <span class="c1">// nodal box</span>
<span class="n">FArrayBox</span> <span class="nf">ccfab</span><span class="p">(</span><span class="n">ccbx</span><span class="p">);</span>
<span class="n">FArrayBox</span> <span class="nf">ndfab</span><span class="p">(</span><span class="n">ndbx</span><span class="p">);</span>
<span class="n">ccfab</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">ndfab</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ccfab</span><span class="p">);</span>   <span class="c1">// runtime error due to type mismatch</span>
</pre></div>
</div>
<p>Because it typically contains a lot of data, BaseFabâs copy constructor and
copy assignment operator are disabled to prevent performance degradation. However, BaseFab does
provide a move constructor. In addition, it also provides a constructor for
making an alias of an existing object. Here is an example using
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">FArrayBox</span> <span class="nf">orig_fab</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 4-component FArrayBox</span>
<span class="c1">// Make a 2-component FArrayBox that is an alias of orig_fab</span>
<span class="c1">// starting from component 1.</span>
<span class="n">FArrayBox</span> <span class="nf">alias_fab</span><span class="p">(</span><span class="n">orig_fab</span><span class="p">,</span> <span class="n">amrex</span><span class="o">::</span><span class="n">make_alias</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, the alias <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> has only two components even though
the original one has four components. The alias has a sliced component view of
the original <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>. This is possible because of the array ordering.
However, it is not possible to slice in the real space (i.e., the first
<code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> dimensions).  Note that no new memory is allocated in
constructing the alias and the alias contains a non-owning pointer. It should
be emphasized that the alias will contain a dangling pointer after the original
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> reaches its end of life.  One can also construct an
alias <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> given an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code>,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">a</span> <span class="o">=</span> <span class="n">orig_fab</span><span class="p">.</span><span class="n">array</span><span class="p">();</span>
<span class="n">FArrayBox</span> <span class="nf">alias_fab</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="fabarray-multifab-and-imultifab">
<span id="sec-basics-multifab"></span><h1>FabArray, MultiFab and iMultiFab<a class="headerlink" href="#fabarray-multifab-and-imultifab" title="Permalink to this headline">Â¶</a></h1>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">FAB</span></span><span class="operator"><span class="pre">&gt;</span></span></code> is a class template in AMReX_FabArray.H for a collection
of FABs on the same AMR level associated with a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> (see the
section on <a class="reference internal" href="#sec-basics-ba"><span class="std std-ref">BoxArray</span></a>). The template parameter <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FAB</span></span></code> is usually
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">&gt;</span></span></code> or its derived classes (e.g., <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>). However, FabArray
can also be used to hold other data structures. To construct a FabArray, a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> must be provided because the FabArray is intended to hold <em>grid</em> data
defined on a union of rectangular regions embedded in a uniform index space.
For example, a FabArray object can be used to hold data for one level as in
<a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 1</span></a>.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code> is a parallel data structure in which the data (i.e., FAB) are
distributed among parallel processes. For each process, a FabArray contains
only the FAB objects owned by that process, and the process operates only on
its local data. For operations that require data owned by other processes,
remote communications are involved. Thus, the construction of a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code>
requires a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> (see the section on <a class="reference internal" href="#sec-basics-dm"><span class="std std-ref">DistributionMapping</span></a>)
that specifies which process owns which Box. For level 2 (<em>red</em>) in
<a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 1</span></a>, there are two Boxes. Suppose there are two
parallel processes, and we use a DistributionMapping that assigns one Box to
each process. Then the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code> on each process is built on the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> with both Boxes, but contains only the FAB associated with its process.</p>
<p>In AMReX, there are some specialized classes derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code>. The
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">iMultiFab</span></span></code> class in AMReX_iMultiFab.H is derived from
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">IArrayBox</span></span><span class="operator"><span class="pre">&gt;</span></span></code>. The most commonly used <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code> kind class
is <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> in AMReX_MultiFab.H derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">FArrayBox</span></span><span class="operator"><span class="pre">&gt;</span></span></code>.
In the rest of this section, we use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> as example. However, these
concepts are equally applicable to other types of FabArrays. There are many
ways to define a MultiFab. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// ba is BoxArray</span>
<span class="c1">// dm is DistributionMapping</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">MultiFab</span> <span class="nf">mf</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we define a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> with 4 components and 1 ghost cell. A MultiFab
contains a number of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>es (see the section
on <a class="reference internal" href="#sec-basics-fab"><span class="std std-ref">BaseFab, FArrayBox, IArrayBox, and Array4</span></a>) defined on Boxes grown by the number of ghost cells
(1 in this example). That is the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> is not
exactly the same as in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>.  If the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> has a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span><span class="punctuation"><span class="pre">{(</span></span><span class="literal number integer"><span class="pre">7</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">7</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">7</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">)}</span></span></code>, the one used for constructing <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>
will be <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span><span class="punctuation"><span class="pre">{(</span></span><span class="literal number integer"><span class="pre">6</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">6</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">6</span></span><span class="punctuation"><span class="pre">)</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">)}</span></span></code> in this example. For cells in
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>, we call those in the original <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> <strong>valid cells</strong> and
the grown part <strong>ghost cells</strong>. Note that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> itself does not have
the concept of ghost cells.  Ghost cells are a key concept of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>, however, that allows for local operations on ghost cell data
originated from remote processes. We will discuss how to fill ghost cells with
data from valid cells later in this section.  <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> also has a
default constructor. One can define an empty <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> first and then
call the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">define</span></span></code> function as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultiFab</span> <span class="n">mf</span><span class="p">;</span>
<span class="c1">// ba is BoxArray</span>
<span class="c1">// dm is DistributionMapping</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mf</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
</pre></div>
</div>
<p>Given an existing <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>, one can also make an alias <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>
as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// orig_mf is an existing MultiFab</span>
<span class="kt">int</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num_comps</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">MultiFab</span> <span class="nf">alias_mf</span><span class="p">(</span><span class="n">orig_mf</span><span class="p">,</span> <span class="n">amrex</span><span class="o">::</span><span class="n">make_alias</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">num_comps</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the first integer parameter is the starting component in the original
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> that will become component 0 in the alias <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> and
the second integer parameter is the number of components in the alias. Itâs a
runtime error if the sum of the two integer parameters is greater than the
number of the components in the original MultiFab. Note that the alias MultiFab
has exactly the same number of ghost cells as the original MultiFab.</p>
<p>We often need to build new MultiFabs that have the same <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> as a given MultiFab.  Below is an example of how to
achieve this.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// mf0 is an already defined MultiFab</span>
<span class="k">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">ba</span> <span class="o">=</span> <span class="n">mf0</span><span class="p">.</span><span class="n">boxArray</span><span class="p">();</span>
<span class="k">const</span> <span class="n">DistributionMapping</span><span class="o">&amp;</span> <span class="n">dm</span> <span class="o">=</span> <span class="n">mf0</span><span class="p">.</span><span class="n">DistributionMap</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="n">mf0</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="n">mf0</span><span class="p">.</span><span class="n">nGrow</span><span class="p">();</span>
<span class="n">MultiFab</span> <span class="nf">mf1</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="n">dm</span><span class="p">,</span><span class="n">ncomp</span><span class="p">,</span><span class="n">ngrow</span><span class="p">);</span>  <span class="c1">// new MF with the same ncomp and ngrow</span>
<span class="n">MultiFab</span> <span class="nf">mf2</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span><span class="n">dm</span><span class="p">,</span><span class="n">ncomp</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">// new MF with no ghost cells</span>
<span class="c1">// new MF with 1 component and 2 ghost cells</span>
<span class="n">MultiFab</span> <span class="nf">mf3</span><span class="p">(</span><span class="n">mf0</span><span class="p">.</span><span class="n">boxArray</span><span class="p">(),</span> <span class="n">mf0</span><span class="p">.</span><span class="n">DistributionMap</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>As we have repeatedly mentioned in this chapter that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> have various index types. Thus, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> also has an
index type that is obtained from the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> used for defining the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>. It should be noted again that index type is a very important
concept in AMReX. Letâs consider an example of a finite-volume code, in which
the state is defined as cell averaged variables and the fluxes are defined as
face averaged variables.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// ba is cell-centered BoxArray</span>
<span class="c1">// dm is DistributionMapping</span>
<span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// Suppose the system has 3 components</span>
<span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// no ghost cells</span>
<span class="n">MultiFab</span> <span class="nf">state</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="nf">xflux</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="nf">yflux</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="nf">zflux</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Here all <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>s  use the same <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>, but their
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>s have different index types. The state is cell-based, whereas
the fluxes are on the faces. Suppose the cell based <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> contains a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span><span class="punctuation"><span class="pre">{(</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">),</span></span> <span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">31</span></span><span class="punctuation"><span class="pre">)}</span></span></code>. The state on that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> is conceptually
a Fortran Array with the dimension of <code class="code fortran docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">31</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">2</span></span><span class="punctuation"><span class="pre">)</span></span></code>. The
fluxes are arrays with slightly different indices. For example, the
<span class="math notranslate nohighlight">\(x\)</span>-direction flux for that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> has the dimension of
<code class="code fortran docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">15</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">16</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">31</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">2</span></span><span class="punctuation"><span class="pre">)</span></span></code>. Note there is an extra element in
<span class="math notranslate nohighlight">\(x\)</span>-direction.</p>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> class provides many functions performing common arithmetic
operations on a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> or between <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>s  built with the
<em>same</em> <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMap</span></span></code>.  For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="n">dmin</span> <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>   <span class="c1">// Minimum value in component 3 of MultiFab mf</span>
                         <span class="c1">// no ghost cells included</span>
<span class="n">Real</span> <span class="n">dmax</span> <span class="o">=</span> <span class="n">mf</span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Maximum value in component 3 of MultiFab mf</span>
                         <span class="c1">// including 1 ghost cell</span>
<span class="n">mf</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>          <span class="c1">// Set all values to zero including ghost cells</span>

<span class="n">MultiFab</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="n">mfdst</span><span class="p">,</span> <span class="n">mfsrc</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span>  <span class="c1">// Add mfsrc to mfdst</span>
<span class="n">MultiFab</span><span class="o">::</span><span class="n">Copy</span><span class="p">(</span><span class="n">mfdst</span><span class="p">,</span> <span class="n">mfsrc</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span> <span class="c1">// Copy from mfsrc to mfdst</span>
<span class="c1">// MultiFab mfdst: destination</span>
<span class="c1">// MultiFab mfsrc: source</span>
<span class="c1">// int      sc   : starting component index in mfsrc for this operation</span>
<span class="c1">// int      dc   : starting component index in mfdst for this operation</span>
<span class="c1">// int      nc   : number of components for this operation</span>
<span class="c1">// int      ng   : number of ghost cells involved in this operation</span>
<span class="c1">//                 mfdst and mfsrc may have more ghost cells</span>
</pre></div>
</div>
<p>We refer the reader to <code class="docutils literal notranslate"><span class="pre">amrex/Src/Base/AMReX_MultiFab.H</span></code> and
<code class="docutils literal notranslate"><span class="pre">amrex/Src/Base/AMReX_FabArray.H</span></code> for more details. It should be noted again
it is a runtime error if the two <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>s  passed to functions like
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Copy</span></span></code> are not built with the <em>same</em> <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> (including
index type) and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>.</p>
<p>It is usually the case that the Boxes in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> used for building
a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> are non-intersecting except that they can be overlapping due
to nodal index type. However, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> can have ghost cells, and in that
case FArrayBoxes are defined on Boxes larger than the Boxes in the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>.  Parallel communication is then needed to fill the ghost cells
with valid cell data from other FArrayBoxes possibly on other parallel
processes. The function for performing this type of communication is
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultiFab</span> <span class="nf">mf</span><span class="p">(...</span><span class="n">parameters</span> <span class="n">omitted</span><span class="p">...);</span>
<span class="n">Geometry</span> <span class="nf">geom</span><span class="p">(...</span><span class="n">parameters</span> <span class="n">omitted</span><span class="p">...);</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">();</span>                    <span class="c1">// Fill ghost cells for all components</span>
                                      <span class="c1">// Periodic boundaries are not filled.</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">periodicity</span><span class="p">());</span>  <span class="c1">// Fill ghost cells for all components</span>
                                      <span class="c1">// Periodic boundaries are filled.</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>        <span class="c1">// Fill 3 components starting from component 2</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">periodicity</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code> does not modify any valid cells. Also note that
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> itself does not have the concept of periodic boundary, but
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> has, and we can provide that information so that periodic
boundaries can be filled as well. You might have noticed that a ghost cell
could overlap with multiple valid cells from different FArrayBoxes in the case
of nodal index type. In that case, it is unspecified that which valid cellâs
value is used to fill the ghost cell. It ought to be the case the values in
those overlapping valid cells are the same up to roundoff errors.  If
a ghost cell does not overlap with any valid cells, its value will not
be modified by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code>.</p>
<p>Another type of parallel communication is copying data from one <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>
to another <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> with a different <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> or the same
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> with a different <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>. The data copy is
performed on the regions of intersection. The most generic interface for this
is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">mfdst</span><span class="p">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">compsrc</span><span class="p">,</span> <span class="n">compdst</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">ngsrc</span><span class="p">,</span> <span class="n">ngdst</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">mfdst</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">mfsrc</span></span></code> are destination and source MultiFabs,
respectively. Parameters <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">compsrc</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">compdst</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ncomp</span></span></code> are
integers specifying the range of components. The copy is performed on
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ncomp</span></span></code> components starting from component <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">compsrc</span></span></code> of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">mfsrc</span></span></code>
and component <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">compdst</span></span></code> of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">mfdst</span></span></code>. Parameters <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ngsrc</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ngdst</span></span></code> specify the number of ghost cells involved for the source and
destination, respectively. Parameter <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">period</span></span></code> is optional, and by default
no periodic copy is performed. Like <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code>, one can use
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">periodicity</span></span><span class="punctuation"><span class="pre">()</span></span></code> to provide the periodicity information. The last
parameter is also optional and is set to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArrayBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">COPY</span></span></code> by default.
One could also use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArrayBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ADD</span></span></code>. This determines whether the
function copies or adds data from the source to the
destination. Similar to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code>, if a destination cell has
multiple cells as source, it is unspecified that which source cell is used in
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArrayBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">COPY</span></span></code>, and, for <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArrayBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ADD</span></span></code>, the multiple
values are all added to the destination cell.  This function has two
variants, in which the periodicity and operation type are also optional.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">mfdst</span><span class="p">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>  <span class="c1">// mfdst and mfsrc must have the same</span>
                                        <span class="c1">// number of components</span>
<span class="n">mfdst</span><span class="p">.</span><span class="n">ParallelCopy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">compsrc</span><span class="p">,</span> <span class="n">compdst</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the number of ghost cells involved is zero, and the copy is performed on
all components if unspecified (assuming the two MultiFabs have the same number
of components).</p>
</div>
<div class="section" id="mfiter-and-tiling">
<span id="sec-basics-mfiter"></span><h1>MFIter and Tiling<a class="headerlink" href="#mfiter-and-tiling" title="Permalink to this headline">Â¶</a></h1>
<p>In this section, we will first show how <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> works without tiling.
Then we will introduce the concept of logical tiling.  Finally we will show how
logical tiling can be launched via <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code>.</p>
<div class="section" id="mfiter-without-tiling">
<span id="sec-basics-mfiter-notiling"></span><h2>MFIter without Tiling<a class="headerlink" href="#mfiter-without-tiling" title="Permalink to this headline">Â¶</a></h2>
<p>In the section on <a class="reference internal" href="#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a>, we have shown some of the
arithmetic functionalities of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>, such as adding two MultiFabs
together. In this section, we will show how you can operate on the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> data with your own functions. AMReX provides an iterator,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> for looping over the FArrayBoxes in MultiFabs. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over grids</span>
<span class="p">{</span>
    <span class="c1">// This is the valid Box of the current FArrayBox.</span>
    <span class="c1">// By &quot;valid&quot;, we mean the original ungrown Box in BoxArray.</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>

    <span class="c1">// A reference to the current FArrayBox in this loop iteration.</span>
    <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

    <span class="c1">// Obtain Array4 from FArrayBox.  We can also do</span>
    <span class="c1">//     Array4&lt;Real&gt; const&amp; a = mf.array(mfi);</span>
    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">array</span><span class="p">();</span>

    <span class="c1">// Call function f1 to work on the region specified by box.</span>
    <span class="c1">// Note that the whole region of the Fab includes ghost</span>
    <span class="c1">// cells (if there are any), and is thus larger than or</span>
    <span class="c1">// equal to &quot;box&quot;.</span>
    <span class="n">f1</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">f1</span></span></code> might be something like below,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f1</span> <span class="p">(</span><span class="n">Box</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">bx</span><span class="p">,</span> <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">const</span> <span class="k">auto</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">lbound</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
   <span class="k">const</span> <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ubound</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
   <span class="k">for</span>     <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">for</span>   <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="p">...</span>
       <span class="p">}</span>
     <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> only loops over grids owned by this process. For example, suppose
there are 5 Boxes in total and processes 0 and 1 own 2 and 3 Boxes,
respectively. That is the MultiFab on process 0 has 2 FArrayBoxes, whereas
there are 3 FArrayBoxes on process 1. Thus the numbers of iterations of MFIter
are 2 and 3 on processes 0 and 1, respectively.</p>
<p>In the example above, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> is assumed to have a single
component. If it has multiple components, we can call <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nc</span> <span class="pre">=</span>
<span class="pre">mf.nComp()</span></code> or <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nc</span> <span class="pre">=</span> <span class="pre">a.nComp()</span></code> to get the number of components.</p>
<p>There is only one <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> in the example above. Below is an example of
working with multiple MultiFabs. Note that these two MultiFabs are not
necessarily built on the same <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>.  But they must have the same
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>, and their BoxArrays are typically related (e.g.,
they are different due to index types).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// U and F are MultiFabs</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">F</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over grids</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>

    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">U</span><span class="p">.</span><span class="n">const_array</span><span class="p">(</span><span class="n">mfi</span><span class="p">);</span>
    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span>      <span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">mfi</span><span class="p">);</span>

    <span class="n">f2</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">f2</span></span></code> might be something like below,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f1</span> <span class="p">(</span><span class="n">Box</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">bx</span><span class="p">,</span> <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">u</span><span class="p">,</span>
         <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">const</span> <span class="k">auto</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">lbound</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
   <span class="k">const</span> <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ubound</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
   <span class="k">const</span> <span class="kt">int</span> <span class="n">nf</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nf</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">for</span>     <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">for</span>   <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="p">...</span> <span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="p">...</span>
         <span class="p">}</span>
       <span class="p">}</span>
     <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mfiter-with-tiling">
<span id="sec-basics-mfiter-tiling"></span><h2>MFIter with Tiling<a class="headerlink" href="#mfiter-with-tiling" title="Permalink to this headline">Â¶</a></h2>
<p>Tiling, also known as cache blocking, is a well known loop transformation
technique for improving data locality.  This is often done by transforming the
loops into tiling loops that iterate over tiles and element loops that iterate
over the data elements within a tile. For example, the original loops might
look like this in Fortran</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="n">kmin</span><span class="p">,</span> <span class="n">kmax</span>
  <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span>
    <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span>
      <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="p">&amp;</span>
                <span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">6.0d0</span><span class="o">*</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
    <span class="k">end do</span>
<span class="k">  end do</span>
<span class="k">end do</span>
</pre></div>
</div>
<p>And the manually tiled loops might look like</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">jblocksize</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">kblocksize</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">jblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">jmax</span><span class="o">-</span><span class="n">jmin</span><span class="o">+</span><span class="n">jblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">jblocksize</span>
<span class="n">kblocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">kmax</span><span class="o">-</span><span class="n">kmin</span><span class="o">+</span><span class="n">kblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">kblocksize</span>
<span class="k">do </span><span class="n">kb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kblocks</span><span class="o">-</span><span class="mi">1</span>
  <span class="k">do </span><span class="n">jb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jblocks</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="n">kb</span><span class="o">*</span><span class="n">kblocksize</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">kb</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">kblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">kmax</span><span class="p">)</span>
      <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">jb</span><span class="o">*</span><span class="n">jblocksize</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">jb</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">jblocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">jmax</span><span class="p">)</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">imin</span><span class="p">,</span> <span class="n">imax</span>
          <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="p">&amp;</span>
                    <span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mf">6.0d0</span><span class="o">*</span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">end do</span>
<span class="k">      end do</span>
<span class="k">    end do</span>
<span class="k">  end do</span>
<span class="k">end do</span>
</pre></div>
</div>
<p>As we can see, to manually tile individual loops is very labor-intensive and
error-prone for large applications. AMReX has incorporated the tiling construct
into <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> so that the application codes can get the benefit of tiling
easily. An <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> loop with tiling is almost the same as the non-tiling
version. The first example in (see the previous section on
<a class="reference internal" href="#sec-basics-mfiter-notiling"><span class="std std-ref">MFIter without Tiling</span></a>) requires only two minor changes:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>passing <code class="code cpp c++ docutils literal notranslate"><span class="name builtin"><span class="pre">true</span></span></code> when defining <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> to indicate tiling;</p></li>
<li><p>calling <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">tilebox</span></span></code> instead of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">validbox</span></span></code> to obtain the work region
for the loop iteration.</p></li>
</ol>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//               * true *  turns on tiling</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over tiles</span>
<span class="p">{</span>
    <span class="c1">//                   tilebox() instead of validbox()</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>

    <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">array</span><span class="p">();</span>
    <span class="n">f1</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second example in the previous section on <a class="reference internal" href="#sec-basics-mfiter-notiling"><span class="std std-ref">MFIter without Tiling</span></a>
also requires only two minor changes.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//              * true *  turns on tiling</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over tiles</span>
<span class="p">{</span>
    <span class="c1">//                   tilebox() instead of validbox()</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>

    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">U</span><span class="p">.</span><span class="n">const_array</span><span class="p">(</span><span class="n">mfi</span><span class="p">);</span>
    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span>      <span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">mfi</span><span class="p">);</span>
    <span class="n">f2</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The kernels functions like <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">f1</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">f2</span></span></code> in the two examples here
usually require very little changes.</p>
<span id="fig-basics-cc-comparison"></span><table class="docutils align-center" id="id3">
<caption><span class="caption-number">Table 5 </span><span class="caption-text">Comparison of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> with (right) and without (left) tiling.</span><a class="headerlink" href="#id3" title="Permalink to this table">Â¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="_images/cc_validbox.png"><img alt="a" src="_images/cc_validbox.png" style="width: 90%;" /></a></p></td>
<td><p><a class="reference internal" href="_images/cc_tilebox.png"><img alt="b" src="_images/cc_tilebox.png" style="width: 90%;" /></a></p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">Example of cell-centered valid boxes.</div>
<div class="line">There are two valid boxes in this example.</div>
<div class="line">Each has <span class="math notranslate nohighlight">\(8^2\)</span> cells.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Example of cell-centered tile boxes. Each grid</div>
<div class="line">is <em>logically</em> broken into 4 tiles, and each tile</div>
<div class="line">as <span class="math notranslate nohighlight">\(4^2\)</span> cells. There are 8 tiles in total.</div>
</div>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#fig-basics-cc-comparison"><span class="std std-numref">Table 5</span></a> shows an example of the difference between
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">validbox</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">tilebox</span></span></code>. In this example, there are two grids of
cell-centered index type. The function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">validbox</span></span></code> always returns a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> for the valid region of an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> no matter whether or not
tiling is enabled, whereas the function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">tilebox</span></span></code> returns a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> for
a tile. (Note that when tiling is disabled, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">tilebox</span></span></code> returns the same
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> as <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">validbox</span></span></code>.) The number of loop iteration is 2 in the
non-tiling version, whereas in the tiling version the kernel function is called
8 times.</p>
<p>It is important to use the correct <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> when implementing tiling, especially
if the box is used to define a work region inside of the loop. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// MFIter loop with tiling on.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Box</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>     <span class="c1">// Gets box of entire, untiled region.</span>
    <span class="n">calcOverBox</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>             <span class="c1">// ERROR! Works on entire box, not tiled box.</span>
                                 <span class="c1">// Other iterations will redo many of the same cells.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The tile size can be explicitly set when defining <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// No tiling in x-direction. Tile size is 16 for y and 32 for z.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">IntVect</span><span class="p">(</span><span class="mi">1024000</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">));</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="p">{...}</span>
</pre></div>
</div>
<p>An <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span></code> is used to specify the tile size for every dimension.  A tile
size larger than the grid size simply means tiling is disabled in that
direction. AMReX has a default tile size <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span><span class="punctuation"><span class="pre">{</span></span><span class="literal number integer"><span class="pre">1024000</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">,</span></span><span class="literal number integer"><span class="pre">8</span></span><span class="punctuation"><span class="pre">}</span></span></code> in 3D and
no tiling in 2D. This is used when tile size is not explicitly set but the
tiling flag is on. One can change the default size using <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code>
(section <a class="reference internal" href="#sec-basics-parmparse"><span class="std std-ref">ParmParse</span></a>) parameter <code class="docutils literal notranslate"><span class="pre">fabarray.mfiter_tile_size.</span></code></p>
<span id="fig-basics-ec-comparison"></span><table class="docutils align-center" id="id4">
<caption><span class="caption-number">Table 6 </span><span class="caption-text">Comparison of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> with (right) and without (left) tiling, for face-centered nodal indexing.</span><a class="headerlink" href="#id4" title="Permalink to this table">Â¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="_images/ec_validbox.png"><img alt="c" src="_images/ec_validbox.png" style="width: 90%;" /></a></p></td>
<td><p><a class="reference internal" href="_images/ec_tilebox.png"><img alt="d" src="_images/ec_tilebox.png" style="width: 90%;" /></a></p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">Example of face valid boxes. There are two</div>
<div class="line">valid boxes in this example. Each has</div>
<div class="line"><span class="math notranslate nohighlight">\(9\times 8\)</span> points. Note that points in one</div>
<div class="line"><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> may overlap with points in the other</div>
<div class="line"><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>. However, the memory locations for</div>
<div class="line">storing floating point data of those points do</div>
<div class="line">not overlap, because they belong to seperate</div>
<div class="line">FArrayBoxes.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Example of face tile boxes. Each grid is</div>
<div class="line"><em>logically</em> broken into 4 tiles as indicated by</div>
<div class="line">the symbols. There are 8 tiles in total. Some</div>
<div class="line">tiles have <span class="math notranslate nohighlight">\(5\times 4\)</span> points, whereas</div>
<div class="line">others have <span class="math notranslate nohighlight">\(4 \times 4\)</span> points. Points from</div>
<div class="line">different Boxes may overlap, but points from</div>
<div class="line">different tiles of the same Box do not.</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Dynamic tiling, which runs one box per OpenMP thread, is also available.
This is useful when the underlying work cannot benefit from thread
parallelization.  Dynamic tiling is implemented using the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFItInfo</span></span></code>
object and requires the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> loop to be defined in an OpenMP
parallel region:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Dynamic tiling, one box per OpenMP thread.</span>
<span class="c1">// No further tiling details,</span>
<span class="c1">//   so each thread works on a single tilebox.</span>
<span class="cp">#ifdef _OPENMP</span>
<span class="cp">#pragma omp parallel</span>
<span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">MFItInfo</span><span class="p">().</span><span class="n">SetDynamic</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>
        <span class="p">...</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Dynamic tiling also allows explicit definition of a tile size:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Dynamic tiling, one box per OpenMP thread.</span>
<span class="c1">// No tiling in x-direction. Tile size is 16 for y and 32 for z.</span>
<span class="cp">#ifdef _OPENMP</span>
<span class="cp">#pragma omp parallel</span>
<span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">MFItInfo</span><span class="p">().</span><span class="n">SetDynamic</span><span class="p">(</span><span class="nb">true</span><span class="p">).</span><span class="n">EnableTiling</span><span class="p">(</span><span class="mi">1024000</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">));</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>
        <span class="p">...</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Usually <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> is used for accessing multiple MultiFabs like the second
example, in which two MultiFabs, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">F</span></span></code>, use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> via
<code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code>. These different MultiFabs may have different BoxArrays. For
example, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code> might be cell-centered, whereas <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">F</span></span></code> might be nodal in
<span class="math notranslate nohighlight">\(x\)</span>-direction and cell in other directions. The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">validbox</span></span></code>
and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">tilebox</span></span></code> functions return Boxes of the same type as the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> used in defining the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> (<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">F</span></span></code> in this example).
<a class="reference internal" href="#fig-basics-ec-comparison"><span class="std std-numref">Table 6</span></a> illustrates an example of non-cell-centered
valid and tile boxes. Besides <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">validbox</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">tilebox</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code>
has a number of functions returning various Boxes.  Examples include,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">fabbox</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>       <span class="c1">// Return the Box of the FArrayBox</span>

<span class="c1">// Return grown tile box.  By default it grows by the number of</span>
<span class="c1">// ghost cells of the MultiFab used for defining the MFIter.</span>
<span class="n">Box</span> <span class="nf">growntilebox</span><span class="p">(</span><span class="kt">int</span> <span class="n">ng</span><span class="o">=</span><span class="mi">-1000000</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// Return tilebox with provided nodal flag as if the MFIter</span>
<span class="c1">// is constructed with MultiFab of such flag.</span>
<span class="n">Box</span> <span class="nf">tilebox</span><span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">nodal_flag</span><span class="p">);</span>
</pre></div>
</div>
<p>It should be noted that the function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">growntilebox</span></span></code> does not grow the tile
Box like a normal <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>. Growing a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> normally means the Box is
extended in every face of every dimension.  However, the function
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">growntilebox</span></span></code> only extends the tile Box in such a way that tiles from the
same grid do not overlap. This is the basic design principle of these various
tiling functions. Tiling is a way of domain decomposition for work sharing.
Overlapping tiles is undesirable because work would be wasted and for
multi-threaded codes race conditions could occur.</p>
<span id="fig-basics-growbox-comparison"></span><table class="docutils align-center" id="id5">
<caption><span class="caption-number">Table 7 </span><span class="caption-text">Comparing growing cell-type and face-type tile boxes.</span><a class="headerlink" href="#id5" title="Permalink to this table">Â¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="_images/cc_growbox.png"><img alt="e" src="_images/cc_growbox.png" style="width: 90%;" /></a></p></td>
<td><p><a class="reference internal" href="_images/ec_growbox.png"><img alt="f" src="_images/ec_growbox.png" style="width: 90%;" /></a></p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">Example of cell-centered grown tile boxes. As</div>
<div class="line">indicated by symbols, there are 8 tiles and four</div>
<div class="line">in each grid in this example. Tiles from the</div>
<div class="line">same grid do not overlap. But tiles from</div>
<div class="line">different grids may overlap.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Example of face type grown tile boxes. As</div>
<div class="line">indicated by symbols, there are 8 tiles and four</div>
<div class="line">in each grid in this example. Tiles from the</div>
<div class="line">same grid do not overlap even though they</div>
<div class="line">have face index type.</div>
</div>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#fig-basics-growbox-comparison"><span class="std std-numref">Table 7</span></a> illustrates an example of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">growntilebox</span></span></code>. These functions in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> return <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> by
value. There are three ways of using these functions.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>  <span class="c1">// const&amp; to temporary object is legal</span>

<span class="c1">// Make a copy if Box needs to be modified later.</span>
<span class="c1">// Compilers can optimize away the temporary object.</span>
<span class="n">Box</span> <span class="n">bx2</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>
<span class="n">bx2</span><span class="p">.</span><span class="n">surroundingNodes</span><span class="p">();</span>

<span class="n">Box</span><span class="o">&amp;&amp;</span> <span class="n">bx3</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span> <span class="c1">// bound to the return value</span>
<span class="n">bx3</span><span class="p">.</span><span class="n">enclosedCells</span><span class="p">();</span>
</pre></div>
</div>
<p>But <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span><span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">bx</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">mfi</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">validbox</span></span><span class="punctuation"><span class="pre">()</span></span></code> is not legal and will not compile.</p>
<p>Finally it should be emphasized that tiling should not be used when
running on GPUs because of kernel launch overhead.</p>
</div>
</div>
<div class="section" id="fortran-and-c-kernels">
<span id="sec-basics-fortran"></span><h1>Fortran and C++ Kernels<a class="headerlink" href="#fortran-and-c-kernels" title="Permalink to this headline">Â¶</a></h1>
<p>In the section on <a class="reference internal" href="#sec-basics-mfiter"><span class="std std-ref">MFIter and Tiling</span></a>, we have shown that a typical
pattern for working with MultiFabs is to use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> to iterate over the
data. In each iteration, a kernel function is called to work on the data and
the work region is specified by a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>.  When tiling is used, the work
region is a tile. The tiling is logical in the sense that there is no data
layout transformation. The kernel function still gets the whole arrays in
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>es, even though it is supposed to work on a tile region of the
arrays.  We have shown examples of writing kernels in C++ in the
previous section.  Fortran is also often used for writing these kernels because of its
native multi-dimensional array support.  To C++, these kernel functions are
C functions, whose function signatures are typically declared in a header file
named <code class="docutils literal notranslate"><span class="pre">*_f.H</span></code> or <code class="docutils literal notranslate"><span class="pre">*_F.H</span></code>. We recommend the users to follow this convention.
Examples of these function declarations are as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;AMReX_BLFort.H&gt;</span><span class="cp"></span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="p">{</span>
<span class="cp">#endif</span>
    <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span>
            <span class="n">amrex_real</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>These Fortran functions take C pointers and view them
as multi-dimensional arrays of the shape specified by the additional integer
arguments.  Note that Fortran takes arguments by reference unless the
<code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">value</span></span></code> keyword is used. So an integer argument on the Fortran side
matches an integer pointer on the C++ side. Thanks to Fortran 2003, function
name mangling is easily achieved by declaring the Fortran function as
<code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">bind</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">c</span></span><span class="punctuation"><span class="pre">)</span></span></code>.</p>
<p>AMReX provides many macros for passing an FArrayBoxâs data into Fortran/C. For
example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>
    <span class="n">f</span><span class="p">(</span><span class="n">BL_TO_FORTRAN_BOX</span><span class="p">(</span><span class="n">box</span><span class="p">),</span>
      <span class="n">BL_TO_FORTRAN_ANYD</span><span class="p">(</span><span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">]));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_TO_FORTRAN_BOX</span></span></code> takes a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> and provides two <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code>
s specifying the lower and upper bounds of the Box.  <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_TO_FORTRAN_ANYD</span></span></code>
takes an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> returned by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">mf</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">mfi</span></span><span class="punctuation"><span class="pre">]</span></span></code> and the preprocessor turns
it into <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Real</span></span> <span class="operator"><span class="pre">*</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code>, where <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Real</span></span> <span class="operator"><span class="pre">*</span></span></code> is the data pointer
that matches real array argument in Fortran, the first <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code> (which
matches an integer argument in Fortran) specifies the lower bounds, and the
second <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code> the upper bounds of the spatial dimensions of the array.
An example of the Fortran function is shown below,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="k">end subroutine </span><span class="n">f</span>
</pre></div>
</div>
<p>Here, the size of the integer arrays is 3, the maximal number of spatial
dimensions. If the actual spatial dimension is less than 3, the values in the
degenerate dimensions are set to zero. So the Fortran function interface does
not have to change according to the spatial dimensionality, and the bound of
the third dimension of the data array simply becomes <code class="code fortran docutils literal notranslate"><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">:</span></span><span class="literal number integer"><span class="pre">0</span></span></code>. With the
data passed by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_TO_FORTRAN_BOX</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_FORTRAN_ANYD</span></span></code>, this
version of Fortran function interface works for any spatial dimensions. If one
wants to write a special version just for 2D and would like to use 2D arrays,
one can use</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f2d</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="k">end subroutine </span><span class="n">f2d</span>
</pre></div>
</div>
<p>Note that this does not require any changes in the C++ part, because when
C++ passes an integer pointer pointing to an array of three integers Fortran
can treat it as a 2-element integer array.</p>
<p>Another commonly used macro is <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_TO_FORTRAN</span></span></code>. This macro takes an
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> and provides a real pointer for the floating point data array
and a number of integer scalars for the bounds.  However, the number of the
integers depends on the dimensionality.  More specifically, there are 6 and 4
integers for 2D and 3D, respectively. The first half of the integers are the
lower bounds for each spatial dimension and the second half the upper bounds.
For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f2d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo1</span><span class="p">:</span><span class="n">uhi1</span><span class="p">,</span><span class="n">ulo2</span><span class="p">:</span><span class="n">uhi2</span><span class="p">)</span>
<span class="k">end subroutine </span><span class="n">f2d</span>

<span class="k">subroutine </span><span class="n">f3d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">ulo3</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">,</span> <span class="n">uhi3</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">ulo1</span><span class="p">,</span> <span class="n">ulo2</span><span class="p">,</span> <span class="n">ulo3</span><span class="p">,</span> <span class="n">uhi1</span><span class="p">,</span> <span class="n">uhi2</span><span class="p">,</span> <span class="n">uhi3</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo1</span><span class="p">:</span><span class="n">uhi1</span><span class="p">,</span><span class="n">ulo2</span><span class="p">:</span><span class="n">uhi2</span><span class="p">,</span><span class="n">ulo3</span><span class="p">:</span><span class="n">uhi3</span><span class="p">)</span>
<span class="k">end subroutine </span><span class="n">f3d</span>
</pre></div>
</div>
<p>Here for simplicity we have omitted passing the tile Box.</p>
<p>Usually <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>s  have multiple components. Thus we often also need to
pass the number of component into Fortran functions. We can obtain the number
by calling the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">nComp</span></span><span class="punctuation"><span class="pre">()</span></span></code> function, and pass it to
Fortran.  We can also use the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_TO_FORTRAN_FAB</span></span></code> macro that is similar to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_TO_FORTRAN_ANYD</span></span></code>
except that it provides an additional <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="operator"><span class="pre">*</span></span></code> for the number of
components. The Fortran function matching <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_TO_FORTRAN_FAB</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">fab</span></span><span class="punctuation"><span class="pre">)</span></span></code> is then
like below,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ulo</span><span class="p">,</span> <span class="n">uhi</span><span class="p">,</span><span class="n">nu</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_real</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span><span class="n">u</span><span class="p">(</span><span class="n">ulo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">ulo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">uhi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">nu</span><span class="p">)</span>
<span class="k">end subroutine </span><span class="n">f</span>
</pre></div>
</div>
<p>There is a potential type safety issue when calling Fortran functions
from C++.  If there is a mismatch between the function declaration on
the C++ side and the function definition in Fortran, the compiler
cannot catch it.  For example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// function declaration</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">f</span> <span class="p">(</span><span class="n">amrex_real</span><span class="o">*</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">].</span><span class="n">dataPtr</span><span class="p">()));</span>
<span class="p">}</span>

<span class="o">!</span> <span class="n">Fortran</span> <span class="n">definition</span>
<span class="n">subroutine</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="n">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">implicit</span> <span class="n">none</span>
    <span class="n">integer</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="n">end</span> <span class="n">subroutine</span> <span class="n">f</span>
</pre></div>
</div>
<p>The code above will compile without errors even though the number of
arguments and types donât match.</p>
<p>To help detect this kind of issues, AMReX provides a type check tool.
Note that it only works when GCC is used.  In the directory an AMReX
based code is compiled, type</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">make typecheck</span>
</pre></div>
</div>
<p>Extra arguments used in a usual AMReX build (e.g., USE_MPI=TRUE DIM=2)
can be added.  When it finishes, the output may look like,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Function my_f in main_F.H vs. Fortran procedure in f.f90</span>
<span class="go">    number of arguments 1 does NOT match 2.</span>
<span class="go">    arg #1: C type [&#39;double&#39;, &#39;pointer&#39;] does NOT match Fortran type (&#39;INTEGER 4&#39;, &#39;pointer&#39;, &#39;x&#39;).</span>
<span class="go">22 functions checked, 1 error(s) found.  More details can be found in tmp_build_dir/t/3d.gnu.DEBUG.EXE/amrex_typecheck.ou.</span>
</pre></div>
</div>
<p>It should be noted that Fortran by default passes argument by
reference.  In the example output above, <code class="docutils literal notranslate"><span class="pre">pointer</span></code> in <code class="docutils literal notranslate"><span class="pre">Fortran</span> <span class="pre">type</span>
<span class="pre">('INTEGER</span> <span class="pre">4',</span> <span class="pre">'pointer',</span> <span class="pre">'x')</span></code> means itâs a reference to argument
(i.e., C pointer), not a Fortran pointer.</p>
<p>The type check tool has known limitations.  For a function to be
checked by the tool in the GNU make build system, the declaration must
be in a header file named <code class="docutils literal notranslate"><span class="pre">*_f.H</span></code> or <code class="docutils literal notranslate"><span class="pre">*_F.H</span></code>, and the header file
must be in the <code class="docutils literal notranslate"><span class="pre">CEXE_headers</span></code> make variable.  The headers are
preprocessed first by cpp as C language, and is then parsed by
pycparser (<a class="reference external" href="https://pypi.python.org/pypi/pycparser">https://pypi.python.org/pypi/pycparser</a>) that needs to be
installed on your system.  Because pycparser is a C parser, C++ parts
of the headers (e.g., <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">extern</span></span> <span class="literal string"><span class="pre">âCâ</span></span> <span class="punctuation"><span class="pre">{</span></span></code>) need to be hidden with
macro <code class="code cpp c++ docutils literal notranslate"><span class="comment preproc"><span class="pre">#ifdef</span> <span class="pre">__cplusplus</span></span></code>.  Headers like <code class="docutils literal notranslate"><span class="pre">AMReX_BLFort.H</span></code> can
be used as a C header, but most other AMReX headers cannot and should
be hidden by <code class="code cpp c++ docutils literal notranslate"><span class="comment preproc"><span class="pre">#ifdef</span> <span class="pre">__cplusplus</span></span></code> if they are included.  More
details can be found at <code class="docutils literal notranslate"><span class="pre">amrex/Docs/Readme.typecheck</span></code>.  Despite
these limitations, it is recommended to use the type check tool and
report issues to us.</p>
<p id="sec-basics-cppkernel">Although Fortran has native multi-dimensional array, we recommend
writing kernels in C++ because of performance portability for CPU and
GPU.  AMReX provides a multi-dimensional array type of syntax, similar
to Fortran, that is readable and easy to implement.  We have
demonstrated how to use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code> in previous sections.  Because
of its importance, we will summarize its basic usage again with the
example below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span> <span class="p">(</span><span class="n">Box</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">bx</span><span class="p">,</span> <span class="n">FArrayBox</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sfab</span><span class="p">,</span> <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">dfab</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Dim3</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">lbound</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">Dim3</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">ubound</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>

    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">src</span> <span class="o">=</span> <span class="n">sfab</span><span class="p">.</span><span class="n">const_array</span><span class="p">();</span>
    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span>      <span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">dfab2</span><span class="p">.</span><span class="n">array</span><span class="p">();</span>

    <span class="k">for</span>         <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span>     <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">AMREX_PRAGMA_SIMD</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dst</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">src</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="n">src</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf1</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>
    <span class="n">f</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">mf1</span><span class="p">[</span><span class="n">mfi</span><span class="p">],</span> <span class="n">mf2</span><span class="p">[</span><span class="n">mfi</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> and two <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>es are passed to a C++ kernel
function.  In the function, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">lbound</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">ubound</span></span></code>
are called to get the start and end of the loops from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">smallEnd</span></span><span class="punctuation"><span class="pre">()</span></span></code>
and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">bigEnd</span></span></code> of <code class="docutils literal notranslate"><span class="pre">bx</span></code>.  Both functions return a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Dim3</span></span></code>, a trivial type containing three integers.
The individual components are accessed by using <code class="code cpp c++ docutils literal notranslate"><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">x</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">y</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">z</span></span></code>, as shown in the <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">for</span></span></code> loops.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">array</span></span><span class="punctuation"><span class="pre">()</span></span></code> is called to obtain an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code> object that is
designed as an independent, <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">()</span></span></code> based accessor to the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code> data. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code> is an AMReX class that contains a
pointer to the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> data and two <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Dim3</span></span></code> structs that
contain the bounds of the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>.  The bounds are stored to
properly translate the three dimensional coordinates to the appropriate
location in the one-dimensional array.  <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array4</span></span></code>'s <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">()</span></span></code>
can also take a fourth integer to access across states of the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>.  When AMReX is built for 1D or 2D, it can be used
by passing <cite>0</cite> to the missing dimensions.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AMREX_PRAGMA_SIMD</span></code> macro is placed in the innermost loop to notify
the compiler that loop iterations are independent and it is safe to
vectorize the loop.  This should be done whenever possible to achieve the
best performance. Be aware: the macro generates a compiler dependent
pragma, so their exact effect on the resulting code is also compiler
dependent.  It should be emphasized that using the <code class="docutils literal notranslate"><span class="pre">AMREX_PRAGMA_SIMD</span></code>
macro on loops that are not safe for vectorization may lead to errors,
so if unsure about the independence of the iterations of a
loop, test and verify before adding the macro.</p>
<p>These loops should usually use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">i</span></span> <span class="operator"><span class="pre">&lt;=</span></span> <span class="name"><span class="pre">hi</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">x</span></span></code>, not <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">i</span></span> <span class="operator"><span class="pre">&lt;</span></span> <span class="name"><span class="pre">hi</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">x</span></span></code>, when
defining the loop bounds. If not, the highest index cells will be left out
of the calculation.</p>
</div>
<div class="section" id="parallelfor">
<span id="sec-basics-parallelfor"></span><h1>ParallelFor<a class="headerlink" href="#parallelfor" title="Permalink to this headline">Â¶</a></h1>
<p>In the examples so far, we have explicitly written out the for loops
when we iterate over a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code>.  AMReX also provides function
templates for writing these in a concise and performance portable way
like below,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef _OPENMP</span>
<span class="cp">#pragma omp parallel if (Gpu::notInLaunchRegion())</span>
<span class="cp">#endif</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mfa</span><span class="p">,</span><span class="n">TilingIfNotGPU</span><span class="p">());</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>
    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">mfa</span><span class="p">[</span><span class="n">mfi</span><span class="p">].</span><span class="n">array</span><span class="p">();</span>
    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">mfb</span><span class="p">[</span><span class="n">mfi</span><span class="p">].</span><span class="n">const_array</span><span class="p">();</span>
    <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">mfc</span><span class="p">[</span><span class="n">mfi</span><span class="p">].</span><span class="n">const_array</span><span class="p">();</span>
    <span class="n">ParallelFor</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">AMREX_GPU_DEVICE</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">+=</span> <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Here, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelFor</span></span></code> takes two arguments.  The first argument is a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Box</span></span></code> specifying the iteration index space, and the second
argument is a C++ lambda function that works on cell <code class="code cpp c++ docutils literal notranslate"><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">i</span></span><span class="punctuation"><span class="pre">,</span></span><span class="name"><span class="pre">j</span></span><span class="punctuation"><span class="pre">,</span></span><span class="name"><span class="pre">k</span></span><span class="punctuation"><span class="pre">)</span></span></code>.
Variables a, b and c in the lambda function are captured by value from
the enclosing scope.  The code above is performance portable.  It
works with and without GPU support.  When AMReX is built with GPU support,
AMREX_GPU_DEVICE indicates that the lambda function is a device
function and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelFor</span></span></code> launches a GPU kernel to do the work.
When it is built without GPU support, AMREX_GPU_DEVICE has no effects
whatsoever.  More details on <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParalleFor</span></span></code> will be presented in
section <a class="reference internal" href="GPU.html#sec-gpu-for"><span class="std std-ref">Launching C++ nested loops</span></a>.  It should be emphasized that
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelFor</span></span></code> does not start an OpenMP parallel region.  The OpenMP parallel
region will be started by the pragma above the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> loop if it is
built with OpenMP and without enabling GPU.  Tiling is turned off if
GPU is enabled so that more parallelism is exposed to GPU kernels.
Also note that when tiling is off, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">tilbox</span></span></code> returns
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">validbox</span></span></code>.</p>
<p>There are other versions of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParalleFor</span></span></code>,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 1D for loop</span>
<span class="n">ParallelFor</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">AMREX_GPU_DEVICE</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">});</span>

<span class="c1">// 4D for loop</span>
<span class="n">ParallelFor</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">numcomps</span><span class="p">,</span>
            <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">AMREX_GPU_DEVICE</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="ghost-cells">
<h1>Ghost Cells<a class="headerlink" href="#ghost-cells" title="Permalink to this headline">Â¶</a></h1>
<p>AMReX uses a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> as a container for floating point data on
multiple Boxes at a single level of refinement. Each rectangular Box has its own boundaries
on the low and high side in each coordinate direction.
Each Box within a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> can have ghost cells for storing data outside
the Boxâs valid region. This allows us to, e.g., perform stencil-type operations on
regular arrays. There are three basic types of boundaries:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>interior boundary</p></li>
<li><p>coarse/fine boundary</p></li>
<li><p>physical boundary</p></li>
</ol>
</div></blockquote>
<p>Interior boundary is the border among the grid Boxes themselves.  For example,
in <a class="reference internal" href="#fig-basics-amrgrids"><span class="std std-numref">Fig. 1</span></a>, the two blue grid Boxes on level 1 share an
interior boundary that is 10 cells long. For a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> with ghost cells
on level 1, we can use the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">FillBoundary</span></span></code> function introduced in
the section on <a class="reference internal" href="#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a> to fill ghost cells at the interior
boundary with valid cell data from other Boxes.  <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">FillBoundary</span></span></code>
can optionally fill periodic boundary ghost cells as well.</p>
<p>A coarse/fine boundary is the border between two AMR levels.
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code> does not fill these ghost cells. These ghost cells on the
fine level need to be interpolated from the coarse level data.  This is a
subject that will be discussed in the section on <a class="reference internal" href="AmrCore.html#sec-amrcore-fillpatch"><span class="std std-ref">FillPatchUtil and Interpolater</span></a>.</p>
<p>Note that periodic boundary is not considered a basic type in the discussion here because
after periodic transformation it becomes either interior boundary or
coarse/fine boundary.</p>
<p>The third type of boundary is the physical boundary at the physical domain.
Note that both coarse and fine AMR levels could have grids touching the
physical boundary. It is up to the application codes to properly fill the ghost
cells at the physical boundary. However, AMReX does provide support for some
common operations.  See the section on <a class="reference internal" href="#sec-basics-boundary"><span class="std std-ref">Boundary Conditions</span></a> for a
discussion on domain boundary conditions in general, including how to implement
physical (non-periodic) boundary conditions.</p>
</div>
<div class="section" id="boundary-conditions">
<span id="sec-basics-boundary"></span><h1>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">Â¶</a></h1>
<p>This section describes how to implement domain boundary conditions in AMReX.  A
ghost cell that is outside of the valid region can be thought of as either
âinteriorâ (which includes periodic and coarse-fine ghost cells), or âphysicalâ.
Physical boundary conditions can occur on domain boundaries and can
be characterized as inflow, outflow, slip/no-slip walls, etc., and are
ultimately linked to mathematical Dirichlet or Neumann conditions.</p>
<p>The basic idea behind physical boundary conditions is as follows:</p>
<ul>
<li><p>Create a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BCRec</span></span></code> object, which is essentially a multidimensional
integer array of <code class="code cpp c++ docutils literal notranslate"><span class="literal number integer"><span class="pre">2</span></span><span class="operator"><span class="pre">*</span></span><span class="name"><span class="pre">DIM</span></span></code> components. Each component defines a boundary
condition type for the lo/hi side of the domain, for each direction.  See
<code class="docutils literal notranslate"><span class="pre">amrex/Src/Base/AMReX_BC_TYPES.H</span></code> for common physical and mathematical
types.  Below is an example of setting up a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">BCRec</span></span><span class="operator"><span class="pre">&gt;</span></span></code> for
multiple components before the call to ghost cell routines.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Set up BC; see ``amrex/Src/Base/AMReX_BC_TYPES.H`` for supported types</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">BCRec</span><span class="o">&gt;</span> <span class="n">bc</span><span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">nComp</span><span class="p">());</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">phi</span><span class="p">.</span><span class="n">nComp</span><span class="p">();</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idim</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="o">++</span><span class="n">idim</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">isPeriodic</span><span class="p">(</span><span class="n">idim</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">bc</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">setLo</span><span class="p">(</span><span class="n">idim</span><span class="p">,</span> <span class="n">BCType</span><span class="o">::</span><span class="n">int_dir</span><span class="p">);</span> <span class="c1">// interior</span>
            <span class="n">bc</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">setHi</span><span class="p">(</span><span class="n">idim</span><span class="p">,</span> <span class="n">BCType</span><span class="o">::</span><span class="n">int_dir</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">bc</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">setLo</span><span class="p">(</span><span class="n">idim</span><span class="p">,</span> <span class="n">BCType</span><span class="o">::</span><span class="n">foextrap</span><span class="p">);</span> <span class="c1">// first-order extrapolation</span>
            <span class="n">bc</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">setHi</span><span class="p">(</span><span class="n">idim</span><span class="p">,</span> <span class="n">BCType</span><span class="o">::</span><span class="n">foextrap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">BCType</span></span></code> has the following types,</p>
<blockquote>
<div><dl class="simple">
<dt>int_dir</dt><dd><p>Interior, including periodic boundary</p>
</dd>
<dt>ext_dir</dt><dd><p>âExternal Dirichletâ. It is the userâs responsibility to write a routine
to fill ghost cells (more details below).</p>
</dd>
<dt>foextrap</dt><dd><p>âFirst Order Extrapolationâ
First order extrapolation from last cell in interior.</p>
</dd>
<dt>reflect_even</dt><dd><p>Reflection from interior cells with sign
unchanged, <span class="math notranslate nohighlight">\(q(-i) = q(i)\)</span>.</p>
</dd>
<dt>reflect_odd</dt><dd><p>Reflection from interior cells with sign
changed, <span class="math notranslate nohighlight">\(q(-i) = -q(i)\)</span>.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>For external Dirichlet boundaries, the user needs to provide a
callable object like below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">MyExtBCFill</span> <span class="p">{</span>
    <span class="n">AMREX_GPU_DEVICE</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">iv</span><span class="p">,</span> <span class="n">Array4</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">dest</span><span class="p">,</span>
                     <span class="k">const</span> <span class="kt">int</span> <span class="n">dcomp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">numcomp</span><span class="p">,</span>
                     <span class="n">GeometryData</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">geom</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">time</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">BCRec</span><span class="o">*</span> <span class="n">bcr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">bcomp</span><span class="p">,</span>
                     <span class="k">const</span> <span class="kt">int</span> <span class="n">orig_comp</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="c1">// external Dirichlet for cell iv</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here, for the CPU build, the AMREX_GPU_DEVICE macro has no effect
whatsoever, whereas for the GPU build, this marks the operator as a GPU
device function.</p>
</li>
<li><p>It is the userâs responsibility to have a consisent definition of
what the ghost cells represent. A common option used in AMReX codes is to
fill the domain ghost cells with the value that lies on the boundary (as
opposed to another common option where the value in the ghost cell represents
an extrapolated value based on the boundary condition type). Then in our
stencil based âworkâ codes, we also pass in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BCRec</span></span></code> object and use
modified stencils near the domain boundary that know the value in the first
ghost cell represents the value on the boundary.</p></li>
</ul>
<p>Depending on the level of complexity of your code, there are various options
for filling domain boundary ghost cells.</p>
<p>For single-level codes built from <code class="docutils literal notranslate"><span class="pre">amrex/Src/Base</span></code> (excluding the
<code class="docutils literal notranslate"><span class="pre">amrex/Src/AmrCore</span></code> and <code class="docutils literal notranslate"><span class="pre">amrex/Src/Amr</span></code> source code directories), you will
have single-level MultiFabs filled with data in the valid region where you need
to fill the ghost cells on each grid.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultiFab</span> <span class="n">mf</span><span class="p">;</span>
<span class="n">Geometry</span> <span class="n">geom</span><span class="p">;</span>
<span class="n">Vector</span><span class="o">&lt;</span><span class="n">BCRec</span><span class="o">&gt;</span> <span class="n">bc</span><span class="p">;</span>
<span class="n">Real</span> <span class="n">time</span><span class="p">;</span>

<span class="c1">// ...</span>

<span class="c1">// fills interior and periodic domain boundary ghost cells</span>
<span class="n">mf</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">periodicity</span><span class="p">());</span>

<span class="c1">// fills physical domain boundary ghost cells for a cell-centered multifab</span>
<span class="k">if</span> <span class="p">(</span><span class="n">not</span> <span class="n">geom</span><span class="p">.</span><span class="n">isAllPeriodic</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">GpuBndryFuncFab</span><span class="o">&lt;</span><span class="n">MyExtBCFill</span><span class="o">&gt;</span> <span class="n">bf</span><span class="p">(</span><span class="n">MyExtBCFill</span><span class="p">{});</span>
    <span class="n">PhysBCFunct</span><span class="o">&lt;</span><span class="n">GpuBndryFuncFab</span><span class="o">&lt;</span><span class="n">MyExtBCFill</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">physbcf</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">bf</span><span class="p">);</span>
    <span class="n">physbcf</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mf</span><span class="p">.</span><span class="n">nComp</span><span class="p">(),</span> <span class="n">mf</span><span class="p">.</span><span class="n">nGrowVector</span><span class="p">(),</span> <span class="n">time</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-allocation">
<h1>Memory Allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">Â¶</a></h1>
<p>Some constructors of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>, etc. can take
an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Arena</span></span></code> argument for memory allocation.  This is usually not
important for CPU codes, but very important for GPU codes.  We will
present more details in <a class="reference internal" href="GPU.html#sec-gpu-memory"><span class="std std-ref">Memory Allocation</span></a> in Chapter GPU.</p>
<p>AMReX has a Fortran module, <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_mempool_module</span></span></code> that can be used to
allocate memory for Fortran pointers. The reason that such a module exists in
AMReX is that memory allocation is often very slow in multi-threaded OpenMP
parallel regions. AMReX <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex_mempool_module</span></span></code> provides a much faster
alternative approach, in which each thread has its own memory pool. Here are
examples of using the module.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_mempool_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">amrex_allocate</span><span class="p">,</span> <span class="n">amrex_deallocate</span>
<span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span> <span class="k">pointer</span><span class="p">,</span> <span class="k">contiguous</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(:,:,:),</span> <span class="n">b</span><span class="p">(:,:,:,:)</span>
<span class="kt">integer</span> <span class="kd">::</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">hi1</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">hi2</span><span class="p">,</span> <span class="n">lo3</span><span class="p">,</span> <span class="n">hi3</span><span class="p">,</span> <span class="n">lo</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c">! lo1 = ...</span>
<span class="c">! a(lo1:hi1, lo2:hi2, lo3:hi3)</span>
<span class="k">call </span><span class="n">amrex_allocate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lo1</span><span class="p">,</span> <span class="n">hi1</span><span class="p">,</span> <span class="n">lo2</span><span class="p">,</span> <span class="n">hi2</span><span class="p">,</span> <span class="n">lo3</span><span class="p">,</span> <span class="n">hi3</span><span class="p">)</span>
<span class="c">! b(lo(1):hi(1),lo(2):hi(2),lo(3):hi(3),lo(4):hi(4))</span>
<span class="k">call </span><span class="n">amrex_allocate</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
<span class="c">! ......</span>
<span class="k">call </span><span class="n">amrex_deallocate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">call </span><span class="n">amrex_deallocate</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The downside of this is we have to use <code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">pointer</span></span></code> instead of
<code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">allocatable</span></span></code>. This means we must explicitly free the memory via
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_deallocate</span></span></code> and we need to declare the pointers as
<code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">contiguous</span></span></code> for performance reason.  Also, we often
pass the Fortran pointer to a procedure with explicit array argument
to get rid of the pointerness completely.</p>
</div>
<div class="section" id="abort-assertion-and-backtrace">
<h1>Abort, Assertion and Backtrace<a class="headerlink" href="#abort-assertion-and-backtrace" title="Permalink to this headline">Â¶</a></h1>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Abort</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword"><span class="pre">const</span></span> <span class="keyword type"><span class="pre">char</span></span> <span class="operator"><span class="pre">*</span></span> <span class="name"><span class="pre">message</span></span><span class="punctuation"><span class="pre">)</span></span></code> is used to terminate a run usually
when something goes wrong. This function takes a message and writes it to
stderr. Files named like <code class="docutils literal notranslate"><span class="pre">Backtrace.1</span></code> (where 1 means process 1)
are produced containing backtrace information of the call stack. In Fortran, we
can call <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_abort</span></span></code> from the <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_error_module</span></span></code>, which
takes a Fortran character variable with assumed size (i.e., <code class="code fortran docutils literal notranslate"><span class="name builtin"><span class="pre">len</span></span><span class="operator"><span class="pre">=*</span></span></code>)
as a message.  A <code class="docutils literal notranslate"><span class="pre">ParmParse</span></code> runtime boolean parameter
<code class="docutils literal notranslate"><span class="pre">amrex.throw_handling</span></code> (which is defaulted to 0, i.e., <code class="code cpp c++ docutils literal notranslate"><span class="name builtin"><span class="pre">false</span></span></code>)
can be set to 1 (i.e., <code class="code cpp c++ docutils literal notranslate"><span class="name builtin"><span class="pre">true</span></span></code>) so that AMReX will throw an
exception instead of aborting.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AMREX_ASSERT</span></span></code> is a macro that takes a Boolean expression. For debug build
(e.g., <code class="docutils literal notranslate"><span class="pre">DEBUG=TRUE</span></code> using the GNU Make build system), if the expression at
runtime is evaluated to false, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Abort</span></span></code> will be called and the run
is thus terminated. For optimized build (e.g., <code class="docutils literal notranslate"><span class="pre">DEBUG=FALSE</span></code> using the GNU
Make build system), the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AMREX_ASSERT</span></span></code> statement is removed at compile
time and thus has no effect at runtime. We often use this as a means of putting
debug statement in the code without adding any extra cost for production runs.
For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AMREX_ASSERT</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">nGrow</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mf</span><span class="p">.</span><span class="n">nComp</span><span class="p">()</span> <span class="o">==</span> <span class="n">mf2</span><span class="p">.</span><span class="n">nComp</span><span class="p">());</span>
</pre></div>
</div>
<p>Here for debug build we like to assert that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">mf</span></span></code> has ghost cells
and it also has the same number of components as <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">mf2</span></span></code>. If we
always want the assertion, we can use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AMREX_ALWAYS_ASSERT</span></span></code>.  The
assertion macros have a <code class="docutils literal notranslate"><span class="pre">_WITH_MESSAGE</span></code> variant that will print a
message when assertion fails.  For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AMREX_ASSERT_WITH_MESSAGE</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">boxArray</span><span class="p">()</span> <span class="o">==</span> <span class="n">mf2</span><span class="p">.</span><span class="n">boxArray</span><span class="p">(),</span>
                          <span class="s">&quot;These two mfs must have the same BoxArray&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Backtrace files are produced by AMReX signal handler by default when
segfault occurs or <code class="docutils literal notranslate"><span class="pre">Abort</span></code> is called.  If the application does not
want AMReX to handle this, <code class="docutils literal notranslate"><span class="pre">ParmParse</span></code> parameter
<cite>amrex.signal_handling=0</cite> can be used to disable it.</p>
</div>
<div class="section" id="debugging">
<h1>Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">Â¶</a></h1>
<p>Debugging is an art.  Everyone has their own favorite method.  Here we
offer a few tips we have found to be useful.</p>
<p>To help debugging, AMReX handles various signals in the C standard
library raised in the runs.  This gives us a chance to print out more
information using Linux/Unix backtrace capability.  The signals
include seg fault, interruption by the user (control-c), assertion
errors, and floating point exceptions (NaNs, divided by zero and
overflow).  The handling of seg fault, assertion errors and
interruption by control-C are enabled by default.  Note that
<code class="docutils literal notranslate"><span class="pre">AMREX_ASSERT()</span></code> is only on when compiled with <code class="docutils literal notranslate"><span class="pre">DEBUG=TRUE</span></code> or
<code class="docutils literal notranslate"><span class="pre">USE_ASSERTION=TRUE</span></code> in GNU make, or with <code class="docutils literal notranslate"><span class="pre">-DCMAKE_BUILD_TYPE=Debug</span></code> or
<code class="docutils literal notranslate"><span class="pre">-DAMReX_ASSERTIONS=YES</span></code> in CMake.  The trapping of floating point exceptions is not
enabled by default unless the code is compiled with <code class="docutils literal notranslate"><span class="pre">DEBUG=TRUE</span></code> in GNU make, or with
<code class="docutils literal notranslate"><span class="pre">-DCMAKE_BUILD_TYPE=Debug</span></code> or <code class="docutils literal notranslate"><span class="pre">-DAMReX_FPE=YES</span></code> in CMake to turn on compiler flags
if supported.  Alternatively, one can always use runtime parameters to control the
handling of floating point exceptions: <code class="docutils literal notranslate"><span class="pre">amrex.fpe_trap_invalid</span></code> for
NaNs, <code class="docutils literal notranslate"><span class="pre">amrex.fpe_trap_zero</span></code> for division by zero and
<code class="docutils literal notranslate"><span class="pre">amrex.fpe_trap_overflow</span></code> for overflow.  To more effectively trap the
use of uninitialized values, AMReX also initializes <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code>s in
<code class="docutils literal notranslate"><span class="pre">MulitFab</span></code>s and arrays allocated by <code class="docutils literal notranslate"><span class="pre">bl_allocate</span></code> to signaling NaNs when it is compiled
with <code class="docutils literal notranslate"><span class="pre">TEST=TRUE</span></code> or <code class="docutils literal notranslate"><span class="pre">DEBUG=TRUE</span></code> in GNU make, or with <code class="docutils literal notranslate"><span class="pre">-DCMAKE_BUILD_TYPE=Debug</span></code> in CMake.
One can also control the setting for <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> using the runtime parameter, <code class="docutils literal notranslate"><span class="pre">fab.init_snan</span></code>.</p>
<p>One can get more information than the backtrace of the call stack by
instrumenting the code.  Here is an example.
You know the line <code class="docutils literal notranslate"><span class="pre">Real</span> <span class="pre">rho</span> <span class="pre">=</span> <span class="pre">state(cell,0);</span></code> is causing a segfault.  You
could add a print statement before that.  But it might print out
thousands (or even millions) of line before it hits the segfault.  What
you could do is the following,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;AMReX_BLBackTrace.H&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">ss</span><span class="p">;</span>
<span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;state.box() = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">state</span><span class="p">.</span><span class="n">box</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; cell = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cell</span><span class="p">;</span>
<span class="n">BL_BACKTRACE_PUSH</span><span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">());</span> <span class="c1">// PUSH takes std::string</span>

<span class="n">Real</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">state</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// state is a Fab, and cell is an IntVect.</span>

<span class="n">BL_BACKTRACE_POP</span><span class="p">();</span> <span class="c1">// One can omit this line.  In that case,</span>
                    <span class="c1">// there is an implicit POP when &quot;PUSH&quot; is</span>
                    <span class="c1">// out of scope.</span>
</pre></div>
</div>
<p>When it hits the segfault, you will only see the last pint out.</p>
<p>Writing a <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> to disk with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">VisMF</span><span class="o">::</span><span class="n">Write</span><span class="p">(</span><span class="k">const</span> <span class="n">FabArray</span><span class="o">&lt;</span><span class="n">FArrayBox</span><span class="o">&gt;&amp;</span> <span class="n">mf</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>in <code class="docutils literal notranslate"><span class="pre">AMReX_VisMF.H</span></code> and examining it with <code class="docutils literal notranslate"><span class="pre">Amrvis</span></code> (section
<a class="reference internal" href="Visualization.html#sec-amrvis"><span class="std std-ref">Amrvis</span></a>) can be helpful as well.  In
<code class="docutils literal notranslate"><span class="pre">AMReX_MultiFabUtil.H</span></code>, function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">print_state</span><span class="p">(</span><span class="k">const</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">mf</span><span class="p">,</span> <span class="k">const</span> <span class="n">IntVect</span><span class="o">&amp;</span> <span class="n">cell</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">-1</span><span class="p">);</span>
</pre></div>
</div>
<p>can output the data for a single cell.</p>
<p>Valgrind is one of our favorite debugging tools.  For MPI runs, one can
tell valgrind to output to different files for different processes.
For example,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">mpiexec -n 4 valgrind --leak-check=yes --track-origins=yes --log-file=vallog.%p ./foo.exe ...</span>
</pre></div>
</div>
</div>
<div class="section" id="example-heatequation-ex1-c">
<span id="sec-basics-heat1"></span><h1>Example: HeatEquation_EX1_C<a class="headerlink" href="#example-heatequation-ex1-c" title="Permalink to this headline">Â¶</a></h1>
<p>We now present an example of solving the heat equation.  The source
code tree for the heat equation example is simple, as shown in
<a class="reference internal" href="#fig-basics-heat-flowchart"><span class="std std-numref">Fig. 3</span></a>. We recommend you study
<code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> and <code class="docutils literal notranslate"><span class="pre">advance.cpp</span></code> to see some of the classes described
below in action.</p>
<div class="figure align-default" id="id6">
<span id="fig-basics-heat-flowchart"></span><a class="reference internal image-reference" href="_images/flowchart2.png"><img alt="_images/flowchart2.png" src="_images/flowchart2.png" style="width: 4in;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Diagram of the source code structure for the HeatEquation_EX1_C example.</span><a class="headerlink" href="#id6" title="Permalink to this image">Â¶</a></p>
</div>
<p>Source code tree for the HeatEquation_EX1_C example</p>
<blockquote>
<div><dl class="simple">
<dt>amrex/Src/Base</dt><dd><p>Contains source code for single-level simulations.  Note that in
<code class="docutils literal notranslate"><span class="pre">amrex/Src</span></code> there are many sub-directories, e.g., <code class="docutils literal notranslate"><span class="pre">Base</span></code>, <code class="docutils literal notranslate"><span class="pre">Amr</span></code>,
<code class="docutils literal notranslate"><span class="pre">AmrCore</span></code>, <code class="docutils literal notranslate"><span class="pre">LinearSolvers</span></code>, etc.  In this tutorial the only source
code directory we need is <code class="docutils literal notranslate"><span class="pre">Base</span></code>.</p>
</dd>
<dt>amrex/Tutorials/HeatEquation_EX1_C/Source</dt><dd><p>Contains the following source code specific to this tutorial:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Make.package</span></code>: lists the source code files</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">main.cpp</span></code>: contains the C++ <code class="docutils literal notranslate"><span class="pre">main</span></code> function</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myfunc.cpp</span></code>: contains function <code class="docutils literal notranslate"><span class="pre">advance</span></code> that advances
the solution by a time step, and function <code class="docutils literal notranslate"><span class="pre">init_phi</span></code> that
initializes the initial solution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">myfunc.H</span></code>: header file for C++ functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mykernel.H</span></code>: kernels functions called by <code class="docutils literal notranslate"><span class="pre">advance</span></code> and <code class="docutils literal notranslate"><span class="pre">init_phi</span></code>.</p></li>
</ol>
</dd>
<dt>amrex/Tutorials/HeatEquation_EX1_C/Exec</dt><dd><p>This is where you build the code with make.  There is a GNUmakefile
and inputs file.</p>
</dd>
</dl>
</div></blockquote>
<p>Now we highlight a few key sections of the code.  In <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> we
demonstrate how to read in parameters from the inputs file:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// inputs parameters</span>
<span class="p">{</span>
    <span class="c1">// ParmParse is way of reading inputs from the inputs file</span>
    <span class="n">ParmParse</span> <span class="n">pp</span><span class="p">;</span>

    <span class="c1">// We need to get n_cell from the inputs file - this is the number of cells on each side of</span>
    <span class="c1">//   a square (or cubic) domain.</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;n_cell&quot;</span><span class="p">,</span><span class="n">n_cell</span><span class="p">);</span>

    <span class="c1">// The domain is broken into boxes of size max_grid_size</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;max_grid_size&quot;</span><span class="p">,</span><span class="n">max_grid_size</span><span class="p">);</span>

    <span class="c1">// Default plot_int to -1, allow us to set it to something else in the inputs file</span>
    <span class="c1">//  If plot_int &lt; 0 then no plot files will be writtenq</span>
    <span class="n">plot_int</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;plot_int&quot;</span><span class="p">,</span><span class="n">plot_int</span><span class="p">);</span>

    <span class="c1">// Default nsteps to 10, allow us to set it to something else in the inputs file</span>
    <span class="n">nsteps</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">pp</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;nsteps&quot;</span><span class="p">,</span><span class="n">nsteps</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> we demonstrate how to define a <code class="docutils literal notranslate"><span class="pre">Box</span></code> for the problem domain,
and then how to chop that <code class="docutils literal notranslate"><span class="pre">Box</span></code> up into multiple boxes that define a
<code class="docutils literal notranslate"><span class="pre">BoxArray</span></code>  We also define a <code class="docutils literal notranslate"><span class="pre">Geometry</span></code> object that knows about the problem
domain, the physical coordinates of the box, and the periodicity:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// make BoxArray and Geometry</span>
<span class="n">BoxArray</span> <span class="n">ba</span><span class="p">;</span>
<span class="n">Geometry</span> <span class="n">geom</span><span class="p">;</span>
<span class="p">{</span>
    <span class="n">IntVect</span> <span class="nf">dom_lo</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span>       <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">));</span>
    <span class="n">IntVect</span> <span class="nf">dom_hi</span><span class="p">(</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="n">n_cell</span><span class="mi">-1</span><span class="p">,</span> <span class="n">n_cell</span><span class="mi">-1</span><span class="p">,</span> <span class="n">n_cell</span><span class="mi">-1</span><span class="p">));</span>
    <span class="n">Box</span> <span class="nf">domain</span><span class="p">(</span><span class="n">dom_lo</span><span class="p">,</span> <span class="n">dom_hi</span><span class="p">);</span>

    <span class="c1">// Initialize the boxarray &quot;ba&quot; from the single box &quot;domain&quot;</span>
    <span class="n">ba</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
    <span class="c1">// Break up boxarray &quot;ba&quot; into chunks no larger than &quot;max_grid_size&quot; along a direction</span>
    <span class="n">ba</span><span class="p">.</span><span class="n">maxSize</span><span class="p">(</span><span class="n">max_grid_size</span><span class="p">);</span>

   <span class="c1">// This defines the physical box, [-1,1] in each direction.</span>
    <span class="n">RealBox</span> <span class="nf">real_box</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mf">-1.0</span><span class="p">,</span><span class="mf">-1.0</span><span class="p">,</span><span class="mf">-1.0</span><span class="p">)},</span>
                     <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)});</span>

    <span class="c1">// periodic in all direction by default</span>
    <span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">is_periodic</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)};</span>

    <span class="c1">// This defines a Geometry object</span>
    <span class="n">geom</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span><span class="n">real_box</span><span class="p">,</span><span class="n">CoordSys</span><span class="o">::</span><span class="n">cartesian</span><span class="p">,</span><span class="n">is_periodic</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> we demonstrate how to build a <code class="docutils literal notranslate"><span class="pre">DistributionMapping</span></code> from the
<code class="docutils literal notranslate"><span class="pre">BoxArray</span></code>, and then build <code class="docutils literal notranslate"><span class="pre">MultiFabs</span></code> with a desired number of components
and ghost cells associated with each grid:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Nghost = number of ghost cells for each array</span>
<span class="kt">int</span> <span class="n">Nghost</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// Ncomp = number of components for each array</span>
<span class="kt">int</span> <span class="n">Ncomp</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// How Boxes are distrubuted among MPI processes</span>
<span class="n">DistributionMapping</span> <span class="nf">dm</span><span class="p">(</span><span class="n">ba</span><span class="p">);</span>

<span class="c1">// we allocate two phi multifabs; one will store the old state, the other the new.</span>
<span class="n">MultiFab</span> <span class="nf">phi_old</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">Ncomp</span><span class="p">,</span> <span class="n">Nghost</span><span class="p">);</span>
<span class="n">MultiFab</span> <span class="nf">phi_new</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">Ncomp</span><span class="p">,</span> <span class="n">Nghost</span><span class="p">);</span>
</pre></div>
</div>
<p>We demonstrate how to build an array of face-based <code class="docutils literal notranslate"><span class="pre">MultiFabs</span></code> :</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// build the flux multifabs</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="p">,</span> <span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">flux</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="n">dir</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// flux(dir) has one component, zero ghost cells, and is nodal in direction dir</span>
    <span class="n">BoxArray</span> <span class="n">edge_ba</span> <span class="o">=</span> <span class="n">ba</span><span class="p">;</span>
    <span class="n">edge_ba</span><span class="p">.</span><span class="n">surroundingNodes</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
    <span class="n">flux</span><span class="p">[</span><span class="n">dir</span><span class="p">].</span><span class="n">define</span><span class="p">(</span><span class="n">edge_ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To access and/or modify data in a <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> we use the <code class="docutils literal notranslate"><span class="pre">MFIter</span></code>, where each
processor loops over grids it owns to access and/or modify data on that grid:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Initialize phi_new by calling a Fortran routine.</span>
<span class="c1">// MFIter = MultiFab Iterator</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">phi_new</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">vbx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>
    <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">phiNew</span> <span class="o">=</span> <span class="n">phi_new</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">mfi</span><span class="p">);</span>
    <span class="n">amrex</span><span class="o">::</span><span class="n">ParallelFor</span><span class="p">(</span><span class="n">vbx</span><span class="p">,</span>
    <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="n">AMREX_GPU_DEVICE</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">init_phi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">phiNew</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">prob_lo</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the kernel function <code class="docutils literal notranslate"><span class="pre">init_phi</span></code> for initializing a single
cell is is <code class="docutils literal notranslate"><span class="pre">mykernel.H</span></code>.  Itâs marked with <cite>AMREX_GPU_DEVICE</cite> to
make it a GPU device function, if it built with GPU support.  Itâs
also marked with <cite>AMREX_FORCE_INLINE</cite> for inlining.</p>
<p>Ghost cells are filled using the <code class="docutils literal notranslate"><span class="pre">FillBoundary</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fill the ghost cells of each grid from the other grids</span>
<span class="c1">// includes periodic domain boundaries</span>
<span class="n">phi_old</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">periodicity</span><span class="p">());</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ManagingGridHierarchy_Chapter.html" class="btn btn-neutral float-right" title="Gridding and Load Balancing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Basics_Chapter.html" class="btn btn-neutral float-left" title="Basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2018, AMReX Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>