

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Particle &mdash; amrex 20.01-dev documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Fortran Interface" href="Fortran_Chapter.html" />
    <link rel="prev" title="Particles" href="Particle_Chapter.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                20.01-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics_Chapter.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Particle_Chapter.html">Particles</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">The Particle</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#setting-particle-data">Setting Particle data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-particlecontainer">The ParticleContainer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#arrays-of-structs-and-structs-of-arrays">Arrays-of-Structs and Structs-of-Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constructing-particlecontainers">Constructing ParticleContainers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-particle-data">Initializing Particle Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-particle-components-at-runtime">Adding particle components at runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterating-over-particles">Iterating over Particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#passing-particle-data-into-fortran-routines">Passing particle data into Fortran routines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interacting-with-mesh-data">Interacting with Mesh Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#short-range-forces">Short Range Forces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#particle-io">Particle IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inputs-parameters">Inputs parameters</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="Particle_Chapter.html">Particles</a> &raquo;</li>
        
      <li>The Particle</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Particle.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-particle">
<span id="sec-particles-particle"></span><h1>The Particle<a class="headerlink" href="#the-particle" title="Permalink to this headline">¶</a></h1>
<p>The particle classes can be used by including the header AMReX_Particles.H. The
most basic particle data structure is the particle itself:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Particle</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a templated data type, designed to allow flexibility in the number and
type of components that the particles carry. The first template parameter is the
number of extra <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Real</span></span></code> variables this particle will have (either single or
double precision <a class="footnote-reference brackets" href="#id4" id="id1">1</a>), while the second is the number of extra integer
variables.  It is important to note that this is the number of <em>extra</em> real and
integer variables; a particle will always have at least <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_SPACEDIM</span></span></code> real
components that store the particle’s position and 2 integer components that
store the particle’s <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">id</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">cpu</span></span></code> numbers. <a class="footnote-reference brackets" href="#id5" id="id2">2</a></p>
<p>The particle struct is designed to store these variables in a way that
minimizes padding, which in practice means that the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Real</span></span></code> components
always come first, and the integer components second. Additionally, the
required particle variables are stored before the optional ones, for both the
real and the integer components. For example, say we want to define a particle
type that stores a mass, three velocity components, and two extra integer
flags. Our particle struct would be set up like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Particle</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</pre></div>
</div>
<p>and the order of the particle components in would be (assuming <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BL_SPACEDIM</span></span></code> is 3):
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">z</span></span> <span class="name"><span class="pre">m</span></span> <span class="name"><span class="pre">vx</span></span> <span class="name"><span class="pre">vy</span></span> <span class="name"><span class="pre">vz</span></span> <span class="name"><span class="pre">id</span></span> <span class="name"><span class="pre">cpu</span></span> <span class="name"><span class="pre">flag1</span></span> <span class="name"><span class="pre">flag2</span></span></code>.  <a class="footnote-reference brackets" href="#id6" id="id3">3</a></p>
<div class="section" id="setting-particle-data">
<h2>Setting Particle data<a class="headerlink" href="#setting-particle-data" title="Permalink to this headline">¶</a></h2>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Particle</span></span></code> struct provides a number of methods for getting and setting
a particle’s data. For the required particle components, there are special,
named methods. For the “extra” real and integer data, you can use the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">rdata</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">idata</span></span></code> methods, respectively.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Particle</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>

<span class="n">p</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">id</span><span class="p">()</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">cpu</span><span class="p">()</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// p.rdata(0) is the first extra real component, not the</span>
<span class="c1">// first real component overall</span>
<span class="n">p</span><span class="p">.</span><span class="n">rdata</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">rdata</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>

<span class="c1">// and likewise for p.idata(0);</span>
<span class="n">p</span><span class="p">.</span><span class="n">idata</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">idata</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">-64</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-particlecontainer">
<span id="sec-particles-particlecontainer"></span><h1>The ParticleContainer<a class="headerlink" href="#the-particlecontainer" title="Permalink to this headline">¶</a></h1>
<p>One particle by itself is not very useful. To do real calculations, a
collection of particles needs to be defined, and the location of the particles
within the AMR hierarchy (and the corresponding MPI process) needs to be
tracked as the particle positions change. To do this, we provide the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code> class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">mypc</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="arrays-of-structs-and-structs-of-arrays">
<h2>Arrays-of-Structs and Structs-of-Arrays<a class="headerlink" href="#arrays-of-structs-and-structs-of-arrays" title="Permalink to this headline">¶</a></h2>
<p>Like the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Particle</span></span></code> class itself, the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code>
class is templated. The first two template parameters have the same meaning as
before: they define the number of each type of variables that the particles in
this container will store. Particles added to the container are stored in the
Array-of-Structs (AoS) style. In addition, there are two more optional template
parameters that allow the user to specify additional particle variables that
will be stored in Struct-of-Array (SoA) form. The difference between
Array-of-Struct and Struct-of-Array data is in how the data is laid out in
memory. For the AoS data, all the variables associated with particle 1 are next
to each other in memory, followed by all the variables associated with particle
2, and so on. For variables stored in SoA style, all the particle data for a
given component is next to each other in memory, and each component is stored
in a separate array. For convenience, we (arbitrarily) refer to the components
in the particle struct as particle <em>data</em>, and components stored in the
Struct-of-Arrays as particle <em>attributes</em>. See the figure
<a class="reference internal" href="#fig-particles-particle-arrays"><span class="std std-ref">below</span></a> for an illustration.</p>
<div class="figure align-default" id="id7">
<span id="fig-particles-particle-arrays"></span><img alt="_images/particle_arrays.png" src="_images/particle_arrays.png" />
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">An illustration of how the particle data for a single tile is arranged in
memory. This particle container has been defined with <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">NStructReal</span></span> <span class="operator"><span class="pre">=</span></span>
<span class="literal number integer"><span class="pre">1</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">NStructInt</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">2</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">NArrayReal</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">2</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">NArrayInt</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">2</span></span></code>.
In this case, each tile in the particle container has five arrays: one with
the particle struct data, two additional real arrays, and two additional
integer arrays.  In the tile shown, there are only 2 particles. We have
labelled the extra real data member of the particle struct to be
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">mass</span></span></code>, while the extra integer members of the particle struct are
labeled <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">p</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">s</span></span></code>, for “phase” and “state”. The variables in
the real and integer arrays are labelled <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">foo</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">bar</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">l</span></span></code>,
and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>, respectively. We have assumed that the particles are double
precision.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<p>To see why the distinction between AoS and SoA data is important, consider the
following extreme case. Say you have particles that carry 100 different
components, but that most of the time, you only need to do calculations
involving 3 of them (say, the particle positions) at once. In this case,
storing all 100 particle variables in the particle struct is clearly
inefficient, since most of the time you are reading 97 extra variables into
cache that you will never use. By splitting up the particle variables into
stuff that gets used all the time (stored in the AoS) and stuff that only gets
used infrequently (stored in the SoA), you can in principle achieve much better
cache reuse. Of course, the usage pattern of your application likely won’t be
so clear-cut. Flexibility in how the particle data is stored also makes it
easier to interface between AMReX and already-existing Fortran subroutines.</p>
<p>Note that while “extra” particle data can be stored in either the SoA or AoS
style, the particle positions and id numbers are <strong>always</strong> stored in the
particle structs. This is because these particle variables are special and used
internally by AMReX to assign the particles to grids and to mark particles as
valid or invalid, respectively.</p>
</div>
<div class="section" id="constructing-particlecontainers">
<h2>Constructing ParticleContainers<a class="headerlink" href="#constructing-particlecontainers" title="Permalink to this headline">¶</a></h2>
<p>A particle container is always associated with a particular set of AMR grids
and a particular set of DistributionMaps that describes which MPI processes
those grids live on.  For example, if you only have one level, you can define a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code> to store particles on that level using the following
constructor:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span> <span class="p">(</span><span class="k">const</span> <span class="n">Geometry</span>            <span class="o">&amp;</span> <span class="n">geom</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">DistributionMapping</span> <span class="o">&amp;</span> <span class="n">dmap</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">BoxArray</span>            <span class="o">&amp;</span> <span class="n">ba</span><span class="p">);</span>
</pre></div>
</div>
<p>Or, if you have multiple levels, you can use following constructor instead:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ParticleContainer</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;</span>            <span class="o">&amp;</span> <span class="n">geom</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">dmap</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;</span>            <span class="o">&amp;</span> <span class="n">ba</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>                 <span class="o">&amp;</span> <span class="n">rr</span><span class="p">);</span>
</pre></div>
</div>
<p>Note the set of grids used to define the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code> doesn’t have
to be the same set used to define the simulation’s mesh data. However, it is
often desirable to have the two hierarchies track each other. If you are using
an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrCore</span></span></code> class in your simulation (see the Chapter on
<a class="reference internal" href="AmrCore_Chapter.html#chap-amrcore"><span class="std std-ref">AmrCore Source Code</span></a>), you can achieve this by using the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrParticleContainer</span></span></code> class. The constructor for this class takes a
pointer to your AmrCore derived class, instead:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AmrTracerParticleContainer</span> <span class="p">(</span><span class="n">AmrCore</span><span class="o">*</span> <span class="n">amr_core</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">BoxArray</span></span><span class="operator"><span class="pre">&gt;</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">DistributionMap</span></span><span class="operator"><span class="pre">&gt;</span></span></code>
used by your <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code> will be updated automatically to match
those in your <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrCore</span></span></code>.</p>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code> stores the particle data in a manner prescribed by
the set of AMR grids used to define it. If tiling is turned off, then every
grid has its own Array-of-Structs and Struct-of-Arrays. Which AMR grid a
particle is assigned to is determined by examining its position and binning it,
using the domain left edge as an offset.  By default, a particle is assigned to
the finest level that contains its position, although this behavior can be
tweaked if desired.  When tiling is enabled, then each <em>tile</em> gets its own
Struct-of-Arrays and Array-of-Structs instead. Note that this is different than
what happens with mesh data. With mesh data, the tiling is strictly logical;
the data is laid out in memory the same whether tiling is turned on or off.
With particle data, however, the particles are actually stored in different
arrays when tiling is enabled. As with mesh data, the particle tile size can be
tuned so that an entire tile’s worth of particles will fit into a cache line at
once.</p>
<p>Once the particles move, their data may no longer be in the right place in the
container. They can be reassigned by calling the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Redistribute</span></span><span class="punctuation"><span class="pre">()</span></span></code> method
of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code>.  After calling this method, all the particles will
be moved to their proper places in the container, and all invalid particles
(particles with id set to <code class="code cpp c++ docutils literal notranslate"><span class="literal number integer"><span class="pre">-1</span></span></code>) will be removed. All the MPI communication
needed to do this happens automatically.</p>
<p>Application codes will likely want to create their own derived
ParticleContainer class that specializes the template parameters and adds
additional functionality, like setting the initial conditions, moving the
particles, etc. See the <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Particles</span></code> for examples of this.</p>
</div>
</div>
<div class="section" id="initializing-particle-data">
<span id="sec-particles-initializing"></span><h1>Initializing Particle Data<a class="headerlink" href="#initializing-particle-data" title="Permalink to this headline">¶</a></h1>
<p>In the following code snippet, we demonstrate how to set particle initial
conditions for both SoA and AoS data. We loop over all the tiles using
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code>, and add as many particles as we want to each one.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span> <span class="o">=</span> <span class="n">MakeMFIter</span><span class="p">(</span><span class="n">lev</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// ``particles&#39;&#39; starts off empty</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">particles</span> <span class="o">=</span> <span class="n">GetParticles</span><span class="p">(</span><span class="n">lev</span><span class="p">)[</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">mfi</span><span class="p">.</span><span class="n">index</span><span class="p">(),</span>
                                        <span class="n">mfi</span><span class="p">.</span><span class="n">LocalTileIndex</span><span class="p">())];</span>

    <span class="n">ParticleType</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span><span class="p">.</span><span class="n">id</span><span class="p">()</span>   <span class="o">=</span> <span class="n">ParticleType</span><span class="o">::</span><span class="n">NextID</span><span class="p">();</span>
    <span class="n">p</span><span class="p">.</span><span class="n">cpu</span><span class="p">()</span>  <span class="o">=</span> <span class="n">ParallelDescriptor</span><span class="o">::</span><span class="n">MyProc</span><span class="p">();</span>
    <span class="n">p</span><span class="p">.</span><span class="n">pos</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">etc</span><span class="p">...</span>

    <span class="c1">// AoS real data</span>
    <span class="n">p</span><span class="p">.</span><span class="n">rdata</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">p</span><span class="p">.</span><span class="n">rdata</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="o">=</span> <span class="p">...</span>

    <span class="c1">// AoS int data</span>
    <span class="n">p</span><span class="p">.</span><span class="n">idata</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">p</span><span class="p">.</span><span class="n">idata</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">...</span>

    <span class="c1">// Particle real attributes (SoA)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">real_attribs</span><span class="p">;</span>
    <span class="n">real_attribs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">real_attribs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span>

    <span class="c1">// Particle int attributes (SoA)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">int_attribs</span><span class="p">;</span>
    <span class="n">int_attribs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">int_attribs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="p">...</span>

    <span class="n">particles</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">particles</span><span class="p">.</span><span class="n">push_back_real</span><span class="p">(</span><span class="n">real_attribs</span><span class="p">);</span>
    <span class="n">particles</span><span class="p">.</span><span class="n">push_back_int</span><span class="p">(</span><span class="n">int_attribs</span><span class="p">);</span>

    <span class="c1">// ... add more particles if desired ...</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Often, it makes sense to have each process only generate particles that it
owns, so that the particles are already in the right place in the container.
In general, however, users may need to call <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Redistribute</span></span><span class="punctuation"><span class="pre">()</span></span></code> after adding
particles, if the processes generate particles they don’t own (for example, if
the particle positions are perturbed from the cell centers and thus end up
outside their parent grid).</p>
</div>
<div class="section" id="adding-particle-components-at-runtime">
<span id="sec-particles-runtime"></span><h1>Adding particle components at runtime<a class="headerlink" href="#adding-particle-components-at-runtime" title="Permalink to this headline">¶</a></h1>
<p>In addition to the components specified as template parameters, you can also
add additional <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Real</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span></code> components at runtime. These components
will be stored in Struct-of-Array style. To add a runtime component, use the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AddRealComp</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AddIntComp</span></span></code> methods of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code>, like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">bool</span> <span class="n">communicate_this_comp</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_runtime_real</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AddRealComp</span><span class="p">(</span><span class="n">communicate_this_comp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_runtime_int</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AddIntComp</span><span class="p">(</span><span class="n">communicate_this_comp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Runtime-added components can be accessed like regular Struct-of-Array data.
The new components will be added at the end of the compile-time defined ones.</p>
<p>When you are using runtime components, it is crucial that when you are adding
particles to the container, you call the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DefineAndReturnParticleTile</span></span></code> method
for each tile prior to adding any particles. This will make sure the space
for the new components has been allocated. For example, in the above section
on <a class="reference internal" href="#sec-particles-initializing"><span class="std std-ref">initializing particle data</span></a>, we accessed
the particle tile data using the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GetParticles</span></span></code> method. If we runtime components
are used, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DefineAndReturnParticleTile</span></span></code> should be used instead:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span> <span class="o">=</span> <span class="n">MakeMFIter</span><span class="p">(</span><span class="n">lev</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// instead of this...</span>
    <span class="c1">// auto&amp; particles = GetParticles(lev)[std::make_pair(mfi.index(),</span>
    <span class="c1">//                                     mfi.LocalTileIndex())];</span>

    <span class="c1">// we do this...</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">particle_tile</span> <span class="o">=</span> <span class="n">DefineAndReturnParticleTile</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">mfi</span><span class="p">);</span>

    <span class="c1">// add particles to particle_tile as above...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iterating-over-particles">
<span id="sec-particles-iterating"></span><h1>Iterating over Particles<a class="headerlink" href="#iterating-over-particles" title="Permalink to this headline">¶</a></h1>
<p>To iterate over the particles on a given level in your container, you can use
the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParIter</span></span></code> class, which comes in both const and non-const flavors. For
example, to iterate over all the AoS data:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">MyParIter</span> <span class="o">=</span> <span class="n">ConstParIter</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">*</span><span class="n">BL_SPACEDIM</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MyParIter</span> <span class="n">pti</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">lev</span><span class="p">);</span> <span class="n">pti</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">pti</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">particles</span> <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">GetArrayOfStructs</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">particles</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// do stuff with p...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The outer loop will execute once every grid (or tile, if tiling is enabled)
<em>that contains particles</em>; grids or tiles that don’t have any particles will be
skipped. You can also access the SoA data using the <span class="math notranslate nohighlight">\(ParIter\)</span> as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">MyParIter</span> <span class="o">=</span> <span class="n">ParIter</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MyParIter</span> <span class="n">pti</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">lev</span><span class="p">);</span> <span class="n">pti</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">pti</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">particle_attributes</span> <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">GetStructOfArrays</span><span class="p">();</span>
    <span class="n">RealVector</span><span class="o">&amp;</span> <span class="n">real_comp0</span> <span class="o">=</span> <span class="n">particle_attributes</span><span class="p">.</span><span class="n">GetRealData</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">IntVector</span><span class="o">&amp;</span>  <span class="n">int_comp1</span>  <span class="o">=</span> <span class="n">particle_attributes</span><span class="p">.</span><span class="n">GetIntData</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pti</span><span class="p">.</span><span class="n">numParticles</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// do stuff with your SoA data...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="passing-particle-data-into-fortran-routines">
<span id="sec-particles-fortran"></span><h1>Passing particle data into Fortran routines<a class="headerlink" href="#passing-particle-data-into-fortran-routines" title="Permalink to this headline">¶</a></h1>
<p>Because the AMReX particle struct is a Plain-Old-Data type, it is interoperable
with Fortran when the <code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">bind</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">C</span></span><span class="punctuation"><span class="pre">)</span></span></code> attribute is used. It is therefore
possible to pass a grid or tile worth of particles into fortran routines for
processing, instead of iterating over them in C++. You can also define a
Fortran derived type that is equivalent to C struct used for the particles. For
example:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span><span class="p">:</span> <span class="n">amrex_particle_real</span>
<span class="k">use </span><span class="nb">iso_c_binding</span> <span class="p">,</span>    <span class="n">only</span><span class="p">:</span> <span class="kt">c_int</span>

<span class="k">type</span><span class="p">,</span> <span class="k">bind</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">particle_t</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">amrex_particle_real</span><span class="p">)</span> <span class="kd">::</span> <span class="n">pos</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">amrex_particle_real</span><span class="p">)</span> <span class="kd">::</span> <span class="n">vel</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">amrex_particle_real</span><span class="p">)</span> <span class="kd">::</span> <span class="n">acc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">id</span>
   <span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">cpu</span>
<span class="k">end type </span><span class="n">particle_t</span>
</pre></div>
</div>
<p>is equivalent to a particle struct you get with <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Particle</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="literal number integer"><span class="pre">6</span></span><span class="punctuation"><span class="pre">,</span></span> <span class="literal number integer"><span class="pre">0</span></span><span class="operator"><span class="pre">&gt;</span></span></code>. Here,
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_particle_real</span></span></code> is either single or doubled precision, depending
on whether <code class="docutils literal notranslate"><span class="pre">USE_SINGLE_PRECISION_PARTICLES</span></code> is <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> or not. We recommend
always using this type in Fortran routines that work on particle data to avoid
hard-to-debug incompatibilities between floating point types.</p>
</div>
<div class="section" id="interacting-with-mesh-data">
<span id="sec-particles-interacting"></span><h1>Interacting with Mesh Data<a class="headerlink" href="#interacting-with-mesh-data" title="Permalink to this headline">¶</a></h1>
<p>It is common to want to have the mesh communicate information to the particles
and vice versa. For example, in Particle-in-Cell calculations, the particles
deposit their charges onto the mesh, and later, the electric fields computed on
the mesh are interpolated back to the particles. Below, we show examples of
both these sorts of operations.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ex</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">gm</span><span class="p">.</span><span class="n">periodicity</span><span class="p">());</span>
<span class="n">Ey</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">gm</span><span class="p">.</span><span class="n">periodicity</span><span class="p">());</span>
<span class="n">Ez</span><span class="p">.</span><span class="n">FillBoundary</span><span class="p">(</span><span class="n">gm</span><span class="p">.</span><span class="n">periodicity</span><span class="p">());</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MyParIter</span> <span class="n">pti</span><span class="p">(</span><span class="n">MyPC</span><span class="p">,</span> <span class="n">lev</span><span class="p">);</span> <span class="n">pti</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">pti</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>

    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">particles</span> <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">GetArrayOfStructs</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">nstride</span> <span class="o">=</span> <span class="n">particles</span><span class="p">.</span><span class="n">dataShape</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">long</span> <span class="n">np</span>  <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">numParticles</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">exfab</span> <span class="o">=</span> <span class="n">Ex</span><span class="p">[</span><span class="n">pti</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">eyfab</span> <span class="o">=</span> <span class="n">Ey</span><span class="p">[</span><span class="n">pti</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">ezfab</span> <span class="o">=</span> <span class="n">Ex</span><span class="p">[</span><span class="n">pti</span><span class="p">];</span>

    <span class="n">interpolate_cic</span><span class="p">(</span><span class="n">particles</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">nstride</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span>
                    <span class="n">exfab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">eyfab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">ezfab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span>
                    <span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="n">plo</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ng</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Here, <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">interpolate_cic</span></span></code> is a Fortran subroutine that actually performs
the interpolation on a single box. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Ex</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Ey</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Ez</span></span></code> are
MultiFabs that contain the electric field data. These MultiFabs must be defined
with the correct number of ghost cells to perform the desired type of
interpolation, and we call <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code> prior to the Fortran call so
that those ghost cells will be up-to-date.</p>
<p>In this example, we have assumed that the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span> <span class="name"><span class="pre">MyPC</span></span></code> has
been defined on the same grids as the electric field MultiFabs, so that we use
the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParIter</span></span></code> to index into the MultiFabs to get the data associated with
current tile. If this is not the case, then an additional copy will need to be
performed. However, if the particles are distributed in an extremely uneven
fashion, it is possible that the load balancing improvements associated with
the two-grid approach are worth the cost of the extra copy.</p>
<p>The inverse operation, in which the particles communicate data <em>to</em> the mesh,
is quite similar:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rho</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MyParIter</span> <span class="n">pti</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">lev</span><span class="p">);</span> <span class="n">pti</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">pti</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>

    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">particles</span> <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">GetArrayOfStructs</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">nstride</span> <span class="o">=</span> <span class="n">particles</span><span class="p">.</span><span class="n">dataShape</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">long</span> <span class="n">np</span>  <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">numParticles</span><span class="p">();</span>

    <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">rhofab</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">rho</span><span class="p">[</span><span class="n">lev</span><span class="p">])[</span><span class="n">pti</span><span class="p">];</span>

    <span class="n">deposit_cic</span><span class="p">(</span><span class="n">particles</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">nstride</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">rhofab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span>
                <span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">(),</span> <span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">(),</span> <span class="n">plo</span><span class="p">,</span> <span class="n">dx</span><span class="p">);</span>
    <span class="p">}</span>

<span class="n">rho</span><span class="p">.</span><span class="n">SumBoundary</span><span class="p">(</span><span class="n">gm</span><span class="p">.</span><span class="n">periodicity</span><span class="p">());</span>
</pre></div>
</div>
<p>As before, we loop over all our particles, calling a Fortran routine that
deposits them on to the appropriate <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span> <span class="name"><span class="pre">rhofab</span></span></code>. The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">rhofab</span></span></code>
must have enough ghost cells to cover the support of all the particles
associated with them. Note that we call <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">SumBoundary</span></span></code> instead of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code> after performing the deposition, to add up the charge in
the ghost cells surrounding each Fab into the corresponding valid cells.</p>
<p>For a complete example of an electrostatic PIC calculation that includes static
mesh refinement, please see <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Particles/ElectrostaticPIC</span></code>.</p>
</div>
<div class="section" id="short-range-forces">
<span id="sec-particles-shortrange"></span><h1>Short Range Forces<a class="headerlink" href="#short-range-forces" title="Permalink to this headline">¶</a></h1>
<p>In a PIC calculation, the particles don’t interact with each other directly;
they only see each other through the mesh. An alternative use case is particles
that exert short-range forces on each other. In this case, beyond some cut-off
distance, the particles don’t interact with each other and therefore don’t need
to be included in the force calculation. Our approach to these kind of
particles is to fill “neighbor buffers” on each tile that contain copies of the
particles on neighboring tiles that are within some number of cells <span class="math notranslate nohighlight">\(N_g\)</span>
of the tile boundaries. See <a class="reference internal" href="#fig-particles-neighbor-particles"><span class="std std-numref">Fig. 11</span></a>, below
for an illustration. By choosing the number of ghost cells to match the
interaction radius of the particles, you can capture all of the neighbors that
can possibly influence the particles in the valid region of the tile. The
forces on the particles on different tiles can then be computed independently
of each other using a variety of methods.</p>
<div class="figure align-default" id="id8">
<span id="fig-particles-neighbor-particles"></span><a class="reference internal image-reference" href="_images/neighbor_particles.png"><img alt="_images/neighbor_particles.png" src="_images/neighbor_particles.png" style="width: 75.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">: An illustration of filling neighbor particles for short-range force
calculations. Here, we have a domain consisting of one <span class="math notranslate nohighlight">\(32 \times 32\)</span>
grid, broken up into <span class="math notranslate nohighlight">\(8 \times 8\)</span> tiles. The number of ghost cells is
taken to be <span class="math notranslate nohighlight">\(1\)</span>.  For the tile in green, particles on other tiles in
the entire shaded region will copied and packed into the green tile’s
neighbor buffer. These particles can then be included in the force
calculation. If the domain is periodic, particles in the grown region for
the blue tile that lie on the other side of the domain will also be copied,
and their positions will modified so that a naive distance calculation
between valid particles and neighbors will be correct.</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>For a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code> that does this neighbor finding, please see
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">NeighborParticleContainer</span></span></code> in
<code class="docutils literal notranslate"><span class="pre">amrex/Src/Particles/AMReX_NeighborParticleContainer.H.</span></code> This
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code> has additional methods called <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">fillNeighbors</span></span><span class="punctuation"><span class="pre">()</span></span></code>
and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">clearNeighbors</span></span><span class="punctuation"><span class="pre">()</span></span></code> that fill the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">neighbors</span></span></code> data structure with
copies of the proper particles. A tutorial that uses these features is
available at <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Particles/ShortRangeParticles</span></code>. This tutorial
computes the forces on a given tile via direct summation by passing the real
and neighbor particles into a Fortran subroutine, as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">ShortRangeParticleContainer</span><span class="o">::</span><span class="n">computeForces</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MyParIter</span> <span class="n">pti</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">lev</span><span class="p">);</span> <span class="n">pti</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">pti</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">AoS</span><span class="o">&amp;</span> <span class="n">particles</span> <span class="o">=</span> <span class="n">pti</span><span class="p">.</span><span class="n">GetArrayOfStructs</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">Np</span> <span class="o">=</span> <span class="n">particles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">PairIndex</span> <span class="nf">index</span><span class="p">(</span><span class="n">pti</span><span class="p">.</span><span class="n">index</span><span class="p">(),</span> <span class="n">pti</span><span class="p">.</span><span class="n">LocalTileIndex</span><span class="p">());</span>
        <span class="kt">int</span> <span class="n">Nn</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="n">amrex_compute_forces</span><span class="p">(</span><span class="n">particles</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Np</span><span class="p">,</span>
                             <span class="n">neighbors</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">Nn</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, one can avoid doing a direct <span class="math notranslate nohighlight">\(N^2\)</span> summation over the
particles on a tile by binning the particles by cell and building a neighbor
list. A tutorial that demonstrates this process is available at
<code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Particles/NeighborList</span></code>. The data structure used to represent
the neighbor lists is illustrated in <a class="reference internal" href="#fig-particles-neighbor-list"><span class="std std-numref">Fig. 12</span></a>.</p>
<div class="figure align-default" id="id9">
<span id="fig-particles-neighbor-list"></span><img alt="_images/neighbor_list.png" src="_images/neighbor_list.png" />
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">: An illustration of the neighbor list data structure used by AMReX. The
list for each tile is represented by an array of integers. The first number
in the array is the number of real (i.e., not in the neighbor buffers)
collision partners for the first particle on this tile, while the second is
the number of collision partners from nearby tiles in the neighbor buffer.
Based on the number of collision partners, the next several entries are the
indices of the collision partners in the real and neighbor particle arrays,
respectively. This pattern continues for all the particles on this tile.</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>This array can then be used to compute the forces on all the particles in one
scan. Users can define their own <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">NeighborParticleContainer</span></span></code> subclasses
that have their own collision criteria by overloading the virtual
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">check_pair</span></span></code> function. For an example of this in action, please see the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">NeighborList</span></span></code> Tutorial.</p>
</div>
<div class="section" id="particle-io">
<span id="sec-particles-io"></span><h1>Particle IO<a class="headerlink" href="#particle-io" title="Permalink to this headline">¶</a></h1>
<p>AMReX provides routines for writing particle data to disk for analysis,
visualization, and for checkpoint / restart. The most important methods are the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">WritePlotFile</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Checkpoint</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Restart</span></span></code> methods of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParticleContainer</span></span></code>, which all use a parallel-aware binary file format for
reading and writing particle data on a grid-by-grid basis. These methods are
designed to complement the functions in AMReX_PlotFileUtil.H for performing
mesh data IO. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">WriteMultiLevelPlotfile</span><span class="p">(</span><span class="s">&quot;plt00000&quot;</span><span class="p">,</span> <span class="n">output_levs</span><span class="p">,</span> <span class="n">GetVecOfConstPtrs</span><span class="p">(</span><span class="n">output</span><span class="p">),</span>
                        <span class="n">varnames</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">level_steps</span><span class="p">,</span> <span class="n">outputRR</span><span class="p">);</span>
<span class="n">pc</span><span class="p">.</span><span class="n">Checkpoint</span><span class="p">(</span><span class="s">&quot;plt00000&quot;</span><span class="p">,</span> <span class="s">&quot;particle0&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>will create a plot file called “plt00000” and write the mesh data in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">output</span></span></code> to it, and then write the particle data in a subdirectory called “particle0”. There is also the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">WriteAsciiFile</span></span></code> method, which writes the particles in a human-readable text format. This is mainly useful for testing and debugging.</p>
<p>The binary file format is currently readable by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">yt</span></span></code>. In additional, there is a Python conversion script in
<code class="docutils literal notranslate"><span class="pre">amrex/Tools/Py_util/amrex_particles_to_vtp</span></code> that can convert both the ASCII and the binary particle files to a
format readable by Paraview. See the chapter on <a class="reference internal" href="Visualization_Chapter.html#chap-visualization"><span class="std std-ref">Visualization</span></a> for more information on visualizing AMReX datasets, including those with particles.</p>
</div>
<div class="section" id="inputs-parameters">
<h1>Inputs parameters<a class="headerlink" href="#inputs-parameters" title="Permalink to this headline">¶</a></h1>
<p id="sec-particles-parameters">There are several runtime parameters users can set in their <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">inputs</span></span></code> files that control the
behavior of the AMReX particle classes. These are summarized below. They should be preceded by
“particles” in your inputs deck.</p>
<p>The first set of parameters concerns the tiling capability of the ParticleContainer. If you are seeing poor performance
with OpenMP, the first thing to look at is whether there are enough tiles available for each thread to work on.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 61%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>do_tiling</p></td>
<td><p>Whether to use tiling for particles. Should be on when using OpenMP,
and off when running on GPUs.</p></td>
<td><p>Bool</p></td>
<td><p>False</p></td>
</tr>
<tr class="row-odd"><td><p>tile_size</p></td>
<td><p>If tiling is on, the maximum tile_size to in each direction</p></td>
<td><p>Ints</p></td>
<td><p>1024000,8,8</p></td>
</tr>
</tbody>
</table>
<p>The next set concerns runtime parameters that control the particle IO. Parallel file systems tend not to like it when
too many MPI tasks touch the disk at once. Additionally, performance can degrade if all MPI tasks try writing to the
same file, or if too many small files are created. In general, the “correct” values of these parameters will depend on the
size of your problem (i.e., number of boxes, number of MPI tasks), as well as the system you are using. If you are experiencing
problems with particle IO, you could try varying some / all of these parameters.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 61%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>particles_nfiles</p></td>
<td><p>How many files to use when writing particle data to plt directories</p></td>
<td><p>Int</p></td>
<td><p>1024</p></td>
</tr>
<tr class="row-odd"><td><p>nreaders</p></td>
<td><p>How many MPI tasks to use as readers when initializing particles
from binary files.</p></td>
<td><p>Ints</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>nparts_per_read</p></td>
<td><p>How many particles each task should read from said files before
calling Redistribute</p></td>
<td><p>Ints</p></td>
<td><p>100000</p></td>
</tr>
<tr class="row-odd"><td><p>datadigits_read</p></td>
<td><p>This for backwards compatibility, don’t use unless you need to read
and old (pre mid 2017) AMReX dataset.</p></td>
<td><p>Int</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td><p>use_prepost</p></td>
<td><p>This is an optimization for large particle datasets that groups MPI
calls needed during the IO together. Try it seeing poor IO speeds
on large problems.</p></td>
<td><p>Bool</p></td>
<td><p>False</p></td>
</tr>
</tbody>
</table>
<p>The following runtime parameters affect the behavior of virtual particles in Nyx.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 61%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>aggregation_type</p></td>
<td><p>How to create virtual particles from finer levels. The options are:</p>
<p>“None” - don’t do any aggregation.
“Cell” - when creating virtuals, combine all particles that are
in the same cell.</p>
</td>
<td><p>String</p></td>
<td><p>“None”</p></td>
</tr>
<tr class="row-odd"><td><p>aggregation_buffer</p></td>
<td><p>If aggregation on, the number of cells around the coarse/fine
boundary in which no aggregation should be performed.</p></td>
<td><p>Int</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p>Finally, the <cite>amrex.use_gpu_aware_mpi</cite> switch can also affect the behavior of the particle communication routines when
running on GPU platforms like Summit. We recommend leaving it off.</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Particles default to double precision for their real data. To use single precision, compile your code with <code class="docutils literal notranslate"><span class="pre">USE_SINGLE_PRECISION_PARTICLES=TRUE</span></code>.</p>
</dd>
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Note that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">cpu</span></span></code> stores the number of the process the particle was <em>generated</em> on, not the one it’s currently assigned to. This number is set on initialization and never changes, just like the particle <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">id</span></span></code>. In essence, the particles have two integer id numbers, and only the combination of the two is unique. This was done to facilitate the creation of particle initial conditions in parallel.</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Note that for the extra particle components, which component refers to which
variable is an application-specific convention - the particles have 4 extra real comps, but which one is “mass” is up to the user. We suggest using an <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">enum</span></span></code> to keep these indices straight; please see <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Particles/ElectrostaticPIC/ElectrosticParticleContainer.H</span></code> for an example of this.</p>
</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Fortran_Chapter.html" class="btn btn-neutral float-right" title="Fortran Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Particle_Chapter.html" class="btn btn-neutral float-left" title="Particles" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2018, AMReX Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>