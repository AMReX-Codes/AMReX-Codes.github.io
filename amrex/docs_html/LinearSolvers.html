<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MLMG and Linear Operator Classes &mdash; amrex 22.07-dev documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Particles" href="Particle_Chapter.html" />
    <link rel="prev" title="Linear Solvers" href="LinearSolvers_Chapter.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> amrex
          </a>
              <div class="version">
                22.07-dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics_Chapter.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">MLMG and Linear Operator Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#coefficients">Coefficients</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-conditions">Boundary Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-stencils-for-cell-centered-solvers">Boundary Stencils for Cell-Centered Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#curvilinear-coordinates">Curvilinear Coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedded-boundaries">Embedded Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#external-solvers">External Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensor-solve">Tensor Solve</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-component-operators">Multi-Component Operators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Particle_Chapter.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeIntegration_Chapter.html">Time Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Post_Processing_Chapter.html">Post-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Faq.html">Frequently Asked Questions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="LinearSolvers_Chapter.html">Linear Solvers</a> &raquo;</li>
      <li>MLMG and Linear Operator Classes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/LinearSolvers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="mlmg-and-linear-operator-classes">
<h1>MLMG and Linear Operator Classes<a class="headerlink" href="#mlmg-and-linear-operator-classes" title="Permalink to this heading"></a></h1>
<p>Multi-Level Multi-Grid or <code class="docutils literal notranslate"><span class="pre">MLMG</span></code> is a class for solving the linear
system using the geometric multigrid method.  The constructor of
<code class="docutils literal notranslate"><span class="pre">MLMG</span></code> takes the reference to <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLLinOp</span></code>, an abstract base
class of various linear operator
classes, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLABecLaplacian</span></code>, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLPoisson</span></code>,
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLNodeLaplacian</span></code>, etc.  We choose the type of linear operator
class according to the type the linear system to solve.</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLABecLaplacian</span></code> for cell-centered canonical form (equation <a class="reference internal" href="LinearSolvers_Chapter.html#equation-eqn-abeclap">(1)</a>).</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLPoisson</span></code> for cell-centered constant coefficient Poisson’s
equation <span class="math notranslate nohighlight">\(\nabla^2 \phi = f\)</span>.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLNodeLaplacian</span></code> for nodal variable coefficient Poisson’s
equation <span class="math notranslate nohighlight">\(\nabla \cdot (\sigma \nabla \phi) = f\)</span>.</p></li>
</ul>
<p>The constructors of these linear operator classes are in the form like
below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLABecLaplacian</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span> <span class="n">a_grids</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span> <span class="n">a_dmap</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">LPInfo</span><span class="o">&amp;</span> <span class="n">a_info</span> <span class="o">=</span> <span class="n">LPInfo</span><span class="p">(),</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FArrayBox</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_factory</span> <span class="o">=</span> <span class="p">{},</span>
                 <span class="k">const</span> <span class="kt">int</span> <span class="n">a_ncomp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>It takes <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Vectors</span></code> of <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Geometry</span></code>, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">BoxArray</span></code> and
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">DistributionMapping</span></code>.  The arguments are <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Vectors</span></code> because MLMG can
do multi-level composite solves.  If you are using it for single-level,
you can do</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Given Geometry geom, BoxArray grids, and DistributionMapping dmap on single level</span>
<span class="n">MLABecLaplacian</span> <span class="nf">mlabeclaplacian</span><span class="p">({</span><span class="n">geom</span><span class="p">},</span> <span class="p">{</span><span class="n">grids</span><span class="p">},</span> <span class="p">{</span><span class="n">dmap</span><span class="p">});</span>
</pre></div>
</div>
<p>to let the compiler construct <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Vectors</span></code> for you.  Recall that the
classes <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Vector</span></code>, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Geometry</span></code>, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">BoxArray</span></code>, and
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">DistributionMapping</span></code> are defined in chapter <a class="reference internal" href="Basics_Chapter.html#chap-basics"><span class="std std-ref">Basics</span></a>.  There are
two new classes that are optional parameters.  <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LPInfo</span></code> is a
class for passing parameters.  <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">FabFactory</span></code> is used in problems
with embedded boundaries (chapter <a class="reference internal" href="EB_Chapter.html#chap-eb"><span class="std std-ref">Embedded Boundaries</span></a>).</p>
<p>After the linear operator is built, we need to set up boundary
conditions.  This will be discussed later in section
<a class="reference internal" href="#sec-linearsolver-bc"><span class="std std-ref">Boundary Conditions</span></a>.</p>
<section id="coefficients">
<h2>Coefficients<a class="headerlink" href="#coefficients" title="Permalink to this heading"></a></h2>
<p>Next, we consider the coefficients for equation <a class="reference internal" href="LinearSolvers_Chapter.html#equation-eqn-abeclap">(1)</a>.
For <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLPoisson</span></code>, there are no coefficients to set so nothing needs to be done.
For <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLABecLaplacian</span></code>, we need to call member functions <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">setScalars</span></code>,
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">setACoeffs</span></code>, and <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">setBCoeffs</span></code>.
The <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">setScalars</span></code> function sets the scalar constants <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setScalars</span> <span class="p">(</span><span class="n">Real</span> <span class="n">a</span><span class="p">,</span> <span class="n">Real</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>For the general case where
<span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are scalar fields, we use</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setACoeffs</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="k">const</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">setBCoeffs</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">MultiFab</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span> <span class="n">beta</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>For the case where <span class="math notranslate nohighlight">\(\alpha\)</span> and/or <span class="math notranslate nohighlight">\(\beta\)</span> are scalar constants,
there is the option to use</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setACoeffs</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="n">Real</span> <span class="n">alpha</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">setBCoeffs</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="n">Real</span> <span class="n">beta</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">setBCoeffs</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">beta</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Note, however, that the solver behaviour is the same regardless of which functions you
use to set the coefficients. These functions solely copy the constant value(s) to a MultiFab
internal to <code class="docutils literal notranslate"><span class="pre">MLMG</span></code> and so no appreciable efficiency gains can be expected.</p>
<p>For <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLNodeLaplacian</span></code>,
one can set a variable <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">sigma</span></code> with the member function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setSigma</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="k">const</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">a_sigma</span><span class="p">);</span>
</pre></div>
</div>
<p>or a constant <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">sigma</span></code> during declaration or definition</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLNodeLaplacian</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span> <span class="n">a_grids</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span> <span class="n">a_dmap</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">LPInfo</span><span class="o">&amp;</span> <span class="n">a_info</span> <span class="o">=</span> <span class="n">LPInfo</span><span class="p">(),</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FArrayBox</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_factory</span> <span class="o">=</span> <span class="p">{},</span>
                 <span class="n">Real</span>  <span class="n">a_const_sigma</span> <span class="o">=</span> <span class="n">Real</span><span class="p">(</span><span class="mf">0.0</span><span class="p">));</span>

<span class="kt">void</span> <span class="nf">define</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span> <span class="n">a_grids</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span> <span class="n">a_dmap</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">LPInfo</span><span class="o">&amp;</span> <span class="n">a_info</span> <span class="o">=</span> <span class="n">LPInfo</span><span class="p">(),</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FArrayBox</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_factory</span> <span class="o">=</span> <span class="p">{},</span>
             <span class="n">Real</span>  <span class="n">a_const_sigma</span> <span class="o">=</span> <span class="n">Real</span><span class="p">(</span><span class="mf">0.0</span><span class="p">));</span>
</pre></div>
</div>
<p>Here, setting a constant <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">sigma</span></code> alters the internal behavior of the solver making it more
efficient for this special case.</p>
<p>The <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="kt">int</span> <span class="n">amrlev</span></code> parameter should be zero for single-level
solves.  For multi-level solves, each level needs to be provided with
<code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>, or <code class="docutils literal notranslate"><span class="pre">sigma</span></code>.  For composite solves, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">amrlev</span></code> 0 will
mean the lowest level for the solver, which is not necessarily the lowest
level in the AMR hierarchy. This is so solves can be done on different sections
of the AMR hierarchy, e.g. on AMR levels 3 to 5.</p>
<p>After boundary conditions and coefficients are prescribed, the linear
operator is ready for an MLMG object like below.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLMG</span> <span class="nf">mlmg</span><span class="p">(</span><span class="n">mlabeclaplacian</span><span class="p">);</span>
</pre></div>
</div>
<p>Optional parameters can be set (see section <a class="reference internal" href="#sec-linearsolver-pars"><span class="std std-ref">Parameters</span></a>),
and then we can use the <code class="docutils literal notranslate"><span class="pre">MLMG</span></code> member function</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="nf">solve</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*&gt;&amp;</span> <span class="n">a_sol</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_rhs</span><span class="p">,</span>
            <span class="n">Real</span> <span class="n">a_tol_rel</span><span class="p">,</span> <span class="n">Real</span> <span class="n">a_tol_abs</span><span class="p">);</span>
</pre></div>
</div>
<p>to solve the problem given an initial guess and a right-hand side.
Zero is a perfectly fine initial guess.  The two <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Reals</span></code> in the argument
list are the targeted relative and absolute error tolerances. The relative
error tolerance is hard-coded to be at least <span class="math notranslate nohighlight">\(10^{-16}\)</span>.
Given the linear system <span class="math notranslate nohighlight">\(Ax=b\)</span>, the solver will terminate when the
max-norm of the residual (<span class="math notranslate nohighlight">\(b-Ax\)</span>) is less than
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">a_tol_abs</span><span class="p">,</span> <span class="n">a_tol_rel</span><span class="o">*</span><span class="n">max_norm</span><span class="p">)</span></code> where <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">max_norm</span></code>
is the max-norm of the rhs, <span class="math notranslate nohighlight">\(b\)</span>, if the flag <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">always_use_bnorm</span></code> is
set to True or if the rhs max-norm is greater than or equal to the max-norm error
of the initial guess, otherwise <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">max_norm</span></code> is equal to the max-norm error
of the initial guess.  Set the absolute tolerance to zero if one does not have a
good value for it.  The return value of <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">solve</span></code> is the max-norm error.</p>
<p>After the solver returns successfully, if needed, we can call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">compResidual</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*&gt;&amp;</span> <span class="n">a_res</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*&gt;&amp;</span> <span class="n">a_sol</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_rhs</span><span class="p">);</span>
</pre></div>
</div>
<p>to compute residual (i.e., <span class="math notranslate nohighlight">\(f - L(\phi)\)</span>) given the solution and
the right-hand side.  For cell-centered solvers, we can also call the
following functions to compute gradient <span class="math notranslate nohighlight">\(\nabla \phi\)</span> and fluxes
<span class="math notranslate nohighlight">\(-\beta \nabla \phi\)</span>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">getGradSolution</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_grad_sol</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">getFluxes</span>       <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_fluxes</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="boundary-conditions">
<span id="sec-linearsolver-bc"></span><h1>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this heading"></a></h1>
<p>We now discuss how to set up boundary conditions for linear operators.
In the following, physical domain boundaries refer to the boundaries
of the physical domain, whereas coarse/fine boundaries refer to the
boundaries between AMR levels. The following steps must be
followed in the exact order.</p>
<p>1) For any type of solver, we first need to set physical domain boundary types via the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLLinOp</span></code> member
function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setDomainBC</span> <span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">BCType</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span> <span class="n">lobc</span><span class="p">,</span>  <span class="c1">// for lower ends</span>
                  <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">BCType</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span> <span class="n">hibc</span><span class="p">);</span> <span class="c1">// for higher ends</span>
</pre></div>
</div>
<p>The supported BC types at the physical domain boundaries are</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span></code> for periodic boundary.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Dirichlet</span></code> for Dirichlet boundary condition.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Neumann</span></code> for homogeneous Neumann boundary condition.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">inhomogNeumann</span></code> for inhomogeneous Neumann boundary condition.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">reflect_odd</span></code> for reflection with sign changed.</p></li>
</ul>
<p>2) Cell-centered solvers only:
if we want to do a linear solve where the boundary conditions on the
coarsest AMR level of the solve come from a coarser level (e.g. the
base AMR level of the solve is &gt; 0 and does not cover the entire domain),
we must explicitly provide the coarser data.  Boundary conditions from a
coarser level are always Dirichlet.</p>
<p>Note that this step, if needed, must be performed before the step below.
The <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLLinOp</span></code> member function for this step is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setCoarseFineBC</span> <span class="p">(</span><span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">crse</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crse_ratio</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">crse</span></code> contains the Dirichlet boundary
values at the coarse resolution, and <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="kt">int</span> <span class="n">crse_ratio</span></code> (e.g., 2)
is the refinement ratio between the coarsest solver level and the AMR
level below it.  The MultiFab crse does not need to have ghost cells itself.
If the coarse grid bc’s for the solve are identically zero, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="k">nullptr</span></code>
can be passed instead of <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">crse</span></code>.</p>
<p>3) Cell-centered solvers only:
before the solve one must always call the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLLinOp</span></code> member function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setLevelBC</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">levelbcdata</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">robinbc_a</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">robinbc_b</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">robinbc_f</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>If we want to supply an inhomogeneous Dirichlet, inhomogeneous Neumann, or
Robin boundary conditions at the domain boundaries, we must supply those values
in <code class="docutils literal notranslate"><span class="pre">MultiFab*</span> <span class="pre">levelbcdata</span></code>, which must have at least one ghost cell.
Note that the argument <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">amrlev</span></code> is relative to the solve, not
necessarily the full AMR hierarchy; amrlev = 0 refers to the coarsest
level of the solve.</p>
<p>If the boundary condition is Dirichlet the ghost cells outside the
domain boundary of <code class="docutils literal notranslate"><span class="pre">levelbcdata</span></code> must hold the value of the solution
at the domain boundary;
if the boundary condition is Neumann those ghost cells must hold
the value of the gradient of the solution normal to the boundary
(e.g. it would hold dphi/dx on both the low and high faces in the x-direction).</p>
<p>If the boundary conditions contain no inhomogeneous Dirichlet or Neumann boundaries,
we can pass <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="k">nullptr</span></code> instead of a MultiFab.</p>
<p>We can use the solution array itself to hold these values;
the values are copied to internal arrays and will not be over-written
when the solution array itself is being updated by the solver.
Note, however, that this call does not provide an initial guess for the solve.</p>
<p>It should be emphasized that the data in <code class="docutils literal notranslate"><span class="pre">levelbcdata</span></code> for
Dirichlet or Neumann boundaries are assumed to be exactly on the face
of the physical domain; storing these values in the ghost cell of
a cell-centered array is a convenience of implementation.</p>
</section>
<section id="parameters">
<span id="sec-linearsolver-pars"></span><h1>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading"></a></h1>
<p>There are many parameters that can be set.  Here we discuss some
commonly used ones.</p>
<p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLLinOp</span><span class="o">::</span><span class="n">setVerbose</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code>, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">setVerbose</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code> and
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="nl">MLMG</span><span class="p">:</span><span class="n">setBottomVerbose</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code> control the verbosity of the
linear operator, multigrid solver and the bottom solver, respectively.</p>
<p>The multigrid solver is an iterative solver.  The maximal number of
iterations can be changed with <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">setMaxIter</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code>.  We can
also do a fixed number of iterations with
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">setFixedIter</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code>.  By default, V-cycle is used.  We can
use <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">setMaxFmgIter</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code> to control how many full multigrid
cycles can be done before switching to V-cycle.</p>
<p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LPInfo</span><span class="o">::</span><span class="n">setMaxCoarseningLevel</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code> can be used to control the
maximal number of multigrid levels.  We usually should not call this
function.  However, we sometimes build the solver to simply apply the
operator (e.g., <span class="math notranslate nohighlight">\(L(\phi)\)</span>) without needing to solve the system.
We can do something as follows to avoid the cost of building coarsened
operators for the multigrid.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLABecLaplacian</span> <span class="nf">mlabeclap</span><span class="p">({</span><span class="n">geom</span><span class="p">},</span> <span class="p">{</span><span class="n">grids</span><span class="p">},</span> <span class="p">{</span><span class="n">dmap</span><span class="p">},</span> <span class="n">LPInfo</span><span class="p">().</span><span class="n">setMaxCoarseningLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="c1">// set up BC</span>
<span class="c1">// set up coefficients</span>
<span class="n">MLMG</span> <span class="nf">mlmg</span><span class="p">(</span><span class="n">mlabeclap</span><span class="p">);</span>
<span class="c1">// out = L(in)</span>
<span class="n">mlmg</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>  <span class="c1">// here both in and out are const Vector&lt;MultiFab*&gt;&amp;</span>
</pre></div>
</div>
<p>At the bottom of the multigrid cycles, we use a <code class="docutils literal notranslate"><span class="pre">bottom</span> <span class="pre">solver</span></code> which may be
different than the relaxation used at the other levels. The default bottom solver is the
biconjugate gradient stabilized method, but can easily be changed with the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span></code> member method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setBottomSolver</span> <span class="p">(</span><span class="n">BottomSolver</span> <span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>Available choices are</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">BottomSolver</span><span class="o">::</span><span class="n">bicgstab</span></code>: The default.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">BottomSolver</span><span class="o">::</span><span class="n">cg</span></code>: The conjugate gradient method.  The
matrix must be symmetric.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">BottomSolver</span><span class="o">::</span><span class="n">smoother</span></code>: Smoother such as Gauss-Seidel.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">BottomSolver</span><span class="o">::</span><span class="n">bicgcg</span></code>: Start with bicgstab. Switch to cg
if bicgstab fails.  The matrix must be symmetric.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">BottomSolver</span><span class="o">::</span><span class="n">cgbicg</span></code>: Start with cg. Switch to bicgstab
if cg fails.  The matrix must be symmetric.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">BottomSolver</span><span class="o">::</span><span class="n">hypre</span></code>: One of the solvers available through hypre;
see the section below on External Solvers</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span><span class="o">::</span><span class="n">BottomSolver</span><span class="o">::</span><span class="n">petsc</span></code>: Currently for cell-centered only.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LPInfo</span><span class="o">::</span><span class="n">setAgglomeration</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span></code> (by default true) can be used
continue to coarsen the multigrid by copying what would have been the
bottom solver to a new <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span></code> with a new <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">BoxArray</span></code> with
fewer, larger grids, to allow for additional coarsening.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LPInfo</span><span class="o">::</span><span class="n">setConsolidation</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span></code> (by default true) can be used
continue to transfer a multigrid problem to fewer MPI ranks.
There are more setting sucsh as <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LPInfo</span><span class="o">::</span><span class="n">setConsolidationGridSize</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span></code>,
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">consolidation_threshold</span></code>, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">consolidation_ratio</span></code>, and
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">consolidation_strategy</span></code>, to give control over how this process works.</p></li>
</ul>
</section>
<section id="boundary-stencils-for-cell-centered-solvers">
<h1>Boundary Stencils for Cell-Centered Solvers<a class="headerlink" href="#boundary-stencils-for-cell-centered-solvers" title="Permalink to this heading"></a></h1>
<p>We have the option using the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLMG</span></code> member method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setMaxOrder</span> <span class="p">(</span><span class="kt">int</span> <span class="n">maxorder</span><span class="p">);</span>
</pre></div>
</div>
<p>to set the order of the cell-centered linear operator stencil at physical boundaries
with Dirichlet boundary conditions and at coarse-fine boundaries.  In both of these
cases, the boundary value is not defined at the center of the ghost cell.
The order determines the number of interior cells that are used in the extrapolation
of the boundary value from the cell face to the center of the ghost cell, where
the extrapolated value is then used in the regular stencil.  For example,
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">maxorder</span> <span class="o">=</span> <span class="mi">2</span></code> uses the boundary value and the first interior value to extrapolate
to the ghost cell center; <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">maxorder</span> <span class="o">=</span> <span class="mi">3</span></code> uses the boundary value and the first two interior values.</p>
</section>
<section id="curvilinear-coordinates">
<h1>Curvilinear Coordinates<a class="headerlink" href="#curvilinear-coordinates" title="Permalink to this heading"></a></h1>
<p>Some of the linear solvers support curvilinear coordinates including 1D
spherical and 2d cylindrical <span class="math notranslate nohighlight">\((r,z)\)</span>.  In those cases, the
divergence operator has extra metric terms.  If one does not want the
solver to include the metric terms because they have been handled in
other ways, one can turn them off with a setter funtion. For
the cell-centered linear solvers <cite>MLABecLaplacian</cite> and <cite>MLPoisson</cite>, one
can call <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">setMetricTerm</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span></code> with <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="nb">false</span></code>
on the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LPInfo</span></code> object passed to the constructor of linear
operators.
For the node-based <cite>MLNodeLaplacian</cite>, one can call <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">setRZCorrection</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span></code>
with <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="nb">false</span></code> on the <cite>MLNodeLaplacian</cite> object.</p>
<p><cite>MLABecLaplacian</cite> and <cite>MLPoisson</cite> support both spherical and cylindrical
coordinates, while <cite>MLNodeLaplacian</cite> supports only cylindrical at this
time. Note that to use cylindrical coordinates with <cite>MLNodeLaplacian</cite>,
the application code must scale <code class="docutils literal notranslate"><span class="pre">sigma</span></code> by the radial coordinate
before calling <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">setSigma</span><span class="p">()</span></code>.</p>
</section>
<section id="embedded-boundaries">
<h1>Embedded Boundaries<a class="headerlink" href="#embedded-boundaries" title="Permalink to this heading"></a></h1>
<p>AMReX supports multi-level solvers for use with embedded boundaries.
These include
1) cell-centered solvers with homogeneous Neumann, homogeneous Dirichlet,
or inhomogeneous Dirichlet boundary conditions on the EB faces, and
2) nodal solvers with homogeneous Neumann boundary conditions,
or inflow velocity conditions on the EB faces.</p>
<p>To use a cell-centered solver with EB, one builds a linear operator
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLEBABecLap</span></code> with <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBFArrayBoxFactory</span></code> (instead of a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLABecLaplacian</span></code>)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLEBABecLap</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span> <span class="n">a_grids</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span> <span class="n">a_dmap</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">LPInfo</span><span class="o">&amp;</span> <span class="n">a_info</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_factory</span><span class="p">);</span>
</pre></div>
</div>
<p>The usage of this EB-specific class is essentially the same as
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLABecLaplacian</span></code>.</p>
<p>The default boundary condition on EB faces is homogeneous Neumann.</p>
<p>To set homogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBHomogDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">coeff</span><span class="p">);</span>
</pre></div>
</div>
<p>where coeff can be a real number (i.e. the value is the same at every cell)
or is the MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>To set inhomogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">phi_on_eb</span><span class="p">,</span> <span class="n">coeff</span><span class="p">);</span>
</pre></div>
</div>
<p>where phi_on_eb is the MultiFab holding the Dirichlet values in every cut cell,
and coeff again is a real number (i.e. the value is the same at every cell)
or a MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>Currently there are options to define the face-based coefficients on
face centers vs face centroids, and to interpret the solution variable
as being defined on cell centers vs cell centroids.</p>
<p>The default is for the solution variable to be defined at cell centers;
to tell the solver to interpret the solution variable as living
at cell centroids, you must set</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setPhiOnCentroid</span><span class="p">();</span>
</pre></div>
</div>
<p>The default is for the face-based coefficients to be defined at face centers;
to tell the that the face-based coefficients should be interpreted
as living at face centroids, modify the setBCoeffs command to be</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setBCoeffs</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">MLMG</span><span class="o">::</span><span class="n">Location</span><span class="o">::</span><span class="n">FaceCentroid</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="external-solvers">
<h1>External Solvers<a class="headerlink" href="#external-solvers" title="Permalink to this heading"></a></h1>
<p>AMReX provides interfaces to the <a class="reference external" href="https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods">hypre</a> preconditioners and solvers, including BoomerAMG, GMRES (all variants), PCG, and BICGStab as
solvers, and BoomerAMG and Euclid as preconditioners.  These can be called as
as bottom solvers for both cell-centered and node-based problems.</p>
<p>If it is built with Hypre support, AMReX initializes Hypre by default in
<cite>amrex::Initialize</cite>.  If it is built with CUDA, AMReX will also set up Hypre
to run on device by default.  The user can choose to disable the Hypre
initialization by AMReX with <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">ParmParse</span></code> parameter
<code class="docutils literal notranslate"><span class="pre">amrex.init_hypre=[0|1]</span></code>.</p>
<p>By default the AMReX linear solver code always tries to geometrically coarsen the
problem as much as possible.  However, as we have mentioned, we can
call <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">setMaxCoarseningLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></code> on the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">LPInfo</span></code> object
passed to the constructor of a linear operator to disable the
coarsening completely.  In that case the bottom solver is solving the
residual correction form of the original problem. To build Hypre, follow the next steps:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span><span class="o">-</span> <span class="n">git</span> <span class="n">clone</span> <span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/hypre-space/hypre.git</span>
<span class="mf">2.</span><span class="o">-</span> <span class="n">cd</span> <span class="n">hypre</span><span class="o">/</span><span class="n">src</span>
<span class="mf">3.</span><span class="o">-</span> <span class="p">.</span><span class="o">/</span><span class="n">configure</span>
    <span class="p">(</span><span class="k">if</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">build</span> <span class="n">hypre</span> <span class="n">with</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">,</span> <span class="k">do</span> <span class="p">.</span><span class="o">/</span><span class="n">configure</span> <span class="o">--</span><span class="n">enable</span><span class="o">-</span><span class="n">bigint</span> <span class="p">)</span>
<span class="mf">4.</span><span class="o">-</span> <span class="n">make</span> <span class="n">install</span>
<span class="mf">5.</span><span class="o">-</span> <span class="n">Create</span> <span class="n">an</span> <span class="n">environment</span> <span class="n">variable</span> <span class="n">with</span> <span class="n">the</span> <span class="n">HYPRE</span> <span class="n">directory</span> <span class="o">--</span>
    <span class="n">HYPRE_DIR</span><span class="o">=/</span><span class="n">hypre_path</span><span class="o">/</span><span class="n">hypre</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">hypre</span>
</pre></div>
</div>
<p>To use hypre, one must include <code class="docutils literal notranslate"><span class="pre">amrex/Src/Extern/HYPRE</span></code> in the build system.
For examples of using hypre, we refer the reader to
<a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">ABecLaplacian</a> or <a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">NodeTensorLap</a>.</p>
<p>The following parameter should be set to True if the problem to be solved has a singular matrix.
In this case, the solution is only defined to within a constant.  Setting this parameter to True
replaces one row in the matrix sent to hypre from AMReX by a row that sets the value at one cell to 0.</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">adjust_singular_matrix</span></code>:   Default is False.</p></li>
</ul>
<p>The following parameters can be set in the inputs file to control the choice of preconditioner and smoother:</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">hypre_solver</span></code>:   Default is BoomerAMG.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">hypre_preconditioner</span></code>: Default is none;  otherwise the type must be specified.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">recompute_preconditioner</span></code>: Default true.  Option to recompute the preconditioner.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">write_matrix_files</span></code>: Default false.   Option to write out matrix into text files.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">overwrite_existing_matrix_files</span></code>: Default false.   Option to over-write existing matrix files.</p></li>
</ul>
<p>The following parameters can be set in the inputs file to control the BoomerAMG solver specifically:</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_verbose</span></code>: verbosity of BoomerAMG preconditioner. Default 0. See <cite>HYPRE_BoomerAMGSetPrintLevel</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_logging</span></code>: Default 0. See <cite>HYPRE_BoomerAMGSetLogging</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_coarsen_type</span></code>: Default 6.  See <cite>HYPRE_BoomerAMGSetCoarsenType</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_cycle_type</span></code>: Default 1.  See <cite>HYPRE_BoomerAMGSetCycleType</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_relax_type</span></code>: Default 6.  See <cite>HYPRE_BoomerAMGSetRelaxType</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_relax_order</span></code>: Default 1.  See <cite>HYPRE_BoomerAMGSetRelaxOrder</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_num_sweeps</span></code>: Default 2.  See <cite>HYPRE_BoomerAMGSetNumSweeps</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_max_levels</span></code>: Default 20.  See <cite>HYPRE_BoomerAMGSetMaxLevels</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_strong_threshold</span></code>: Default 0.25 for 2D, 0.57 for 3D.  See <cite>HYPRE_BoomerAMGSetStrongThreshold</cite></p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">hypre</span><span class="p">.</span><span class="n">bamg_interp_type</span></code>:  Default 0.  See <cite>HYPRE_BoomerAMGSetInterpType</cite></p></li>
</ul>
<p>The user is referred to the
<a class="reference external" href="https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods">hypre</a> Hypre Reference Manual for full details on the usage of the parameters described briefly above.</p>
<p>AMReX can also use <a class="reference external" href="https://www.mcs.anl.gov/petsc/">PETSc</a> as a bottom solver for cell-centered
problems. To build PETSc, follow the next steps:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span><span class="o">-</span> <span class="n">git</span> <span class="n">clone</span> <span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/petsc/petsc.git</span>
<span class="mf">2.</span><span class="o">-</span> <span class="n">cd</span> <span class="n">petsc</span>
<span class="mf">3.</span><span class="o">-</span> <span class="p">.</span><span class="o">/</span><span class="n">configure</span> <span class="o">--</span><span class="n">download</span><span class="o">-</span><span class="n">hypre</span><span class="o">=</span><span class="n">yes</span> <span class="o">--</span><span class="n">prefix</span><span class="o">=</span><span class="n">build_dir</span>
<span class="mf">4.</span><span class="o">-</span> <span class="n">Follow</span> <span class="n">the</span> <span class="n">steps</span> <span class="n">given</span> <span class="n">by</span> <span class="n">petsc</span>
<span class="mf">5.</span><span class="o">-</span> <span class="n">Create</span> <span class="n">an</span> <span class="n">environment</span> <span class="n">variable</span> <span class="n">with</span> <span class="n">the</span> <span class="n">PETSC</span> <span class="n">directory</span> <span class="o">--</span>
    <span class="n">PETSC_DIR</span><span class="o">=/</span><span class="n">petsc_path</span><span class="o">/</span><span class="n">petsc</span><span class="o">/</span><span class="n">build_dir</span>
</pre></div>
</div>
<p>To use PETSc, one must include <code class="docutils literal notranslate"><span class="pre">amrex/Src/Extern/PETSc</span></code>
in the build system.  For an example of using PETSc, we refer the
reader to the tutorial, <a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">ABecLaplacian</a>.</p>
</section>
<section id="tensor-solve">
<h1>Tensor Solve<a class="headerlink" href="#tensor-solve" title="Permalink to this heading"></a></h1>
<p>Application codes that solve the Navier-Stokes equations need to evaluate
the viscous term;  solving for this term implicitly requires a multi-component
solve with cross terms.  Because this is a commonly used motif, we provide
a tensor solve for cell-centered velocity components.</p>
<p>Consider a velocity field <span class="math notranslate nohighlight">\(U = (u,v,w)\)</span> with all
components co-located on cell centers.  The viscous term can be written in vector form as</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot (\eta \nabla U) + \nabla \cdot (\eta (\nabla U)^T ) + \nabla \cdot ( (\kappa - \frac{2}{3} \eta) (\nabla \cdot U) )\]</div>
<p>and in 3-d Cartesian component form as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}( (\eta u_x)_x + (\eta u_y)_y + (\eta u_z)_z ) + ( (\eta u_x)_x + (\eta v_x)_y + (\eta w_x)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_x\\( (\eta v_x)_x + (\eta v_y)_y + (\eta v_z)_z ) + ( (\eta u_y)_x + (\eta v_y)_y + (\eta w_y)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_y\\( (\eta w_x)_x + (\eta w_y)_y + (\eta w_z)_z ) + ( (\eta u_z)_x + (\eta v_z)_y + (\eta w_z)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_z\end{aligned}\end{align} \]</div>
<p>Here <span class="math notranslate nohighlight">\(\eta\)</span> is the dynamic viscosity and <span class="math notranslate nohighlight">\(\kappa\)</span> is the bulk viscosity.</p>
<p>We evaluate the following terms from the above using the <code class="docutils literal notranslate"><span class="pre">MLABecLaplacian</span></code> and <code class="docutils literal notranslate"><span class="pre">MLEBABecLaplacian</span></code> operators;</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}( (\frac{4}{3} \eta + \kappa) u_x)_x + (              \eta           u_y)_y + (\eta u_z)_z\\              (\eta           v_x)_x + ( (\frac{4}{3} \eta + \kappa) v_y)_y + (\eta v_z)_z\\ (\eta w_x)_x                        + (              \eta           w_y)_y + ( (\frac{4}{3} \eta + \kappa) w_z)_z\end{aligned}\end{align} \]</div>
<p>the following cross-terms are evaluated separately using the <code class="docutils literal notranslate"><span class="pre">MLTensorOp</span></code> and <code class="docutils literal notranslate"><span class="pre">MLEBTensorOp</span></code> operators.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}( (\kappa - \frac{2}{3} \eta) (v_y + w_z) )_x + (\eta v_x)_y  + (\eta w_x)_z\\(\eta u_y)_x + ( (\kappa - \frac{2}{3} \eta) (u_x + w_z) )_y  + (\eta w_y)_z\\(\eta u_z)_x + (\eta v_z)_y - ( (\kappa - \frac{2}{3} \eta) (u_x + v_y) )_z\end{aligned}\end{align} \]</div>
<p>The code below is an example of how to set up the solver to compute the
viscous term <cite>divtau</cite> explicitly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">domain</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Domain</span><span class="p">());</span>

<span class="c1">// Set BCs for Poisson solver in bc_lo, bc_hi</span>
<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// First define the operator &quot;ebtensorop&quot;</span>
<span class="c1">// Note we call LPInfo().setMaxCoarseningLevel(0) because we are only applying the operator,</span>
<span class="c1">//      not doing an implicit solve</span>
<span class="c1">//</span>
<span class="c1">//       (alpha * a - beta * (del dot b grad)) sol</span>
<span class="c1">//</span>
<span class="c1">// LPInfo                       info;</span>
<span class="n">MLEBTensorOp</span> <span class="n">ebtensorop</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="n">LPInfo</span><span class="p">().</span><span class="n">setMaxCoarseningLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                        <span class="n">amrex</span><span class="o">::</span><span class="n">GetVecOfConstPtrs</span><span class="p">(</span><span class="n">ebfactory</span><span class="p">));</span>

<span class="c1">// It is essential that we set MaxOrder of the solver to 2</span>
<span class="c1">// if we want to use the standard sol(i)-sol(i-1) approximation</span>
<span class="c1">// for the gradient at Dirichlet boundaries.</span>
<span class="c1">// The solver&#39;s default order is 3 and this uses three points for the</span>
<span class="c1">// gradient at a Dirichlet boundary.</span>
<span class="n">ebtensorop</span><span class="p">.</span><span class="n">setMaxOrder</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// LinOpBCType Definitions are in amrex/Src/Boundary/AMReX_LO_BCTYPES.H</span>
<span class="n">ebtensorop</span><span class="p">.</span><span class="n">setDomainBC</span> <span class="p">(</span> <span class="p">{(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_lo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_lo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_lo</span><span class="p">[</span><span class="mi">2</span><span class="p">]},</span>
                         <span class="p">{(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_hi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_hi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_hi</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">);</span>

<span class="c1">// Return div (eta grad)) phi</span>
<span class="n">ebtensorop</span><span class="p">.</span><span class="n">setScalars</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>

<span class="n">amrex</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">amrex</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">amrex</span><span class="o">::</span><span class="n">MultiFab</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">max_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">// Compute the coefficients</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lev</span> <span class="o">&lt;</span> <span class="n">nlev</span><span class="p">;</span> <span class="n">lev</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// We average eta onto faces</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="n">dir</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">BoxArray</span> <span class="n">edge_ba</span> <span class="o">=</span> <span class="n">grids</span><span class="p">[</span><span class="n">lev</span><span class="p">];</span>
        <span class="n">edge_ba</span><span class="p">.</span><span class="n">surroundingNodes</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">][</span><span class="n">dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge_ba</span><span class="p">,</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nghost</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="o">*</span><span class="n">ebfactory</span><span class="p">[</span><span class="n">lev</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">average_cellcenter_to_face</span><span class="p">(</span> <span class="n">GetArrOfPtrs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">]),</span> <span class="o">*</span><span class="n">etan</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">]</span> <span class="p">);</span>

    <span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">periodicity</span><span class="p">());</span>
    <span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">periodicity</span><span class="p">());</span>
    <span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">periodicity</span><span class="p">());</span>

    <span class="n">ebtensorop</span><span class="p">.</span><span class="n">setShearViscosity</span>  <span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">GetArrOfConstPtrs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">]));</span>
    <span class="n">ebtensorop</span><span class="p">.</span><span class="n">setEBShearViscosity</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">eta</span><span class="p">[</span><span class="n">lev</span><span class="p">]));</span>

    <span class="n">ebtensorop</span><span class="p">.</span><span class="n">setLevelBC</span> <span class="p">(</span> <span class="n">lev</span><span class="p">,</span> <span class="n">GetVecOfConstPtrs</span><span class="p">(</span><span class="n">vel</span><span class="p">)[</span><span class="n">lev</span><span class="p">]</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">MLMG</span> <span class="n">solver</span><span class="p">(</span><span class="n">ebtensorop</span><span class="p">);</span>

<span class="n">solver</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">GetVecOfPtrs</span><span class="p">(</span><span class="n">divtau</span><span class="p">),</span> <span class="n">GetVecOfPtrs</span><span class="p">(</span><span class="n">vel</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="multi-component-operators">
<h1>Multi-Component Operators<a class="headerlink" href="#multi-component-operators" title="Permalink to this heading"></a></h1>
<p>This section discusses solving linear systems in which the solution variable <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span> has multiple components.
An example (implemented in the <code class="docutils literal notranslate"><span class="pre">MultiComponent</span></code> tutorial) might be:</p>
<div class="math notranslate nohighlight">
\[D(\mathbf{\phi})_i = \sum_{i=1}^N \alpha_{ij} \nabla^2 \phi_j\]</div>
<p>(Note: only operators of the form <span class="math notranslate nohighlight">\(D:\mathbb{R}^n\to\mathbb{R}^n\)</span> are currently allowed.)</p>
<ul>
<li><p>To implement a multi-component <em>cell-based</em> operator, inherit from the <code class="docutils literal notranslate"><span class="pre">MLCellLinOp</span></code> class.
Override the <code class="docutils literal notranslate"><span class="pre">getNComp</span></code> function to return the number of components (<code class="docutils literal notranslate"><span class="pre">N</span></code>)that the operator will use.
The solution and rhs fabs must also have at least one ghost node.
<code class="docutils literal notranslate"><span class="pre">Fapply</span></code>, <code class="docutils literal notranslate"><span class="pre">Fsmooth</span></code>, <code class="docutils literal notranslate"><span class="pre">Fflux</span></code> must be implemented such that the solution and rhs fabs all have <code class="docutils literal notranslate"><span class="pre">N</span></code> components.</p></li>
<li><p>Implementing a multi-component <em>node-based</em> operator is slightly different.
A MC nodal operator must specify that the reflux-free coarse/fine strategy is being used by the solver.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="p">.</span><span class="n">setCFStrategy</span><span class="p">(</span><span class="n">MLMG</span><span class="o">::</span><span class="n">CFStrategy</span><span class="o">::</span><span class="n">ghostnodes</span><span class="p">);</span>
</pre></div>
</div>
<p>The reflux-free method circumvents the need to implement a special <code class="docutils literal notranslate"><span class="pre">reflux</span></code> at the coarse-fine boundary.
This is accomplished by using ghost nodes.
Each AMR level must have 2 layers of ghost nodes.
The second (outermost) layer of nodes is treated as constant by the relaxation, essentially acting as a Dirichlet boundary.
The first layer of nodes is evolved using the relaxation, in the same manner as the rest of the solution.
When the residual is restricted onto the coarse level (in <code class="docutils literal notranslate"><span class="pre">reflux</span></code>) this allows the residual at the coarse-fine boundary to be interpolated using the first layer of ghost nodes.
<a class="reference internal" href="#fig-refluxfreecoarsefine"><span class="std std-numref">Fig. 7</span></a> illustrates the how the coarse-fine update takes place.</p>
<figure class="align-center" id="id2">
<span id="fig-refluxfreecoarsefine"></span><a class="reference internal image-reference" href="_images/refluxfreecoarsefine.png"><img alt="_images/refluxfreecoarsefine.png" src="_images/refluxfreecoarsefine.png" style="height: 4cm;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">Reflux-free coarse-fine boundary update.
Level 2 ghost nodes (small dark blue) are interpolated from coarse boundary.
Level 1 ghost nodes are updated during the relaxation along with all the other interior fine nodes.
Coarse nodes (large blue) on the coarse/fine boundary are updated by restricting with interior nodes
and the first level of ghost nodes.
Coarse nodes underneath level 2 ghost nodes are not updated.
The remaining coarse nodes are updates by restriction.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The MC nodal operator can inherit from the <code class="docutils literal notranslate"><span class="pre">MCNodeLinOp</span></code> class.
<code class="docutils literal notranslate"><span class="pre">Fapply</span></code>, <code class="docutils literal notranslate"><span class="pre">Fsmooth</span></code>, and <code class="docutils literal notranslate"><span class="pre">Fflux</span></code> must update level 1 ghost nodes that are inside the domain.
<cite>interpolation</cite> and <cite>restriction</cite> can be implemented as usual.
<cite>reflux</cite> is a straightforward restriction from fine to coarse, using level 1 ghost nodes for restriction as described above.</p>
</li>
</ul>
<p>See <code class="docutils literal notranslate"><span class="pre">amrex-tutorials/ExampleCodes/LinearSolvers/MultiComponent</span></code> for a complete working example.</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="LinearSolvers_Chapter.html" class="btn btn-neutral float-left" title="Linear Solvers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Particle_Chapter.html" class="btn btn-neutral float-right" title="Particles" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2018, AMReX Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>