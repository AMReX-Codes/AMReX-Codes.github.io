<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MLMG and Linear Operator Classes &mdash; amrex 21.10-dev documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Particles" href="Particle_Chapter.html" />
    <link rel="prev" title="Linear Solvers" href="LinearSolvers_Chapter.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> amrex
          </a>
              <div class="version">
                21.10-dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics_Chapter.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">MLMG and Linear Operator Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-conditions">Boundary Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boundary-stencils-for-cell-centered-solvers">Boundary Stencils for Cell-Centered Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#curvilinear-coordinates">Curvilinear Coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedded-boundaries">Embedded Boundaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#external-solvers">External Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mac-projection">MAC Projection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nodal-projection">Nodal Projection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensor-solve">Tensor Solve</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-component-operators">Multi-Component Operators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Particle_Chapter.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Post_Processing_Chapter.html">Post-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="LinearSolvers_Chapter.html">Linear Solvers</a> &raquo;</li>
      <li>MLMG and Linear Operator Classes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/LinearSolvers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="mlmg-and-linear-operator-classes">
<h1>MLMG and Linear Operator Classes<a class="headerlink" href="#mlmg-and-linear-operator-classes" title="Permalink to this headline"></a></h1>
<p>Multi-Level Multi-Grid or <code class="docutils literal notranslate"><span class="pre">MLMG</span></code> is a class for solving the linear
system using the geometric multigrid method.  The constructor of
<code class="docutils literal notranslate"><span class="pre">MLMG</span></code> takes the reference to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLLinOp</span></span></code>, an abstract base
class of various linear operator
classes, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLPoisson</span></span></code>,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLNodeLaplacian</span></span></code>, etc.  We choose the type of linear operator
class according to the type the linear system to solve.</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code> for cell-centered canonical form (equation <a class="reference internal" href="LinearSolvers_Chapter.html#equation-eqn-abeclap">(1)</a>).</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLPoisson</span></span></code> for cell-centered constant coefficient Poisson’s
equation <span class="math notranslate nohighlight">\(\nabla^2 \phi = f\)</span>.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLNodeLaplacian</span></span></code> for nodal variable coefficient Poisson’s
equation <span class="math notranslate nohighlight">\(\nabla \cdot (\sigma \nabla \phi) = f\)</span>.</p></li>
</ul>
<p>The constructors of these linear operator classes are in the form like
below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLABecLaplacian</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span> <span class="n">a_grids</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span> <span class="n">a_dmap</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">LPInfo</span><span class="o">&amp;</span> <span class="n">a_info</span> <span class="o">=</span> <span class="n">LPInfo</span><span class="p">(),</span>
                 <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FArrayBox</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_factory</span> <span class="o">=</span> <span class="p">{});</span>
</pre></div>
</div>
<p>It takes <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vectors</span></span></code> of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>.  The arguments are <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vectors</span></span></code> because MLMG can
do multi-level composite solve.  If you are using it for single-level,
you can do</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Given Geometry geom, BoxArray grids, and DistributionMapping dmap on single level</span>
<span class="n">MLABecLaplacian</span> <span class="nf">mlabeclaplacian</span><span class="p">({</span><span class="n">geom</span><span class="p">},</span> <span class="p">{</span><span class="n">grids</span><span class="p">},</span> <span class="p">{</span><span class="n">dmap</span><span class="p">});</span>
</pre></div>
</div>
<p>to let the compiler construct <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vectors</span></span></code> for you.  Recall that the
classes <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code>, and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> are defined in chapter <a class="reference internal" href="Basics_Chapter.html#chap-basics"><span class="std std-ref">Basics</span></a>.  There are
two new classes that are optional parameters.  <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LPInfo</span></span></code> is a
class for passing parameters.  <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabFactory</span></span></code> is used in problems
with embedded boundaries (chapter <a class="reference internal" href="EB_Chapter.html#chap-eb"><span class="std std-ref">Embedded Boundaries</span></a>).</p>
<p>After the linear operator is built, we need to set up boundary
conditions.  This will be discussed later in section
<a class="reference internal" href="#sec-linearsolver-bc"><span class="std std-ref">Boundary Conditions</span></a>.</p>
<p>For <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code>, we next need to call member functions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setScalars</span> <span class="p">(</span><span class="n">Real</span> <span class="n">A</span><span class="p">,</span> <span class="n">Real</span> <span class="n">B</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">setACoeffs</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="k">const</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">setBCoeffs</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">MultiFab</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span> <span class="n">beta</span><span class="p">);</span>
</pre></div>
</div>
<p>to set up the coefficients for equation <a class="reference internal" href="LinearSolvers_Chapter.html#equation-eqn-abeclap">(1)</a>. This is unnecessary for
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLPoisson</span></span></code>, as there are no coefficients to set.  For <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLNodeLaplacian</span></span></code>,
one needs to call the member function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setSigma</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="k">const</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">a_sigma</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">amrlev</span></span></code> parameter should be zero for single-level
solves.  For multi-level solves, each level needs to be provided with
<code class="docutils literal notranslate"><span class="pre">alpha</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>, or <code class="docutils literal notranslate"><span class="pre">sigma</span></code>.  For composite solves, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrlev</span></span></code> 0 will
mean the lowest level for the solver, which is not necessarily the lowest
level in the AMR hierarchy. This is so solves can be done on different sections
of the AMR hierarchy, e.g. on AMR levels 3 to 5.</p>
<p>After boundary conditions and coefficients are prescribed, the linear
operator is ready for an MLMG object like below.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLMG</span> <span class="nf">mlmg</span><span class="p">(</span><span class="n">mlabeclaplacian</span><span class="p">);</span>
</pre></div>
</div>
<p>Optional parameters can be set (see section <a class="reference internal" href="#sec-linearsolver-pars"><span class="std std-ref">Parameters</span></a>),
and then we can use the <code class="docutils literal notranslate"><span class="pre">MLMG</span></code> member function</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="nf">solve</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*&gt;&amp;</span> <span class="n">a_sol</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_rhs</span><span class="p">,</span>
            <span class="n">Real</span> <span class="n">a_tol_rel</span><span class="p">,</span> <span class="n">Real</span> <span class="n">a_tol_abs</span><span class="p">);</span>
</pre></div>
</div>
<p>to solve the problem given an initial guess and a right-hand side.
Zero is a perfectly fine initial guess.  The two <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Reals</span></span></code> in the argument
list are the targeted relative and absolute error tolerances.
The solver will terminate when one of these targets is met.
Set the absolute tolerance to zero if one
does not have a good value for it.  The return value of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">solve</span></span></code>
is the max-norm error.</p>
<p>After the solver returns successfully, if needed, we can call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">compResidual</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*&gt;&amp;</span> <span class="n">a_res</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*&gt;&amp;</span> <span class="n">a_sol</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">MultiFab</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_rhs</span><span class="p">);</span>
</pre></div>
</div>
<p>to compute residual (i.e., <span class="math notranslate nohighlight">\(f - L(\phi)\)</span>) given the solution and
the right-hand side.  For cell-centered solvers, we can also call the
following functions to compute gradient <span class="math notranslate nohighlight">\(\nabla \phi\)</span> and fluxes
<span class="math notranslate nohighlight">\(-B \nabla \phi\)</span>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">getGradSolution</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_grad_sol</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">getFluxes</span>       <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">a_fluxes</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="boundary-conditions">
<span id="sec-linearsolver-bc"></span><h1>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline"></a></h1>
<p>We now discuss how to set up boundary conditions for linear operators.
In the following, physical domain boundaries refer to the boundaries
of the physical domain, whereas coarse/fine boundaries refer to the
boundaries between AMR levels. The following steps must be
followed in the exact order.</p>
<p>1) For any type of solver, we first need to set physical domain boundary types via the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLLinOp</span></span></code> member
function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setDomainBC</span> <span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">BCType</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span> <span class="n">lobc</span><span class="p">,</span>  <span class="c1">// for lower ends</span>
                  <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">BCType</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span> <span class="n">hibc</span><span class="p">);</span> <span class="c1">// for higher ends</span>
</pre></div>
</div>
<p>The supported BC types at the physical domain boundaries are</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LinOpBCType</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Periodic</span></span></code> for periodic boundary.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LinOpBCType</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Dirichlet</span></span></code> for Dirichlet boundary condition.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LinOpBCType</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Neumann</span></span></code> for homogeneous Neumann boundary condition.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LinOpBCType</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">inhomogNeumann</span></span></code> for inhomogeneous Neumann boundary condition.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LinOpBCType</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">reflect_odd</span></span></code> for reflection with sign changed.</p></li>
</ul>
<p>2) Cell-centered solvers only:
if we want to do a linear solve where the boundary conditions on the
coarsest AMR level of the solve come from a coarser level (e.g. the
base AMR level of the solve is &gt; 0 and does not cover the entire domain),
we must explicitly provide the coarser data.  Boundary conditions from a
coarser level are always Dirichlet.</p>
<p>Note that this step, if needed, must be performed before the step below.
The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLLinOp</span></span></code> member function for this step is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setCoarseFineBC</span> <span class="p">(</span><span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">crse</span><span class="p">,</span> <span class="kt">int</span> <span class="n">crse_ratio</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">const</span></span> <span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">*</span></span> <span class="name"><span class="pre">crse</span></span></code> contains the Dirichlet boundary
values at the coarse resolution, and <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">crse_ratio</span></span></code> (e.g., 2)
is the refinement ratio between the coarsest solver level and the AMR
level below it.  The MultiFab crse does not need to have ghost cells itself.
If the coarse grid bc’s for the solve are identically zero, <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">nullptr</span></span></code>
can be passed instead of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">crse</span></span></code>.</p>
<p>3) Cell-centered solvers only:
before the solve one must always call the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLLinOp</span></span></code> member function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setLevelBC</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amrlev</span><span class="p">,</span> <span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">levelbcdata</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">robinbc_a</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">robinbc_b</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">MultiFab</span><span class="o">*</span> <span class="n">robinbc_f</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>If we want to supply an inhomogeneous Dirichlet, inhomogeneous Neumann, or
Robin boundary conditions at the domain boundaries, we must supply those values
in <code class="docutils literal notranslate"><span class="pre">MultiFab*</span> <span class="pre">levelbcdata</span></code>, which must have at least one ghost cell.
Note that the argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrlev</span></span></code> is relative to the solve, not
necessarily the full AMR hierarchy; amrlev = 0 refers to the coarsest
level of the solve.</p>
<p>If the boundary condition is Dirichlet the ghost cells outside the
domain boundary of <code class="docutils literal notranslate"><span class="pre">levelbcdata</span></code> must hold the value of the solution
at the domain boundary;
if the boundary condition is Neumann those ghost cells must hold
the value of the gradient of the solution normal to the boundary
(e.g. it would hold dphi/dx on both the low and high faces in the x-direction).</p>
<p>If the boundary conditions contain no inhomogeneous Dirichlet or Neumann boundaries,
we can pass <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">nullptr</span></span></code> instead of a MultiFab.</p>
<p>We can use the solution array itself to hold these values;
the values are copied to internal arrays and will not be over-written
when the solution array itself is being updated by the solver.
Note, however, that this call does not provide an initial guess for the solve.</p>
<p>It should be emphasized that the data in <code class="docutils literal notranslate"><span class="pre">levelbcdata</span></code> for
Dirichlet or Neumann boundaries are assumed to be exactly on the face
of the physical domain; storing these values in the ghost cell of
a cell-centered array is a convenience of implementation.</p>
</div>
<div class="section" id="parameters">
<span id="sec-linearsolver-pars"></span><h1>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline"></a></h1>
<p>There are many parameters that can be set.  Here we discuss some
commonly used ones.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLLinOp</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setVerbose</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">)</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setVerbose</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">)</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name label"><span class="pre">MLMG</span></span><span class="punctuation"><span class="pre">:</span></span><span class="name"><span class="pre">setBottomVerbose</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">)</span></span></code> control the verbosity of the
linear operator, multigrid solver and the bottom solver, respectively.</p>
<p>The multigrid solver is an iterative solver.  The maximal number of
iterations can be changed with <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setMaxIter</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">)</span></span></code>.  We can
also do a fixed number of iterations with
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setFixedIter</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">)</span></span></code>.  By default, V-cycle is used.  We can
use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setMaxFmgIter</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">)</span></span></code> to control how many full multigrid
cycles can be done before switching to V-cycle.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LPInfo</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setMaxCoarseningLevel</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">)</span></span></code> can be used to control the
maximal number of multigrid levels.  We usually should not call this
function.  However, we sometimes build the solver to simply apply the
operator (e.g., <span class="math notranslate nohighlight">\(L(\phi)\)</span>) without needing to solve the system.
We can do something as follows to avoid the cost of building coarsened
operators for the multigrid.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLABecLaplacian</span> <span class="nf">mlabeclap</span><span class="p">({</span><span class="n">geom</span><span class="p">},</span> <span class="p">{</span><span class="n">grids</span><span class="p">},</span> <span class="p">{</span><span class="n">dmap</span><span class="p">},</span> <span class="n">LPInfo</span><span class="p">().</span><span class="n">setMaxCoarseningLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="c1">// set up BC</span>
<span class="c1">// set up coefficients</span>
<span class="n">MLMG</span> <span class="nf">mlmg</span><span class="p">(</span><span class="n">mlabeclap</span><span class="p">);</span>
<span class="c1">// out = L(in)</span>
<span class="n">mlmg</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>  <span class="c1">// here both in and out are const Vector&lt;MultiFab*&gt;&amp;</span>
</pre></div>
</div>
<p>At the bottom of the multigrid cycles, we use a <code class="docutils literal notranslate"><span class="pre">bottom</span> <span class="pre">solver</span></code> which may be
different than the relaxation used at the other levels. The default bottom solver is the
biconjugate gradient stabilized method, but can easily be changed with the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span></code> member method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setBottomSolver</span> <span class="p">(</span><span class="n">BottomSolver</span> <span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>Available choices are</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">BottomSolver</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">bicgstab</span></span></code>: The default.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">BottomSolver</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">cg</span></span></code>: The conjugate gradient method.  The
matrix must be symmetric.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">BottomSolver</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">smoother</span></span></code>: Smoother such as Gauss-Seidel.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">BottomSolver</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">bicgcg</span></span></code>: Start with bicgstab. Switch to cg
if bicgstab fails.  The matrix must be symmetric.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">BottomSolver</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">cgbicg</span></span></code>: Start with cg. Switch to bicgstab
if cg fails.  The matrix must be symmetric.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">BottomSolver</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">hypre</span></span></code>: One of the solvers available through hypre;
see the section below on External Solvers</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">BottomSolver</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">petsc</span></span></code>: Currently for cell-centered only.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LPInfo</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setAgglomeration</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">bool</span></span><span class="punctuation"><span class="pre">)</span></span></code> (by default true) can be used
continue to coarsen the multigrid by copying what would have been the
bottom solver to a new <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> with a new <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> with
fewer, larger grids, to allow for additional coarsening.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LPInfo</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setConsolidation</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">bool</span></span><span class="punctuation"><span class="pre">)</span></span></code> (by default true) can be used
continue to transfer a multigrid problem to fewer MPI ranks.
There are more setting sucsh as <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LPInfo</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">setConsolidationGridSize</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">int</span></span><span class="punctuation"><span class="pre">)</span></span></code>,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">consolidation_threshold</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">consolidation_ratio</span></span></code>, and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">consolidation_strategy</span></span></code>, to give control over how this process works.</p></li>
</ul>
</div>
<div class="section" id="boundary-stencils-for-cell-centered-solvers">
<h1>Boundary Stencils for Cell-Centered Solvers<a class="headerlink" href="#boundary-stencils-for-cell-centered-solvers" title="Permalink to this headline"></a></h1>
<p>We have the option using the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLMG</span></span></code> member method</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setMaxOrder</span> <span class="p">(</span><span class="kt">int</span> <span class="n">maxorder</span><span class="p">);</span>
</pre></div>
</div>
<p>to set the order of the cell-centered linear operator stencil at physical boundaries
with Dirichlet boundary conditions and at coarse-fine boundaries.  In both of these
cases, the boundary value is not defined at the center of the ghost cell.
The order determines the number of interior cells that are used in the extrapolation
of the boundary value from the cell face to the center of the ghost cell, where
the extrapolated value is then used in the regular stencil.  For example,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">maxorder</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">2</span></span></code> uses the boundary value and the first interior value to extrapolate
to the ghost cell center; <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">maxorder</span></span> <span class="operator"><span class="pre">=</span></span> <span class="literal number integer"><span class="pre">3</span></span></code> uses the boundary value and the first two interior values.</p>
</div>
<div class="section" id="curvilinear-coordinates">
<h1>Curvilinear Coordinates<a class="headerlink" href="#curvilinear-coordinates" title="Permalink to this headline"></a></h1>
<p>The linear solvers support curvilinear coordinates including 1D
spherical and 2d cylindrical <span class="math notranslate nohighlight">\((r,z)\)</span>.  In those cases, the
divergence operator has extra metric terms.  If one does not want the
solver to include the metric terms because they have been handled in
other ways, one can call <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">setMetricTerm</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">bool</span></span><span class="punctuation"><span class="pre">)</span></span></code> with <code class="code cpp c++ docutils literal notranslate"><span class="name builtin"><span class="pre">false</span></span></code>
on the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LPInfo</span></span></code> object passed to the constructor of linear
operators.</p>
</div>
<div class="section" id="embedded-boundaries">
<h1>Embedded Boundaries<a class="headerlink" href="#embedded-boundaries" title="Permalink to this headline"></a></h1>
<p>AMReX supports multi-level solvers for use with embedded boundaries.
These include
1) cell-centered solvers with homogeneous Neumann, homogeneous Dirichlet,
or inhomogeneous Dirichlet boundary conditions on the EB faces, and
2) nodal solvers with homogeneous Neumann boundary conditions on the EB faces.</p>
<p>To use a cell-centered solver with EB, one builds a linear operator
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLEBABecLap</span></span></code> with <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> (instead of a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code>)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLEBABecLap</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span> <span class="n">a_grids</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span> <span class="n">a_dmap</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">LPInfo</span><span class="o">&amp;</span> <span class="n">a_info</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_factory</span><span class="p">);</span>
</pre></div>
</div>
<p>The usage of this EB-specific class is essentially the same as
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code>.</p>
<p>The default boundary condition on EB faces is homogeneous Neumann.</p>
<p>To set homogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBHomogDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">coeff</span><span class="p">);</span>
</pre></div>
</div>
<p>where coeff can be a real number (i.e. the value is the same at every cell)
or is the MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>To set inhomogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">phi_on_eb</span><span class="p">,</span> <span class="n">coeff</span><span class="p">);</span>
</pre></div>
</div>
<p>where phi_on_eb is the MultiFab holding the Dirichlet values in every cut cell,
and coeff again is a real number (i.e. the value is the same at every cell)
or a MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>Currently there are options to define the face-based coefficients on
face centers vs face centroids, and to interpret the solution variable
as being defined on cell centers vs cell centroids.</p>
<p>The default is for the solution variable to be defined at cell centers;
to tell the solver to interpret the solution variable as living
at cell centroids, you must set</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setPhiOnCentroid</span><span class="p">();</span>
</pre></div>
</div>
<p>The default is for the face-based coefficients to be defined at face centers;
to tell the that the face-based coefficients should be interpreted
as living at face centroids, modify the setBCoeffs command to be</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setBCoeffs</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">MLMG</span><span class="o">::</span><span class="n">Location</span><span class="o">::</span><span class="n">FaceCentroid</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="external-solvers">
<h1>External Solvers<a class="headerlink" href="#external-solvers" title="Permalink to this headline"></a></h1>
<p>AMReX provides interfaces to the <a class="reference external" href="https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods">hypre</a> preconditioners and solvers, including BoomerAMG, GMRES (all variants), PCG, and BICGStab as
solvers, and BoomerAMG and Euclid as preconditioners.  These can be called as
as bottom solvers for both cell-centered and node-based problems.</p>
<p>If it is built with Hypre support, AMReX initializes Hypre by default in
<cite>amrex::Initialize</cite>.  If it is built with CUDA, AMReX will also set up Hypre
to run on device by default.  The user can choose to disable the Hypre
initialization by AMReX with <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> parameter
<code class="docutils literal notranslate"><span class="pre">amrex.init_hypre=[0|1]</span></code>.</p>
<p>By default the AMReX linear solver code always tries to geometrically coarsen the
problem as much as possible.  However, as we have mentioned, we can
call <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">setMaxCoarseningLevel</span></span><span class="punctuation"><span class="pre">(</span></span><span class="literal number integer"><span class="pre">0</span></span><span class="punctuation"><span class="pre">)</span></span></code> on the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LPInfo</span></span></code> object
passed to the constructor of a linear operator to disable the
coarsening completely.  In that case the bottom solver is solving the
residual correction form of the original problem. To build Hypre, follow the next steps:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span><span class="o">-</span> <span class="n">git</span> <span class="n">clone</span> <span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/hypre-space/hypre.git</span>
<span class="mf">2.</span><span class="o">-</span> <span class="n">cd</span> <span class="n">hypre</span><span class="o">/</span><span class="n">src</span>
<span class="mf">3.</span><span class="o">-</span> <span class="p">.</span><span class="o">/</span><span class="n">configure</span>
    <span class="p">(</span><span class="k">if</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">build</span> <span class="n">hypre</span> <span class="n">with</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">,</span> <span class="k">do</span> <span class="p">.</span><span class="o">/</span><span class="n">configure</span> <span class="o">--</span><span class="n">enable</span><span class="o">-</span><span class="n">bigint</span> <span class="p">)</span>
<span class="mf">4.</span><span class="o">-</span> <span class="n">make</span> <span class="n">install</span>
<span class="mf">5.</span><span class="o">-</span> <span class="n">Create</span> <span class="n">an</span> <span class="n">environment</span> <span class="n">variable</span> <span class="n">with</span> <span class="n">the</span> <span class="n">HYPRE</span> <span class="n">directory</span> <span class="o">--</span>
    <span class="n">HYPRE_DIR</span><span class="o">=/</span><span class="n">hypre_path</span><span class="o">/</span><span class="n">hypre</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">hypre</span>
</pre></div>
</div>
<p>To use hypre, one must include <code class="docutils literal notranslate"><span class="pre">amrex/Src/Extern/HYPRE</span></code> in the build system.
For examples of using hypre, we refer the reader to
<a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">ABecLaplacian</a> or <a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">Nodal Projection EB</a>.</p>
<p>The following parameter should be set to True if the problem to be solved has a singular matrix.
In this case, the solution is only defined to within a constant.  Setting this parameter to True
replaces one row in the matrix sent to hypre from AMReX by a row that sets the value at one cell to 0.</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">adjust_singular_matrix</span></span></code>:   Default is False.</p></li>
</ul>
<p>The following parameters can be set in the inputs file to control the choice of preconditioner and smoother:</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">hypre_solver</span></span></code>:   Default is BoomerAMG.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">hypre_preconditioner</span></span></code>: Default is none;  otherwise the type must be specified.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">recompute_preconditioner</span></span></code>: Default true.  Option to recompute the preconditioner.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">write_matrix_files</span></span></code>: Default false.   Option to write out matrix into text files.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">overwrite_existing_matrix_files</span></span></code>: Default false.   Option to over-write existing matrix files.</p></li>
</ul>
<p>The following parameters can be set in the inputs file to control the BoomerAMG solver specifically:</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_verbose</span></span></code>: verbosity of BoomerAMG preconditioner. Default 0. See <cite>HYPRE_BoomerAMGSetPrintLevel</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_logging</span></span></code>: Default 0. See <cite>HYPRE_BoomerAMGSetLogging</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_coarsen_type</span></span></code>: Default 6.  See <cite>HYPRE_BoomerAMGSetCoarsenType</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_cycle_type</span></span></code>: Default 1.  See <cite>HYPRE_BoomerAMGSetCycleType</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_relax_type</span></span></code>: Default 6.  See <cite>HYPRE_BoomerAMGSetRelaxType</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_relax_order</span></span></code>: Default 1.  See <cite>HYPRE_BoomerAMGSetRelaxOrder</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_num_sweeps</span></span></code>: Default 2.  See <cite>HYPRE_BoomerAMGSetNumSweeps</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_max_levels</span></span></code>: Default 20.  See <cite>HYPRE_BoomerAMGSetMaxLevels</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_strong_threshold</span></span></code>: Default 0.25 for 2D, 0.57 for 3D.  See <cite>HYPRE_BoomerAMGSetStrongThreshold</cite></p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">hypre</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">bamg_interp_type</span></span></code>:  Default 0.  See <cite>HYPRE_BoomerAMGSetInterpType</cite></p></li>
</ul>
<p>The user is referred to the
<a class="reference external" href="https://computing.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods">hypre</a> Hypre Reference Manual for full details on the usage of the parameters described briefly above.</p>
<p>AMReX can also use <a class="reference external" href="https://www.mcs.anl.gov/petsc/">PETSc</a> as a bottom solver for cell-centered
problems. To build PETSc, follow the next steps:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span><span class="o">-</span> <span class="n">git</span> <span class="n">clone</span> <span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/petsc/petsc.git</span>
<span class="mf">2.</span><span class="o">-</span> <span class="n">cd</span> <span class="n">petsc</span>
<span class="mf">3.</span><span class="o">-</span> <span class="p">.</span><span class="o">/</span><span class="n">configure</span> <span class="o">--</span><span class="n">download</span><span class="o">-</span><span class="n">hypre</span><span class="o">=</span><span class="n">yes</span> <span class="o">--</span><span class="n">prefix</span><span class="o">=</span><span class="n">build_dir</span>
<span class="mf">4.</span><span class="o">-</span> <span class="n">Follow</span> <span class="n">the</span> <span class="n">steps</span> <span class="n">given</span> <span class="n">by</span> <span class="n">petsc</span>
<span class="mf">5.</span><span class="o">-</span> <span class="n">Create</span> <span class="n">an</span> <span class="n">environment</span> <span class="n">variable</span> <span class="n">with</span> <span class="n">the</span> <span class="n">PETSC</span> <span class="n">directory</span> <span class="o">--</span>
    <span class="n">PETSC_DIR</span><span class="o">=/</span><span class="n">petsc_path</span><span class="o">/</span><span class="n">petsc</span><span class="o">/</span><span class="n">build_dir</span>
</pre></div>
</div>
<p>To use PETSc, one must include <code class="docutils literal notranslate"><span class="pre">amrex/Src/Extern/PETSc</span></code>
in the build system.  For an example of using PETSc, we refer the
reader to the tutorial, <a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">ABecLaplacian</a>.</p>
</div>
<div class="section" id="mac-projection">
<h1>MAC Projection<a class="headerlink" href="#mac-projection" title="Permalink to this headline"></a></h1>
<p>Some codes define a velocity field <span class="math notranslate nohighlight">\(U = (u,v,w)\)</span> on faces, i.e.
<span class="math notranslate nohighlight">\(u\)</span> is defined on x-faces, <span class="math notranslate nohighlight">\(v\)</span> is defined on y-faces,
and <span class="math notranslate nohighlight">\(w\)</span> is defined on z-faces.   We refer to the exact projection
of this velocity field as a MAC projection, in which we solve</p>
<div class="math notranslate nohighlight">
\[D( \beta \nabla \phi) = D(U^*) - S\]</div>
<p>for <span class="math notranslate nohighlight">\(\phi\)</span> and then set</p>
<div class="math notranslate nohighlight">
\[U = U^* - \beta \nabla \phi\]</div>
<p>where <span class="math notranslate nohighlight">\(U^*\)</span> is a vector field (typically velocity) that we want to satisfy
<span class="math notranslate nohighlight">\(D(U) = S\)</span>.  For incompressible flow,  <span class="math notranslate nohighlight">\(S = 0\)</span>.</p>
<p>The MacProjection class can be defined and used to perform the MAC projection without explicitly
calling the solver directly.  In addition to solving the variable coefficient Poisson equation,
the MacProjector internally computes the divergence of the vector field, <span class="math notranslate nohighlight">\(D(U^*)\)</span>,
to compute the right-hand-side, and after the solve, subtracts the weighted gradient term to
make the vector field result satisfy the divergence constraint.</p>
<p>In the simplest form of the call, <span class="math notranslate nohighlight">\(S\)</span> is assumed to be zero and does not need to be specified.
Typically, the user does not allocate the solution array, but it is also possible to create and pass
in the solution array and have <span class="math notranslate nohighlight">\(\phi\)</span> returned as well as <span class="math notranslate nohighlight">\(U\)</span>.</p>
<p>Caveat:  Currently the MAC projection only works when the base level covers the full domain; it does
not yet have the interface to pass boundary conditions for a fine level that come from coarser data.</p>
<p>Also note that any Dirichlet or Neumann boundary conditions at domain boundaries
are assumed to be homogeneous.  The call to the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLLinOp</span></span></code> member function
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">setLevelBC</span></span></code> occurs inside the MacProjection class; one does not need to call that
explicitly when using the MacProjection class.</p>
<p>The code below is taken from the file
<code class="docutils literal notranslate"><span class="pre">Tutorials/LinearSolvers/MAC_Projection_EB/main.cpp</span></code> in <a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">MAC Projection EB</a> and demonstrates how to set up
the MACProjector object and use it to perform a MAC projection.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBFArrayBoxFactory</span> <span class="nf">factory</span><span class="p">(</span><span class="n">eb_level</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="n">ng_ebs</span><span class="p">,</span> <span class="n">ebs</span><span class="p">);</span>

<span class="c1">// allocate face-centered velocities and face-centered beta coefficient</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idim</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="o">++</span><span class="n">idim</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vel</span><span class="p">[</span><span class="n">idim</span><span class="p">].</span><span class="n">define</span> <span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span><span class="n">IntVect</span><span class="o">::</span><span class="n">TheDimensionVector</span><span class="p">(</span><span class="n">idim</span><span class="p">)),</span> <span class="n">dmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>
    <span class="n">beta</span><span class="p">[</span><span class="n">idim</span><span class="p">].</span><span class="n">define</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span><span class="n">IntVect</span><span class="o">::</span><span class="n">TheDimensionVector</span><span class="p">(</span><span class="n">idim</span><span class="p">)),</span> <span class="n">dmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>
    <span class="n">beta</span><span class="p">[</span><span class="n">idim</span><span class="p">].</span><span class="n">setVal</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>  <span class="c1">// set beta to 1</span>
<span class="p">}</span>

<span class="c1">// If we want to use phi elsewhere, we must create an array in which to return the solution</span>
<span class="c1">// MultiFab phi_inout(grids, dmap, 1, 1, MFInfo(), factory);</span>

<span class="c1">// If we want to supply a non-zero S we must allocate and fill it outside the solver</span>
<span class="c1">// MultiFab S(grids, dmap, 1, 0, MFInfo(), factory);</span>
<span class="c1">// Set S here ...</span>

<span class="c1">// set initial velocity to U=(1,0,0)</span>
<span class="n">AMREX_D_TERM</span><span class="p">(</span><span class="n">vel</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">setVal</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);,</span>
             <span class="n">vel</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);,</span>
             <span class="n">vel</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">););</span>

<span class="n">LPInfo</span> <span class="n">lp_info</span><span class="p">;</span>

<span class="c1">// If we want to use hypre to solve the full problem we do not need to coarsen the GMG stencils</span>
<span class="k">if</span> <span class="p">(</span><span class="n">use_hypre_as_full_solver</span><span class="p">)</span>
    <span class="n">lp_info</span><span class="p">.</span><span class="n">setMaxCoarseningLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">MacProjector</span> <span class="nf">macproj</span><span class="p">({</span><span class="n">amrex</span><span class="o">::</span><span class="n">GetArrOfPtrs</span><span class="p">(</span><span class="n">vel</span><span class="p">)},</span>       <span class="c1">// face-based velocity</span>
                     <span class="p">{</span><span class="n">amrex</span><span class="o">::</span><span class="n">GetArrOfConstPtrs</span><span class="p">(</span><span class="n">beta</span><span class="p">)},</span> <span class="c1">// beta</span>
                     <span class="p">{</span><span class="n">geom</span><span class="p">},</span>                           <span class="c1">// the geometry object</span>
                     <span class="n">lp_info</span><span class="p">);</span>                         <span class="c1">// structure for passing info to the operator</span>

<span class="c1">// Here we specify the desired divergence S</span>
<span class="c1">// MacProjector macproj({amrex::GetArrOfPtrs(vel)},       // face-based velocity</span>
<span class="c1">//                      {amrex::GetArrOfConstPtrs(beta)}, // beta</span>
<span class="c1">//                      {geom},                           // the geometry object</span>
<span class="c1">//                      lp_info,                          // structure for passing info to the operator</span>
<span class="c1">//                      {&amp;S});                            // defines the specified RHS divergence</span>

<span class="c1">// Set bottom-solver to use hypre instead of native BiCGStab</span>
<span class="k">if</span> <span class="p">(</span><span class="n">use_hypre_as_full_solver</span> <span class="o">||</span> <span class="n">use_hypre_as_bottom_solver</span><span class="p">)</span>
   <span class="n">macproj</span><span class="p">.</span><span class="n">setBottomSolver</span><span class="p">(</span><span class="n">MLMG</span><span class="o">::</span><span class="n">BottomSolver</span><span class="o">::</span><span class="n">hypre</span><span class="p">);</span>

<span class="c1">// Set boundary conditions.</span>
<span class="c1">//  Here we use Neumann on the low x-face, Dirichlet on the high x-face,</span>
<span class="c1">//  and periodic in the other two directions</span>
<span class="c1">//  (the first argument is for the low end, the second is for the high end)</span>
<span class="c1">// Note that Dirichlet and Neumann boundary conditions are assumed to be homogeneous.</span>
<span class="n">macproj</span><span class="p">.</span><span class="n">setDomainBC</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Neumann</span><span class="p">,</span>
                                  <span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span><span class="p">,</span>
                                  <span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span><span class="p">)},</span>
                    <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Dirichlet</span><span class="p">,</span>
                                  <span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span><span class="p">,</span>
                                  <span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span><span class="p">)});</span>

<span class="n">macproj</span><span class="p">.</span><span class="n">setVerbose</span><span class="p">(</span><span class="n">mg_verbose</span><span class="p">);</span>
<span class="n">macproj</span><span class="p">.</span><span class="n">setBottomVerbose</span><span class="p">(</span><span class="n">bottom_verbose</span><span class="p">);</span>

<span class="c1">// Define the relative tolerance</span>
<span class="n">Real</span> <span class="n">reltol</span> <span class="o">=</span> <span class="mf">1.e-8</span><span class="p">;</span>

<span class="c1">// Define the absolute tolerance; note that this argument is optional</span>
<span class="n">Real</span> <span class="n">abstol</span> <span class="o">=</span> <span class="mf">1.e-15</span><span class="p">;</span>

<span class="c1">// Solve for phi and subtract from the velocity to make it divergence-free</span>
<span class="c1">// Note that when we build with USE_EB = TRUE, we must specify whether the velocities live</span>
<span class="c1">//  at face centers (MLMG::Location::FaceCenter) or face centroids (MLMG::Location::FaceCentroid)</span>
<span class="n">macproj</span><span class="p">.</span><span class="n">project</span><span class="p">(</span><span class="n">reltol</span><span class="p">,</span><span class="n">abstol</span><span class="p">,</span><span class="n">MLMG</span><span class="o">::</span><span class="n">Location</span><span class="o">::</span><span class="n">FaceCenter</span><span class="p">);</span>

<span class="c1">// If we want to use phi elsewhere, we can pass in an array in which to return the solution</span>
<span class="c1">// macproj.project({&amp;phi_inout},reltol,abstol,MLMG::Location::FaceCenter);</span>
</pre></div>
</div>
<p>See the <a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">MAC Projection EB</a> tutorial for the complete working example.</p>
</div>
<div class="section" id="nodal-projection">
<h1>Nodal Projection<a class="headerlink" href="#nodal-projection" title="Permalink to this headline"></a></h1>
<p>Some codes define a velocity field <span class="math notranslate nohighlight">\(U = (u,v,w)\)</span> with all
components co-located on cell centers.  The nodal solver in AMReX
can be used to compute an approximate projection of the cell-centered
velocity field, with pressure and velocity divergence defined on nodes.
When we use the nodal solver this way, and subtract only the cell average
of the gradient from the velocity, it is effectively an approximate projection.</p>
<p>As with the MAC projection, consider that we want to solve</p>
<div class="math notranslate nohighlight">
\[D( \beta \nabla \phi) = D(U^*) - S\]</div>
<p>for <span class="math notranslate nohighlight">\(\phi\)</span> and then set</p>
<div class="math notranslate nohighlight">
\[U = U^* - \beta \nabla \phi\]</div>
<p>where <span class="math notranslate nohighlight">\(U^*\)</span> is a vector field defined on cell centers and we want to satisfy
<span class="math notranslate nohighlight">\(D(U) = S\)</span>.  For incompressible flow,  <span class="math notranslate nohighlight">\(S = 0\)</span>.</p>
<p>Currently this nodal approximate projection does not exist in a separate
operator like the MAC projection; instead we demonstrate below the steps needed
to compute the approximate projection.  This means we must compute explicitly the
right-hand-side , including the the divergence of the vector field, <span class="math notranslate nohighlight">\(D(U^*)\)</span>,
solve the variable coefficient Poisson equation, then subtract the weighted
gradient term to make the vector field result satisfy the divergence constraint.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Given a cell-centered velocity (vel) field, a cell-centered</span>
<span class="c1">// scalar field (sigma) field, and a source term S (either node-</span>
<span class="c1">// or cell-centered )solve:</span>
<span class="c1">//</span>
<span class="c1">//   div( sigma * grad(phi) ) = div(vel) - S</span>
<span class="c1">//</span>
<span class="c1">// and then perform the projection:</span>
<span class="c1">//</span>
<span class="c1">//     vel = vel - sigma * grad(phi)</span>
<span class="c1">//</span>

<span class="c1">//</span>
<span class="c1">// Create the EB factory</span>
<span class="c1">//</span>
<span class="n">EBFArrayBoxFactory</span> <span class="nf">factory</span><span class="p">(</span><span class="n">eb_level</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="n">ng_ebs</span><span class="p">,</span> <span class="n">ebs</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">//  Create the cell-centered velocity field we want to project</span>
<span class="c1">//</span>
<span class="n">MultiFab</span> <span class="nf">vel</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="n">AMREX_SPACEDIM</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>

<span class="c1">// Set velocity field to (1,0,0) including ghost cells for this example</span>
<span class="n">vel</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">vel</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">AMREX_SPACEDIM</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Setup linear operator, AKA the nodal Laplacian</span>
<span class="c1">//</span>
<span class="n">LPInfo</span> <span class="n">lp_info</span><span class="p">;</span>

<span class="c1">// If we want to use hypre to solve the full problem we do not need to coarsen the GMG stencils</span>
<span class="c1">// if (use_hypre_as_full_solver)</span>
<span class="c1">//     lp_info.setMaxCoarseningLevel(0);</span>

<span class="n">MLNodeLaplacian</span> <span class="nf">matrix</span><span class="p">({</span><span class="n">geom</span><span class="p">},</span> <span class="p">{</span><span class="n">grids</span><span class="p">},</span> <span class="p">{</span><span class="n">dmap</span><span class="p">},</span> <span class="n">lp_info</span><span class="p">,</span>
                       <span class="n">Vector</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">{</span><span class="o">&amp;</span><span class="n">factory</span><span class="p">});</span>

<span class="c1">// Set boundary conditions.</span>
<span class="c1">// Here we use Neumann on the low x-face, Dirichlet on the high x-face,</span>
<span class="c1">// and periodic in the other two directions</span>
<span class="c1">// (the first argument is for the low end, the second is for the high end)</span>
<span class="c1">// Note that Dirichlet boundary conditions are assumed to be homogeneous (i.e. phi = 0)</span>
<span class="n">matrix</span><span class="p">.</span><span class="n">setDomainBC</span><span class="p">({</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Neumann</span><span class="p">,</span>
                                 <span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span><span class="p">,</span>
                                 <span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span><span class="p">)},</span>
                   <span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Dirichlet</span><span class="p">,</span>
                                 <span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span><span class="p">,</span>
                                 <span class="n">LinOpBCType</span><span class="o">::</span><span class="n">Periodic</span><span class="p">)});</span>

<span class="c1">// Set matrix attributes to be used by MLMG solver</span>
<span class="n">matrix</span><span class="p">.</span><span class="n">setGaussSeidel</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">matrix</span><span class="p">.</span><span class="n">setHarmonicAverage</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Compute RHS</span>
<span class="c1">//</span>
<span class="c1">// NOTE: it&#39;s up to the user to compute the RHS. as opposed</span>
<span class="c1">//       to the MAC projection case !!!</span>
<span class="c1">//</span>
<span class="c1">// NOTE: do this operation AFTER setting up the linear operator so</span>
<span class="c1">//       that compRHS method can be used</span>
<span class="c1">//</span>

<span class="c1">// RHS is nodal</span>
<span class="k">const</span> <span class="n">BoxArray</span> <span class="o">&amp;</span> <span class="n">nd_grids</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">IntVect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span> <span class="c1">// nodal grids</span>

<span class="c1">// MultiFab to host RHS</span>
<span class="n">MultiFab</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">nd_grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>

<span class="c1">// Cell-centered contributions to RHS</span>
<span class="n">MultiFab</span> <span class="nf">S_cc</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>
<span class="n">S_cc</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Set it to zero for this example</span>

<span class="c1">// Node-centered contributions to RHS</span>
<span class="n">MultiFab</span> <span class="nf">S_nd</span><span class="p">(</span><span class="n">nd_grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>
<span class="n">S_nd</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Set it to zero for this example</span>

<span class="c1">// Compute RHS -- vel must be cell-centered</span>
<span class="n">matrix</span><span class="p">.</span><span class="n">compRHS</span><span class="p">({</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">},</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">vel</span><span class="p">},</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">S_nd</span><span class="p">},</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">S_cc</span><span class="p">});</span>

<span class="c1">//</span>
<span class="c1">// Create the cell-centered sigma field and set it to 1 for this example</span>
<span class="c1">//</span>
<span class="n">MultiFab</span> <span class="nf">sigma</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>
<span class="n">sigma</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

<span class="c1">// Set sigma</span>
<span class="n">matrix</span><span class="p">.</span><span class="n">setSigma</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Create node-centered phi</span>
<span class="c1">//</span>
<span class="n">MultiFab</span> <span class="nf">phi</span><span class="p">(</span><span class="n">nd_grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>
<span class="n">phi</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Setup MLMG solver</span>
<span class="c1">//</span>
<span class="n">MLMG</span> <span class="nf">nodal_solver</span><span class="p">(</span><span class="n">matrix</span><span class="p">);</span>

<span class="c1">// We can specify the maximum number of iterations</span>
<span class="n">nodal_solver</span><span class="p">.</span><span class="n">setMaxIter</span><span class="p">(</span><span class="n">mg_maxiter</span><span class="p">);</span>
<span class="n">nodal_solver</span><span class="p">.</span><span class="n">setBottomMaxIter</span><span class="p">(</span><span class="n">mg_bottom_maxiter</span><span class="p">);</span>

<span class="n">nodal_solver</span><span class="p">.</span><span class="n">setVerbose</span><span class="p">(</span><span class="n">mg_verbose</span><span class="p">);</span>
<span class="n">nodal_solver</span><span class="p">.</span><span class="n">setBottomVerbose</span><span class="p">(</span><span class="n">mg_bottom_verbose</span><span class="p">);</span>

<span class="c1">// Set bottom-solver to use hypre instead of native BiCGStab</span>
<span class="c1">//   ( we could also have set this to cg, bicgcg, cgbicg)</span>
<span class="c1">// if (use_hypre_as_full_solver || use_hypre_as_bottom_solver)</span>
<span class="c1">//     nodal_solver.setBottomSolver(MLMG::BottomSolver::hypre);</span>

<span class="c1">// Define the relative tolerance</span>
<span class="n">Real</span> <span class="n">reltol</span> <span class="o">=</span> <span class="mf">1.e-8</span><span class="p">;</span>

<span class="c1">// Define the absolute tolerance; note that this argument is optional</span>
<span class="n">Real</span> <span class="n">abstol</span> <span class="o">=</span> <span class="mf">1.e-15</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Solve div( sigma * grad(phi) ) = RHS</span>
<span class="c1">//</span>
<span class="n">nodal_solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">phi</span><span class="p">},</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">},</span> <span class="n">reltol</span><span class="p">,</span> <span class="n">abstol</span><span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Create cell-centered MultiFab to hold value of -sigma*grad(phi) at cell-centers</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="n">MultiFab</span> <span class="nf">fluxes</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="n">AMREX_SPACEDIM</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="n">factory</span><span class="p">);</span>
<span class="n">fluxes</span><span class="p">.</span><span class="n">setVal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

<span class="c1">// Get fluxes from solver</span>
<span class="n">nodal_solver</span><span class="p">.</span><span class="n">getFluxes</span><span class="p">(</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">fluxes</span><span class="p">}</span> <span class="p">);</span>

<span class="c1">//</span>
<span class="c1">// Apply projection explicitly --  vel = vel - sigma * grad(phi)</span>
<span class="c1">//</span>
<span class="n">MultiFab</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span> <span class="o">*</span><span class="n">vel</span><span class="p">,</span> <span class="o">*</span><span class="n">fluxes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">AMREX_SPACEDIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>See the <a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/LinearSolvers_Tutorial.html">Nodal Projection EB</a> tutorial for the complete working example.</p>
</div>
<div class="section" id="tensor-solve">
<h1>Tensor Solve<a class="headerlink" href="#tensor-solve" title="Permalink to this headline"></a></h1>
<p>Application codes that solve the Navier-Stokes equations need to evaluate
the viscous term;  solving for this term implicitly requires a multi-component
solve with cross terms.  Because this is a commonly used motif, we provide
a tensor solve for cell-centered velocity components.</p>
<p>Consider a velocity field <span class="math notranslate nohighlight">\(U = (u,v,w)\)</span> with all
components co-located on cell centers.  The viscous term can be written in vector form as</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot (\eta \nabla U) + \nabla \cdot (\eta (\nabla U)^T ) + \nabla \cdot ( (\kappa - \frac{2}{3} \eta) (\nabla \cdot U) )\]</div>
<p>and in 3-d Cartesian component form as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}( (\eta u_x)_x + (\eta u_y)_y + (\eta u_z)_z ) + ( (\eta u_x)_x + (\eta v_x)_y + (\eta w_x)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_x\\( (\eta v_x)_x + (\eta v_y)_y + (\eta v_z)_z ) + ( (\eta u_y)_x + (\eta v_y)_y + (\eta w_y)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_y\\( (\eta w_x)_x + (\eta w_y)_y + (\eta w_z)_z ) + ( (\eta u_z)_x + (\eta v_z)_y + (\eta w_z)_z ) +  ( (\kappa - \frac{2}{3} \eta) (u_x+v_y+w_z) )_z\end{aligned}\end{align} \]</div>
<p>Here <span class="math notranslate nohighlight">\(\eta\)</span> is the dynamic viscosity and <span class="math notranslate nohighlight">\(\kappa\)</span> is the bulk viscosity.</p>
<p>We evaluate the following terms from the above using the <code class="docutils literal notranslate"><span class="pre">MLABecLaplacian</span></code> and <code class="docutils literal notranslate"><span class="pre">MLEBABecLaplacian</span></code> operators;</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}( (\frac{4}{3} \eta + \kappa) u_x)_x + (              \eta           u_y)_y + (\eta u_z)_z\\              (\eta           v_x)_x + ( (\frac{4}{3} \eta + \kappa) v_y)_y + (\eta v_z)_z\\ (\eta w_x)_x                        + (              \eta           w_y)_y + ( (\frac{4}{3} \eta + \kappa) w_z)_z\end{aligned}\end{align} \]</div>
<p>the following cross-terms are evaluated separately using the <code class="docutils literal notranslate"><span class="pre">MLTensorOp</span></code> and <code class="docutils literal notranslate"><span class="pre">MLEBTensorOp</span></code> operators.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}( (\kappa - \frac{2}{3} \eta) (v_y + w_z) )_x + (\eta v_x)_y  + (\eta w_x)_z\\(\eta u_y)_x + ( (\kappa - \frac{2}{3} \eta) (u_x + w_z) )_y  + (\eta w_y)_z\\(\eta u_z)_x + (\eta v_z)_y - ( (\kappa - \frac{2}{3} \eta) (u_x + v_y) )_z\end{aligned}\end{align} \]</div>
<p>The code below is an example of how to set up the solver to compute the
viscous term <cite>divtau</cite> explicitly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span> <span class="nf">domain</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Domain</span><span class="p">());</span>

<span class="c1">// Set BCs for Poisson solver in bc_lo, bc_hi</span>
<span class="p">...</span>

<span class="c1">//</span>
<span class="c1">// First define the operator &quot;ebtensorop&quot;</span>
<span class="c1">// Note we call LPInfo().setMaxCoarseningLevel(0) because we are only applying the operator,</span>
<span class="c1">//      not doing an implicit solve</span>
<span class="c1">//</span>
<span class="c1">//       (alpha * a - beta * (del dot b grad)) sol</span>
<span class="c1">//</span>
<span class="c1">// LPInfo                       info;</span>
<span class="n">MLEBTensorOp</span> <span class="n">ebtensorop</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">dmap</span><span class="p">,</span> <span class="n">LPInfo</span><span class="p">().</span><span class="n">setMaxCoarseningLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                        <span class="n">amrex</span><span class="o">::</span><span class="n">GetVecOfConstPtrs</span><span class="p">(</span><span class="n">ebfactory</span><span class="p">));</span>

<span class="c1">// It is essential that we set MaxOrder of the solver to 2</span>
<span class="c1">// if we want to use the standard sol(i)-sol(i-1) approximation</span>
<span class="c1">// for the gradient at Dirichlet boundaries.</span>
<span class="c1">// The solver&#39;s default order is 3 and this uses three points for the</span>
<span class="c1">// gradient at a Dirichlet boundary.</span>
<span class="n">ebtensorop</span><span class="p">.</span><span class="n">setMaxOrder</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// LinOpBCType Definitions are in amrex/Src/Boundary/AMReX_LO_BCTYPES.H</span>
<span class="n">ebtensorop</span><span class="p">.</span><span class="n">setDomainBC</span> <span class="p">(</span> <span class="p">{(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_lo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_lo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_lo</span><span class="p">[</span><span class="mi">2</span><span class="p">]},</span>
                         <span class="p">{(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_hi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_hi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">LinOpBCType</span><span class="p">)</span><span class="n">bc_hi</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">);</span>

<span class="c1">// Return div (eta grad)) phi</span>
<span class="n">ebtensorop</span><span class="p">.</span><span class="n">setScalars</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>

<span class="n">amrex</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">amrex</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">amrex</span><span class="o">::</span><span class="n">MultiFab</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">max_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">// Compute the coefficients</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lev</span> <span class="o">&lt;</span> <span class="n">nlev</span><span class="p">;</span> <span class="n">lev</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// We average eta onto faces</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="n">AMREX_SPACEDIM</span><span class="p">;</span> <span class="n">dir</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">BoxArray</span> <span class="n">edge_ba</span> <span class="o">=</span> <span class="n">grids</span><span class="p">[</span><span class="n">lev</span><span class="p">];</span>
        <span class="n">edge_ba</span><span class="p">.</span><span class="n">surroundingNodes</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">][</span><span class="n">dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge_ba</span><span class="p">,</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nghost</span><span class="p">,</span> <span class="n">MFInfo</span><span class="p">(),</span> <span class="o">*</span><span class="n">ebfactory</span><span class="p">[</span><span class="n">lev</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">average_cellcenter_to_face</span><span class="p">(</span> <span class="n">GetArrOfPtrs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">]),</span> <span class="o">*</span><span class="n">etan</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">]</span> <span class="p">);</span>

    <span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">periodicity</span><span class="p">());</span>
    <span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">periodicity</span><span class="p">());</span>
    <span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">FillBoundary</span><span class="p">(</span><span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">periodicity</span><span class="p">());</span>

    <span class="n">ebtensorop</span><span class="p">.</span><span class="n">setShearViscosity</span>  <span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">GetArrOfConstPtrs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">lev</span><span class="p">]));</span>
    <span class="n">ebtensorop</span><span class="p">.</span><span class="n">setEBShearViscosity</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">eta</span><span class="p">[</span><span class="n">lev</span><span class="p">]));</span>

    <span class="n">ebtensorop</span><span class="p">.</span><span class="n">setLevelBC</span> <span class="p">(</span> <span class="n">lev</span><span class="p">,</span> <span class="n">GetVecOfConstPtrs</span><span class="p">(</span><span class="n">vel</span><span class="p">)[</span><span class="n">lev</span><span class="p">]</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">MLMG</span> <span class="n">solver</span><span class="p">(</span><span class="n">ebtensorop</span><span class="p">);</span>

<span class="n">solver</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">GetVecOfPtrs</span><span class="p">(</span><span class="n">divtau</span><span class="p">),</span> <span class="n">GetVecOfPtrs</span><span class="p">(</span><span class="n">vel</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="multi-component-operators">
<h1>Multi-Component Operators<a class="headerlink" href="#multi-component-operators" title="Permalink to this headline"></a></h1>
<p>This section discusses solving linear systems in which the solution variable <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span> has multiple components.
An example (implemented in the <code class="docutils literal notranslate"><span class="pre">MultiComponent</span></code> tutorial) might be:</p>
<div class="math notranslate nohighlight">
\[D(\mathbf{\phi})_i = \sum_{i=1}^N \alpha_{ij} \nabla^2 \phi_j\]</div>
<p>(Note: only operators of the form <span class="math notranslate nohighlight">\(D:\mathbb{R}^n\to\mathbb{R}^n\)</span> are currently allowed.)</p>
<ul>
<li><p>To implement a multi-component <em>cell-based</em> operator, inherit from the <code class="docutils literal notranslate"><span class="pre">MLCellLinOp</span></code> class.
Override the <code class="docutils literal notranslate"><span class="pre">getNComp</span></code> function to return the number of components (<code class="docutils literal notranslate"><span class="pre">N</span></code>)that the operator will use.
The solution and rhs fabs must also have at least one ghost node.
<code class="docutils literal notranslate"><span class="pre">Fapply</span></code>, <code class="docutils literal notranslate"><span class="pre">Fsmooth</span></code>, <code class="docutils literal notranslate"><span class="pre">Fflux</span></code> must be implemented such that the solution and rhs fabs all have <code class="docutils literal notranslate"><span class="pre">N</span></code> components.</p></li>
<li><p>Implementing a multi-component <em>node-based</em> operator is slightly different.
A MC nodal operator must specify that the reflux-free coarse/fine strategy is being used by the solver.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="p">.</span><span class="n">setCFStrategy</span><span class="p">(</span><span class="n">MLMG</span><span class="o">::</span><span class="n">CFStrategy</span><span class="o">::</span><span class="n">ghostnodes</span><span class="p">);</span>
</pre></div>
</div>
<p>The reflux-free method circumvents the need to implement a special <code class="docutils literal notranslate"><span class="pre">reflux</span></code> at the coarse-fine boundary.
This is accomplished by using ghost nodes.
Each AMR level must have 2 layers of ghost nodes.
The second (outermost) layer of nodes is treated as constant by the relaxation, essentially acting as a Dirichlet boundary.
The first layer of nodes is evolved using the relaxation, in the same manner as the rest of the solution.
When the residual is restricted onto the coarse level (in <code class="docutils literal notranslate"><span class="pre">reflux</span></code>) this allows the residual at the coarse-fine boundary to be interpolated using the first layer of ghost nodes.
<a class="reference internal" href="#fig-refluxfreecoarsefine"><span class="std std-numref">Fig. 8</span></a> illustrates the how the coarse-fine update takes place.</p>
<div class="figure align-center" id="id2">
<span id="fig-refluxfreecoarsefine"></span><a class="reference internal image-reference" href="_images/refluxfreecoarsefine.png"><img alt="_images/refluxfreecoarsefine.png" src="_images/refluxfreecoarsefine.png" style="height: 2cm;" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">: Reflux-free coarse-fine boundary update.
Level 2 ghost nodes (small dark blue) are interpolated from coarse boundary.
Level 1 ghost nodes are updated during the relaxation along with all the other interior fine nodes.
Coarse nodes (large blue) on the coarse/fine boundary are updated by restricting with interior nodes
and the first level of ghost nodes.
Coarse nodes underneath level 2 ghost nodes are not updated.
The remaining coarse nodes are updates by restriction.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</div>
<p>The MC nodal operator can inherit from the <code class="docutils literal notranslate"><span class="pre">MCNodeLinOp</span></code> class.
<code class="docutils literal notranslate"><span class="pre">Fapply</span></code>, <code class="docutils literal notranslate"><span class="pre">Fsmooth</span></code>, and <code class="docutils literal notranslate"><span class="pre">Fflux</span></code> must update level 1 ghost nodes that are inside the domain.
<cite>interpolation</cite> and <cite>restriction</cite> can be implemented as usual.
<cite>reflux</cite> is a straightforward restriction from fine to coarse, using level 1 ghost nodes for restriction as described above.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">Tutorials/LinearSolvers/MultiComponent</span></code> for a complete working example.</p>
</li>
</ul>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="LinearSolvers_Chapter.html" class="btn btn-neutral float-left" title="Linear Solvers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Particle_Chapter.html" class="btn btn-neutral float-right" title="Particles" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2018, AMReX Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>