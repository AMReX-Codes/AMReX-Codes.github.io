

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Getting Started &mdash; amrex 20.01-dev documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Embedded Boundaries" href="EB_Chapter.html" />
    <link rel="prev" title="Fortran Interface" href="Fortran_Chapter.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                20.01-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics_Chapter.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particle_Chapter.html">Particles</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-basics">The Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#amr-core-infrastructure">Amr Core Infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#octree">Octree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="Fortran_Chapter.html">Fortran Interface</a> &raquo;</li>
        
      <li>Getting Started</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Fortran.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started">
<h1>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>We have discussed AMReX’s build systems in the chapter on
<a class="reference internal" href="BuildingAMReX_Chapter.html#chap-buildingamrex"><span class="std std-ref">Building AMReX</span></a>.  To build with GNU Make, we need to include the
Fortran interface source tree into the make system. The source codes for the
Fortran interface are in <code class="docutils literal notranslate"><span class="pre">amrex/Src/F_Interfaces</span></code> and there are several
sub-directories. The “Base” directory includes sources for the basic
functionality, the “AmrCore” directory wraps around the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrCore</span></span></code> class
(see the chapter on <a class="reference internal" href="AmrCore_Chapter.html#chap-amrcore"><span class="std std-ref">AmrCore Source Code</span></a>), and the “Octree” directory adds
support for octree type of AMR grids. Each directory has a “Make.package” file
that can be included in make files (see <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Basic/HelloWorld_F</span></code> and
<code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Amr/Advection_F</span></code> for examples). The libamrex approach includes the
Fortran interface by default.</p>
<p>A simple example can be found at <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Basic/HelloWorld_F/</span></code>. The source code
is shown below in its entirety.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">main</span>
  <span class="k">use </span><span class="n">amrex_base_module</span>
  <span class="k">implicit none</span>
<span class="k">  call </span><span class="n">amrex_init</span><span class="p">()</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">amrex_parallel_ioprocessor</span><span class="p">())</span> <span class="k">then</span>
<span class="k">     print</span> <span class="o">*</span><span class="p">,</span> <span class="s2">&quot;Hello world!&quot;</span>
  <span class="k">end if</span>
<span class="k">  call </span><span class="n">amrex_finalize</span><span class="p">()</span>
<span class="k">end program </span><span class="n">main</span>
</pre></div>
</div>
<p>To access the AMReX Fortran interfaces, we can use these three
modules, amrex_base_module for the basics functionalities
(Section <a class="reference external" href="#sec:fi:basics">2</a>), amrex_amrcore_module for AMR
support (Section <a class="reference external" href="#sec:fi:amrcore">3</a>) and amrex_octree_module
for octree style AMR (Section <a class="reference external" href="#sec:fi:octree">4</a>).</p>
</div>
<div class="section" id="the-basics">
<span id="sec-fi-basics"></span><h1>The Basics<a class="headerlink" href="#the-basics" title="Permalink to this headline">¶</a></h1>
<p>Module <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_base_module</span></span></code> is a collection of various Fortran modules
providing interfaces to most of the basics of AMReX C++ library (see the
chapter on <a class="reference internal" href="Basics_Chapter.html#chap-basics"><span class="std std-ref">Basics</span></a>). These modules shown in this section can be used
without being explicitly included because they are included by
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_base_module</span></span></code>.</p>
<p>The spatial dimension is an integer parameter <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_spacedim</span></span></code>.  We
can also use the <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">AMREX_SPACEDIM</span></span></code> macro in preprocessed Fortran codes
(e.g., .F90 files) just like in the C++ codes. Unlike in C++, the convention
for AMReX Fortran interface is that coordinate direction index starts at 1.</p>
<p>There is an integer parameter <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_real</span></span></code>, a Fortran kind parameter
for <code class="code fortran docutils literal notranslate"><span class="keyword type"><span class="pre">real</span></span></code>. Fortran <code class="code fortran docutils literal notranslate"><span class="keyword type"><span class="pre">real</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">amrex_real</span></span><span class="punctuation"><span class="pre">)</span></span></code> corresponds to
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Real</span></span></code> in C++, which is either double or single precision depending
the setting of precision.</p>
<p>The module <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_parallel_module</span></span></code> (
<code class="docutils literal notranslate"><span class="pre">amrex/Src/F_Interfaces/Base/AMReX_parallel_mod.F90</span></code>) includes wrappers to the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelDescriptor</span></span></code> namespace, which is in turn a wrapper to the parallel
communication library used by AMReX (e.g. MPI).</p>
<p>The module <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex_parmparse_module</span></span></code> (
<code class="docutils literal notranslate"><span class="pre">amrex/Src/Base/AMReX_parmparse_mod.F90</span></code>) provides interface to
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> (see the section on <a class="reference internal" href="Basics.html#sec-basics-parmparse"><span class="std std-ref">ParmParse</span></a>). Here are some
examples.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">type</span><span class="p">(</span><span class="n">amrex_parmparse</span><span class="p">)</span> <span class="kd">::</span> <span class="n">pp</span>
<span class="kt">integer</span> <span class="kd">::</span> <span class="n">n_cell</span><span class="p">,</span> <span class="n">max_grid_size</span>
<span class="k">call </span><span class="n">amrex_parmparse_build</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
<span class="k">call </span><span class="n">pp</span><span class="p">%</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_cell&quot;</span><span class="p">,</span> <span class="n">n_cell</span><span class="p">)</span>
<span class="n">max_grid_size</span> <span class="o">=</span> <span class="mi">32</span> <span class="c">! default size</span>
<span class="k">call </span><span class="n">pp</span><span class="p">%</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;max_grid_size&quot;</span><span class="p">,</span> <span class="n">max_grid_size</span><span class="p">)</span>
<span class="k">call </span><span class="n">amrex_parmpase_destroy</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="c">! optional if compiler supports finalization</span>
</pre></div>
</div>
<p>Finalization is a Fortran 2003 feature that some compilers may not support. For
those compilers, we must explicitly destroy the objects, otherwise there will
be memory leaks. This applies to many other derived types.</p>
<p><code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_box</span></span></code> is a derived type in <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_box_module</span></span></code>
<code class="docutils literal notranslate"><span class="pre">amrex/Src/F_Interfaces/Base/AMReX_box_mod.F90</span></code>. It has three members, <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">lo</span></span></code>
(lower corner), <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">hi</span></span></code> (upper corner) and <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">nodal</span></span></code> (logical flag
for index type).</p>
<p><code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_geometry</span></span></code> is a wrapper for the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> class
containing information for the physical domain. Below is an example
of building it.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">n_cell</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_box</span><span class="p">)</span> <span class="kd">::</span> <span class="n">domain</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_geometry</span><span class="p">)</span> <span class="p">:</span> <span class="n">geom</span>
<span class="c">! n_cell = ...</span>
<span class="c">! Define a single box covering the domain</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">amrex_box</span><span class="p">((</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">/</span><span class="p">),</span> <span class="p">(</span><span class="o">/</span><span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">))</span>
<span class="c">! This defines a amrex_geometry object.</span>
<span class="k">call </span><span class="n">amrex_geometry_build</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
<span class="c">!</span>
<span class="c">! ...</span>
<span class="c">!</span>
<span class="k">call </span><span class="n">amrex_geometry_destroy</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_boxarray</span></span></code> ( <code class="docutils literal notranslate"><span class="pre">amrex/Src/F_Interfaces/Base/AMReX_boxarray_mod.F90</span></code>) is a
wrapper for the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> class, and <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_distromap</span></span></code> (
<code class="docutils literal notranslate"><span class="pre">amrex/Src/F_Interfaces/Base/AMReX_distromap_mod.F90</span></code>) is a wrapper for the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code> class. Here is an example of building a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> and a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">n_cell</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_box</span><span class="p">)</span> <span class="kd">::</span> <span class="n">domain</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_boxarray</span><span class="p">)</span> <span class="p">:</span> <span class="n">ba</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_distromap</span><span class="p">)</span> <span class="kd">::</span> <span class="n">dm</span>
<span class="c">! n_cell = ...</span>
<span class="c">! Define a single box covering the domain</span>
<span class="n">domain</span> <span class="o">=</span> <span class="n">amrex_box</span><span class="p">((</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">/</span><span class="p">),</span> <span class="p">(</span><span class="o">/</span><span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_cell</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">))</span>
<span class="c">! Initialize the boxarray &quot;ba&quot; from the single box &quot;bx&quot;</span>
<span class="k">call </span><span class="n">amrex_boxarray_build</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
<span class="c">! Break up boxarray &quot;ba&quot; into chunks no larger than &quot;max_grid_size&quot;</span>
<span class="k">call </span><span class="n">ba</span><span class="p">%</span><span class="n">maxSize</span><span class="p">(</span><span class="n">max_grid_size</span><span class="p">)</span>
<span class="c">! Build a DistributionMapping for the boxarray</span>
<span class="k">call </span><span class="n">amrex_distromap_build</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">ba</span><span class="p">)</span>
<span class="c">!</span>
<span class="c">! ...</span>
<span class="c">!</span>
<span class="k">call </span><span class="n">amrex_distromap_distromap</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="k">call </span><span class="n">amrex_boxarray_destroy</span><span class="p">(</span><span class="n">ba</span><span class="p">)</span>
</pre></div>
</div>
<p>Given <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_boxarray</span></span></code> and <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_distromap</span></span></code>, we can build
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code>, a wrapper for the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> class, as follows.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">nghost</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_boxarray</span><span class="p">)</span> <span class="p">:</span> <span class="n">ba</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_distromap</span><span class="p">)</span> <span class="kd">::</span> <span class="n">dm</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_multifab</span><span class="p">)</span> <span class="kd">::</span> <span class="n">mf</span><span class="p">,</span> <span class="n">ndmf</span>
<span class="c">! Build amrex_boxarray and amrex_distromap</span>
<span class="c">! ncomp = ...</span>
<span class="c">! nghost = ...</span>
<span class="c">! ...</span>
<span class="c">! Build amrex_multifab with ncomp component and nghost ghost cells</span>
<span class="k">call </span><span class="n">amrex_multifab_build</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">nghost</span><span class="p">)</span>
<span class="c">! Build a nodal multifab</span>
<span class="k">call </span><span class="n">amrex_multifab_build</span><span class="p">(</span><span class="n">ndmf</span><span class="p">,</span><span class="n">ba</span><span class="p">,</span><span class="n">dm</span><span class="p">,</span><span class="n">ncomp</span><span class="p">,</span><span class="n">nghost</span><span class="p">,(</span><span class="o">/</span><span class="p">.</span><span class="n">true</span><span class="p">.,.</span><span class="n">true</span><span class="p">.,.</span><span class="n">true</span><span class="p">.</span><span class="o">/</span><span class="p">))</span>
<span class="c">!</span>
<span class="c">! ...</span>
<span class="c">!</span>
<span class="k">call </span><span class="n">amrex_multifab_destroy</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="k">call </span><span class="n">amrex_multifab_destroy</span><span class="p">(</span><span class="n">ndmf</span><span class="p">)</span>
</pre></div>
</div>
<p>There are many type-bound procedures for <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code>. For example</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">ncomp</span>   <span class="c">! Return the number of components</span>
<span class="n">nghost</span>  <span class="c">! Return the number of ghost cells</span>
<span class="n">setval</span>  <span class="c">! Set the data to the given value</span>
<span class="n">copy</span>    <span class="c">! Copy data from given amrex_multifab to this amrex_multifab</span>
</pre></div>
</div>
<p>Note that the copy function here only works on copying data from another
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code> built with the same <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_distromap</span></span></code>, like
the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Copy</span></span></code> function in C++.  <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code> also has
two parallel communication procedures, <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">fill_boundary</span></span></code> and
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">parallel_copy</span></span></code>. Their and interface and usage are very similar to
functions <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillBoundary</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParallelCopy</span></span></code> for <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> in
C++.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">type</span><span class="p">(</span><span class="n">amrex_geometry</span><span class="p">)</span> <span class="kd">::</span> <span class="n">geom</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_multifab</span><span class="p">)</span> <span class="kd">::</span> <span class="n">mf</span><span class="p">,</span> <span class="n">mfsrc</span>
<span class="c">! ...</span>
<span class="k">call </span><span class="n">mf</span><span class="p">%</span><span class="n">fill_boundary</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>       <span class="c">! Fill all components</span>
<span class="k">call </span><span class="n">mf</span><span class="p">%</span><span class="n">fill_boundary</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c">! Fill 3 components starting with component 1</span>

<span class="k">call </span><span class="n">mf</span><span class="p">%</span><span class="n">parallel_copy</span><span class="p">(</span><span class="n">mfsrc</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span> <span class="c">! Parallel copy from another multifab</span>
</pre></div>
</div>
<p>It should be emphasized that the component index for <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code>
starts with 1 following Fortran convention. This is different from the C++ part
of AMReX.</p>
<p>AMReX provides a Fortran interface to <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">MFIter</span></span></code> for iterating over the
data in <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code>. The Fortran type for this is
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_mfiter</span></span></code>. Here is an example of using <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_mfiter</span></span></code> to
loop over <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code> with tiling and launch a kernel function.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">plo</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">phi</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_box</span><span class="p">)</span> <span class="kd">::</span> <span class="n">bx</span>
<span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span> <span class="k">contiguous</span><span class="p">,</span> <span class="k">dimension</span><span class="p">(:,:,:,:),</span> <span class="k">pointer</span> <span class="kd">::</span> <span class="n">po</span><span class="p">,</span> <span class="n">pn</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_multifab</span><span class="p">)</span> <span class="kd">::</span> <span class="n">old_phi</span><span class="p">,</span> <span class="n">new_phi</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_mfiter</span><span class="p">)</span> <span class="kd">::</span> <span class="n">mfi</span>
<span class="c">! Define old_phi and new_phi ...</span>
<span class="c">! In this example they are built with the same boxarray and distromap.</span>
<span class="c">! And they have the same number of ghost cells and 1 component.</span>
<span class="k">call </span><span class="n">amrex_mfiter_build</span><span class="p">(</span><span class="n">mfi</span><span class="p">,</span> <span class="n">old_phi</span><span class="p">,</span> <span class="n">tiling</span><span class="o">=</span><span class="p">.</span><span class="n">true</span><span class="p">.)</span>
<span class="k">do while</span> <span class="p">(</span><span class="n">mfi</span><span class="p">%</span><span class="n">next</span><span class="p">())</span>
  <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">%</span><span class="n">tilebox</span><span class="p">()</span>
  <span class="n">po</span> <span class="o">=&gt;</span> <span class="n">old_phi</span><span class="p">%</span><span class="n">dataptr</span><span class="p">(</span><span class="n">mfi</span><span class="p">)</span>
  <span class="n">pn</span> <span class="o">=&gt;</span> <span class="n">new_phi</span><span class="p">%</span><span class="n">dataptr</span><span class="p">(</span><span class="n">mfi</span><span class="p">)</span>
  <span class="n">plo</span> <span class="o">=</span> <span class="nb">lbound</span><span class="p">(</span><span class="n">po</span><span class="p">)</span>
  <span class="n">phi</span> <span class="o">=</span> <span class="nb">ubound</span><span class="p">(</span><span class="n">po</span><span class="p">)</span>
  <span class="k">call </span><span class="n">update_phi</span><span class="p">(</span><span class="n">bx</span><span class="p">%</span><span class="n">lo</span><span class="p">,</span> <span class="n">bx</span><span class="p">&amp;</span><span class="n">hi</span><span class="p">,</span> <span class="n">po</span><span class="p">,</span> <span class="n">pn</span><span class="p">,</span> <span class="n">plo</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
<span class="k">end do</span>
<span class="k">call </span><span class="n">amrex_mfiter_destroy</span><span class="p">(</span><span class="n">mfi</span><span class="p">)</span>
</pre></div>
</div>
<p>Here procedure <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">update_phi</span></span></code> is</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">update_phi</span> <span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">pold</span><span class="p">,</span> <span class="n">pnew</span><span class="p">,</span> <span class="n">plo</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
 <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">plo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">phi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span>   <span class="p">)</span> <span class="n">pold</span><span class="p">(</span><span class="n">plo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">phi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">plo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">phi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">plo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">phi</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="n">pnew</span><span class="p">(</span><span class="n">plo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">phi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">plo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">phi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">plo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">phi</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
  <span class="c">! ...</span>
<span class="k">end subroutine </span><span class="n">update_phi</span>
</pre></div>
</div>
<p>Note that amrex_multifab’s procedure <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">dataptr</span></span></code> takes
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_mfiter</span></span></code> and returns a 4-dimensional Fortran pointer. For
performance, we should declare the pointer as <code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">contiguous</span></span></code>. In C++,
the similar operation returns a reference to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>.  However,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> and Fortran pointer have a similar capability of containing
array bound information. We can call <code class="code fortran docutils literal notranslate"><span class="name builtin"><span class="pre">lbound</span></span></code> and <code class="code fortran docutils literal notranslate"><span class="name builtin"><span class="pre">ubound</span></span></code> on
the pointer to return its lower and upper bounds. The first three dimensions of
the bounds are spatial and the fourth is for the number of component.</p>
<p>Many of the derived Fortran types in (e.g., <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code>,
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_boxarray</span></span></code>, <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_distromap</span></span></code>, <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_mfiter</span></span></code>,
and <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_geometry</span></span></code>) contain a <code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">type</span></span><span class="punctuation"><span class="pre">(</span></span><span class="keyword type"><span class="pre">c_ptr</span></span><span class="punctuation"><span class="pre">)</span></span></code> that points a
C++ object. They also contain a <code class="code fortran docutils literal notranslate"><span class="keyword type"><span class="pre">logical</span></span></code> type indicating whether or
not this object owns the underlying object (i.e., responsible for deleting the
object). Due to the semantics of Fortran, one should not return these types
with functions. Instead we should pass them as arguments to procedures
(preferably with <code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">intent</span></span></code> specified). These five types all have
assignment(=) operator that performs a shallow copy. After the assignment, the
original objects still owns the data and the copy is just an alias. For
example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">type</span><span class="p">(</span><span class="n">amrex_multifab</span><span class="p">)</span> <span class="kd">::</span> <span class="n">mf1</span><span class="p">,</span> <span class="n">mf2</span>
<span class="k">call </span><span class="n">amrex_multifab_build</span><span class="p">(</span><span class="n">mf1</span><span class="p">,</span> <span class="p">...)</span>
<span class="k">call </span><span class="n">amrex_multifab_build</span><span class="p">(</span><span class="n">mf2</span><span class="p">,</span> <span class="p">...)</span>
<span class="c">! At this point, both mf1 and mf2 are data owners</span>
<span class="n">mf2</span> <span class="o">=</span> <span class="n">mf1</span>   <span class="c">! This will destroy the original data in mf2.</span>
            <span class="c">! Then mf2 becomes a shallow copy of mf1.</span>
            <span class="c">! mf1 is still the owner of the data.</span>
<span class="k">call </span><span class="n">amrex_multifab_destroy</span><span class="p">(</span><span class="n">mf1</span><span class="p">)</span>
<span class="c">! mf2 no longer contains a valid pointer because mf1 has been destroyed.</span>
<span class="k">call </span><span class="n">amrex_multifab_destroy</span><span class="p">(</span><span class="n">mf2</span><span class="p">)</span>  <span class="c">! But we still need to destroy it.</span>
</pre></div>
</div>
<p>If we need to transfer the ownership, <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code>,
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_boxarray</span></span></code> and <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_distromap</span></span></code> provide type-bound
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">move</span></span></code> procedure. We can use it as follows</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">type</span><span class="p">(</span><span class="n">amrex_multifab</span><span class="p">)</span> <span class="kd">::</span> <span class="n">mf1</span><span class="p">,</span> <span class="n">mf2</span>
<span class="k">call </span><span class="n">amrex_multifab_build</span><span class="p">(</span><span class="n">mf1</span><span class="p">,</span> <span class="p">...)</span>
<span class="k">call </span><span class="n">mf2</span><span class="p">%</span><span class="n">move</span><span class="p">(</span><span class="n">mf1</span><span class="p">)</span>   <span class="c">! mf2 is now the data owner and mf1 is not.</span>
<span class="k">call </span><span class="n">amrex_multifab_destroy</span><span class="p">(</span><span class="n">mf1</span><span class="p">)</span>
<span class="k">call </span><span class="n">amrex_multifab_destroy</span><span class="p">(</span><span class="n">mf2</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_multifab</span></span></code> also has a type-bound <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">swap</span></span></code> procedure for
exchanging the data.</p>
<p>AMReX also provides <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_plotfile_module</span></span></code> for writing plotfiles. The
interface is similar to the C++ versions.</p>
</div>
<div class="section" id="amr-core-infrastructure">
<span id="sec-fi-amrcore"></span><h1>Amr Core Infrastructure<a class="headerlink" href="#amr-core-infrastructure" title="Permalink to this headline">¶</a></h1>
<p>The module <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_amr_module</span></span></code> provides interfaces to AMR core
infrastructure. With AMR, the main program might look like below,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">main</span>
  <span class="k">use </span><span class="n">amrex_amr_module</span>
  <span class="k">implicit none</span>
<span class="k">  call </span><span class="n">amrex_init</span><span class="p">()</span>
  <span class="k">call </span><span class="n">amrex_amrcore_init</span><span class="p">()</span>
  <span class="k">call </span><span class="n">my_amr_init</span><span class="p">()</span>       <span class="c">! user&#39;s own code, not part of AMReX</span>
  <span class="c">! ...</span>
  <span class="k">call </span><span class="n">my_amr_finalize</span><span class="p">()</span>   <span class="c">! user&#39;s own code, not part of AMReX</span>
  <span class="k">call </span><span class="n">amrex_amrcore_finalize</span><span class="p">()</span>
  <span class="k">call </span><span class="n">amrex_finalize</span><span class="p">()</span>
<span class="k">end program </span><span class="n">main</span>
</pre></div>
</div>
<p>Here we need to call <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_amrcore_init</span></span></code> and
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_amrcore_finalize</span></span></code>. And usually we need to call application code
specific procedures to provide some “hooks” needed by AMReX.  In C++, this is
achieved by using virtual functions. In Fortran, we need to call</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">amrex_init_virtual_functions</span> <span class="p">(</span><span class="n">mk_lev_scrtch</span><span class="p">,</span> <span class="n">mk_lev_crse</span><span class="p">,</span> <span class="p">&amp;</span>
                                         <span class="n">mk_lev_re</span><span class="p">,</span> <span class="n">clr_lev</span><span class="p">,</span> <span class="n">err_est</span><span class="p">)</span>

  <span class="c">! Make a new level from scratch using provided boxarray and distromap</span>
  <span class="c">! Only used during initialization.</span>
  <span class="k">procedure</span><span class="p">(</span><span class="n">amrex_make_level_proc</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">mk_lev_scrtch</span>
  <span class="c">! Make a new level using provided boxarray and distromap, and fill</span>
  <span class="c">! with interpolated coarse level data.</span>
  <span class="k">procedure</span><span class="p">(</span><span class="n">amrex_make_level_proc</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">mk_lev_crse</span>
  <span class="c">! Remake an existing level using provided boxarray and distromap,</span>
  <span class="c">! and fill with existing fine and coarse data.</span>
  <span class="k">procedure</span><span class="p">(</span><span class="n">amrex_make_level_proc</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">mk_lev_re</span>
  <span class="c">! Delete level data</span>
  <span class="k">procedure</span><span class="p">(</span><span class="n">amrex_clear_level_proc</span><span class="p">)</span> <span class="kd">::</span> <span class="n">clr_lev</span>
  <span class="c">! Tag cells for refinement</span>
  <span class="k">procedure</span><span class="p">(</span><span class="n">amrex_error_est_proc</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">err_est</span>
<span class="k">end subroutine </span><span class="n">amrex_init_virtual_functions</span>
</pre></div>
</div>
<p>We need to provide five functions and these functions have three types of
interfaces:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">amrex_make_level_proc</span> <span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">import</span>
<span class="k">  implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">lev</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="nb">time</span>
<span class="nb">  </span><span class="k">type</span><span class="p">(</span><span class="kt">c_ptr</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">ba</span><span class="p">,</span> <span class="n">dm</span>
<span class="k">end subroutine </span><span class="n">amrex_make_level_proc</span>

<span class="k">subroutine </span><span class="n">amrex_clear_level_proc</span> <span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">import</span>
<span class="k">  implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="p">,</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">lev</span>
<span class="k">end subroutine </span><span class="n">amrex_clear_level_proc</span>

<span class="k">subroutine </span><span class="n">amrex_error_est_proc</span> <span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="nb">time</span><span class="p">,</span> <span class="n">tagval</span><span class="p">,</span> <span class="n">clearval</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="k">import</span>
<span class="k">  implicit none</span>
<span class="k">  </span><span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">lev</span>
  <span class="k">type</span><span class="p">(</span><span class="kt">c_ptr</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">tags</span>
  <span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="nb">time</span>
<span class="nb">  </span><span class="kt">character</span><span class="p">(</span><span class="kt">c_char</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="k">value</span> <span class="kd">::</span> <span class="n">tagval</span><span class="p">,</span> <span class="n">clearval</span>
<span class="k">end subroutine </span><span class="n">amrex_error_est_proc</span>
</pre></div>
</div>
<p>Tutorials/Amr/Advection_F/Source/my_amr_mod.F90 shows an
example of the setup process. The user provided
<code class="code fortran docutils literal notranslate"><span class="keyword"><span class="pre">procedure</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">amrex_error_est_proc</span></span><span class="punctuation"><span class="pre">)</span></span></code> has a tags argument that
is of type <code class="code fortran docutils literal notranslate"><span class="keyword type"><span class="pre">c_ptr</span></span></code> and its value is a pointer to a
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">TagBoxArray</span></span></code> object. We need to convert this into a Fortran
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_tagboxarray</span></span></code> object.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">type</span><span class="p">(</span><span class="n">amrex_tagboxarray</span><span class="p">)</span> <span class="kd">::</span> <span class="n">tag</span>
<span class="n">tag</span> <span class="o">=</span> <span class="n">tags</span>
</pre></div>
</div>
<p>The module <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_fillpatch_module</span></span></code> provides interface to
C++ functions <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillPatchSinglelevel</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FillPatchTwoLevels</span></span></code>. To use
it, the application code needs to provide procedures for interpolation and
filling physical boundaries.  See
Tutorials/Amr/Advection_F/Source/fillpatch_mod.F90 for an example.</p>
<p>Module <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_fluxregister_module</span></span></code> provides interface to
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FluxRegister</span></span></code> (see the section on <a class="reference internal" href="AmrCore.html#sec-amrcore-fluxreg"><span class="std std-ref">Using FluxRegisters</span></a>). Its usage
is demonstrated in the tutorial at Tutorials/Amr/Advection_F/.</p>
</div>
<div class="section" id="octree">
<span id="sec-fi-octree"></span><h1>Octree<a class="headerlink" href="#octree" title="Permalink to this headline">¶</a></h1>
<p>In AMReX, the union of fine level grids is properly contained within the union
of coarse level grids. There are no required direct parent-child connections
between levels. Therefore, grids in AMReX in general cannot be represented by
trees. Nevertheless, octree type grids are supported via Fortran interface,
because grids are more general than octree grids. A tutorial example using
amrex_octree_module ( <code class="docutils literal notranslate"><span class="pre">amrex/Src/F_Interfaces/Octree/AMReX_octree_mod.f90</span></code>) is
available at <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Amr/Advection_octree_F/</span></code>. Procedures
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_octree_init</span></span></code> and <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_octree_finalize</span></span></code> must be
called as follows,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">main</span>
  <span class="k">use </span><span class="n">amrex_amrcore_module</span>
  <span class="k">use </span><span class="n">amrex_octree_module</span>
  <span class="k">implicit none</span>
<span class="k">  call </span><span class="n">amrex_init</span><span class="p">()</span>
  <span class="k">call </span><span class="n">amrex_octree_int</span><span class="p">()</span>  <span class="c">! This should be called before amrex_amrcore_init.</span>
  <span class="k">call </span><span class="n">amrex_amrcore_init</span><span class="p">()</span>
  <span class="k">call </span><span class="n">my_amr_init</span><span class="p">()</span>       <span class="c">! user&#39;s own code, not part of AMReX</span>
  <span class="c">! ...</span>
  <span class="k">call </span><span class="n">my_amr_finalize</span><span class="p">()</span>   <span class="c">! user&#39;s own code, not part of AMReX</span>
  <span class="k">call </span><span class="n">amrex_amrcore_finalize</span><span class="p">()</span>
  <span class="k">call </span><span class="n">amrex_octree_finalize</span><span class="p">()</span>
  <span class="k">call </span><span class="n">amrex_finalize</span><span class="p">()</span>
<span class="k">end program </span><span class="n">main</span>
</pre></div>
</div>
<p>By default, the grid size is <span class="math notranslate nohighlight">\(8^3\)</span>, and this can be changed via
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ParmParse</span></span></code> parameter <code class="docutils literal notranslate"><span class="pre">amr.max_grid_size</span></code>. The module
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_octree_module</span></span></code> provides <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_octree_iter</span></span></code> that can
be used to iterate over leaves of octree. For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">type</span><span class="p">(</span><span class="n">amrex_octree_iter</span><span class="p">)</span> <span class="kd">::</span> <span class="n">oti</span>
<span class="k">type</span><span class="p">(</span><span class="n">multifab</span><span class="p">)</span> <span class="kd">::</span> <span class="n">phi_new</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>   <span class="c">! one multifab for each level</span>
<span class="kt">integer</span> <span class="kd">::</span> <span class="n">ilev</span><span class="p">,</span> <span class="n">igrd</span>
<span class="k">type</span><span class="p">(</span><span class="n">amrex_box</span><span class="p">)</span> <span class="kd">::</span> <span class="n">bx</span>
<span class="kt">real</span><span class="p">(</span><span class="n">amrex_real</span><span class="p">),</span> <span class="k">contiguous</span><span class="p">,</span> <span class="k">pointer</span><span class="p">,</span> <span class="k">dimension</span><span class="p">(:,:,:,:)</span> <span class="kd">::</span> <span class="n">pout</span>
<span class="k">call </span><span class="n">amrex_octree_iter_build</span><span class="p">(</span><span class="n">oti</span><span class="p">)</span>
<span class="k">do while</span><span class="p">(</span><span class="n">oti</span><span class="p">%</span><span class="n">next</span><span class="p">())</span>
   <span class="n">ilev</span> <span class="o">=</span> <span class="n">oti</span><span class="p">%</span><span class="n">level</span><span class="p">()</span>
   <span class="n">igrd</span> <span class="o">=</span> <span class="n">oti</span><span class="p">%</span><span class="n">grid_index</span><span class="p">()</span>
   <span class="n">bx</span>   <span class="o">=</span> <span class="n">oti</span><span class="p">%</span><span class="n">box</span><span class="p">()</span>
   <span class="n">pout</span> <span class="o">=&gt;</span> <span class="n">phi_new</span><span class="p">(</span><span class="n">ilev</span><span class="p">)%</span><span class="n">dataptr</span><span class="p">(</span><span class="n">igrd</span><span class="p">)</span>
   <span class="c">! ...</span>
<span class="k">end do</span>
<span class="k">call </span><span class="n">amrex_octree_iter_destroy</span><span class="p">(</span><span class="n">oti</span><span class="p">)</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="EB_Chapter.html" class="btn btn-neutral float-right" title="Embedded Boundaries" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Fortran_Chapter.html" class="btn btn-neutral float-left" title="Fortran Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2018, AMReX Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>