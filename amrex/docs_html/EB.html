<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Initializing the Geometric Database &mdash; amrex 24.04-dev documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Time Integration" href="TimeIntegration_Chapter.html" />
    <link rel="prev" title="Embedded Boundaries" href="EB_Chapter.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            amrex
          </a>
              <div class="version">
                24.04-dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics_Chapter.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particle_Chapter.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Python_Chapter.html">Python Interface</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Initializing the Geometric Database</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implicit-function">Implicit Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eb2-geometryshop"><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">GeometryShop</span><span class="w"></span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#eb2-indexspace"><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="w"></span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ebfarrayboxfactory">EBFArrayBoxFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedded-boundary-data">Embedded Boundary Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedded-boundary-data-structures">Embedded Boundary Data Structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ebcellflagfab"><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBCellFlagFab</span><span class="w"></span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#small-cell-problem-and-redistribution">Small Cell Problem and Redistribution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#finite-volume-discretizations">Finite Volume Discretizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#small-cells-and-stability">Small Cells And Stability</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flux-redistribution">Flux Redistribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#state-redistribution">State Redistribution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linear-solvers">Linear Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorials">Tutorials</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="TimeIntegration_Chapter.html">Time Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Post_Processing_Chapter.html">Post-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Faq.html">Frequently Asked Questions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="EB_Chapter.html">Embedded Boundaries</a></li>
      <li class="breadcrumb-item active">Initializing the Geometric Database</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/EB.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="initializing-the-geometric-database">
<span id="sec-eb-ebinit"></span><h1>Initializing the Geometric Database<a class="headerlink" href="#initializing-the-geometric-database" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>In AMReX geometric information is stored in a distributed database
class that must be initialized at the start of the calculation. The
procedure for this goes as follows:</p>
<ul class="simple">
<li><p>Define an implicit function of position which describes the surface of the
embedded object. Specifically, the function class must have a public member
function that takes a position and returns a negative value if that position
is inside the fluid, a positive value in the body, and identically zero at the
embedded boundary.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span><span class="w"> </span><span class="nf">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Make a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">GeometryShop</span><span class="w"></span></code> object using the implicit function.</p></li>
<li><p>Build an <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="w"></span></code> with the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">GeometryShop</span><span class="w"></span></code> object and a
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Geometry</span><span class="w"></span></code> object that contains the information about the domain and the
mesh.</p></li>
</ul>
<p>Here is a simple example of initialize the database for an embedded sphere.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span><span class="w"> </span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w"></span>
<span class="n">Array</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span><span class="w"> </span><span class="n">center</span><span class="p">{</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">};</span><span class="w"> </span><span class="c1">//Center of the sphere</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// Is the fluid inside the sphere?</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span><span class="w"> </span><span class="nf">sphere</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="n">inside</span><span class="p">);</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">shop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EB2</span><span class="o">::</span><span class="n">makeShop</span><span class="p">(</span><span class="n">sphere</span><span class="p">);</span><span class="w"></span>

<span class="n">Geometry</span><span class="w"> </span><span class="nf">geom</span><span class="p">(...);</span><span class="w"></span>
<span class="n">EB2</span><span class="o">::</span><span class="n">Build</span><span class="p">(</span><span class="n">shop</span><span class="p">,</span><span class="w"> </span><span class="n">geom</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Alternatively, the EB information can be initialized from an STL file
specified by a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">ParmParse</span><span class="w"></span></code> parameter <code class="docutils literal notranslate"><span class="pre">eb2.stl_file</span></code>. (This also requires setting <code class="docutils literal notranslate"><span class="pre">eb2.geom_type</span> <span class="pre">=</span> <span class="pre">stl</span></code>.) The
initialization is done by calling</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EB2</span><span class="o">::</span><span class="n">Build</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Geometry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">geom</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">required_coarsening_level</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">max_coarsening_level</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">ngrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">build_coarse_level_by_coarsening</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Additionally one can use <code class="docutils literal notranslate"><span class="pre">eb2.stl_scale</span></code>, <code class="docutils literal notranslate"><span class="pre">eb2.stl_center</span></code> and
<code class="docutils literal notranslate"><span class="pre">eb2.stl_reverse_normal</span></code> to scale, translate and reverse the object,
respectively.</p>
<section id="implicit-function">
<span id="sec-eb-ebinit-if"></span><h2>Implicit Function<a class="headerlink" href="#implicit-function" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">amrex/Src/EB/</span></code>, there are a number of predefined implicit function classes
for basic shapes. One can use these directly or as template for their own
classes.</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">AllRegularIF</span><span class="w"></span></code>:  No embedded boundaries at all.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">BoxIF</span><span class="w"></span></code>: Box.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">CylinderIF</span><span class="w"></span></code>: Cylinder.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EllipsoidIF</span><span class="w"></span></code>: Ellipsoid.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">PlaneIF</span><span class="w"></span></code>: Half-space plane.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">SphereIF</span><span class="w"></span></code>: Sphere.</p></li>
</ul>
<p>AMReX also provides a number of transformation operations to apply to an object.</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">makeComplement</span><span class="w"></span></code>: Complement of an object. E.g. a sphere with fluid on
outside becomes a sphere with fluid inside.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">makeIntersection</span><span class="w"></span></code>: Intersection of two or more objects.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">makeUnion</span><span class="w"></span></code>: Union of two or more objects.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Translate</span><span class="w"></span></code>: Translates an object.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">scale</span><span class="w"></span></code>: Scales an object.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">rotate</span><span class="w"></span></code>: Rotates an object.</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">lathe</span><span class="w"></span></code>: Creates a surface of revolution by rotating a 2D object around an axis.</p></li>
</ul>
<p>Here are some examples of using these functions.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span><span class="w"> </span><span class="nf">sphere1</span><span class="p">(...);</span><span class="w"></span>
<span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span><span class="w"> </span><span class="nf">sphere2</span><span class="p">(...);</span><span class="w"></span>
<span class="n">EB2</span><span class="o">::</span><span class="n">BoxIF</span><span class="w"> </span><span class="nf">box</span><span class="p">(...);</span><span class="w"></span>
<span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span><span class="w"> </span><span class="nf">cylinder</span><span class="p">(...);</span><span class="w"></span>
<span class="n">EB2</span><span class="o">::</span><span class="n">PlaneIF</span><span class="w"> </span><span class="nf">plane</span><span class="p">(...);</span><span class="w"></span>

<span class="c1">// union of two spheres</span>
<span class="k">auto</span><span class="w"> </span><span class="n">twospheres</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EB2</span><span class="o">::</span><span class="n">makeUnion</span><span class="p">(</span><span class="n">sphere1</span><span class="p">,</span><span class="w"> </span><span class="n">sphere2</span><span class="p">);</span><span class="w"></span>

<span class="c1">// intersection of a rotated box, a plane and the union of two spheres</span>
<span class="k">auto</span><span class="w"> </span><span class="n">box_plane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EB2</span><span class="o">::</span><span class="n">makeIntersection</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">box</span><span class="p">,...),</span><span class="w"></span>
<span class="w">                                       </span><span class="n">plane</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">twospheres</span><span class="p">);</span><span class="w"></span>

<span class="c1">// scale a cylinder by a factor of 2 in x and y directions, and 3 in z-direction.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">scylinder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EB2</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">cylinder</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mf">2.</span><span class="p">,</span><span class="w"> </span><span class="mf">2.</span><span class="p">,</span><span class="w"> </span><span class="mf">3.</span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="eb2-geometryshop">
<h2><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">GeometryShop</span><span class="w"></span></code><a class="headerlink" href="#eb2-geometryshop" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Given an implicit function object, say <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">f</span><span class="w"></span></code>, we can make a
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">GeometryShop</span><span class="w"></span></code> object with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">shop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EB2</span><span class="o">::</span><span class="n">makeShop</span><span class="p">(</span><span class="n">f</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="eb2-indexspace">
<h2><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="w"></span></code><a class="headerlink" href="#eb2-indexspace" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>We build <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="w"></span></code> with a template function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">G</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">EB2</span><span class="o">::</span><span class="n">Build</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">G</span><span class="o">&amp;</span><span class="w"> </span><span class="n">gshop</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Geometry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">geom</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">required_coarsening_level</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">max_coarsening_level</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">ngrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Here the template parameter is a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">GeometryShop</span><span class="w"></span></code>. <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Geometry</span><span class="w"></span></code> (see
section <a class="reference internal" href="Basics.html#sec-basics-geom"><span class="std std-ref">RealBox and Geometry</span></a>) describes the rectangular problem domain and the
mesh on the finest AMR level. Coarse level EB data is generated from coarsening
the original fine data. The <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="kt">int</span><span class="w"> </span><span class="n">required_coarsening_level</span><span class="w"></span></code> parameter
specifies the number of coarsening levels required. This is usually set to
<span class="math notranslate nohighlight">\(N-1\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the total number of AMR levels. The <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="kt">int</span><span class="w"></span>
<span class="n">max_coarsening_levels</span><span class="w"></span></code> parameter specifies the number of coarsening levels AMReX
should try to have. This is usually set to a big number, say 20 if multigrid
solvers are used. This essentially tells the build to coarsen as much as it can.
If there are no multigrid solvers, the parameter should be set to the same as
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">required_coarsening_level</span><span class="w"></span></code>. It should be noted that coarsening could
create multi-valued cells even if the fine level does not have any multi-valued
cells. This occurs when the embedded boundary cuts a cell in such a way that
there is fluid on multiple sides of the boundary within that cell. Because
multi-valued cells are not supported, it will cause a runtime error if the
required coarsening level generates multi-valued cells. The optional <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="kt">int</span><span class="w"></span>
<span class="n">ngrow</span><span class="w"></span></code> parameter specifies the number of ghost cells outside the domain on
required levels. For levels coarser than the required level, no EB data are
generated for ghost cells outside the domain.</p>
<p>The newly built <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="w"></span></code> is pushed on to a stack. Static function
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="o">::</span><span class="n">top</span><span class="p">()</span><span class="w"></span></code> returns a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="w"></span></code> to the new
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="w"></span></code> object. We usually only need to build one
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="w"></span></code> object. However, if your application needs multiple
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="w"></span></code> objects, you can save the pointers for later use. For
simplicity, we assume there is only one <cite>EB2::IndexSpace</cite> object for the rest of
this chapter.</p>
</section>
</section>
<section id="ebfarrayboxfactory">
<h1>EBFArrayBoxFactory<a class="headerlink" href="#ebfarrayboxfactory" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>After the EB database is initialized, the next thing we build is
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBFArrayBoxFactory</span><span class="w"></span></code>. This object provides access to the EB database in the
format of basic AMReX objects such as <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">BaseFab</span><span class="w"></span></code>, <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">FArrayBox</span><span class="w"></span></code>,
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">FabArray</span><span class="w"></span></code>, and <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span><span class="w"></span></code>. We can construct it with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBFArrayBoxFactory</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Geometry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_geom</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">BoxArray</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_ba</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">DistributionMapping</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_dm</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_ngrow</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">EBSupport</span><span class="w"> </span><span class="n">a_support</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">makeEBFabFactory</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Geometry</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_geom</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">BoxArray</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_ba</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">DistributionMapping</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_dm</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_ngrow</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">EBSupport</span><span class="w"> </span><span class="n">a_support</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Argument <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_ngrow</span><span class="w"></span></code> specifies the number of
ghost cells we need for EB data at various <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBSupport</span><span class="w"></span></code> levels,
and argument <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBSupport</span><span class="w"> </span><span class="n">a_support</span><span class="w"></span></code> specifies the level of support
needed.</p>
<ul class="simple">
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="nl">EBSupport</span><span class="p">:</span><span class="n">basic</span><span class="w"></span></code>:  basic flags for cell types</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="nl">EBSupport</span><span class="p">:</span><span class="n">volume</span><span class="w"></span></code>: basic plus volume fraction and centroid</p></li>
<li><p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="nl">EBSupport</span><span class="p">:</span><span class="n">full</span><span class="w"></span></code>: volume plus area fraction, boundary centroid
and face centroid</p></li>
</ul>
<p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBFArrayBoxFactory</span><span class="w"></span></code> is derived from <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FArrayBox</span><span class="o">&gt;</span><span class="w"></span></code>.
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span><span class="w"></span></code> constructors have an optional argument <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="k">const</span><span class="w"></span>
<span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FArrayBox</span><span class="o">&gt;&amp;</span><span class="w"></span></code>.  We can use <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBFArrayBoxFactory</span><span class="w"></span></code> to
build <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span><span class="w"></span></code>s that carry EB data.  Member function of
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">FabArray</span><span class="w"></span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FAB</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">Factory</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>can then be used to return a reference to the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBFArrayBoxFactory</span><span class="w"></span></code> used for
building the <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span><span class="w"></span></code>. Using <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="k">dynamic_cast</span><span class="w"></span></code>, we can test whether a
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span><span class="w"></span></code> is built with an <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBFArrayBoxFactory</span><span class="w"></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span><span class="w"> </span><span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">Factory</span><span class="p">()));</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">factory</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// this is EBFArrayBoxFactory</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// regular FabFactory&lt;FArrayBox&gt;</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="embedded-boundary-data">
<h1>Embedded Boundary Data<a class="headerlink" href="#embedded-boundary-data" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>Through member functions of <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBFArrayBoxFactory</span><span class="w"></span></code>, we have access to the
following data:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// see section on EBCellFlagFab</span>
<span class="k">const</span><span class="w"> </span><span class="n">FabArray</span><span class="o">&lt;</span><span class="n">EBCellFlagFab</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">getMultiEBCellFlagFab</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="c1">// volume fraction</span>
<span class="k">const</span><span class="w"> </span><span class="n">MultiFab</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">getVolFrac</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="c1">// volume centroid</span>
<span class="k">const</span><span class="w"> </span><span class="n">MultiCutFab</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">getCentroid</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="c1">// embedded boundary centroid</span>
<span class="k">const</span><span class="w"> </span><span class="n">MultiCutFab</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">getBndryCent</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="c1">// area fractions</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MultiCutFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span><span class="w"> </span><span class="n">getAreaFrac</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>

<span class="c1">// face centroid</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">MultiCutFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span><span class="w"> </span><span class="n">getFaceCent</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Volume fraction</strong> is in a single-component <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span><span class="w"></span></code>. Data are in the range
of <span class="math notranslate nohighlight">\([0,1]\)</span> with zero representing covered cells and one for regular
cells.</p></li>
<li><p><strong>Volume centroid</strong> (also called cell centroid) is
in a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiCutFab</span><span class="w"></span></code> with <code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> components. Each component
of the data is in the range of <span class="math notranslate nohighlight">\([-0.5,0.5]\)</span>, based on each
cell‚Äôs local coordinates with respect to the regular cell‚Äôs center.</p></li>
<li><p><strong>Boundary centroid</strong> is also in a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiCutFab</span><span class="w"></span></code> with
<code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> components.  Each component
of the data is in the range of <span class="math notranslate nohighlight">\([-0.5,0.5]\)</span>, based on each
cell‚Äôs local coordinates with respect to the regular cell‚Äôs center.</p></li>
<li><p><strong>Face centroid</strong> is in a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiCutFab</span><span class="w"></span></code> with <code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> components.
Each component of the data is in the range of <span class="math notranslate nohighlight">\([-0.5,0.5]\)</span>, based on
each cell‚Äôs local coordinates with respect to the embedded boundary.</p></li>
<li><p><strong>Area fractions</strong> are returned in an <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Array</span><span class="w"></span></code> of <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiCutFab</span><span class="w"></span></code>
pointers. For each direction, area fraction is for the face of that direction.
Data are in the range of <span class="math notranslate nohighlight">\([0,1]\)</span> with zero representing a covered face
and one an un-cut face.</p></li>
<li><p><strong>Face centroids</strong> are returned in an <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">Array</span><span class="w"></span></code> of <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiCutFab</span><span class="w"></span></code>
pointers. There are two components for each direction and the
ordering is always the same as the original ordering of the coordinates. For
example, for <span class="math notranslate nohighlight">\(y\)</span> face, the component 0 is for <span class="math notranslate nohighlight">\(x\)</span> coordinate and 1
for <span class="math notranslate nohighlight">\(z\)</span>. The coordinates are in each face‚Äôs local frame normalized to the
range of <span class="math notranslate nohighlight">\([-0.5,0.5]\)</span>.</p></li>
</ul>
</section>
<section id="embedded-boundary-data-structures">
<h1>Embedded Boundary Data Structures<a class="headerlink" href="#embedded-boundary-data-structures" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>A <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiCutFab</span><span class="w"></span></code> is very similar to a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span><span class="w"></span></code>. Its data can be
accessed with subscript operator</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">CutFab</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MFIter</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mfi</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Here <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">CutFab</span><span class="w"></span></code> is derived from <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">FArrayBox</span><span class="w"></span></code> and can be passed to Fortran
just like <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">FArrayBox</span><span class="w"></span></code>. The difference between <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiCutFab</span><span class="w"></span></code> and
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiFab</span><span class="w"></span></code> is that to save memory <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MultiCutFab</span><span class="w"></span></code> only has data on boxes
that contain cut cells. It is an error to call <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="k">operator</span><span class="p">[]</span><span class="w"></span></code> if that box
does not have cut cells. Thus the call must be in a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="k">if</span><span class="w"></span></code> test block (see
section <a class="reference internal" href="#sec-eb-flag"><span class="std std-ref">EBCellFlagFab</span></a>).</p>
<section id="ebcellflagfab">
<span id="sec-eb-flag"></span><h2><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBCellFlagFab</span><span class="w"></span></code><a class="headerlink" href="#ebcellflagfab" title="Permalink to this heading">ÔÉÅ</a></h2>
<p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBCellFlagFab</span><span class="w"></span></code> contains information on cell types.  We can use
it to determine if a box contains cut cells.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">getMultiEBCellFlagFab</span><span class="p">();</span><span class="w"></span>
<span class="n">MultiCutFab</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">centroid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">();</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">MFIter</span><span class="w"> </span><span class="n">mfi</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Box</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">FabType</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="p">[</span><span class="n">mfi</span><span class="p">].</span><span class="n">getType</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">regular</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This box is regular</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">covered</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This box is covered</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">singlevalued</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This box has cut cells</span>
<span class="w">        </span><span class="c1">// Getting cutfab is safe</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">centroid_fab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">centroid</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBCellFlagFab</span><span class="w"></span></code> is derived from <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">BaseFab</span><span class="w"></span></code>. Its data are stored in an
array of 32-bit integers, and can be used in C++ or passed to Fortran just like
an <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">IArrayBox</span><span class="w"></span></code> (section <a class="reference internal" href="Basics.html#sec-basics-fab"><span class="std std-ref">BaseFab, FArrayBox, IArrayBox, and Array4</span></a>). AMReX provides a Fortran
module called <code class="docutils literal notranslate"><span class="pre">amrex_ebcellflag_module</span></code>. This module contains procedures for
testing cell types and getting neighbor information. For example</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_ebcellflag_module</span><span class="p">,</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">is_regular_cell</span><span class="p">,</span><span class="w"> </span><span class="n">is_single_valued_cell</span><span class="p">,</span><span class="w"> </span><span class="n">is_covered_cell</span><span class="w"></span>

<span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">flags</span><span class="p">(...)</span><span class="w"></span>

<span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="w"></span>

<span class="k">do </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">do </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_covered_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">                </span><span class="c">! this is a completely covered cells</span>
<span class="w">            </span><span class="k">else if</span><span class="w"> </span><span class="p">(</span><span class="n">is_regular_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">                </span><span class="c">! this is a regular cell</span>
<span class="w">            </span><span class="k">else if</span><span class="w"> </span><span class="p">(</span><span class="n">is_single_valued_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">                </span><span class="c">! this is a cut cell</span>
<span class="w">            </span><span class="k">end if</span>
<span class="k">        end do</span>
<span class="k">    end do</span>
<span class="k">end do</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="small-cell-problem-and-redistribution">
<span id="sec-eb-redistribution"></span><h1>Small Cell Problem and Redistribution<a class="headerlink" href="#small-cell-problem-and-redistribution" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>First, we review finite volume discretizations with embedded boundaries as used by
AMReX-based applications. Then we illustrate the small cell problem.</p>
<section id="finite-volume-discretizations">
<h2>Finite Volume Discretizations<a class="headerlink" href="#finite-volume-discretizations" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Consider a system of PDEs to advance a conserved quantity <span class="math notranslate nohighlight">\(U\)</span> with fluxes
<span class="math notranslate nohighlight">\(F\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eqn-hypsys">
<span class="eqno">(2)<a class="headerlink" href="#equation-eqn-hypsys" title="Permalink to this equation">ÔÉÅ</a></span>\[\frac{\partial U}{\partial t} + \nabla \cdot F = 0.\]</div>
<p>A conservative, finite volume discretization starts with the divergence theorm</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot F dV = \int_{\partial V} F \cdot n dA.\]</div>
<p>In an embedded boundary cell, the ‚Äúconservative divergence‚Äù is discretized (as
<span class="math notranslate nohighlight">\(D^c(F)\)</span>) as follows</p>
<div class="math notranslate nohighlight" id="equation-eqn-ebdiv">
<span class="eqno">(3)<a class="headerlink" href="#equation-eqn-ebdiv" title="Permalink to this equation">ÔÉÅ</a></span>\[ D^c(F) = \frac{1}{\kappa h} \left( \sum^D_{d = 1}
   (F_{d, \mathrm{hi}} \, \alpha_{d, \mathrm{hi}} - F_{d, \mathrm{lo}}\, \alpha_{d, \mathrm{lo}})
   + F^{EB} \alpha^{EB} \right).\]</div>
<p>Geometry is discretely represented by volumes (<span class="math notranslate nohighlight">\(V = \kappa h^d\)</span>) and
apertures (<span class="math notranslate nohighlight">\(A= \alpha h^{d-1}\)</span>), where <span class="math notranslate nohighlight">\(h\)</span> is the (uniform) mesh
spacing at that AMR level, <span class="math notranslate nohighlight">\(\kappa\)</span> is the volume fraction and
<span class="math notranslate nohighlight">\(\alpha\)</span> are the area fractions. Without multivalued cells the volume
fractions, area fractions and cell and face centroids (see
<a class="reference internal" href="#fig-volume"><span class="std std-numref">Table 11</span></a>) are the only geometric information needed to compute
second-order fluxes centered at the face centroids, and to infer the
connectivity of the cells. Cells are connected if adjacent on the Cartesian
mesh, and only via coordinate-aligned faces on the mesh. If an aperture,
<span class="math notranslate nohighlight">\(\alpha = 0\)</span>, between two cells, they are not directly connected to each
other.</p>
<span id="fig-volume"></span><table class="docutils align-center" id="id1">
<caption><span class="caption-number">Table 11 </span><span class="caption-text">Illustration of embedded boundary cutting a two-dimensional cell.</span><a class="headerlink" href="#id1" title="Permalink to this table">ÔÉÅ</a></caption>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="_images/areas_and_volumes.png"><img alt="a" src="_images/areas_and_volumes.png" style="width: 100%;" /></a></p></td>
<td><p><a class="reference internal" href="_images/eb_fluxes.png"><img alt="b" src="_images/eb_fluxes.png" style="width: 100%;" /></a></p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">A typical two-dimensional uniform cell that is</div>
<div class="line">cut by the embedded boundary. The grey area</div>
<div class="line">represents the region excluded from the</div>
<div class="line">calculation. The portion of the cell faces</div>
<div class="line">faces (labelled with A) through which fluxes</div>
<div class="line">flow are the ‚Äúuncovered‚Äù regions of the full</div>
<div class="line">cell faces. The volume (labelled V) is the</div>
<div class="line">uncovered region of the interior.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Fluxes in a cut cell.</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
</tr>
</tbody>
</table>
</section>
<section id="small-cells-and-stability">
<h2>Small Cells And Stability<a class="headerlink" href="#small-cells-and-stability" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>In the context of time-explicit advance methods for, say hyperbolic
conservation laws, a naive discretization in time of <a class="reference internal" href="#equation-eqn-hypsys">(2)</a> using
<a class="reference internal" href="#equation-eqn-ebdiv">(3)</a>,</p>
<div class="math notranslate nohighlight">
\[U^{n+1} = U^{n} - \delta t D^c(F)\]</div>
<p>would have a time step constraint <span class="math notranslate nohighlight">\(\delta t \sim h \kappa^{1/D}/V_m\)</span>,
which goes to zero as the size of the smallest volume fraction <span class="math notranslate nohighlight">\(\kappa\)</span> in
the calculation. Since EB volume fractions can be arbitrarily small, this presents an
unacceptable constraint. This is the so-called ‚Äúsmall cell problem,‚Äù and AMReX-based
applications address it with redistribution methods.</p>
</section>
<section id="flux-redistribution">
<h2>Flux Redistribution<a class="headerlink" href="#flux-redistribution" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>Consider a conservative update in the form:</p>
<div class="math notranslate nohighlight">
\[(\rho \phi)_t + \nabla \cdot ( \rho \phi u) = RHS\]</div>
<p>For each valid cell in the domain, compute the conservative divergence, <span class="math notranslate nohighlight">\((\nabla \cdot F)^c\)</span> ,
of the convective fluxes, <span class="math notranslate nohighlight">\(F\)</span></p>
<div class="math notranslate nohighlight">
\[(\nabla \cdot {F})^c_i = \dfrac{1}{\mathcal{V}_i} \sum_{f=1}^{N_f} ({F}_f\cdot{n}_f) A_f\]</div>
<p>Here <span class="math notranslate nohighlight">\(N_f\)</span> is the number of faces of cell <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(\vec{n}_f\)</span> and <span class="math notranslate nohighlight">\(A_f\)</span>
are the unit normal and area of the <span class="math notranslate nohighlight">\(f\)</span> -th face respectively,
and <span class="math notranslate nohighlight">\(\mathcal{V}_i\)</span> is the volume of cell <span class="math notranslate nohighlight">\(i\)</span> given by</p>
<div class="math notranslate nohighlight">
\[\mathcal{V}_i = (\Delta x \Delta y \Delta z)\cdot \mathcal{K}_i\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{K}_i\)</span> is the volume fraction of cell <span class="math notranslate nohighlight">\(i\)</span> .</p>
<p>Now, a conservative update can be written as</p>
<div class="math notranslate nohighlight">
\[\frac{ \rho^{n+1} \phi^{n+1} - \rho^{n} \phi^{n} }{\Delta t} = - \nabla \cdot{F}^c\]</div>
<p>For each cell cut by the EB geometry, compute the non-conservative update, <span class="math notranslate nohighlight">\(\nabla \cdot {F}^{nc}\)</span> ,</p>
<div class="math notranslate nohighlight">
\[\nabla\cdot{F}^{nc}_i = \dfrac{\sum\limits_{j\in N(i) } \mathcal{K}_j\nabla \cdot {F}^c_j} {\sum\limits_{j\in N(i) } {\mathcal{K}}_j}\]</div>
<p>where <span class="math notranslate nohighlight">\(N(i)\)</span> is the index set of cell <span class="math notranslate nohighlight">\(i\)</span> and its neighbors.</p>
<p>For each cell cut by the EB geometry, compute the convective update <span class="math notranslate nohighlight">\(\nabla \cdot{F}^{EB}\)</span> follows:</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot{F}^{EB}_i = \mathcal{K}_i\nabla \cdot{F}^{c}_i +(1-\mathcal{K}_i) \nabla \cdot \mathcal{F}^{nc}_i\]</div>
<p>For each cell cut by the EB geometry, redistribute its mass loss, <span class="math notranslate nohighlight">\(\delta M_i\)</span> , to its neighbors:</p>
<div class="math notranslate nohighlight">
\[\nabla \cdot {F}^{EB}_j :=   \nabla \cdot {F}^{EB}_j + w_{ij}\delta M_i\, \qquad \forall j\in N(i)\setminus i\]</div>
<p>where the mass loss in cell <span class="math notranslate nohighlight">\(i\)</span> , <span class="math notranslate nohighlight">\(\delta M_i\)</span> , is given by</p>
<div class="math notranslate nohighlight">
\[\delta M_i =  \mathcal{K}_i(1- \mathcal{K}_i)[ \nabla \cdot {F}^c_i-  \nabla \cdot {F}^{nc}_i]\]</div>
<p>and the weights, <span class="math notranslate nohighlight">\(w_{ij}\)</span> , are</p>
<div class="math notranslate nohighlight">
\[w_{ij} = \dfrac{1}{\sum\limits_{j\in N(i)\setminus i}  \mathcal{K}_j}\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\nabla \cdot{F}_i^{EB}\)</span> gives an update for <span class="math notranslate nohighlight">\(\rho \phi\)</span> ; i.e.,</p>
<div class="math notranslate nohighlight">
\[\frac{(\rho \phi_i)^{n+1} - (\rho \phi_i)^{n} }{\Delta t} = - \nabla \cdot{F}^{EB}_i\]</div>
<p>Typically, the redistribution neighborhood for each cell is one that can be
reached via a monotonic path in each coordinate direction of unit length (see,
e.g., <a class="reference internal" href="#fig-redistribution"><span class="std std-numref">Fig. 12</span></a>)</p>
<figure class="align-default" id="id2">
<span id="fig-redistribution"></span><a class="reference internal image-reference" href="_images/redist.png"><img alt="_images/redist.png" src="_images/redist.png" style="width: 50.0%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 12 </span><span class="caption-text">: Redistribution illustration. Excess update distributed to neighbor cells.</span><a class="headerlink" href="#id2" title="Permalink to this image">ÔÉÅ</a></p>
</figcaption>
</figure>
</section>
<section id="state-redistribution">
<h2>State Redistribution<a class="headerlink" href="#state-redistribution" title="Permalink to this heading">ÔÉÅ</a></h2>
<p>For state redistribution we implement the weighted state
redistribution algorithm as described in Guiliani et al (2021),
which is available on <a class="reference external" href="https://arxiv.org/abs/2112.12360">arxiv</a> .
This is an extension of the original state redistribution algorithm
of Berger and Guiliani (2020).</p>
</section>
</section>
<section id="linear-solvers">
<h1>Linear Solvers<a class="headerlink" href="#linear-solvers" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>Linear solvers for the canonical form (equation <a class="reference internal" href="LinearSolvers_Chapter.html#equation-eqn-abeclap">(1)</a>)
have been discussed in chapter <a class="reference internal" href="LinearSolvers_Chapter.html#chap-linearsolvers"><span class="std std-ref">Linear Solvers</span></a>.</p>
<p>AMReX supports multi-level
1) cell-centered solvers with homogeneous Neumann, homogeneous Dirichlet,
or inhomogeneous Dirichlet boundary conditions on the EB faces, and
2) nodal solvers with homogeneous Neumann boundary conditions,
or inflow velocity conditions on the EB faces.</p>
<p>To use a cell-centered solver with EB, one builds a linear operator
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLEBABecLap</span><span class="w"></span></code> with <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">EBFArrayBoxFactory</span><span class="w"></span></code> (instead of a <code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLABecLaplacian</span><span class="w"></span></code>)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLEBABecLap</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_geom</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_grids</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">a_dmap</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">LPInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a_info</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span><span class="w"> </span><span class="k">const</span><span class="o">*&gt;&amp;</span><span class="w"> </span><span class="n">a_factory</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The usage of this EB-specific class is essentially the same as
<code class="code highlight cpp c++ docutils literal highlight-c++"><span class="n">MLABecLaplacian</span><span class="w"></span></code>.</p>
<p>The default boundary condition on EB faces is homogeneous Neumann.</p>
<p>To set homogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBHomogDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span><span class="w"> </span><span class="n">coeff</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where coeff can be a real number (i.e. the value is the same at every cell)
or is the MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>To set inhomogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span><span class="w"> </span><span class="n">phi_on_eb</span><span class="p">,</span><span class="w"> </span><span class="n">coeff</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where phi_on_eb is the MultiFab holding the Dirichlet values in every cut cell,
and coeff again is a real number (i.e. the value is the same at every cell)
or a MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>Currently there are options to define the face-based coefficients on
face centers vs face centroids, and to interpret the solution variable
as being defined on cell centers vs cell centroids.</p>
<p>The default is for the solution variable to be defined at cell centers;
to tell the solver to interpret the solution variable as living
at cell centroids, you must set</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setPhiOnCentroid</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>The default is for the face-based coefficients to be defined at face centers;
to tell the that the face-based coefficients should be interpreted
as living at face centroids, modify the setBCoeffs command to be</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setBCoeffs</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"> </span><span class="n">MLMG</span><span class="o">::</span><span class="n">Location</span><span class="o">::</span><span class="n">FaceCentroid</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="tutorials">
<h1>Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this heading">ÔÉÅ</a></h1>
<p><a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/EB_Tutorial.html">EB/CNS</a> is an AMR code for solving compressible
Navier-Stokes equations with the embedded boundary approach.</p>
<p><a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/EB_Tutorial.html">EB/Poisson</a> is a single-level code that is a proxy for
solving the electrostatic Poisson equation for a grounded sphere with a point
charge inside.</p>
<p><a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/EB_Tutorial.html">EB/MacProj</a> is a single-level code that computes a divergence-free
flow field around a sphere.  A MAC projection is performed on an initial velocity
field of (1,0,0).</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="EB_Chapter.html" class="btn btn-neutral float-left" title="Embedded Boundaries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="TimeIntegration_Chapter.html" class="btn btn-neutral float-right" title="Time Integration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2018, AMReX Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>