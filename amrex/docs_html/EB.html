

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overview of Embedded Boundary Description &mdash; amrex 20.09-dev documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="GPU" href="GPU_Chapter.html" />
    <link rel="prev" title="Embedded Boundaries" href="EB_Chapter.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> amrex
          

          
          </a>

          
            
            
              <div class="version">
                20.09-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics_Chapter.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particle_Chapter.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Overview of Embedded Boundary Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#finite-volume-discretizations">Finite Volume Discretizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#small-cells-and-stability">Small Cells And Stability</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-the-geometric-database">Initializing the Geometric Database</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implicit-function">Implicit Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eb2-geometryshop"><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#eb2-indexspace"><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ebfarrayboxfactory">EBFArrayBoxFactory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#eb-data">EB Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ebcellflagfab"><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#level-sets">Level Sets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-note-on-filling-level-sets-from-ebfarrayboxfactory">A Note on Filling Level-Sets from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#filling-level-sets-without-lsfactory">Filling Level-Sets without <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-lsfactory">Using <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#filling-multi-level-level-sets-without-lscore">Filling Multi-Level Level-Sets without <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-lscore">Using <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linear-solvers">Linear Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorials">Tutorials</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="EB_Chapter.html">Embedded Boundaries</a> &raquo;</li>
        
      <li>Overview of Embedded Boundary Description</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/EB.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overview-of-embedded-boundary-description">
<span id="sec-eb-eboverview"></span><h1>Overview of Embedded Boundary Description<a class="headerlink" href="#overview-of-embedded-boundary-description" title="Permalink to this headline">¶</a></h1>
<p>For computations with complex geometries, AMReX provides data structures and
algorithms to employ an embedded boundary (EB) approach to PDE discretizations.
In this approach, the underlying computational mesh is uniform and
block-structured, but the boundary of the irregular-shaped computational domain
conceptually cuts through this mesh. Each cell in the mesh becomes labeled as
regular, cut or covered, and the finite-volume based discretization methods
traditionally used in AMReX applications can be modified to incorporate these
cell shapes. See <a class="reference internal" href="#fig-ebexample"><span class="std std-numref">Fig. 13</span></a> for an illustration.</p>
<div class="figure align-default" id="id1">
<span id="fig-ebexample"></span><a class="reference internal image-reference" href="_images/EB_example.png"><img alt="_images/EB_example.png" src="_images/EB_example.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">: In the embedded boundary approach to discretizing PDEs, the (uniform)
rectangular mesh is cut by the irregular shape of the computational domain.
The cells in the mesh are label as regular, cut or covered.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>Because this is a relatively simple grid generation technique, computational
meshes for rather complex geometries can be generated quickly and robustly.
However, the technique can produce arbitrarily small cut cells in the domain.
In practice such small cells can have significant impact on the robustness and
stability of traditional finite volume methods. In this chapter we overview a
class of approaches to deal with this “small cell” problem in a robust and
efficient way, and discuss the tools and data that AMReX provides in order to
implement them.</p>
<p>Note that in a completely general implementation of the EB approach, there
would be no restrictions on the shape or complexity of the EB surface.  With
this generality comes the possibility that the process of “cutting” the cells
results in a single <span class="math notranslate nohighlight">\((i,j,k)\)</span> cell being broken into multiple cell
fragments.  The current release of AMReX does not support multi-valued cells,
thus there is a practical restriction on the complexity of domains (and
numerical algorithms) supported.</p>
<p>This chapter discusses the EB tools, data structures and algorithms currently
supported by AMReX to enable the construction of discretizations of
conservation law systems. The discussion will focus on general requirements
associated with building fluxes and taking divergences of them to advance such
systems. We also give examples of how to initialize the geometry data
structures and access them to build the numerical difference
operators.  Finally we present EB support of linear solvers.</p>
<div class="section" id="finite-volume-discretizations">
<h2>Finite Volume Discretizations<a class="headerlink" href="#finite-volume-discretizations" title="Permalink to this headline">¶</a></h2>
<p>Consider a system of PDEs to advance a conserved quantity <span class="math notranslate nohighlight">\(U\)</span> with fluxes
<span class="math notranslate nohighlight">\(F\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eqn-hypsys">
<span class="eqno">(2)<a class="headerlink" href="#equation-eqn-hypsys" title="Permalink to this equation">¶</a></span>\[\frac{\partial U}{\partial t} + \nabla \cdot F = 0.\]</div>
<p>A conservative, finite volume discretization starts with the divergence theorm</p>
<div class="math notranslate nohighlight">
\[\int_V \nabla \cdot F dV = \int_{\partial V} F \cdot n dA.\]</div>
<p>In an embedded boundary cell, the “conservative divergence” is discretized (as
<span class="math notranslate nohighlight">\(D^c(F)\)</span>) as follows</p>
<div class="math notranslate nohighlight" id="equation-eqn-ebdiv">
<span class="eqno">(3)<a class="headerlink" href="#equation-eqn-ebdiv" title="Permalink to this equation">¶</a></span>\[ D^c(F) = \frac{1}{\kappa h} \left( \sum^D_{d = 1}
   (F_{d, \mathrm{hi}} \, \alpha_{d, \mathrm{hi}} - F_{d, \mathrm{lo}}\, \alpha_{d, \mathrm{lo}})
   + F^{EB} \alpha^{EB} \right).\]</div>
<p>Geometry is discretely represented by volumes (<span class="math notranslate nohighlight">\(V = \kappa h^d\)</span>) and
apertures (<span class="math notranslate nohighlight">\(A= \alpha h^{d-1}\)</span>), where <span class="math notranslate nohighlight">\(h\)</span> is the (uniform) mesh
spacing at that AMR level, <span class="math notranslate nohighlight">\(\kappa\)</span> is the volume fraction and
<span class="math notranslate nohighlight">\(\alpha\)</span> are the area fractions. Without multivalued cells the volume
fractions, area fractions and cell and face centroids (see
<a class="reference internal" href="#fig-volume"><span class="std std-numref">Table 10</span></a>) are the only geometric information needed to compute
second-order fluxes centered at the face centroids, and to infer the
connectivity of the cells. Cells are connected if adjacent on the Cartesian
mesh, and only via coordinate-aligned faces on the mesh. If an aperture,
<span class="math notranslate nohighlight">\(\alpha = 0\)</span>, between two cells, they are not directly connected to each
other.</p>
<span id="fig-volume"></span><table class="docutils align-center" id="id2">
<caption><span class="caption-number">Table 10 </span><span class="caption-text">Illustration of embedded boundary cutting a two-dimensional cell.</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="_images/areas_and_volumes.png"><img alt="a" src="_images/areas_and_volumes.png" style="width: 100%;" /></a></p></td>
<td><p><a class="reference internal" href="_images/eb_fluxes.png"><img alt="b" src="_images/eb_fluxes.png" style="width: 100%;" /></a></p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">A typical two-dimensional uniform cell that is</div>
<div class="line">cut by the embedded boundary. The grey area</div>
<div class="line">represents the region excluded from the</div>
<div class="line">calculation. The portion of the cell faces</div>
<div class="line">faces (labelled with A) through which fluxes</div>
<div class="line">flow are the “uncovered” regions of the full</div>
<div class="line">cell faces. The volume (labelled V) is the</div>
<div class="line">uncovered region of the interior.</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Fluxes in a cut cell.</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="small-cells-and-stability">
<h2>Small Cells And Stability<a class="headerlink" href="#small-cells-and-stability" title="Permalink to this headline">¶</a></h2>
<p>In the context of time-explicit advance methods for, say hyperbolic
conservation laws, a naive discretization in time of <a class="reference internal" href="#equation-eqn-hypsys">(2)</a> using
<a class="reference internal" href="#equation-eqn-ebdiv">(3)</a>,</p>
<div class="math notranslate nohighlight">
\[U^{n+1} = U^{n} - \delta t D^c(F)\]</div>
<p>would have a time step constraint <span class="math notranslate nohighlight">\(\delta t \sim h \kappa^{1/D}/V_m\)</span>,
which goes to zero as the size of the smallest volume fraction <span class="math notranslate nohighlight">\(\kappa\)</span> in
the calculation. Since EB volume fractions can be arbitrarily small, this is an
unacceptable constraint. One way to remedy this is to create “non-conservative”
approximation to the divergence <span class="math notranslate nohighlight">\(D^{nc}\)</span>, which at a cell <span class="math notranslate nohighlight">\({\bf i}\)</span>,
can be formed as an average of the conservative divergences in the neighborhood,
<span class="math notranslate nohighlight">\(N_{\bf i}\)</span>, of <span class="math notranslate nohighlight">\({\bf i}\)</span>.</p>
<div class="math notranslate nohighlight">
\[D^{nc}(F)_{\bf i}= \frac{\sum_{{\bf j}\in N_{\bf i}}\kappa_{\bf j}D(F)_{\bf j}}{\sum_{{\bf j}\in N_{\bf i}}\kappa_{\bf j}}\]</div>
<p>Incorporating this form, the solution can be updated using a <em>hybrid
divergence</em>, <span class="math notranslate nohighlight">\(D^H(F) = \kappa D^c(F) + (1-\kappa)D^{nc}\)</span>:</p>
<div class="math notranslate nohighlight">
\[U^{n+1,*} = U^n - \delta t D^H(F)\]</div>
<p>However, we would like our finite-volume scheme to strictly conserve the field
quantities over the domain. To enforce this, we calculate <span class="math notranslate nohighlight">\(\delta M\)</span>, the
mass gained or lost by not using <span class="math notranslate nohighlight">\(D^c\)</span> directly,</p>
<div class="math notranslate nohighlight">
\[\delta M_{\bf i}= \kappa (1-\kappa)(D^c(F)_{\bf i}- D^{nc}(F)_{\bf i})\]</div>
<p>This “excess material” (mass, if <span class="math notranslate nohighlight">\(U=\rho\)</span>) can be <em>redistributed</em> in a
time-explicit fashion to neighboring cells, <span class="math notranslate nohighlight">\({\bf j}\in N_{\bf i}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\delta M_{\bf i}= \sum_{{\bf j}\in N_{\bf i}} \delta M_{{\bf j}, {\bf i}}.\]</div>
<p>in order to preserve strict conservation over <span class="math notranslate nohighlight">\(N_{\bf i}\)</span>.</p>
<p>Note that the physics at hand may impact the optimal choice of precisely how the
excess mass is distributed in this fashion. We introduce a weighting for
redistribution, <span class="math notranslate nohighlight">\(W\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-eqn-massweight">
<span class="eqno">(4)<a class="headerlink" href="#equation-eqn-massweight" title="Permalink to this equation">¶</a></span>\[ \delta M_{{\bf j}, {\bf i}} =  \frac{\delta M_{\bf i}\kappa_{\bf j}
   W_{\bf j}}{\sum_{{\bf k}\in N_{\bf i}} \kappa_{\bf k}W_{\bf k}}\]</div>
<p>For all <span class="math notranslate nohighlight">\({\bf j}\in N_{\bf i}\)</span>,</p>
<div class="math notranslate nohighlight">
\[U^{n+1}_{\bf j}= U^{n+1,*}_{\bf j}+
 \frac{\delta M_{\bf i}
  W_{\bf j}}{\sum_{{\bf k}\in N_{\bf i}} \kappa_{\bf k}W_{\bf k}}.\]</div>
<p>Typically, the redistribution neighborhood for each cell is one that can be
reached via a monotonic path in each coordinate direction of unit length (see,
e.g., <a class="reference internal" href="#fig-redistribution"><span class="std std-numref">Fig. 14</span></a>)</p>
<div class="figure align-default" id="id3">
<span id="fig-redistribution"></span><a class="reference internal image-reference" href="_images/redist.png"><img alt="_images/redist.png" src="_images/redist.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">: Redistribution illustration. Excess mass due to using a hybrid divergence
<span class="math notranslate nohighlight">\(D^H\)</span> instead of the conservative divergence <span class="math notranslate nohighlight">\(D^C\)</span> is
distributed to neighbor cells.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="initializing-the-geometric-database">
<span id="sec-eb-ebinit"></span><h1>Initializing the Geometric Database<a class="headerlink" href="#initializing-the-geometric-database" title="Permalink to this headline">¶</a></h1>
<p>In AMReX geometric information is stored in a distributed database
class that must be initialized at the start of the calculation. The
procedure for this goes as follows:</p>
<ul class="simple">
<li><p>Define an implicit function of position which describes the surface of the
embedded object. Specifically, the function class must have a public member
function that takes a position and returns a negative value if that position
is inside the fluid, a positive value in the body, and identically zero at the
embedded boundary.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Make a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code> object using the implicit function.</p></li>
<li><p>Build an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> with the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code> object and a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> object that contains the information about the domain and the
mesh.</p></li>
</ul>
<p>Here is a simple example of initialize the database for an embedded sphere.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="n">Real</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">center</span><span class="p">{</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">};</span> <span class="c1">//Center of the sphere</span>
<span class="kt">bool</span> <span class="n">inside</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// Is the fluid inside the sphere?</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span> <span class="n">sphere</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">inside</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">shop</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeShop</span><span class="p">(</span><span class="n">sphere</span><span class="p">);</span>

<span class="n">Geometry</span> <span class="nf">geom</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">Build</span><span class="p">(</span><span class="n">shop</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="implicit-function">
<span id="sec-eb-ebinit-if"></span><h2>Implicit Function<a class="headerlink" href="#implicit-function" title="Permalink to this headline">¶</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">amrex/Src/EB/</span></code>, there are a number of predefined implicit function classes
for basic shapes. One can use these directly or as template for their own
classes.</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AllRegularIF</span></span></code>:  No embedded boundaries at all.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxIF</span></span></code>: Box.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">CylinderIF</span></span></code>: Cylinder.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EllipsoidIF</span></span></code>: Ellipsoid.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">PlaneIF</span></span></code>: Half-space plane.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">SphereIF</span></span></code>: Sphere.</p></li>
</ul>
<p>AMReX also provides a number of transformation operations to apply to an object.</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">makeComplement</span></span></code>: Complement of an object. E.g. a sphere with fluid on
outside becomes a sphere with fluid inside.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">makeIntersection</span></span></code>: Intersection of two or more objects.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">makeUnion</span></span></code>: Union of two or more objects.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Translate</span></span></code>: Translates an object.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">scale</span></span></code>: Scales an object.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">rotate</span></span></code>: Rotates an object.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">lathe</span></span></code>: Creates a surface of revolution by rotating a 2D object around an axis.</p></li>
</ul>
<p>Here are some examples of using these functions.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span> <span class="n">sphere1</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">SphereIF</span> <span class="n">sphere2</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">BoxIF</span> <span class="n">box</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span> <span class="n">cylinder</span><span class="p">(...);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">PlaneIF</span> <span class="n">plane</span><span class="p">(...);</span>

<span class="c1">// union of two spheres</span>
<span class="k">auto</span> <span class="n">twospheres</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeUnion</span><span class="p">(</span><span class="n">sphere1</span><span class="p">,</span> <span class="n">sphere2</span><span class="p">);</span>

<span class="c1">// intersection of a rotated box, a plane and the union of two spheres</span>
<span class="k">auto</span> <span class="n">box_plane</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeIntersection</span><span class="p">(</span><span class="n">amrex</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">box</span><span class="p">,...),</span>
                                       <span class="n">plane</span><span class="p">,</span>
                                       <span class="n">twospheres</span><span class="p">);</span>

<span class="c1">// scale a cylinder by a factor of 2 in x and y directions, and 3 in z-direction.</span>
<span class="k">auto</span> <span class="n">scylinder</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">cylinder</span><span class="p">,</span> <span class="p">{</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="eb2-geometryshop">
<h2><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code><a class="headerlink" href="#eb2-geometryshop" title="Permalink to this headline">¶</a></h2>
<p>Given an implicit function object, say <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">f</span></span></code>, we can make a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GeometryShop</span></span></code> object with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">shop</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">makeShop</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="eb2-indexspace">
<h2><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code><a class="headerlink" href="#eb2-indexspace" title="Permalink to this headline">¶</a></h2>
<p>We build <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> with a template function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">G</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">EB2</span><span class="o">::</span><span class="n">Build</span> <span class="p">(</span><span class="k">const</span> <span class="n">G</span><span class="o">&amp;</span> <span class="n">gshop</span><span class="p">,</span> <span class="k">const</span> <span class="n">Geometry</span><span class="o">&amp;</span> <span class="n">geom</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">required_coarsening_level</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">max_coarsening_level</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">ngrow</span> <span class="o">=</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the template parameter is a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">GeometryShop</span></span></code>. <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span></code> (see
section <a class="reference internal" href="Basics.html#sec-basics-geom"><span class="std std-ref">RealBox and Geometry</span></a>) describes the rectangular problem domain and the
mesh on the finest AMR level. Coarse level EB data is generated from coarsening
the original fine data. The <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span> <span class="name"><span class="pre">required_coarsening_level</span></span></code> parameter
specifies the number of coarsening levels required. This is usually set to
<span class="math notranslate nohighlight">\(N-1\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the total number of AMR levels. The <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span>
<span class="name"><span class="pre">max_coarsening_levels</span></span></code> parameter specifies the number of coarsening levels AMReX
should try to have. This is usually set to a big number, say 20 if multigrid
solvers are used. This essentially tells the build to coarsen as much as it can.
If there are no multigrid solvers, the parameter should be set to the same as
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">required_coarsening_level</span></span></code>. It should be noted that coarsening could
create multi-valued cells even if the fine level does not have any multi-valued
cells. This occurs when the embedded boundary cuts a cell in such a way that
there is fluid on multiple sides of the boundary within that cell. Because
multi-valued cells are not supported, it will cause a runtime error if the
required coarsening level generates multi-valued cells. The optional <code class="code cpp c++ docutils literal notranslate"><span class="keyword type"><span class="pre">int</span></span>
<span class="name"><span class="pre">ngrow</span></span></code> parameter specifies the number of ghost cells outside the domain on
required levels. For levels coarser than the required level, no EB data are
generated for ghost cells outside the domain.</p>
<p>The newly built <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> is pushed on to a stack. Static function
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">top</span></span><span class="punctuation"><span class="pre">()</span></span></code> returns a <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">const</span></span> <span class="operator"><span class="pre">&amp;</span></span></code> to the new
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> object. We usually only need to build one
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> object. However, if your application needs multiple
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">IndexSpace</span></span></code> objects, you can save the pointers for later use. For
simplicity, we assume there is only one <cite>EB2::IndexSpace</cite> object for the rest of
this chapter.</p>
</div>
</div>
<div class="section" id="ebfarrayboxfactory">
<h1>EBFArrayBoxFactory<a class="headerlink" href="#ebfarrayboxfactory" title="Permalink to this headline">¶</a></h1>
<p>After the EB database is initialized, the next thing we build is
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code>. This object provides access to the EB database in the
format of basic AMReX objects such as <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>. We can construct it with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBFArrayBoxFactory</span> <span class="p">(</span><span class="k">const</span> <span class="n">Geometry</span><span class="o">&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">a_ba</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">DistributionMapping</span><span class="o">&amp;</span> <span class="n">a_dm</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a_ngrow</span><span class="p">,</span>
                    <span class="n">EBSupport</span> <span class="n">a_support</span><span class="p">);</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span><span class="o">&gt;</span>
<span class="n">makeEBFabFactory</span> <span class="p">(</span><span class="k">const</span> <span class="n">Geometry</span><span class="o">&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">BoxArray</span><span class="o">&amp;</span> <span class="n">a_ba</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">DistributionMapping</span><span class="o">&amp;</span> <span class="n">a_dm</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a_ngrow</span><span class="p">,</span>
                  <span class="n">EBSupport</span> <span class="n">a_support</span><span class="p">);</span>
</pre></div>
</div>
<p>Argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword type"><span class="pre">int</span></span><span class="operator"><span class="pre">&gt;</span></span> <span class="keyword"><span class="pre">const</span></span><span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">a_ngrow</span></span></code> specifies the number of
ghost cells we need for EB data at various <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBSupport</span></span></code> levels,
and argument <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBSupport</span></span> <span class="name"><span class="pre">a_support</span></span></code> specifies the level of support
needed.</p>
<ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name label"><span class="pre">EBSupport</span></span><span class="punctuation"><span class="pre">:</span></span><span class="name"><span class="pre">basic</span></span></code>:  basic flags for cell types</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name label"><span class="pre">EBSupport</span></span><span class="punctuation"><span class="pre">:</span></span><span class="name"><span class="pre">volume</span></span></code>: basic plus volume fraction and centroid</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name label"><span class="pre">EBSupport</span></span><span class="punctuation"><span class="pre">:</span></span><span class="name"><span class="pre">full</span></span></code>: volume plus area fraction, boundary centroid
and face centroid</p></li>
</ul>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> is derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabFactory</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">FArrayBox</span></span><span class="operator"><span class="pre">&gt;</span></span></code>.
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> constructors have an optional argument <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">const</span></span>
<span class="name"><span class="pre">FabFactory</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">FArrayBox</span></span><span class="operator"><span class="pre">&gt;&amp;</span></span></code>.  We can use <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> to
build <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>s that carry EB data.  Member function of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FabArray</span></span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">FabFactory</span><span class="o">&lt;</span><span class="n">FAB</span><span class="o">&gt;&amp;</span> <span class="n">Factory</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>can then be used to return a reference to the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> used for
building the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>. Using <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">dynamic_cast</span></span></code>, we can test whether a
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> is built with an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mf</span><span class="p">.</span><span class="n">Factory</span><span class="p">()));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">factory</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// this is EBFArrayBoxFactory</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// regular FabFactory&lt;FArrayBox&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="eb-data">
<h1>EB Data<a class="headerlink" href="#eb-data" title="Permalink to this headline">¶</a></h1>
<p>Through member functions of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code>, we have access to the
following data:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// see section on EBCellFlagFab</span>
<span class="k">const</span> <span class="n">FabArray</span><span class="o">&lt;</span><span class="n">EBCellFlagFab</span><span class="o">&gt;&amp;</span> <span class="n">getMultiEBCellFlagFab</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// volume fraction</span>
<span class="k">const</span> <span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">getVolFrac</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// volume centroid</span>
<span class="k">const</span> <span class="n">MultiCutFab</span><span class="o">&amp;</span> <span class="n">getCentroid</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// embedded boundary centroid</span>
<span class="k">const</span> <span class="n">MultiCutFab</span><span class="o">&amp;</span> <span class="n">getBndryCent</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// area fractions</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MultiCutFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">getAreaFrac</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// face centroid</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MultiCutFab</span><span class="o">*</span><span class="p">,</span><span class="n">AMREX_SPACEDIM</span><span class="o">&gt;</span> <span class="n">getFaceCent</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Volume fraction is in a single-component <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>, and it is zero for
covered cells, one for regular cells, and in between for cut cells. Centroid is
in a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> with <code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> components with each component
of the data is in the range of <span class="math notranslate nohighlight">\([-0.5,0.5]\)</span>. The centroid is based on each
cell’s local coordinates with respect to the embedded boundary. A
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> is very similar to a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>. Its data can be
accessed with subscript operator</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">CutFab</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">MFIter</span><span class="o">&amp;</span> <span class="n">mfi</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Here <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">CutFab</span></span></code> is derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code> and can be passed to Fortran
just like <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">FArrayBox</span></span></code>. The difference between <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> is that to save memory <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> only has data on boxes
that contain cut cells. It is an error to call <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">operator</span></span><span class="punctuation"><span class="pre">[]</span></span></code> if that box
does not have cut cells. Thus the call must be in a <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">if</span></span></code> test block (see
section <a class="reference internal" href="#sec-eb-flag"><span class="std std-ref">EBCellFlagFab</span></a>). Boundary centroid is also a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code> with
<code class="docutils literal notranslate"><span class="pre">AMREX_SPACEDIM</span></code> components, and it uses each cell’s local coordinates. Area
fractions and face centroids are returned in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Array</span></span></code> of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiCutFab</span></span></code>
pointers. For each direction, area fraction is for the face of that direction.
As for face centroids, there are two components for each direction and the
ordering is always the same as the original ordering of the coordinates. For
example, for <span class="math notranslate nohighlight">\(y\)</span> face, the component 0 is for <span class="math notranslate nohighlight">\(x\)</span> coordinate and 1
for <span class="math notranslate nohighlight">\(z\)</span>. The coordinates are in each face’s local frame normalized to the
range of <span class="math notranslate nohighlight">\([-0.5,0.5]\)</span>.</p>
<div class="section" id="ebcellflagfab">
<span id="sec-eb-flag"></span><h2><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code><a class="headerlink" href="#ebcellflagfab" title="Permalink to this headline">¶</a></h2>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code> contains information on cell types.  We can use
it to determine if a box contains cut cells.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">getMultiEBCellFlagFab</span><span class="p">();</span>
<span class="n">MultiCutFab</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">centroid</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">getCentroid</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">tilebox</span><span class="p">();</span>
    <span class="n">FabType</span> <span class="n">t</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="n">mfi</span><span class="p">].</span><span class="n">getType</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">regular</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// This box is regular</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">covered</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// This box is covered</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">FabType</span><span class="o">::</span><span class="n">singlevalued</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// This box has cut cells</span>
        <span class="c1">// Getting cutfab is safe</span>
        <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">centroid_fab</span> <span class="o">=</span> <span class="n">centroid</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBCellFlagFab</span></span></code> is derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BaseFab</span></span></code>. Its data are stored in an
array of 32-bit integers, and can be used in C++ or passed to Fortran just like
an <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IArrayBox</span></span></code> (section <a class="reference internal" href="Basics.html#sec-basics-fab"><span class="std std-ref">BaseFab, FArrayBox, IArrayBox, and Array4</span></a>). AMReX provides a Fortran
module called <code class="docutils literal notranslate"><span class="pre">amrex_ebcellflag_module</span></code>. This module contains procedures for
testing cell types and getting neighbor information. For example</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">use </span><span class="n">amrex_ebcellflag_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">is_regular_cell</span><span class="p">,</span> <span class="n">is_single_valued_cell</span><span class="p">,</span> <span class="n">is_covered_cell</span>

<span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">flags</span><span class="p">(...)</span>

<span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span>

<span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="p">...</span>
    <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="p">...</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="p">...</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_covered_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="k">then</span>
                <span class="c">! this is a completely covered cells</span>
            <span class="k">else if</span> <span class="p">(</span><span class="n">is_regular_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="k">then</span>
                <span class="c">! this is a regular cell</span>
            <span class="k">else if</span> <span class="p">(</span><span class="n">is_single_valued_cell</span><span class="p">(</span><span class="n">flags</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="k">then</span>
                <span class="c">! this is a cut cell</span>
            <span class="k">end if</span>
<span class="k">        end do</span>
<span class="k">    end do</span>
<span class="k">end do</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="level-sets">
<span id="sec-eb-levelset"></span><h1>Level Sets<a class="headerlink" href="#level-sets" title="Permalink to this headline">¶</a></h1>
<p>In order to speed up direct interactions with embedded boundaries, AMReX also
provides a way to construct level-sets representing the signed distance function
from the closest EB surface. In our implementation, the level-set data is stored
as a 1-component nodal <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> (cf. <a class="reference internal" href="Basics.html#sec-basics-multifab"><span class="std std-ref">FabArray, MultiFab and iMultiFab</span></a>) where
each node stores its closest distance to the EB. The subroutine
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_eb_interp_levelset</span></span></code> (in <code class="docutils literal notranslate"><span class="pre">/Scr/EB/AMREX_EB_levelset_F.F90</span></code>)
interpolates the level-set <span class="math notranslate nohighlight">\(\phi(\mathbf{r})\)</span> to any position
<span class="math notranslate nohighlight">\(\mathbf{r}\)</span> from the pre-computed level-set <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>. Likewise the
subroutine <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_eb_normal_levelset</span></span></code> interpolated the normal
<span class="math notranslate nohighlight">\(\mathbf{\hat{n}}(\mathbf{r})\)</span> at any position from the derivative of the
level-set function <span class="math notranslate nohighlight">\(\mathbf{\hat{n}}(\mathbf{r}) = \nabla
\phi(\mathrm{r})\)</span>. <strong>Note</strong> that since the normal is computed by taking the
derivative of the interpolation function, it is discontinuous at positions
corresponding to the nodal points of the level-set <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> (i.e.
<span class="math notranslate nohighlight">\(\mathbf{r} = (i, j, k) \cdot h\)</span>).</p>
<p>At this point, AMReX does not provide a C++ interface for interpolating the
level-set at a point. This is because so far the level-set was only needed while performing calculations in Fortran. The interpolation subroutines contained in <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">amrex_eb_levelset_module</span></span></code> are:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">pure subroutine </span><span class="n">amrex_eb_interp_levelset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">plo</span><span class="p">,</span>  <span class="n">n_refine</span><span class="p">,</span> <span class="p">&amp;</span>
                                         <span class="n">phi</span><span class="p">,</span> <span class="n">phlo</span><span class="p">,</span> <span class="n">phhi</span><span class="p">,</span>     <span class="p">&amp;</span>
                                         <span class="n">dx</span><span class="p">,</span>  <span class="n">phi_interp</span>    <span class="p">)</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">pure subroutine </span><span class="n">amrex_eb_normal_levelset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">plo</span><span class="p">,</span>   <span class="n">n_refine</span><span class="p">,</span> <span class="p">&amp;</span>
                                         <span class="n">phi</span><span class="p">,</span> <span class="n">phlo</span><span class="p">,</span>  <span class="n">phhi</span><span class="p">,</span>     <span class="p">&amp;</span>
                                         <span class="n">dx</span><span class="p">,</span>  <span class="n">normal</span>         <span class="p">)</span>
</pre></div>
</div>
<p>which interpolate the level-set value <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">phi_interp</span></span></code> and
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">normal</span></span></code>, respectively, at the 3-dimensional point <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">pos</span></span></code>. The
nodal values of the level-set are given by the <code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">phi</span></span></code> array.
<code class="code fortran docutils literal notranslate"><span class="name"><span class="pre">dx</span></span><span class="operator"><span class="pre">/</span></span><span class="name"><span class="pre">n_refine</span></span></code> is the refined cell-size of the level-set array. For
example</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">use </span><span class="nb">iso_c_binding</span>    <span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="kt">c_int</span>
<span class="k">use </span><span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">c_real</span> <span class="o">=&gt;</span> <span class="n">amrex_real</span>
<span class="k">use </span><span class="n">amrex_eb_levelset_module</span><span class="p">,</span> <span class="n">only</span><span class="p">:</span> <span class="n">amrex_eb_interp_levelset</span>

<span class="c">! ** level-set data</span>
<span class="c">!    philo, phihi - dimensions of phi array</span>
<span class="c">!    dx           - spatial discretization</span>
<span class="c">!    n_refine     - refinement of phi array (wrt to dx)</span>
<span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">)</span> <span class="kd">::</span> <span class="n">philo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">phihi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="kt">real</span><span class="p">(</span><span class="n">c_real</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">phi</span><span class="p">(</span>  <span class="n">phlo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">phhi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">phlo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">phhi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">phlo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">phhi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="kt">real</span><span class="p">(</span><span class="n">c_real</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">dx</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="kt">integer</span><span class="p">(</span><span class="kt">c_int</span><span class="p">)</span> <span class="kd">::</span> <span class="n">n_refine</span>

<span class="c">! ** interpolated level-set</span>
<span class="c">!    pos      - coordinate where to interpolate</span>
<span class="c">!    ls_value - interpolated level-set value (output)</span>
<span class="kt">real</span><span class="p">(</span><span class="n">c_real</span><span class="p">)</span> <span class="kd">::</span> <span class="n">pos</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ls_value</span>

<span class="k">call </span><span class="n">amrex_eb_interp_levelset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">plo</span><span class="p">,</span> <span class="n">n_refine</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">phlo</span><span class="p">,</span> <span class="n">phhi</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ls_value</span><span class="p">);</span>
</pre></div>
</div>
<p>AMReX provides collection of functions and subroutines to fill single and
multi-level level-set data. For convenience, the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">LSFactory</span></span></code> helps
manage the level-set data for a single AMR level. And <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">LSCore</span></span></code>
manages multi-level level-set data. These are described in further detail below.</p>
<div class="section" id="a-note-on-filling-level-sets-from-ebfarrayboxfactory">
<h2>A Note on Filling Level-Sets from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code><a class="headerlink" href="#a-note-on-filling-level-sets-from-ebfarrayboxfactory" title="Permalink to this headline">¶</a></h2>
<p>The data stored in a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code>, represents the embedded boundary
as a discrete collection of volume fractions, and area fractions over a grid.
Here this is further simplified by thinking of the EB as a collection of planar
facets. This means that for any given node in a grid, the nearest EB facet might
be in another grid. Hence if the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> has <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">n_pad</span></span></code>
ghost cells, then for any given grid, there could be EB facets that are
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">n_pad</span></span> <span class="operator"><span class="pre">+</span></span> <span class="literal number integer"><span class="pre">1</span></span></code> cells away, yet we would <em>not</em> “see”. In other words, if the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> is defined on a grid with spacing <span class="math notranslate nohighlight">\(h\)</span>, then, and
we do not have any EB facets in the current grid, then any node within that grid
is <em>at least</em> <span class="math notranslate nohighlight">\((n_\mathrm{pad}+1)h\)</span> away from the nearest EB surface.</p>
<p>Hence, when filling a level-set, it will “max-out” at
<span class="math notranslate nohighlight">\(\pm(n_\mathrm{pad}+1)h\)</span>. Hence it is recommended to think of this kind of
level-set function as the point being “at least” <span class="math notranslate nohighlight">\(\phi(\mathbf{r})\)</span> from
the EB surface.</p>
<div class="figure align-default" id="id4">
<span id="fig-local-levelset"></span><a class="reference internal image-reference" href="_images/loc_ls_ex.png"><img alt="_images/loc_ls_ex.png" src="_images/loc_ls_ex.png" style="width: 50.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">: Example of a “local” level-set representing a cylinder. The level-set
function is a (linear) signed distance function near the EB-surface, and it
plateaus further away from it.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>Figure <a class="reference internal" href="#fig-local-levelset"><span class="std std-numref">Fig. 15</span></a> shows an example of such a local level-set
description for a cylinder. Only cells that are within
<span class="math notranslate nohighlight">\(\pm(n_\mathrm{pad}+1)h\)</span> of the EB surface are filled with a level-set.
The rest is filled with lower (upper) bound. If the goal is capture interactions
between the EB surface and a point somewhere else, this approach usually
suffices as we only need to know if we are “far enough” from the EB in most
applications.</p>
<p>Since finding the closest distance between a point and an arbitrary surface is
computationally expensive, we advice that <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">n_pad</span></span></code> is chosen as the smallest
necessary number for the application.</p>
</div>
<div class="section" id="filling-level-sets-without-lsfactory">
<span id="ss-ls-nolsf"></span><h2>Filling Level-Sets without <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code><a class="headerlink" href="#filling-level-sets-without-lsfactory" title="Permalink to this headline">¶</a></h2>
<p>The static function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">LSFactory</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">fill_data</span></span></code> (defined in
<code class="docutils literal notranslate"><span class="pre">Src/EB/AMReX_EB_levelset.cpp</span></code>) fills a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> with the nodal level-set
values and another <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">iMultiFab</span></span></code> with integer tags that are 1 whenever a node
is near the EB surface. It is then left up to the application to manage the
level-set <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code>.</p>
<p>AMReX defines embedded surfaces using implicit functions (see above). Normally
these implicit functions are usually <em>not</em> signed distance functions (i.e. their
value at <span class="math notranslate nohighlight">\(\mathbf{r}\)</span> is not the minimal distance to the EB surface).
However, in rare cases such as the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">PlaneIF</span></span></code>, it is. In this case, the
most straight-forward way to fill a level-set. If an signed-distance implicit
function is know, and stored as a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">mf_impfunc</span></span></code>, then we can use</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_data</span> <span class="p">(</span><span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">iMultiFab</span> <span class="o">&amp;</span> <span class="n">valid</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">mf_impfunc</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="n">eb_pad</span><span class="p">,</span> <span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span> <span class="n">eb_geom</span><span class="p">);</span>
</pre></div>
</div>
<p>so then the function call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fill implicit function</span>
<span class="n">GShopLSFactory</span><span class="o">&lt;</span><span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span><span class="o">&gt;</span> <span class="n">cylinder_lsgs</span><span class="p">(</span><span class="n">cylinder_ghsop</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">&gt;</span> <span class="n">cylinder_mf_impfunc</span> <span class="o">=</span> <span class="n">cylinder_lsgs</span><span class="p">.</span><span class="n">fill_impfunc</span><span class="p">();</span>


<span class="n">MultiFab</span> <span class="nf">ls_grid</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">iMultiFab</span> <span class="nf">ls_valid</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">amrex</span><span class="o">::</span><span class="n">LSFactory</span><span class="o">::</span><span class="n">fill_data</span><span class="p">(</span><span class="n">ls_grid</span><span class="p">,</span> <span class="n">ls_valid</span><span class="p">,</span> <span class="n">mf_impfunc</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">geom_eb</span><span class="p">);</span>
</pre></div>
</div>
<p>fills a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">ls_grid</span></span></code> with level-set data given the implicit function
stored in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">mf_impfunc</span></span></code>, and a threshold of
<code class="code cpp c++ docutils literal notranslate"><span class="literal number integer"><span class="pre">2</span></span><span class="operator"><span class="pre">*</span></span><span class="name"><span class="pre">geom_eb</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">CellSize</span></span><span class="punctuation"><span class="pre">()</span></span></code>. The helper class <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">GShopLSFactory</span></span></code> converts EB2
implicit functions to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFabs</span></span></code> (defined in
<code class="docutils literal notranslate"><span class="pre">Src/EB/AMReX_EB_levelset.H</span></code>).</p>
<p>The much more interesting application of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">LSFactory</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">fill_data</span></span></code> is
filling a level-set given a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_data</span> <span class="p">(</span><span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">iMultiFab</span> <span class="o">&amp;</span> <span class="n">valid</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">EBFArrayBoxFactory</span> <span class="o">&amp;</span> <span class="n">eb_factory</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">eb_impfunc</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">IntVect</span> <span class="o">&amp;</span> <span class="n">ebt_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ls_ref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eb_ref</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span> <span class="n">geom</span><span class="p">,</span> <span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span> <span class="n">geom_eb</span><span class="p">);</span>
</pre></div>
</div>
<p>which fills the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">data</span></span></code> with level-set data from the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span> <span class="name"><span class="pre">eb_factory</span></span></code>. Here the user must still supply the EB
implicit function using the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">eb_impfunc</span></span></code>, as this is used to
determine the inside/outside when no EB facets can be found, or in special
edge-cases. The user also needs to specify the tile size (<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">IntVect</span></span>
<span class="name"><span class="pre">ebt_size</span></span></code>), the level-set and EB refinement (i.e. the grid over which
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">data</span></span></code> is defined is refined by a factor of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ls_ref</span></span><span class="operator"><span class="pre">/</span></span><span class="name"><span class="pre">eb_ref</span></span></code> compared
to the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">eb_factory</span></span></code> ‘s grid), and the Geometries <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">geom</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">geom_eb</span></span></code> corresponding to the grids of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">data</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">eb_factory</span></span></code>
respectively.</p>
<p>When filling <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">data</span></span></code>, a tile-size of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ebt_size</span></span></code> is used. Only EB facets
within a tile (plus the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">eb_factory</span></span></code> ghost cells) are considered. Hence,
chosing an appropriate <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ebt_size</span></span></code> can significantly increase performance.</p>
<p>For example, the following fills a level-set with a cylinder EB (like that shown
in Fig. <a class="reference internal" href="#fig-local-levelset"><span class="std std-numref">Fig. 15</span></a>).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define nGrow of level-set and EB</span>
<span class="kt">int</span> <span class="n">ls_pad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">eb_pad</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// Define EB</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span> <span class="n">cylinder</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">centre</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">GeometryShop</span><span class="o">&lt;</span><span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span><span class="o">&gt;</span> <span class="n">cylinder_gshop</span><span class="p">(</span><span class="n">cylinder</span><span class="p">);</span>

<span class="c1">// Build EB</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">Build</span><span class="p">(</span><span class="n">cylinder_gshop</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">max_level</span><span class="p">,</span> <span class="n">max_level</span><span class="p">);</span>
<span class="k">const</span> <span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span> <span class="o">&amp;</span> <span class="n">cylinder_ebis</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="o">::</span><span class="n">top</span><span class="p">();</span>
<span class="k">const</span> <span class="n">EB2</span><span class="o">::</span><span class="n">Level</span> <span class="o">&amp;</span>      <span class="n">cylinder_lev</span>  <span class="o">=</span> <span class="n">cylinder_ebis</span><span class="p">.</span><span class="n">getLevel</span><span class="p">(</span><span class="n">geom</span><span class="p">);</span>

<span class="c1">// Build EB factory</span>
<span class="n">EBFArrayBoxFactory</span> <span class="nf">eb_factory</span><span class="p">(</span><span class="n">cylinder_lev</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="p">{</span><span class="n">eb_pad</span><span class="p">,</span> <span class="n">eb_pad</span><span class="p">,</span> <span class="n">eb_pad</span><span class="p">});</span>

<span class="c1">// Fill implicit function</span>
<span class="n">GShopLSFactory</span><span class="o">&lt;</span><span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span><span class="o">&gt;</span> <span class="n">cylinder_lsgs</span><span class="p">(</span><span class="n">cylinder_ghsop</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="n">ls_pad</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">&gt;</span> <span class="n">cylinder_mf_impfunc</span> <span class="o">=</span> <span class="n">cylinder_lsgs</span><span class="p">.</span><span class="n">fill_impfunc</span><span class="p">();</span>

<span class="c1">// Fill level-set</span>
<span class="n">MultiFab</span> <span class="nf">ls_grid</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ls_pad</span><span class="p">);</span>
<span class="n">iMultiFab</span> <span class="nf">ls_valid</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ls_pad</span><span class="p">);</span>
<span class="n">LSFactory</span><span class="o">::</span><span class="n">fill_data</span><span class="p">(</span><span class="n">ls_grid</span><span class="p">,</span> <span class="n">ls_valid</span><span class="p">,</span> <span class="n">eb_factory</span><span class="p">,</span> <span class="o">*</span> <span class="n">cylinder_mf_impfunc</span><span class="p">,</span>
                     <span class="n">ebt_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">geom</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that in theory the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span> <span class="name"><span class="pre">eb_factory</span></span></code> could be defined on
a different resolution as the the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span> <span class="name"><span class="pre">ba</span></span></code>. In this case, the
appropriate refinements and geometries must be specified. Also note that the
thresholding behaviour (due to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">eb_pad</span></span></code>) is specified via the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> constructor. The implicit function MultiFab needs to
have the same grids as <cite>data</cite>.</p>
<p>Since this relies on the interplay of many different parameters, a number of
utility functions and helper classes have been created. These are discussed in
the subsequent sections.</p>
<p>The common operations of intersections and unions (similar to EB implicit
functions, discussed in <a class="reference internal" href="#sec-eb-ebinit-if"><span class="std std-ref">Implicit Function</span></a>) can also be applied to
level-sets. Without the use of a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code>, the functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">intersect_data</span> <span class="p">(</span><span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">iMultiFab</span> <span class="o">&amp;</span> <span class="n">valid</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">data_in</span><span class="p">,</span> <span class="k">const</span> <span class="n">iMultiFab</span> <span class="o">&amp;</span> <span class="n">valid_in</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span> <span class="n">geom_ls</span><span class="p">);</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">union_data</span> <span class="p">(</span><span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">iMultiFab</span> <span class="o">&amp;</span> <span class="n">valid</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">data_in</span><span class="p">,</span> <span class="k">const</span> <span class="n">iMultiFab</span> <span class="o">&amp;</span> <span class="n">valid_in</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span> <span class="n">geom_ls</span><span class="p">);</span>
</pre></div>
</div>
<p>These apply the intersection (element-wise minimum) and union (maximum) between
the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">data</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">data_in</span></span></code>. The result overwrites the contents
of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">data</span></span></code>. The tags stored in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">iMultiFab</span></span> <span class="name"><span class="pre">valid_in</span></span></code> determine where
the intersection takes place (i.e. only cells where both <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">valid_in</span></span> <span class="operator"><span class="pre">==</span></span> <span class="literal number integer"><span class="pre">1</span></span></code>
are intersected, others are ignored).</p>
</div>
<div class="section" id="using-lsfactory">
<h2>Using <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code><a class="headerlink" href="#using-lsfactory" title="Permalink to this headline">¶</a></h2>
<p>In the previous section, we’ve seen that the level-set and EB grids can exist on
different levels of refinement. The practical reason behind this is that
sometimes we want to capture interactions that are very sensitive close to EBs,
but this can sometimes be difficult to keep track of. Hence the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code>
can be helpful in taking care of all of these parameters.</p>
<p>The basic principle of the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code> (defined in
<code class="docutils literal notranslate"><span class="pre">Src/EB/AMReX_EB_levelset.H</span></code>) is that it is created relative to some reference
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span> <span class="name"><span class="pre">ba</span></span></code>, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Geometry</span></span> <span class="name"><span class="pre">geom</span></span></code>, and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span> <span class="name"><span class="pre">dm</span></span></code>. The
user then specifies refinement factors <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ls_ref</span></span></code> of the level-set data and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">eb_ref</span></span></code> of the EB grid. Calling the constructor:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LSFactory</span><span class="p">(</span><span class="kt">int</span> <span class="n">lev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ls_ref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eb_ref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ls_pad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eb_pad</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">BoxArray</span> <span class="o">&amp;</span> <span class="n">ba</span><span class="p">,</span> <span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span> <span class="n">geom</span><span class="p">,</span> <span class="k">const</span> <span class="n">DistributionMapping</span> <span class="o">&amp;</span> <span class="n">dm</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">eb_tile_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">);</span>
</pre></div>
</div>
<p>Then creates all appropriate grids and geometries. Note that we can also specify
the tile size used internally in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">fill_data</span></span></code> function.</p>
<p>When a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFacotry</span></span></code> is first created, its level-set values are set to
<code class="code fortran docutils literal notranslate"><span class="name builtin"><span class="pre">huge</span></span><span class="punctuation"><span class="pre">(</span></span><span class="name"><span class="pre">amrex_real</span></span><span class="punctuation"><span class="pre">)</span></span></code>. I. e. there are no surfaces, and so the level-set
value is effectively infinite. It can then be filled just like in the previous
section:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define refinement of level-set and EB</span>
<span class="kt">int</span> <span class="n">ls_ref</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">eb_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// Define nGrow of level-set and EB</span>
<span class="kt">int</span> <span class="n">ls_pad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">eb_pad</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// Define EB</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span> <span class="n">cylinder</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">centre</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">GeometryShop</span><span class="o">&lt;</span><span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span><span class="o">&gt;</span> <span class="n">cylinder_gshop</span><span class="p">(</span><span class="n">cylinder</span><span class="p">);</span>

<span class="c1">// Build level-set factory</span>
<span class="n">LSFactory</span> <span class="nf">level_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ls_ref</span><span class="p">,</span> <span class="n">eb_ref</span><span class="p">,</span> <span class="n">ls_pad</span><span class="p">,</span> <span class="n">eb_pad</span><span class="p">,</span> <span class="n">ba</span><span class="p">,</span> <span class="n">geom</span><span class="p">,</span> <span class="n">dm</span><span class="p">);</span>

<span class="c1">// Build EB</span>
<span class="k">const</span> <span class="n">Geometry</span> <span class="o">&amp;</span> <span class="n">eb_geom</span> <span class="o">=</span> <span class="n">level_set</span><span class="p">.</span><span class="n">get_eb_geom</span><span class="p">()</span>
<span class="n">EB2</span><span class="o">::</span><span class="n">Build</span><span class="p">(</span><span class="n">cylinder_gshop</span><span class="p">,</span> <span class="n">eb_geom</span><span class="p">,</span> <span class="n">max_level</span><span class="p">,</span> <span class="n">max_level</span><span class="p">);</span>

<span class="k">const</span> <span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span> <span class="o">&amp;</span> <span class="n">cylinder_ebis</span> <span class="o">=</span> <span class="n">EB2</span><span class="o">::</span><span class="n">IndexSpace</span><span class="o">::</span><span class="n">top</span><span class="p">();</span>
<span class="k">const</span> <span class="n">EB2</span><span class="o">::</span><span class="n">Level</span> <span class="o">&amp;</span>      <span class="n">cylinder_lev</span>  <span class="o">=</span> <span class="n">cylinder_ebis</span><span class="p">.</span><span class="n">getLevel</span><span class="p">(</span><span class="n">eb_geom</span><span class="p">);</span>

<span class="c1">// Build EB factory</span>
<span class="n">EBFArrayBoxFactory</span> <span class="nf">eb_factory</span><span class="p">(</span><span class="n">cylinder_lev</span><span class="p">,</span> <span class="n">eb_geom</span><span class="p">,</span> <span class="n">level_set</span><span class="p">.</span><span class="n">get_eb_ba</span><span class="p">(),</span> <span class="n">dm</span><span class="p">,</span>
                              <span class="p">{</span><span class="n">level_set</span><span class="p">.</span><span class="n">get_eb_pad</span><span class="p">(),</span> <span class="n">level_set</span><span class="p">.</span><span class="n">get_eb_pad</span><span class="p">(),</span>
                               <span class="n">level_set</span><span class="p">.</span><span class="n">get_eb_pad</span><span class="p">()});</span>

<span class="c1">// Fill level-set (factory)</span>
<span class="n">GShopLSFactory</span><span class="o">&lt;</span><span class="n">EB2</span><span class="o">::</span><span class="n">CylinderIF</span><span class="o">&gt;</span> <span class="n">cylinder_lsgs</span><span class="p">(</span><span class="n">cylinder_ghsop</span><span class="p">,</span> <span class="n">level_set</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">&gt;</span> <span class="n">cylinder_mf_impfunc</span> <span class="o">=</span> <span class="n">cylinder_lsgs</span><span class="p">.</span><span class="n">fill_impfunc</span><span class="p">();</span>
<span class="n">level_set</span><span class="p">.</span><span class="n">Fill</span><span class="p">(</span><span class="n">eb_factory</span><span class="p">,</span> <span class="o">*</span> <span class="n">cylinder_mf_impfunc</span><span class="p">);</span>
</pre></div>
</div>
<p>where the level-set data can now be accessed using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">MultiFab</span> <span class="o">*</span> <span class="n">level_set_data</span> <span class="o">=</span> <span class="n">level_set</span><span class="p">.</span><span class="n">get_data</span><span class="p">();</span>
</pre></div>
</div>
<p>or alternatively a copy of the data can be generated using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">&gt;</span> <span class="n">level_set_data</span> <span class="o">=</span> <span class="n">level_set</span><span class="p">.</span><span class="n">copy_data</span><span class="p">();</span>
</pre></div>
</div>
<p>Both of the data above are on grids that have been refined by <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ls_ref</span></span></code>
(with respect to the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span> <span class="name"><span class="pre">ba</span></span></code>). In order to get a copy of the
level-set data at the coarseness of the original grids, use:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MultiFab</span><span class="o">&gt;</span> <span class="n">level_set_data_crse</span> <span class="o">=</span> <span class="n">level_set</span><span class="p">.</span><span class="n">coarsen_data</span><span class="p">();</span>
</pre></div>
</div>
<p>Note however, that the level-set data is nodal data. Therefore, even though the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span> <span class="name"><span class="pre">level_set_data_crse</span></span></code> is defined on a grid with the same
resolution as the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span> <span class="name"><span class="pre">ba</span></span></code>, it is defined on the nodal version of that
grid.</p>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code> is also there to make operations on the level-set easier.
Intersection and Union operations with EB factories and implicit functions are
available in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSFactory</span></span></code> class. As well as functions to regrid
(updating the underlying <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">BoxArray</span></span></code> and <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">DistributionMapping</span></span></code>),
copying, and inverting the level-set function.</p>
</div>
<div class="section" id="filling-multi-level-level-sets-without-lscore">
<h2>Filling Multi-Level Level-Sets without <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code><a class="headerlink" href="#filling-multi-level-level-sets-without-lscore" title="Permalink to this headline">¶</a></h2>
<p>AMReX also provides code to fill the level-set function on different levels of
refinement. The static function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">LSCoreBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">FillLevelSet</span></span></code>,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">LSCoreBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">MakeNewLevelFromCoarse</span></span></code>, and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">LSCoreBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">FillVolfracTags</span></span></code> (or
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amrex</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">LSCoreBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">FillLevelSetTags</span></span></code> for level-set tagging instead of
volume-fraction tagging) fill a finer level from a coarse one. Just like the
section on <a class="reference internal" href="#ss-ls-nolsf"><span class="std std-ref">Filling Level-Sets without LSFactory</span></a>, the philosophy here is to enable to user to fill
a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MultiFab</span></span></code> with level-set values, and manage this data structure
themselves. Later we will discuss the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code> class, which automatically
constructs multi-level level-sets.</p>
<p>One common problem with level-set function is that they are expensive to
compute. Therefore, a strategy would be to compromise by computing the level-set
function accurately near embedded boundaries (where precision is important), and
at a lower resolution for from walls. The function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">FillVolfracTags</span><span class="p">(</span> <span class="kt">int</span> <span class="n">lev</span><span class="p">,</span> <span class="n">TagBoxArray</span> <span class="o">&amp;</span> <span class="n">tags</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">grids</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">dmap</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">EB2</span><span class="o">::</span><span class="n">Level</span> <span class="o">&amp;</span> <span class="n">eb_lev</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">geom</span> <span class="p">);</span>
</pre></div>
</div>
<p>fills a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">TagBoxArray</span></span></code> with tags wherever the volume fraction is between 0
and 1. This way any cut-cells a buffered of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">amr</span></span><span class="punctuation"><span class="pre">.</span></span><span class="name"><span class="pre">n_error_buf</span></span></code> many
neighbors is tagged for refinement. If we need finer control over the tagging,
the function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">FillLevelSetTags</span><span class="p">(</span> <span class="kt">int</span> <span class="n">lev</span><span class="p">,</span> <span class="n">TagBoxArray</span> <span class="o">&amp;</span> <span class="n">tags</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">phierr</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">MultiFab</span> <span class="o">&amp;</span> <span class="n">levelset_data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">geom</span> <span class="p">);</span>
</pre></div>
</div>
<p>takes a list of threshold level-set values (<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">Real</span></span><span class="operator"><span class="pre">&gt;</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="name"><span class="pre">phierr</span></span></code>) and
tags cells for refinement if the coarse estimate of the levelset
(<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">levelset_data</span></span></code>) from level <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">lev</span></span></code> is less than <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">phierr</span></span><span class="punctuation"><span class="pre">[</span></span><span class="name"><span class="pre">lev</span></span><span class="punctuation"><span class="pre">]</span></span></code>.</p>
<p>The following code would then fill a multi-level hierarchy of level-sets
contained in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">&gt;</span></span> <span class="name"><span class="pre">level_sets</span></span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//___________________________________________________________________________</span>
<span class="c1">// Start with level zero</span>

<span class="n">EBFArrayBoxFactory</span> <span class="nf">eb_factory</span><span class="p">(</span><span class="o">*</span> <span class="n">eb_levels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                              <span class="p">{</span><span class="n">eb_pad</span><span class="p">,</span> <span class="n">eb_pad</span><span class="p">,</span> <span class="n">leb_pad</span><span class="p">},</span> <span class="n">EBSupport</span><span class="o">::</span><span class="n">full</span><span class="p">);</span>

<span class="c1">// NOTE: reference BoxArray is not nodal</span>
<span class="n">BoxArray</span> <span class="n">nd_ba</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IntVect</span><span class="o">::</span><span class="n">TheNodeVector</span><span class="p">());</span>

<span class="n">level_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">define</span><span class="p">(</span><span class="n">nd_ba</span><span class="p">,</span> <span class="n">dmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
<span class="n">iMultiFab</span> <span class="nf">valid</span><span class="p">(</span><span class="n">nd_ba</span><span class="p">,</span> <span class="n">dmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>

<span class="c1">// NOTE: implicit function data might not be on the right grids</span>
<span class="n">MultiFab</span> <span class="n">impfunc</span> <span class="o">=</span> <span class="n">MFUtil</span><span class="o">::</span><span class="n">regrid</span><span class="p">(</span><span class="n">nd_ba</span><span class="p">,</span> <span class="n">dmap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">implicit_functions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">true</span><span class="p">);</span>

<span class="n">LSFactory</span><span class="o">::</span><span class="n">fill_data</span><span class="p">(</span><span class="n">level_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">valid</span><span class="p">,</span> <span class="n">ebfactory</span><span class="p">,</span> <span class="n">impfunc</span><span class="p">,</span>
                     <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>


<span class="c1">//___________________________________________________________________________</span>
<span class="c1">// Fill finer levels, using coarser level to estimate level-set</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lev</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">lev</span> <span class="o">&lt;</span> <span class="n">nlev</span><span class="p">;</span> <span class="n">lev</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// NOTE: reference BoxArray is not nodal</span>
         <span class="n">BoxArray</span> <span class="n">ba</span> <span class="o">=</span> <span class="n">amrex</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">IntVect</span><span class="o">::</span><span class="n">TheNodeVector</span><span class="p">());</span>
         <span class="n">level_sets</span><span class="p">[</span><span class="n">lev</span><span class="p">].</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">MultiFab</span><span class="p">);</span>
         <span class="n">iMultiFab</span> <span class="nf">valid</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>

         <span class="c1">// Fills level_sets[lev] with coarse data</span>
         <span class="n">LSCoreBase</span><span class="o">::</span><span class="n">MakeNewLevelFromCoarse</span><span class="p">(</span> <span class="n">level_sets</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">level_sets</span><span class="p">[</span><span class="n">lev</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                            <span class="n">ba</span><span class="p">,</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                            <span class="n">bcs_ls</span><span class="p">,</span> <span class="n">refRatio</span><span class="p">(</span><span class="n">lev</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

         <span class="n">EBFArrayBoxFactory</span> <span class="nf">eb_factory</span><span class="p">(</span><span class="o">*</span> <span class="n">eb_levels</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">grids</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span>
                                       <span class="p">{</span><span class="n">eb_pad</span><span class="p">,</span> <span class="n">eb_pad</span><span class="p">,</span> <span class="n">eb_pad</span><span class="p">},</span> <span class="n">EBSupport</span><span class="o">::</span><span class="n">full</span><span class="p">);</span>

         <span class="c1">// NOTE: implicit function data might not be on the right grids</span>
         <span class="n">MultiFab</span> <span class="n">impfunc</span> <span class="o">=</span> <span class="n">MFUtil</span><span class="o">::</span><span class="n">regrid</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">dmap</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">implicit_functions</span><span class="p">[</span><span class="n">lev</span><span class="p">]);</span>

         <span class="n">IntVect</span> <span class="n">ebt_size</span><span class="p">{</span><span class="n">AMREX_D_DECL</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)};</span> <span class="c1">// Fudge factors...</span>
         <span class="n">LSCoreBase</span><span class="o">::</span><span class="n">FillLevelSet</span><span class="p">(</span><span class="n">level_sets</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">level_sets</span><span class="p">[</span><span class="n">lev</span><span class="p">],</span> <span class="n">eb_factory</span><span class="p">,</span> <span class="n">impfunc</span><span class="p">,</span>
                                  <span class="n">ebt_size</span><span class="p">,</span> <span class="n">eb_pad</span><span class="p">,</span> <span class="n">geom</span><span class="p">[</span><span class="n">lev</span><span class="p">]);</span>
     <span class="p">}</span>
</pre></div>
</div>
<p>Here the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="keyword"><span class="pre">const</span></span> <span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Level</span></span> <span class="operator"><span class="pre">*&gt;</span></span> <span class="name"><span class="pre">eb_levels</span></span></code> has been filled while
initializing the embedded boundaries. At the same time, the implicit functions
need to be saved to <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">MultiFab</span></span><span class="operator"><span class="pre">&gt;</span></span> <span class="name"><span class="pre">implicit_functions</span></span></code>. The user also
needs to specify the level-set boundary conditions in <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Vector</span></span><span class="operator"><span class="pre">&lt;</span></span><span class="name"><span class="pre">BCRec</span></span><span class="operator"><span class="pre">&gt;</span></span>
<span class="name"><span class="pre">bcs_ls</span></span></code>. Note that the function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCoreBase</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">FillLevelSet</span></span></code> uses the coarse
level-set as an upper bound to the tile size used for testing EB facets.</p>
</div>
<div class="section" id="using-lscore">
<h2>Using <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code><a class="headerlink" href="#using-lscore" title="Permalink to this headline">¶</a></h2>
<p>The process described in the previous section is automated in the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code>
class. It is derived from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCoreBase</span></span></code>, which in turn is derived from
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrCore</span></span></code> (cf. <a class="reference internal" href="AmrCore_Chapter.html#chap-amrcore"><span class="std std-ref">AmrCore Source Code</span></a>). <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code> is a template class
depending on the embedded boundary implicit function. This way, it can build new
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EB2</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">Level</span></span></code> objects for every new level that is needed.</p>
<p>Since <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code> is a template class, it might lead to problems in
applications where the template parameter can depend of runtime parameters. This
is the reason why it derives from the base class <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCoreBase</span></span></code>.
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCore</span></span></code> overwrites the virtual function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MakeNewLevelFromScratch</span></span></code> in
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LSCoreBase</span></span></code>. The application can then employ the following polymorphism to
construct the level-set;</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LSCoreBase</span> <span class="o">*</span> <span class="n">ls_core</span><span class="p">;</span>

<span class="c1">// sets ls_core pointer</span>
<span class="n">make_my_eb</span><span class="p">(</span><span class="n">ls_core</span><span class="p">);</span>

<span class="n">ls_core</span><span class="o">-&gt;</span><span class="n">InitData</span><span class="p">();</span>
</pre></div>
</div>
<p>where the function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">make_my_eb</span></span></code> defines the actual EB geometry:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">make_my_eb</span><span class="p">(</span><span class="n">LSCoreBase</span> <span class="o">*&amp;</span> <span class="n">ls_core</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// MyIF is an EB2 Implicit Fuction</span>
    <span class="n">GeometryShop</span><span class="o">&lt;</span><span class="n">MyIF</span><span class="o">&gt;</span> <span class="n">gshop</span><span class="p">;</span>

    <span class="c1">// Build an EB geometry shop here</span>

    <span class="n">ls_core</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LSCore</span><span class="o">&lt;</span><span class="n">MyIF</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gshop</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">make_my_eb</span></span></code> is only defines the EB geometry. The function call
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">ls_core</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">InitData</span></span><span class="punctuation"><span class="pre">()</span></span></code> constructs level hierarchy and fills it with
level-set values.</p>
</div>
</div>
<div class="section" id="linear-solvers">
<h1>Linear Solvers<a class="headerlink" href="#linear-solvers" title="Permalink to this headline">¶</a></h1>
<p>Linear solvers for the canonical form (equation <a class="reference internal" href="LinearSolvers_Chapter.html#equation-eqn-abeclap">(1)</a>)
have been discussed in chapter <a class="reference internal" href="LinearSolvers_Chapter.html#chap-linearsolvers"><span class="std std-ref">Linear Solvers</span></a>.</p>
<p>AMReX supports multi-level
1) cell-centered solvers with homogeneous Neumann, homogeneous Dirichlet,
or inhomogeneous Dirichlet boundary conditions on the EB faces, and
2) nodal solvers with homogeneous Neumann boundary conditions on the EB faces.</p>
<p>To use a cell-centered solver with EB, one builds a linear operator
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLEBABecLap</span></span></code> with <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">EBFArrayBoxFactory</span></span></code> (instead of a <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code>)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLEBABecLap</span> <span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Geometry</span><span class="o">&gt;&amp;</span> <span class="n">a_geom</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BoxArray</span><span class="o">&gt;&amp;</span> <span class="n">a_grids</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">DistributionMapping</span><span class="o">&gt;&amp;</span> <span class="n">a_dmap</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">LPInfo</span><span class="o">&amp;</span> <span class="n">a_info</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">EBFArrayBoxFactory</span> <span class="k">const</span><span class="o">*&gt;&amp;</span> <span class="n">a_factory</span><span class="p">);</span>
</pre></div>
</div>
<p>The usage of this EB-specific class is essentially the same as
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">MLABecLaplacian</span></span></code>.</p>
<p>The default boundary condition on EB faces is homogeneous Neumann.</p>
<p>To set homogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBHomogDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">coeff</span><span class="p">);</span>
</pre></div>
</div>
<p>where coeff can be a real number (i.e. the value is the same at every cell)
or is the MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>To set inhomogeneous Dirichlet boundary conditions, call</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setEBDirichlet</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">phi_on_eb</span><span class="p">,</span> <span class="n">coeff</span><span class="p">);</span>
</pre></div>
</div>
<p>where phi_on_eb is the MultiFab holding the Dirichlet values in every cut cell,
and coeff again is a real number (i.e. the value is the same at every cell)
or a MultiFab holding the coefficient of the gradient at each cell with an EB face.</p>
<p>Currently there are options to define the face-based coefficients on
face centers vs face centroids, and to interpret the solution variable
as being defined on cell centers vs cell centroids.</p>
<p>The default is for the solution variable to be defined at cell centers;
to tell the solver to interpret the solution variable as living
at cell centroids, you must set</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setPhiOnCentroid</span><span class="p">();</span>
</pre></div>
</div>
<p>The default is for the face-based coefficients to be defined at face centers;
to tell the that the face-based coefficients should be interpreted
as living at face centroids, modify the setBCoeffs command to be</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ml_ebabeclap</span><span class="o">-&gt;</span><span class="n">setBCoeffs</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">MLMG</span><span class="o">::</span><span class="n">Location</span><span class="o">::</span><span class="n">FaceCentroid</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorials">
<h1>Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/EB/CNS</span></code> is an AMR code for solving compressible
Navier-Stokes equations with the embedded boundary approach.</p>
<p><code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/EB/Poisson</span></code> is a single-level code that is a proxy for
solving the electrostatic Poisson equation for a grounded sphere with a point
charge inside.</p>
<p><code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/EB/MacProj</span></code> is a single-level code that computes a divergence-free
flow field around a sphere.  A MAC projection is performed on an initial velocity
field of (1,0,0).</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="GPU_Chapter.html" class="btn btn-neutral float-right" title="GPU" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="EB_Chapter.html" class="btn btn-neutral float-left" title="Embedded Boundaries" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2018, AMReX Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>