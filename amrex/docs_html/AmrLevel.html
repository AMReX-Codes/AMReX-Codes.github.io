<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Amr Class &mdash; amrex 21.10-dev documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Fork-Join" href="ForkJoin.html" />
    <link rel="prev" title="Amr Source Code" href="AmrLevel_Chapter.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> amrex
          </a>
              <div class="version">
                21.10-dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">AMReX Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted_Chapter.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAMReX_Chapter.html">Building AMReX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics_Chapter.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ManagingGridHierarchy_Chapter.html">Gridding and Load Balancing</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrCore_Chapter.html">AmrCore Source Code</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="AmrLevel_Chapter.html">Amr Source Code</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Amr Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#amrlevel-class">AmrLevel Class</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#statedata">StateData</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#levelbld-class">LevelBld Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-advection-amrlevel">Example: Advection_AmrLevel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#particles">Particles</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ForkJoin.html">Fork-Join</a></li>
<li class="toctree-l1"><a class="reference internal" href="IO_Chapter.html">I/O (Plotfile, Checkpoint)</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearSolvers_Chapter.html">Linear Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particle_Chapter.html">Particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fortran_Chapter.html">Fortran Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="EB_Chapter.html">Embedded Boundaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPU_Chapter.html">GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization_Chapter.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Post_Processing_Chapter.html">Post-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Inputs_Chapter.html">Run-time Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMReX_Profiling_Tools_Chapter.html">AMReX-based Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Profiling_Tools_Chapter.html">External Profiling Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="External_Frameworks_Chapter.html">External Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="Regression_Testing_Chapter.html">Regression Testing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">amrex</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="AmrLevel_Chapter.html">Amr Source Code</a> &raquo;</li>
      <li>Amr Class</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/AmrLevel.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="amr-class">
<h1>Amr Class<a class="headerlink" href="#amr-class" title="Permalink to this headline"></a></h1>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Amr</span></span></code> class is designed to manage parts of the computation which do
not belong on a single level, like establishing and updating the hierarchy of
levels, global timestepping, and managing the different <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevel</span></span></code>s.
Most likely you will not need to derive any classes from <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Amr</span></span></code>. Our
mature application codes use this base class without any derived classes.</p>
<p>One of the most important data members is an array of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevel</span></span></code>s - the
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">Amr</span></span></code> class calls many functions from the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevel</span></span></code> class to do
things like advance the solution on a level, compute a time step to be used for
a level, etc.</p>
</div>
<div class="section" id="amrlevel-class">
<h1>AmrLevel Class<a class="headerlink" href="#amrlevel-class" title="Permalink to this headline"></a></h1>
<p>Pure virtual functions include:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">computeInitialDt</span></span></code> Compute an array of time steps for each level of
refinement. Called at the beginning of the simulation.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">computeNewDt</span></span></code> Compute an array of time steps for each level of
refinement. Called at the end of a coarse level advance.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">advance</span></span></code> Advance the grids at a level.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">post_timestep</span></span></code> Work after at time step at a given level. In this
tutorial we do the AMR synchronization here.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">post_regrid</span></span></code> Work after regridding. In this tutorial we redistribute
particles.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">post_init</span></span></code> Work after initialization. In this tutorial we perform
AMR synchronization.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">initData</span></span></code> Initialize the data on a given level at the beginning of
the simulation.</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">init</span></span></code> There are two versions of this function used to initialize
data on a level during regridding. One version is specifically for the
case where the level did not previously exist (a newly created refined
level).</p></li>
<li><p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">errorEst</span></span></code> Perform the tagging at a level for refinement.</p></li>
</ul>
</div></blockquote>
<div class="section" id="statedata">
<h2>StateData<a class="headerlink" href="#statedata" title="Permalink to this headline"></a></h2>
<p>The most important data managed by the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevel</span></span></code> is an array of
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateData</span></span></code>, which holds the scalar fields, etc., in the boxes that
together make up the level.</p>
<p><code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateData</span></span></code> is a class that essentially holds a pair of MultiFabs: one at
the old time and one at the new time. AMReX knows how to interpolate in time
between these states to get data at any intermediate point in time. The main
data that we care about in our applications codes (such as the fluid state)
will be stored as <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateData</span></span></code>.  Essentially, data is made <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateData</span></span></code>
if we need it to be stored in checkpoints/plotfiles, and/or we want it to be
automatically interpolated when we refine.  An <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevel</span></span></code> stores an array
of <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateData</span></span></code> (in a C++ array called <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">state</span></span></code>). We index this array
using integer keys (defined via an <code class="code cpp c++ docutils literal notranslate"><span class="keyword"><span class="pre">enum</span></span></code> in, e.g., <code class="docutils literal notranslate"><span class="pre">AmrLevelAdv.H</span></code>):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">StateType</span> <span class="p">{</span> <span class="n">Phi_Type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">NUM_STATE_TYPE</span> <span class="p">};</span>
</pre></div>
</div>
<p>In our tutorial code, we use the function <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevelAdv</span></span><span class="operator"><span class="pre">::</span></span><span class="name"><span class="pre">variableSetup</span></span></code> to
tell our simulation about the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateData</span></span></code> (e.g., how many variables, ghost
cells, nodality, etc.). Note that if you have more than one <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateType</span></span></code>,
each of the different <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateData</span></span></code> carried in the state array can have
different numbers of components, ghost cells, boundary conditions, etc.
This is the main reason we separate all this data into separate <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateData</span></span></code>
objects collected together in an indexable array.</p>
</div>
</div>
<div class="section" id="levelbld-class">
<h1>LevelBld Class<a class="headerlink" href="#levelbld-class" title="Permalink to this headline"></a></h1>
<p>The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LevelBld</span></span></code> class is a pure virtual class for defining variable types
and attributes. To more easily understand its usage, refer to the derived
class, <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LevelBldAdv</span></span></code> in the tutorial. The <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">variableSetUp</span></span></code> and
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">variableCleanUp</span></span></code> are implemented, and in this tutorial call routines in
the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevelAdv</span></span></code> class, e.g.,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="n">AmrLevelAdv</span><span class="o">::</span><span class="n">variableSetUp</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="n">BL_ASSERT</span><span class="p">(</span><span class="n">desc_lst</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Get options, set phys_bc</span>
    <span class="n">read_params</span><span class="p">();</span>

    <span class="n">desc_lst</span><span class="p">.</span><span class="n">addDescriptor</span><span class="p">(</span><span class="n">Phi_Type</span><span class="p">,</span><span class="n">IndexType</span><span class="o">::</span><span class="n">TheCellType</span><span class="p">(),</span>
                           <span class="n">StateDescriptor</span><span class="o">::</span><span class="n">Point</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NUM_STATE</span><span class="p">,</span>
                           <span class="o">&amp;</span><span class="n">cell_cons_interp</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">lo_bc</span><span class="p">[</span><span class="n">BL_SPACEDIM</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">hi_bc</span><span class="p">[</span><span class="n">BL_SPACEDIM</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BL_SPACEDIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lo_bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hi_bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INT_DIR</span><span class="p">;</span>   <span class="c1">// periodic boundaries</span>
    <span class="p">}</span>

    <span class="n">BCRec</span> <span class="n">bc</span><span class="p">(</span><span class="n">lo_bc</span><span class="p">,</span> <span class="n">hi_bc</span><span class="p">);</span>

    <span class="n">StateDescriptor</span><span class="o">::</span><span class="n">BndryFunc</span> <span class="n">bndryfunc</span><span class="p">(</span><span class="n">nullfill</span><span class="p">);</span>
    <span class="n">bndryfunc</span><span class="p">.</span><span class="n">setRunOnGPU</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>  <span class="c1">// I promise the bc function will launch gpu kernels.</span>

    <span class="n">desc_lst</span><span class="p">.</span><span class="n">setComponent</span><span class="p">(</span><span class="n">Phi_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
                          <span class="n">bndryfunc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We see how to define the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">StateType</span></span></code>, including nodality, whether or not
we want the variable to represent a point in time or an interval over time
(useful for returning the time associated with data), the number of ghost
cells, number of components, and the interlevel interpolation (See
AMReX_Interpolator for various interpolation types). We also see how to specify
physical boundary functions by providing a function (in this case,
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">nullfill</span></span></code> since we are not using physical boundary conditions), where
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">nullfill</span></span></code> is defined in <code class="docutils literal notranslate"><span class="pre">Src/bc_nullfill.cpp</span></code> in the tutorial source
code.</p>
</div>
<div class="section" id="example-advection-amrlevel">
<h1>Example: Advection_AmrLevel<a class="headerlink" href="#example-advection-amrlevel" title="Permalink to this headline"></a></h1>
<p>The Advection_AmrLevel example is documented in detail
<a class="reference external" href="https://amrex-codes.github.io/amrex/tutorials_html/AMR_Tutorial.html#advection-amrlevel">here</a>
in the AMReX tutorial documentation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Src</span></code> subdirectory contains source code that is specific to this example. Most notably is the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevelAdv</span></span></code> class, which is derived from the base
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">AmrLevel</span></span></code> class, and the <code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LevelBldAdv</span></span></code> class, derived from the base
<code class="code cpp c++ docutils literal notranslate"><span class="name"><span class="pre">LevelBld</span></span></code> class as described above. The subdirectory <code class="docutils literal notranslate"><span class="pre">Src/Src_K</span></code> contain GPU kernels.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Exec</span></code> subdirectory contains two examples: <code class="docutils literal notranslate"><span class="pre">SingleVortex</span></code> and
<code class="docutils literal notranslate"><span class="pre">UniformVelocity</span></code>. Each subdirectory contains problem-specific source code
used for initialization using a Fortran subroutine (<code class="docutils literal notranslate"><span class="pre">Prob.f90</span></code>) and
specifying the velocity fields used in this simulation
(<code class="docutils literal notranslate"><span class="pre">face_velocity_2d_K.H</span></code> and <code class="docutils literal notranslate"><span class="pre">face_velocity_3d_K.H</span></code> for the 2-D and 3-D
problem, respectively). Build the code here by editing the <code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code>
and running <code class="docutils literal notranslate"><span class="pre">make</span></code>.</p>
<p>The pseudocode for the main program is given below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Advection_AmrLevel Pseudocode */</span>
<span class="n">main</span><span class="p">()</span>
  <span class="n">Amr</span> <span class="n">amr</span><span class="p">;</span>
  <span class="n">amr</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
  <span class="n">loop</span> <span class="p">{</span>
    <span class="n">amr</span><span class="p">.</span><span class="n">coarseTimeStep</span><span class="p">()</span>
      <span class="cm">/* compute dt */</span>
      <span class="n">timeStep</span><span class="p">()</span>
        <span class="n">amr_level</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">advance</span><span class="p">()</span>
        <span class="cm">/* call timeStep r times for next-finer level */</span>
        <span class="n">amr_level</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">post_timestep</span><span class="p">()</span> <span class="c1">// AMR synchronization</span>
      <span class="n">postCoarseTimeStep</span><span class="p">()</span>
      <span class="cm">/* write plotfile and checkpoint */</span>
  <span class="p">}</span>
  <span class="cm">/* write final plotfile and checkpoint */</span>
</pre></div>
</div>
</div>
<div class="section" id="particles">
<h1>Particles<a class="headerlink" href="#particles" title="Permalink to this headline"></a></h1>
<p>There is an option to turn on passively advected particles. In the
<code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code>, add the line <code class="docutils literal notranslate"><span class="pre">USE_PARTICLES</span> <span class="pre">=</span> <span class="pre">TRUE</span></code> and build the code
(do a <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">realclean</span> <span class="pre">first</span></code>).
In the inputs file, add the line <code class="docutils literal notranslate"><span class="pre">adv.do_tracers</span> <span class="pre">=</span> <span class="pre">1</span></code>.
When you run the code, within each plotfile directory there will be a
subdirectory called “Tracer”.</p>
<p>Copy the files from <code class="docutils literal notranslate"><span class="pre">amrex/Tools/Py_util/amrex_particles_to_vtp</span></code> into
the run directory and type, e.g.,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">python amrex_binary_particles_to_vtp.py plt00000 Tracer</span>
</pre></div>
</div>
<p>To generate a vtp file you can open with ParaView (Refer to the chapter on <a class="reference internal" href="Visualization_Chapter.html#chap-visualization"><span class="std std-ref">Visualization</span></a>).</p>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="AmrLevel_Chapter.html" class="btn btn-neutral float-left" title="Amr Source Code" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ForkJoin.html" class="btn btn-neutral float-right" title="Fork-Join" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2018, AMReX Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>