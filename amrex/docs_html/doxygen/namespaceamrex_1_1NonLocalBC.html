<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!--title>AMReX: amrex::NonLocalBC Namespace Reference</title-->
<title>AMReX: Block-Structured AMR Software Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="resize_AMReX_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Block-Structured AMR Software Framework
   </div>
   <!--div id="projectbrief">Block-Structured AMR Software Framework</div-->
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceamrex_1_1NonLocalBC.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">amrex::NonLocalBC Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceamrex_1_1NonLocalBC_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1HasInverseMemFn.html">HasInverseMemFn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that tests if T has an InverseImage class member function.  <a href="structamrex_1_1NonLocalBC_1_1HasInverseMemFn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1IsIndexMapping.html">IsIndexMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a given type IndexMap is usable as an index mapping between two index based coordinate systems.  <a href="structamrex_1_1NonLocalBC_1_1IsIndexMapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockIndexMapping.html">MultiBlockIndexMapping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct describes an affine index transformation for two coordinate systems.  <a href="structamrex_1_1NonLocalBC_1_1MultiBlockIndexMapping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData.html">MultiBlockCommMetaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the index mapping based on the DTOS MultiBlockDestToSrc.  <a href="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type trait tests if a type P is a projetion for FAB.  <a href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1Identity.html">Identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as a default no-op operator.  <a href="structamrex_1_1NonLocalBC_1_1Identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1MapComponents.html">MapComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class takes a projection and a component map and combines them to form a new projection.  <a href="structamrex_1_1NonLocalBC_1_1MapComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1SwapComponents.html">SwapComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a permutation where only two components are swapped.  <a href="structamrex_1_1NonLocalBC_1_1SwapComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1SwapComponents_3_01I_00_01-1_01_4.html">SwapComponents&lt; I, -1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1SwapComponents_3-1_00_01J_01_4.html">SwapComponents&lt;-1, J &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1SwapComponents_3-1_00_01-1_01_4.html">SwapComponents&lt;-1, -1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds data buffers for either immediate MPI send or recv calls.  <a href="structamrex_1_1NonLocalBC_1_1CommData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class stores both recv and send buffers with an associated MPI tag.  <a href="structamrex_1_1NonLocalBC_1_1CommHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1IsDataPacking.html">IsDataPacking</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type trait tests if a given type DP satisfies the DataPacking concept for type FAB.  <a href="structamrex_1_1NonLocalBC_1_1IsDataPacking.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about which components take part of the data transaction.  <a href="structamrex_1_1NonLocalBC_1_1PackComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever.html">ApplyDtosAndProjectionOnReciever</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class specializes behaviour on local copies and unpacking receive buffers.  <a href="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1NoLocalCopy.html">NoLocalCopy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1NonLocalBC_1_1DoLocalCopy.html">DoLocalCopy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a165fdced073fa98b961fd6aaceb213d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a165fdced073fa98b961fd6aaceb213d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a165fdced073fa98b961fd6aaceb213d5">Inverse_t</a> = decltype(std::declval&lt; T &gt;().Inverse(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:a165fdced073fa98b961fd6aaceb213d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of an InverseImage class member function.  <a href="namespaceamrex_1_1NonLocalBC.html#a165fdced073fa98b961fd6aaceb213d5">More...</a><br /></td></tr>
<tr class="separator:a165fdced073fa98b961fd6aaceb213d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc23e3a1b040b4f68b4429a2a40e00d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#adc23e3a1b040b4f68b4429a2a40e00d6">DynamicSwapComponents</a> = <a class="el" href="structamrex_1_1NonLocalBC_1_1SwapComponents.html">SwapComponents</a>&lt;-1, -1 &gt;</td></tr>
<tr class="separator:adc23e3a1b040b4f68b4429a2a40e00d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d38898e06da05aa7e4bfab9706f1f0"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa9d38898e06da05aa7e4bfab9706f1f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#aa9d38898e06da05aa7e4bfab9706f1f0">PrepareSendBuffers_t</a> = decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#a5e37435a999c0eb51e29139501d7ca49">PrepareSendBuffers</a>(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="separator:aa9d38898e06da05aa7e4bfab9706f1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac352232fe0363d175aaf2615666c8439"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac352232fe0363d175aaf2615666c8439"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ac352232fe0363d175aaf2615666c8439">PrepareRecvBuffers_t</a> = decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#a101b2f07560880fda8bab055214f3222">PrepareRecvBuffers</a>(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="separator:ac352232fe0363d175aaf2615666c8439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2457a717c906cb9f086a39faea4da88d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2457a717c906cb9f086a39faea4da88d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a2457a717c906cb9f086a39faea4da88d">PackSendBuffers_t</a> = decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#a291d1c78ece15e2eb717acc0ec36835d">PackSendBuffers</a>(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="separator:a2457a717c906cb9f086a39faea4da88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0050536eff7fd3244ef573e961858999"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0050536eff7fd3244ef573e961858999"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a0050536eff7fd3244ef573e961858999">UnpackRecvBuffers_t</a> = decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#a9dad3936d4a2ede70ac57d5d2d3b6e2e">UnpackRecvBuffers</a>(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="separator:a0050536eff7fd3244ef573e961858999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b44aa3d7a205826948ced4323d0be80"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4b44aa3d7a205826948ced4323d0be80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a4b44aa3d7a205826948ced4323d0be80">LocalCopy_t</a> = decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#ab719edc50f1af0377bb308024219baa3">LocalCopy</a>(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="separator:a4b44aa3d7a205826948ced4323d0be80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a303b8c034244500930c9f5ead86a22bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a303b8c034244500930c9f5ead86a22bf">PrepareCommBuffers</a> (<a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;comm, const <a class="el" href="classamrex_1_1FabArrayBase.html#aa36883196eb7b1d039fd1941966a4310">FabArrayBase::MapOfCopyComTagContainers</a> &amp;cctc, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> n_components, std::size_t object_size, std::size_t align)</td></tr>
<tr class="memdesc:a303b8c034244500930c9f5ead86a22bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill all class member variables of comm but the request and the stats vector.  <a href="namespaceamrex_1_1NonLocalBC.html#a303b8c034244500930c9f5ead86a22bf">More...</a><br /></td></tr>
<tr class="separator:a303b8c034244500930c9f5ead86a22bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62685cb385ba3363c973d758cbb7cde8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a62685cb385ba3363c973d758cbb7cde8">PostRecvs</a> (<a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;recv, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> mpi_tag)</td></tr>
<tr class="memdesc:a62685cb385ba3363c973d758cbb7cde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate all recvieves with MPI_Irecv calls associated with tag mpi_tag.  <a href="namespaceamrex_1_1NonLocalBC.html#a62685cb385ba3363c973d758cbb7cde8">More...</a><br /></td></tr>
<tr class="separator:a62685cb385ba3363c973d758cbb7cde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccb53a5bfee4c68f588b17d3642c2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a5ccb53a5bfee4c68f588b17d3642c2c5">PostSends</a> (<a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;send, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> mpi_tag)</td></tr>
<tr class="memdesc:a5ccb53a5bfee4c68f588b17d3642c2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate all sends with MPI_Isend calls associated with tag mpi_tag.  <a href="namespaceamrex_1_1NonLocalBC.html#a5ccb53a5bfee4c68f588b17d3642c2c5">More...</a><br /></td></tr>
<tr class="separator:a5ccb53a5bfee4c68f588b17d3642c2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11bf269e7aebae89bdc5d7d178bb12f"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData.html">MultiBlockCommMetaData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ab11bf269e7aebae89bdc5d7d178bb12f">ParallelCopy</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; <a class="el" href="classamrex_1_1FArrayBox.html">FArrayBox</a> &gt; &amp;dest, const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;destbox, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; <a class="el" href="classamrex_1_1FArrayBox.html">FArrayBox</a> &gt; &amp;src, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> destcomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> srccomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> numcomp, const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;ngrow, <a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockIndexMapping.html">MultiBlockIndexMapping</a> const &amp;, <a class="el" href="structamrex_1_1NonLocalBC_1_1Identity.html">Identity</a> const &amp;)</td></tr>
<tr class="separator:ab11bf269e7aebae89bdc5d7d178bb12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d136063b9c85d97111978faff29c87"><td class="memTemplParams" colspan="2">template&lt;typename DTOS &gt; </td></tr>
<tr class="memitem:a56d136063b9c85d97111978faff29c87"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;::value, <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a56d136063b9c85d97111978faff29c87">Apply</a> (DTOS const &amp;dtos, const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;iv)</td></tr>
<tr class="memdesc:a56d136063b9c85d97111978faff29c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto IntVects.  <a href="namespaceamrex_1_1NonLocalBC.html#a56d136063b9c85d97111978faff29c87">More...</a><br /></td></tr>
<tr class="separator:a56d136063b9c85d97111978faff29c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f43ddf52003ccef3fd4189be4b4e26a"><td class="memTemplParams" colspan="2">template&lt;typename DTOS &gt; </td></tr>
<tr class="memitem:a7f43ddf52003ccef3fd4189be4b4e26a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;::value &amp;&amp;!<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="classamrex_1_1IndexType.html">IndexType</a>, DTOS, <a class="el" href="classamrex_1_1IndexType.html">IndexType</a> &gt;::value, <a class="el" href="classamrex_1_1Box.html">Box</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a7f43ddf52003ccef3fd4189be4b4e26a">Image</a> (DTOS const &amp;dtos, const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr class="memdesc:a7f43ddf52003ccef3fd4189be4b4e26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto Boxes but does not change the index type.  <a href="namespaceamrex_1_1NonLocalBC.html#a7f43ddf52003ccef3fd4189be4b4e26a">More...</a><br /></td></tr>
<tr class="separator:a7f43ddf52003ccef3fd4189be4b4e26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc017cb71584ee0d0505c7ecf92a79de"><td class="memTemplParams" colspan="2">template&lt;typename DTOS &gt; </td></tr>
<tr class="memitem:afc017cb71584ee0d0505c7ecf92a79de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;::value &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="classamrex_1_1IndexType.html">IndexType</a>, DTOS, <a class="el" href="classamrex_1_1IndexType.html">IndexType</a> &gt;::value, <a class="el" href="classamrex_1_1Box.html">Box</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#afc017cb71584ee0d0505c7ecf92a79de">Image</a> (DTOS const &amp;dtos, const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr class="memdesc:afc017cb71584ee0d0505c7ecf92a79de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto Boxes and maps the index type.  <a href="namespaceamrex_1_1NonLocalBC.html#afc017cb71584ee0d0505c7ecf92a79de">More...</a><br /></td></tr>
<tr class="separator:afc017cb71584ee0d0505c7ecf92a79de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f58b54718389e636ab3b07295eebac"><td class="memTemplParams" colspan="2">template&lt;typename DTOS &gt; </td></tr>
<tr class="memitem:a72f58b54718389e636ab3b07295eebac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1NonLocalBC_1_1HasInverseMemFn.html">HasInverseMemFn</a>&lt; DTOS &gt;::value, <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a72f58b54718389e636ab3b07295eebac">ApplyInverse</a> (DTOS const &amp;dtos, const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;iv)</td></tr>
<tr class="memdesc:a72f58b54718389e636ab3b07295eebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> invserse mapping onto IntVects.  <a href="namespaceamrex_1_1NonLocalBC.html#a72f58b54718389e636ab3b07295eebac">More...</a><br /></td></tr>
<tr class="separator:a72f58b54718389e636ab3b07295eebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab444df90b90c40442170ef5db4b0bea1"><td class="memTemplParams" colspan="2">template&lt;typename DTOS &gt; </td></tr>
<tr class="memitem:ab444df90b90c40442170ef5db4b0bea1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1NonLocalBC_1_1HasInverseMemFn.html">HasInverseMemFn</a>&lt; DTOS &gt;::value &amp;&amp;!<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="classamrex_1_1IndexType.html">IndexType</a>, DTOS, <a class="el" href="classamrex_1_1IndexType.html">IndexType</a> &gt;::value, <a class="el" href="classamrex_1_1Box.html">Box</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ab444df90b90c40442170ef5db4b0bea1">InverseImage</a> (DTOS const &amp;dtos, const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr class="memdesc:ab444df90b90c40442170ef5db4b0bea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the inverse <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto Boxes without changing the index type.  <a href="namespaceamrex_1_1NonLocalBC.html#ab444df90b90c40442170ef5db4b0bea1">More...</a><br /></td></tr>
<tr class="separator:ab444df90b90c40442170ef5db4b0bea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad979c6dbf27225b1f20a986185e2977b"><td class="memTemplParams" colspan="2">template&lt;typename DTOS &gt; </td></tr>
<tr class="memitem:ad979c6dbf27225b1f20a986185e2977b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1NonLocalBC_1_1HasInverseMemFn.html">HasInverseMemFn</a>&lt; DTOS &gt;::value &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="classamrex_1_1IndexType.html">IndexType</a>, DTOS, <a class="el" href="classamrex_1_1IndexType.html">IndexType</a> &gt;::value, <a class="el" href="classamrex_1_1Box.html">Box</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ad979c6dbf27225b1f20a986185e2977b">InverseImage</a> (DTOS const &amp;dtos, const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr class="memdesc:ad979c6dbf27225b1f20a986185e2977b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the inverse <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto Boxes.  <a href="namespaceamrex_1_1NonLocalBC.html#ad979c6dbf27225b1f20a986185e2977b">More...</a><br /></td></tr>
<tr class="separator:ad979c6dbf27225b1f20a986185e2977b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd3a3fb3e0b792ebdb724cc5725176d"><td class="memTemplParams" colspan="2">template&lt;class FAB , class DTOS  = Identity, class Proj  = Identity&gt; </td></tr>
<tr class="memitem:a3cd3a3fb3e0b792ebdb724cc5725176d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a3cd3a3fb3e0b792ebdb724cc5725176d">local_copy_cpu</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> dcomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> const &amp;local_tags, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{}) noexcept</td></tr>
<tr class="separator:a3cd3a3fb3e0b792ebdb724cc5725176d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4039bcfeee7e444019168686df8dfe36"><td class="memTemplParams" colspan="2">template&lt;class FAB , class DTOS  = Identity, class Proj  = Identity&gt; </td></tr>
<tr class="memitem:a4039bcfeee7e444019168686df8dfe36"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a4039bcfeee7e444019168686df8dfe36">unpack_recv_buffer_cpu</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> dcomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; char * &gt; const &amp;recv_data, <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; std::size_t &gt; const &amp;recv_size, <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> const * &gt; const &amp;recv_cctc, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{}) noexcept</td></tr>
<tr class="separator:a4039bcfeee7e444019168686df8dfe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea4e6f4775e59312efdc7e5e42788c3"><td class="memTemplParams" colspan="2">template&lt;class FAB , class DTOS  = Identity, class Proj  = Identity&gt; </td></tr>
<tr class="memitem:a4ea4e6f4775e59312efdc7e5e42788c3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a4ea4e6f4775e59312efdc7e5e42788c3">local_copy_gpu</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> dcomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> const &amp;local_tags, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{}) noexcept</td></tr>
<tr class="separator:a4ea4e6f4775e59312efdc7e5e42788c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a98a57dd1e0440eac5dee97d79d326"><td class="memTemplParams" colspan="2">template&lt;class FAB , class DTOS  = Identity, class Proj  = Identity&gt; </td></tr>
<tr class="memitem:ab6a98a57dd1e0440eac5dee97d79d326"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ab6a98a57dd1e0440eac5dee97d79d326">unpack_recv_buffer_gpu</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; char * &gt; const &amp;recv_data, <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; std::size_t &gt; const &amp;recv_size, <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> const * &gt; const &amp;recv_cctc, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</td></tr>
<tr class="separator:ab6a98a57dd1e0440eac5dee97d79d326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab719edc50f1af0377bb308024219baa3"><td class="memTemplParams" colspan="2">template&lt;typename FAB &gt; </td></tr>
<tr class="memitem:ab719edc50f1af0377bb308024219baa3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ab719edc50f1af0377bb308024219baa3">LocalCopy</a> (const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;components, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, const <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> &amp;local_tags)</td></tr>
<tr class="memdesc:ab719edc50f1af0377bb308024219baa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch local copies to the default behaviour that knows no DTOS nor projection.  <a href="namespaceamrex_1_1NonLocalBC.html#ab719edc50f1af0377bb308024219baa3">More...</a><br /></td></tr>
<tr class="separator:ab719edc50f1af0377bb308024219baa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37435a999c0eb51e29139501d7ca49"><td class="memTemplParams" colspan="2">template&lt;typename FAB &gt; </td></tr>
<tr class="memitem:a5e37435a999c0eb51e29139501d7ca49"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a5e37435a999c0eb51e29139501d7ca49">PrepareSendBuffers</a> (const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;components, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, <a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;comm, const <a class="el" href="classamrex_1_1FabArrayBase.html#aa36883196eb7b1d039fd1941966a4310">FabArrayBase::MapOfCopyComTagContainers</a> &amp;cctc)</td></tr>
<tr class="memdesc:a5e37435a999c0eb51e29139501d7ca49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls PrepareComBuffers.  <a href="namespaceamrex_1_1NonLocalBC.html#a5e37435a999c0eb51e29139501d7ca49">More...</a><br /></td></tr>
<tr class="separator:a5e37435a999c0eb51e29139501d7ca49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101b2f07560880fda8bab055214f3222"><td class="memTemplParams" colspan="2">template&lt;typename FAB &gt; </td></tr>
<tr class="memitem:a101b2f07560880fda8bab055214f3222"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a101b2f07560880fda8bab055214f3222">PrepareRecvBuffers</a> (const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;components, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, <a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;comm, const <a class="el" href="classamrex_1_1FabArrayBase.html#aa36883196eb7b1d039fd1941966a4310">FabArrayBase::MapOfCopyComTagContainers</a> &amp;cctc)</td></tr>
<tr class="memdesc:a101b2f07560880fda8bab055214f3222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls PrepareComBuffers.  <a href="namespaceamrex_1_1NonLocalBC.html#a101b2f07560880fda8bab055214f3222">More...</a><br /></td></tr>
<tr class="separator:a101b2f07560880fda8bab055214f3222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291d1c78ece15e2eb717acc0ec36835d"><td class="memTemplParams" colspan="2">template&lt;typename FAB &gt; </td></tr>
<tr class="memitem:a291d1c78ece15e2eb717acc0ec36835d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a291d1c78ece15e2eb717acc0ec36835d">PackSendBuffers</a> (const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;components, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, <a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;send)</td></tr>
<tr class="memdesc:a291d1c78ece15e2eb717acc0ec36835d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes FAB data without any knowledge of a DTOS nor a projection.  <a href="namespaceamrex_1_1NonLocalBC.html#a291d1c78ece15e2eb717acc0ec36835d">More...</a><br /></td></tr>
<tr class="separator:a291d1c78ece15e2eb717acc0ec36835d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dad3936d4a2ede70ac57d5d2d3b6e2e"><td class="memTemplParams" colspan="2">template&lt;typename FAB &gt; </td></tr>
<tr class="memitem:a9dad3936d4a2ede70ac57d5d2d3b6e2e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a9dad3936d4a2ede70ac57d5d2d3b6e2e">UnpackRecvBuffers</a> (const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;components, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;recv)</td></tr>
<tr class="memdesc:a9dad3936d4a2ede70ac57d5d2d3b6e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-serializes FAB data without any knowledge of a DTOS nor a projection.  <a href="namespaceamrex_1_1NonLocalBC.html#a9dad3936d4a2ede70ac57d5d2d3b6e2e">More...</a><br /></td></tr>
<tr class="separator:a9dad3936d4a2ede70ac57d5d2d3b6e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa70005c1319e11f11266ae94abe4bb"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS , typename FabProj &gt; </td></tr>
<tr class="memitem:a0fa70005c1319e11f11266ae94abe4bb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a0fa70005c1319e11f11266ae94abe4bb">LocalCopy</a> (const <a class="el" href="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever.html">ApplyDtosAndProjectionOnReciever</a>&lt; DTOS, FabProj &gt; &amp;packing, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, const <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> &amp;local_tags)</td></tr>
<tr class="memdesc:a0fa70005c1319e11f11266ae94abe4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do local copies of FABs using DTOS and projection.  <a href="namespaceamrex_1_1NonLocalBC.html#a0fa70005c1319e11f11266ae94abe4bb">More...</a><br /></td></tr>
<tr class="separator:a0fa70005c1319e11f11266ae94abe4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1af16f3ccbf44b758a852b190bedd33"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS , typename FabProj &gt; </td></tr>
<tr class="memitem:ab1af16f3ccbf44b758a852b190bedd33"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ab1af16f3ccbf44b758a852b190bedd33">UnpackRecvBuffers</a> (const <a class="el" href="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever.html">ApplyDtosAndProjectionOnReciever</a>&lt; DTOS, FabProj &gt; &amp;packing, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;recv)</td></tr>
<tr class="memdesc:ab1af16f3ccbf44b758a852b190bedd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from received data in the buffer to destination FABs using DTOS and projection.  <a href="namespaceamrex_1_1NonLocalBC.html#ab1af16f3ccbf44b758a852b190bedd33">More...</a><br /></td></tr>
<tr class="separator:ab1af16f3ccbf44b758a852b190bedd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf19b06a9bab53ac6dea6bfa875af9d"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DataPacking , typename  = std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;, typename  = std::enable_if_t&lt;IsDataPacking&lt;DataPacking, FAB&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7bf19b06a9bab53ac6dea6bfa875af9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="AMReX__Extension_8H.html#a8cfb0291f150c6676f99a0b6c4578717">AMREX_NODISCARD</a> <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a7bf19b06a9bab53ac6dea6bfa875af9d">ParallelCopy_nowait</a> (<a class="el" href="structamrex_1_1NonLocalBC_1_1NoLocalCopy.html">NoLocalCopy</a>, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, const DataPacking &amp;data_packing)</td></tr>
<tr class="separator:a7bf19b06a9bab53ac6dea6bfa875af9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dca62d2b38257c9da61d6a1f0ed9d8"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DataPacking , typename  = std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;, typename  = std::enable_if_t&lt;IsDataPacking&lt;DataPacking, FAB&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a57dca62d2b38257c9da61d6a1f0ed9d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="AMReX__Extension_8H.html#a8cfb0291f150c6676f99a0b6c4578717">AMREX_NODISCARD</a> <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a57dca62d2b38257c9da61d6a1f0ed9d8">ParallelCopy_nowait</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, const DataPacking &amp;data_packing)</td></tr>
<tr class="separator:a57dca62d2b38257c9da61d6a1f0ed9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fb0add78ab242015474585b0f7207e"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DataPacking &gt; </td></tr>
<tr class="memitem:a51fb0add78ab242015474585b0f7207e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsDataPacking.html">IsDataPacking</a>&lt; DataPacking, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a51fb0add78ab242015474585b0f7207e">ParallelCopy_finish</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a> handler, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, const DataPacking &amp;data_packing)</td></tr>
<tr class="separator:a51fb0add78ab242015474585b0f7207e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f46a71c7807b33fa3fac96c36e8d09b"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DataPacking &gt; </td></tr>
<tr class="memitem:a7f46a71c7807b33fa3fac96c36e8d09b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsDataPacking.html">IsDataPacking</a>&lt; DataPacking, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a7f46a71c7807b33fa3fac96c36e8d09b">ParallelCopy_finish</a> (<a class="el" href="structamrex_1_1NonLocalBC_1_1DoLocalCopy.html">DoLocalCopy</a>, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a> handler, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, const DataPacking &amp;data_packing)</td></tr>
<tr class="separator:a7f46a71c7807b33fa3fac96c36e8d09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2fff17888a770c492a1c014fee2b73"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS  = Identity, typename Proj  = Identity&gt; </td></tr>
<tr class="memitem:a9c2fff17888a770c492a1c014fee2b73"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a9c2fff17888a770c492a1c014fee2b73">ParallelCopy</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, <a class="el" href="structamrex_1_1SrcComp.html">SrcComp</a> srccomp, <a class="el" href="structamrex_1_1DestComp.html">DestComp</a> destcomp, <a class="el" href="structamrex_1_1NumComps.html">NumComps</a> numcomp, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</td></tr>
<tr class="memdesc:a9c2fff17888a770c492a1c014fee2b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call ParallelCopy_nowait followed by ParallelCopy_finish, strong typed version.  <a href="namespaceamrex_1_1NonLocalBC.html#a9c2fff17888a770c492a1c014fee2b73">More...</a><br /></td></tr>
<tr class="separator:a9c2fff17888a770c492a1c014fee2b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5984b6f2bffd16fd4a1737326e32aef0"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS  = Identity, typename Proj  = Identity&gt; </td></tr>
<tr class="memitem:a5984b6f2bffd16fd4a1737326e32aef0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a5984b6f2bffd16fd4a1737326e32aef0">ParallelCopy</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> srccomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> destcomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> numcomp, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</td></tr>
<tr class="memdesc:a5984b6f2bffd16fd4a1737326e32aef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call ParallelCopy_nowait followed by ParallelCopy_finish.  <a href="namespaceamrex_1_1NonLocalBC.html#a5984b6f2bffd16fd4a1737326e32aef0">More...</a><br /></td></tr>
<tr class="separator:a5984b6f2bffd16fd4a1737326e32aef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc887605744ff53411090ea98c15a04"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS  = Identity, typename Proj  = Identity&gt; </td></tr>
<tr class="memitem:aedc887605744ff53411090ea98c15a04"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsIndexMapping.html">IsIndexMapping</a>&lt; DTOS &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;), <a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData.html">MultiBlockCommMetaData</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#aedc887605744ff53411090ea98c15a04">ParallelCopy</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;destbox, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, <a class="el" href="structamrex_1_1SrcComp.html">SrcComp</a> srccomp, <a class="el" href="structamrex_1_1DestComp.html">DestComp</a> destcomp, <a class="el" href="structamrex_1_1NumComps.html">NumComps</a> numcomp, const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;ngrow, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</td></tr>
<tr class="memdesc:aedc887605744ff53411090ea98c15a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call ParallelCopy_nowait followed by ParallelCopy_finish, strong typed version.  <a href="namespaceamrex_1_1NonLocalBC.html#aedc887605744ff53411090ea98c15a04">More...</a><br /></td></tr>
<tr class="separator:aedc887605744ff53411090ea98c15a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af874a9f4652076f42120db672af7f447"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS  = Identity, typename Proj  = Identity&gt; </td></tr>
<tr class="memitem:af874a9f4652076f42120db672af7f447"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsIndexMapping.html">IsIndexMapping</a>&lt; DTOS &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;), <a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData.html">MultiBlockCommMetaData</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#af874a9f4652076f42120db672af7f447">ParallelCopy</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;dest, const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;destbox, const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;src, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> srccomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> destcomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> numcomp, const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;ngrow, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</td></tr>
<tr class="memdesc:af874a9f4652076f42120db672af7f447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call ParallelCopy_nowait followed by ParallelCopy_finish.  <a href="namespaceamrex_1_1NonLocalBC.html#af874a9f4652076f42120db672af7f447">More...</a><br /></td></tr>
<tr class="separator:af874a9f4652076f42120db672af7f447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9ef1abd51b6a59a2938c4aefbe3456"><td class="memTemplParams" colspan="2">template&lt;class FAB &gt; </td></tr>
<tr class="memitem:a2d9ef1abd51b6a59a2938c4aefbe3456"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a2d9ef1abd51b6a59a2938c4aefbe3456">Rotate90</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> const &amp;nghost, <a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;domain)</td></tr>
<tr class="separator:a2d9ef1abd51b6a59a2938c4aefbe3456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33354739811ccff59e69722da63a9f5c"><td class="memTemplParams" colspan="2">template&lt;class FAB &gt; </td></tr>
<tr class="memitem:a33354739811ccff59e69722da63a9f5c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a33354739811ccff59e69722da63a9f5c">Rotate90</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;domain)</td></tr>
<tr class="separator:a33354739811ccff59e69722da63a9f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b23e1690efb2d7f63af0118739d12e"><td class="memTemplParams" colspan="2">template&lt;class FAB &gt; </td></tr>
<tr class="memitem:a35b23e1690efb2d7f63af0118739d12e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a35b23e1690efb2d7f63af0118739d12e">Rotate180</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> const &amp;nghost, <a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;domain)</td></tr>
<tr class="separator:a35b23e1690efb2d7f63af0118739d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b5ad1aeccc1b34a6874b4609654e14"><td class="memTemplParams" colspan="2">template&lt;class FAB &gt; </td></tr>
<tr class="memitem:ad6b5ad1aeccc1b34a6874b4609654e14"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ad6b5ad1aeccc1b34a6874b4609654e14">Rotate180</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;domain)</td></tr>
<tr class="separator:ad6b5ad1aeccc1b34a6874b4609654e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22290d0dc38cd0254f5d14100fec970f"><td class="memTemplParams" colspan="2">template&lt;class FAB &gt; </td></tr>
<tr class="memitem:a22290d0dc38cd0254f5d14100fec970f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a22290d0dc38cd0254f5d14100fec970f">FillPolar</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> const &amp;nghost, <a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;domain)</td></tr>
<tr class="separator:a22290d0dc38cd0254f5d14100fec970f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569fc178d4aad983c5bdd14a8f69127e"><td class="memTemplParams" colspan="2">template&lt;class FAB &gt; </td></tr>
<tr class="memitem:a569fc178d4aad983c5bdd14a8f69127e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a569fc178d4aad983c5bdd14a8f69127e">FillPolar</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;domain)</td></tr>
<tr class="separator:a569fc178d4aad983c5bdd14a8f69127e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1089b238bcca4ae52a70fd9bdf8518e"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS , typename Proj  = Identity&gt; </td></tr>
<tr class="memitem:ab1089b238bcca4ae52a70fd9bdf8518e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;), <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ab1089b238bcca4ae52a70fd9bdf8518e">FillBoundary_nowait</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, DTOS const &amp;dtos, Proj const &amp;proj=Proj{})</td></tr>
<tr class="memdesc:ab1089b238bcca4ae52a70fd9bdf8518e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start communication to fill boundary.  <a href="namespaceamrex_1_1NonLocalBC.html#ab1089b238bcca4ae52a70fd9bdf8518e">More...</a><br /></td></tr>
<tr class="separator:ab1089b238bcca4ae52a70fd9bdf8518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe22ad727872227b4f95e3dad1e36814"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS , typename Proj  = Identity&gt; </td></tr>
<tr class="memitem:afe22ad727872227b4f95e3dad1e36814"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#afe22ad727872227b4f95e3dad1e36814">FillBoundary_finish</a> (<a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a> handler, <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, DTOS const &amp;dtos, Proj const &amp;proj=Proj{})</td></tr>
<tr class="memdesc:afe22ad727872227b4f95e3dad1e36814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish communication started by FillBoundary_nowait.  <a href="namespaceamrex_1_1NonLocalBC.html#afe22ad727872227b4f95e3dad1e36814">More...</a><br /></td></tr>
<tr class="separator:afe22ad727872227b4f95e3dad1e36814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc89a1b931348146e70b8e54e95ffd41"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS , typename Proj  = Identity&gt; </td></tr>
<tr class="memitem:afc89a1b931348146e70b8e54e95ffd41"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;) &amp;&amp;<a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt; Proj, FAB &gt;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#afc89a1b931348146e70b8e54e95ffd41">FillBoundary</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;cmd, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> scomp, <a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a> ncomp, DTOS const &amp;dtos, Proj const &amp;proj=Proj{})</td></tr>
<tr class="memdesc:afc89a1b931348146e70b8e54e95ffd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill ghost cells for FabArray/MultiFab.  <a href="namespaceamrex_1_1NonLocalBC.html#afc89a1b931348146e70b8e54e95ffd41">More...</a><br /></td></tr>
<tr class="separator:afc89a1b931348146e70b8e54e95ffd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273df272494afdcf1d9275ab5ed13e77"><td class="memTemplParams" colspan="2">template&lt;typename FAB , typename DTOS &gt; </td></tr>
<tr class="memitem:a273df272494afdcf1d9275ab5ed13e77"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; FAB &gt;) &amp;&amp;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt; <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> &gt;), <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a273df272494afdcf1d9275ab5ed13e77">makeFillBoundaryMetaData</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;mf, <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> const &amp;nghost, <a class="el" href="classamrex_1_1Geometry.html">Geometry</a> const &amp;geom, DTOS const &amp;dtos)</td></tr>
<tr class="memdesc:a273df272494afdcf1d9275ab5ed13e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make metadata for FillBoundary.  <a href="namespaceamrex_1_1NonLocalBC.html#a273df272494afdcf1d9275ab5ed13e77">More...</a><br /></td></tr>
<tr class="separator:a273df272494afdcf1d9275ab5ed13e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abb7cd050d6dd1aef7603048eeccd7ded"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structamrex_1_1NonLocalBC_1_1Identity.html">Identity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#abb7cd050d6dd1aef7603048eeccd7ded">identity</a> {}</td></tr>
<tr class="separator:abb7cd050d6dd1aef7603048eeccd7ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618f8d1f0b1258ad4931eb6a5ae65ebc"><td class="memTemplParams" colspan="2">template&lt;int I, int J&gt; </td></tr>
<tr class="memitem:a618f8d1f0b1258ad4931eb6a5ae65ebc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="structamrex_1_1NonLocalBC_1_1SwapComponents.html">SwapComponents</a>&lt; I, J &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#a618f8d1f0b1258ad4931eb6a5ae65ebc">swap_indices</a> {}</td></tr>
<tr class="separator:a618f8d1f0b1258ad4931eb6a5ae65ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad604544d2fd60b6d9fb7a8b75f95ffe0"><td class="memItemLeft" align="right" valign="top">static constexpr struct <a class="el" href="structamrex_1_1NonLocalBC_1_1NoLocalCopy.html">amrex::NonLocalBC::NoLocalCopy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#ad604544d2fd60b6d9fb7a8b75f95ffe0">no_local_copy</a></td></tr>
<tr class="separator:ad604544d2fd60b6d9fb7a8b75f95ffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0174cdbe72e2968e46f0293c2ecab73"><td class="memItemLeft" align="right" valign="top">static constexpr struct <a class="el" href="structamrex_1_1NonLocalBC_1_1DoLocalCopy.html">amrex::NonLocalBC::DoLocalCopy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamrex_1_1NonLocalBC.html#aa0174cdbe72e2968e46f0293c2ecab73">do_local_copy</a></td></tr>
<tr class="separator:aa0174cdbe72e2968e46f0293c2ecab73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adc23e3a1b040b4f68b4429a2a40e00d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc23e3a1b040b4f68b4429a2a40e00d6">&#9670;&nbsp;</a></span>DynamicSwapComponents</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceamrex_1_1NonLocalBC.html#adc23e3a1b040b4f68b4429a2a40e00d6">amrex::NonLocalBC::DynamicSwapComponents</a> = typedef <a class="el" href="structamrex_1_1NonLocalBC_1_1SwapComponents.html">SwapComponents</a>&lt;-1, -1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a165fdced073fa98b961fd6aaceb213d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165fdced073fa98b961fd6aaceb213d5">&#9670;&nbsp;</a></span>Inverse_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceamrex_1_1NonLocalBC.html#a165fdced073fa98b961fd6aaceb213d5">amrex::NonLocalBC::Inverse_t</a> = typedef decltype(std::declval&lt;T&gt;().Inverse(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type of an InverseImage class member function. </p>

</div>
</div>
<a id="a4b44aa3d7a205826948ced4323d0be80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b44aa3d7a205826948ced4323d0be80">&#9670;&nbsp;</a></span>LocalCopy_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceamrex_1_1NonLocalBC.html#a4b44aa3d7a205826948ced4323d0be80">amrex::NonLocalBC::LocalCopy_t</a> = typedef decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#ab719edc50f1af0377bb308024219baa3">LocalCopy</a>(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2457a717c906cb9f086a39faea4da88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2457a717c906cb9f086a39faea4da88d">&#9670;&nbsp;</a></span>PackSendBuffers_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceamrex_1_1NonLocalBC.html#a2457a717c906cb9f086a39faea4da88d">amrex::NonLocalBC::PackSendBuffers_t</a> = typedef decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#a291d1c78ece15e2eb717acc0ec36835d">PackSendBuffers</a>(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac352232fe0363d175aaf2615666c8439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac352232fe0363d175aaf2615666c8439">&#9670;&nbsp;</a></span>PrepareRecvBuffers_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceamrex_1_1NonLocalBC.html#ac352232fe0363d175aaf2615666c8439">amrex::NonLocalBC::PrepareRecvBuffers_t</a> = typedef decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#a101b2f07560880fda8bab055214f3222">PrepareRecvBuffers</a>(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9d38898e06da05aa7e4bfab9706f1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d38898e06da05aa7e4bfab9706f1f0">&#9670;&nbsp;</a></span>PrepareSendBuffers_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceamrex_1_1NonLocalBC.html#aa9d38898e06da05aa7e4bfab9706f1f0">amrex::NonLocalBC::PrepareSendBuffers_t</a> = typedef decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#a5e37435a999c0eb51e29139501d7ca49">PrepareSendBuffers</a>(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0050536eff7fd3244ef573e961858999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0050536eff7fd3244ef573e961858999">&#9670;&nbsp;</a></span>UnpackRecvBuffers_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceamrex_1_1NonLocalBC.html#a0050536eff7fd3244ef573e961858999">amrex::NonLocalBC::UnpackRecvBuffers_t</a> = typedef decltype(<a class="el" href="namespaceamrex_1_1NonLocalBC.html#a9dad3936d4a2ede70ac57d5d2d3b6e2e">UnpackRecvBuffers</a>(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a56d136063b9c85d97111978faff29c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d136063b9c85d97111978faff29c87">&#9670;&nbsp;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DTOS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;::value, <a class="el" href="classamrex_1_1IntVect.html">IntVect</a>&gt; amrex::NonLocalBC::Apply </td>
          <td>(</td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto IntVects. </p>
<p>This is used to map indices from the dest index space into the source index space.</p>
<p><a class="el" href="classamrex_1_1IntVect.html">IntVect</a> is being embedded in <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> by trailing zeros. <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> is being projected to <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> by dopping z for AMREX_SPACEDIM = 2 or z and y components for AMREX_SPACEDIM = 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>The <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> that lives in the destination index space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="classamrex_1_1IntVect.html">IntVect</a>{dtos(<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>{iv})} </dd></dl>

</div>
</div>
<a id="a72f58b54718389e636ab3b07295eebac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f58b54718389e636ab3b07295eebac">&#9670;&nbsp;</a></span>ApplyInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DTOS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1NonLocalBC_1_1HasInverseMemFn.html">HasInverseMemFn</a>&lt;DTOS&gt;::value, <a class="el" href="classamrex_1_1IntVect.html">IntVect</a>&gt; amrex::NonLocalBC::ApplyInverse </td>
          <td>(</td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> invserse mapping onto IntVects. </p>
<p>This is used to map indices from the src index space into the dest index space.</p>
<p><a class="el" href="classamrex_1_1IntVect.html">IntVect</a> is being embedded in <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> by trailing zeros. <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> is being projected to <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> by dopping z for AMREX_SPACEDIM = 2 or z and y components for AMREX_SPACEDIM = 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>The <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> that lives in the src index space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="classamrex_1_1IntVect.html">IntVect</a>{dtos.Inverse(<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>{iv})} </dd></dl>

</div>
</div>
<a id="afc89a1b931348146e70b8e54e95ffd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc89a1b931348146e70b8e54e95ffd41">&#9670;&nbsp;</a></span>FillBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS , typename Proj  = Identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>,DTOS,<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj,FAB&gt;)&gt; amrex::NonLocalBC::FillBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill ghost cells for FabArray/MultiFab. </p>
<p>This fills ghost cells of a <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>. This function is supposed to be used together with makeFillBoundaryMetaData as follows. </p><pre class="fragment">    auto cmd = makeFillBoundaryMetaData(mf, mf.nGrowVect, geom, dtos);
    // The metadata cmd can be cached and reused on a MultiFab/FabArray with
    // the same BoxArray and DistributionMapping.
    FillBoundary_finish(mf, cmd, scomp, ncomp, dtos, proj);
</pre><p>The FillBoundary capability here is more flexible than <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>'s FillBoundary member functions, which only fill ghost cells inside the domain and ghost cells at periodic boundaries. The FillBoundary here can be used to fill non-local domain boundaries (e.g., in spherical and cylindrical coordinates) given appropriate index and component mappings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FAB</td><td>MultiFab/FabArray type </td></tr>
    <tr><td class="paramname">DTOS</td><td>Index mapping from destination from source. See SphThetaPhiRIndexMapping for an example. </td></tr>
    <tr><td class="paramname">Proj</td><td>Component mapping from source to destination. See SphThetaPhiRComponentMapping for an example.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>FabArray/MultiFab whose ghost cells need to be filled. </td></tr>
    <tr><td class="paramname">cmd</td><td>communication metadata. </td></tr>
    <tr><td class="paramname">scomp</td><td>starting component. </td></tr>
    <tr><td class="paramname">ncomp</td><td>number of components. </td></tr>
    <tr><td class="paramname">dtos</td><td>index mapping. </td></tr>
    <tr><td class="paramname">proj</td><td>component mapping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe22ad727872227b4f95e3dad1e36814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe22ad727872227b4f95e3dad1e36814">&#9670;&nbsp;</a></span>FillBoundary_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS , typename Proj  = Identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>,DTOS,<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj,FAB&gt;)&gt; amrex::NonLocalBC::FillBoundary_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish communication started by FillBoundary_nowait. </p>
<p>This finishes the communication to fill ghost cells of a <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>. This function is supposed to be used together with FillBoundary_nowait and makeFillBoundaryMetaData as follows. </p><pre class="fragment">    auto cmd = makeFillBoundaryMetaData(mf, mf.nGrowVect, geom, dtos);
    // The metadata cmd can be cached and reused on a MultiFab/FabArray with
    // the same BoxArray and DistributionMapping.
    auto handler = FillBoundary_nowait(mf, cmd, scomp, ncomp, dtos, proj);
    // Independent computation can be performed.
    FillBoundary_finish(std::move(handler), mf, cmd, scomp, ncomp, dtos, proj);
</pre><p>The FillBoundary capability here is more flexible than <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>'s FillBoundary member functions, which only fill ghost cells inside the domain and ghost cells at periodic boundaries. The FillBoundary here can be used to fill non-local domain boundaries (e.g., in spherical and cylindrical coordinates) given appropriate index and component mappings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FAB</td><td>MultiFab/FabArray type </td></tr>
    <tr><td class="paramname">DTOS</td><td>Index mapping from destination from source. See SphThetaPhiRIndexMapping for an example. </td></tr>
    <tr><td class="paramname">Proj</td><td>Component mapping from source to destination. See SphThetaPhiRComponentMapping for an example.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td><a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html" title="This class stores both recv and send buffers with an associated MPI tag.">CommHandler</a> returned by FillBoundary_nowait. </td></tr>
    <tr><td class="paramname">mf</td><td>FabArray/MultiFab whose ghost cells need to be filled. </td></tr>
    <tr><td class="paramname">cmd</td><td>communication metadata. </td></tr>
    <tr><td class="paramname">scomp</td><td>starting component. </td></tr>
    <tr><td class="paramname">ncomp</td><td>number of components. </td></tr>
    <tr><td class="paramname">dtos</td><td>index mapping </td></tr>
    <tr><td class="paramname">proj</td><td>component mapping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1089b238bcca4ae52a70fd9bdf8518e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1089b238bcca4ae52a70fd9bdf8518e">&#9670;&nbsp;</a></span>FillBoundary_nowait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS , typename Proj  = Identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>,DTOS,<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj,FAB&gt;), <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a>&gt; amrex::NonLocalBC::FillBoundary_nowait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start communication to fill boundary. </p>
<p>This starts communication to fill ghost cells of a <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>. This function is supposed to be used together with FillBoundary_finish and makeFillBoundaryMetaData as follows. </p><pre class="fragment">    auto cmd = makeFillBoundaryMetaData(mf, mf.nGrowVect, geom, dtos);
    // The metadata cmd can be cached and reused on a MultiFab/FabArray with
    // the same BoxArray and DistributionMapping.
    auto handler = FillBoundary_nowait(mf, cmd, scomp, ncomp, dtos, proj);
    // Independent computation can be performed.
    FillBoundary_finish(std::move(handler), mf, cmd, scomp, ncomp, dtos, proj);
</pre><p>The FillBoundary capability here is more flexible than <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>'s FillBoundary member functions, which only fill ghost cells inside the domain and ghost cells at periodic boundaries. The FillBoundary here can be used to fill non-local domain boundaries (e.g., in spherical and cylindrical coordinates) given appropriate index and component mappings.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FAB</td><td>MultiFab/FabArray type </td></tr>
    <tr><td class="paramname">DTOS</td><td>Index mapping from destination from source. See SphThetaPhiRIndexMapping for an example. </td></tr>
    <tr><td class="paramname">Proj</td><td>Component mapping from source to destination. See SphThetaPhiRComponentMapping for an example.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>FabArray/MultiFab whose ghost cells need to be filled. </td></tr>
    <tr><td class="paramname">cmd</td><td>communication metadata. </td></tr>
    <tr><td class="paramname">scomp</td><td>starting component. </td></tr>
    <tr><td class="paramname">ncomp</td><td>number of components. </td></tr>
    <tr><td class="paramname">dtos</td><td>index mapping. </td></tr>
    <tr><td class="paramname">proj</td><td>component mapping.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html" title="This class stores both recv and send buffers with an associated MPI tag.">CommHandler</a> object needed for calling FillBoundary_finish. </dd></dl>

</div>
</div>
<a id="a569fc178d4aad983c5bdd14a8f69127e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569fc178d4aad983c5bdd14a8f69127e">&#9670;&nbsp;</a></span>FillPolar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::FillPolar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22290d0dc38cd0254f5d14100fec970f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22290d0dc38cd0254f5d14100fec970f">&#9670;&nbsp;</a></span>FillPolar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::FillPolar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1IntVect.html">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f43ddf52003ccef3fd4189be4b4e26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f43ddf52003ccef3fd4189be4b4e26a">&#9670;&nbsp;</a></span>Image() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DTOS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;::value &amp;&amp; !<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="classamrex_1_1IndexType.html">IndexType</a>, DTOS, <a class="el" href="classamrex_1_1IndexType.html">IndexType</a>&gt;::value, <a class="el" href="classamrex_1_1Box.html">Box</a>&gt; amrex::NonLocalBC::Image </td>
          <td>(</td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto Boxes but does not change the index type. </p>
<p>This function assumes monotonicity of dtos in each component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box that lives the destination index space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the smallest <a class="el" href="classamrex_1_1Box.html" title="A Rectangular Domain on an Integer Lattice.">Box</a> in the source index space that contains images of Apply(dtos, box.smallEnd()) and Apply(dtos, box.bigEnd()). </dd></dl>

</div>
</div>
<a id="afc017cb71584ee0d0505c7ecf92a79de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc017cb71584ee0d0505c7ecf92a79de">&#9670;&nbsp;</a></span>Image() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DTOS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;::value &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="classamrex_1_1IndexType.html">IndexType</a>, DTOS, <a class="el" href="classamrex_1_1IndexType.html">IndexType</a>&gt;::value, <a class="el" href="classamrex_1_1Box.html">Box</a>&gt; amrex::NonLocalBC::Image </td>
          <td>(</td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto Boxes and maps the index type. </p>
<p>This function assumes monotonicity of dtos in each component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box that lives the destination index space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the smallest <a class="el" href="classamrex_1_1Box.html" title="A Rectangular Domain on an Integer Lattice.">Box</a> in the source index space that contains images of Apply(dtos, box.smallEnd()) and Apply(dtos, box.bigEnd()). </dd></dl>

</div>
</div>
<a id="ab444df90b90c40442170ef5db4b0bea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab444df90b90c40442170ef5db4b0bea1">&#9670;&nbsp;</a></span>InverseImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DTOS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1NonLocalBC_1_1HasInverseMemFn.html">HasInverseMemFn</a>&lt;DTOS&gt;::value &amp;&amp; !<a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="classamrex_1_1IndexType.html">IndexType</a>, DTOS, <a class="el" href="classamrex_1_1IndexType.html">IndexType</a>&gt;::value, <a class="el" href="classamrex_1_1Box.html">Box</a>&gt; amrex::NonLocalBC::InverseImage </td>
          <td>(</td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the inverse <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto Boxes without changing the index type. </p>
<p>This function assumes monotonicity in each component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box that lives the source index space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the smallest <a class="el" href="classamrex_1_1Box.html" title="A Rectangular Domain on an Integer Lattice.">Box</a> in the destination index space that contains images of ApplyInverse(box.smallEnd()) and ApplyInverse(box.bigEnd()). </dd></dl>

</div>
</div>
<a id="ad979c6dbf27225b1f20a986185e2977b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad979c6dbf27225b1f20a986185e2977b">&#9670;&nbsp;</a></span>InverseImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DTOS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1NonLocalBC_1_1HasInverseMemFn.html">HasInverseMemFn</a>&lt;DTOS&gt;::value &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="classamrex_1_1IndexType.html">IndexType</a>, DTOS, <a class="el" href="classamrex_1_1IndexType.html">IndexType</a>&gt;::value, <a class="el" href="classamrex_1_1Box.html">Box</a>&gt; amrex::NonLocalBC::InverseImage </td>
          <td>(</td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the inverse <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> to <a class="el" href="structamrex_1_1Dim3.html">Dim3</a> mapping onto Boxes. </p>
<p>This function assumes monotonicity in each component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The box that lives the source index space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the smallest <a class="el" href="classamrex_1_1Box.html" title="A Rectangular Domain on an Integer Lattice.">Box</a> in the destination index space that contains images of ApplyInverse(box.smallEnd()) and ApplyInverse(box.bigEnd()). </dd></dl>

</div>
</div>
<a id="a3cd3a3fb3e0b792ebdb724cc5725176d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd3a3fb3e0b792ebdb724cc5725176d">&#9670;&nbsp;</a></span>local_copy_cpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB , class DTOS  = Identity, class Proj  = Identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::local_copy_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>dcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> const &amp;&#160;</td>
          <td class="paramname"><em>local_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em> = <code>DTOS{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ea4e6f4775e59312efdc7e5e42788c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea4e6f4775e59312efdc7e5e42788c3">&#9670;&nbsp;</a></span>local_copy_gpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB , class DTOS  = Identity, class Proj  = Identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::local_copy_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>dcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> const &amp;&#160;</td>
          <td class="paramname"><em>local_tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em> = <code>DTOS{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fa70005c1319e11f11266ae94abe4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa70005c1319e11f11266ae94abe4bb">&#9670;&nbsp;</a></span>LocalCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS , typename FabProj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::LocalCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever.html">ApplyDtosAndProjectionOnReciever</a>&lt; DTOS, FabProj &gt; &amp;&#160;</td>
          <td class="paramname"><em>packing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>local_tags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do local copies of FABs using DTOS and projection. </p>

</div>
</div>
<a id="ab719edc50f1af0377bb308024219baa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab719edc50f1af0377bb308024219baa3">&#9670;&nbsp;</a></span>LocalCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::LocalCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>local_tags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch local copies to the default behaviour that knows no DTOS nor projection. </p>

</div>
</div>
<a id="a273df272494afdcf1d9275ab5ed13e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273df272494afdcf1d9275ab5ed13e77">&#9670;&nbsp;</a></span>makeFillBoundaryMetaData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>,DTOS,<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;), <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a>&gt; amrex::NonLocalBC::makeFillBoundaryMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1IntVect.html">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Geometry.html">Geometry</a> const &amp;&#160;</td>
          <td class="paramname"><em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make metadata for FillBoundary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FAB</td><td>MultiFab/FabArray type </td></tr>
    <tr><td class="paramname">DTOS</td><td>Index mapping from destination from source. See SphThetaPhiRIndexMapping for an example.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>FabArray/MultiFab whose ghost cells need to be filled. </td></tr>
    <tr><td class="paramname">nghost</td><td>number of ghost cells to be filled. </td></tr>
    <tr><td class="paramname">geom</td><td>a <a class="el" href="classamrex_1_1Geometry.html" title="Rectangular problem domain geometry.">Geometry</a> object that contains the domain information. </td></tr>
    <tr><td class="paramname">dtos</td><td>index mapping.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>communication metadata </dd></dl>

</div>
</div>
<a id="a291d1c78ece15e2eb717acc0ec36835d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291d1c78ece15e2eb717acc0ec36835d">&#9670;&nbsp;</a></span>PackSendBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::PackSendBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;&#160;</td>
          <td class="paramname"><em>send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes FAB data without any knowledge of a DTOS nor a projection. </p>

</div>
</div>
<a id="af874a9f4652076f42120db672af7f447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af874a9f4652076f42120db672af7f447">&#9670;&nbsp;</a></span>ParallelCopy() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS  = Identity, typename Proj  = Identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsIndexMapping.html">IsIndexMapping</a>&lt;DTOS&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj, FAB&gt;),<a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData.html">MultiBlockCommMetaData</a>&gt; amrex::NonLocalBC::ParallelCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>destbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>srccomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>destcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>numcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>ngrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em> = <code>DTOS{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call ParallelCopy_nowait followed by ParallelCopy_finish. </p>
<p>This function constructs a new MultiCommMetaData from the given DTOS, destbox and ngrow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The Multifab that is going to be filled with received data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destbox</td><td>The index box in the destination space that will be filled by data from src. The source box that describes the dependencies will be computed by the specified DTOS.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The Multifab that is used to fill the send buffers.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srccomp</td><td>The first component in src that will be copied to dest.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destcomp</td><td>The first component in dest that will get written by src.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncomp</td><td>The number of successive components that will be copied.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ngrow</td><td>The amount of ghost cells that will be taking into consideration. Note, even if destbox contains indices outside the domain we need to specify an appropriate ngrow that covers the amount of ghost cells that we want to copy.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtos</td><td>An index mapping that maps indices from destination space to source space and from source space to destination space.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>A transformation function that might change the data when it is being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the CommMetaData object that can be cached for future calls to ParallelCopy. </dd></dl>

</div>
</div>
<a id="aedc887605744ff53411090ea98c15a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc887605744ff53411090ea98c15a04">&#9670;&nbsp;</a></span>ParallelCopy() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS  = Identity, typename Proj  = Identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsIndexMapping.html">IsIndexMapping</a>&lt;DTOS&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj, FAB&gt;),<a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData.html">MultiBlockCommMetaData</a>&gt; amrex::NonLocalBC::ParallelCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>destbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SrcComp.html">SrcComp</a>&#160;</td>
          <td class="paramname"><em>srccomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1DestComp.html">DestComp</a>&#160;</td>
          <td class="paramname"><em>destcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NumComps.html">NumComps</a>&#160;</td>
          <td class="paramname"><em>numcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>ngrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em> = <code>DTOS{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call ParallelCopy_nowait followed by ParallelCopy_finish, strong typed version. </p>
<p>This function constructs a new MultiCommMetaData from the given DTOS, destbox and ngrow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The Multifab that is going to be filled with received data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destbox</td><td>The index box in the destination space that will be filled by data from src. The source box that describes the dependencies will be computed by the specified DTOS.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The Multifab that is used to fill the send buffers.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srccomp</td><td>The first component in src that will be copied to dest.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destcomp</td><td>The first component in dest that will get written by src.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncomp</td><td>The number of successive components that will be copied.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ngrow</td><td>The amount of ghost cells that will be taking into consideration. Note, even if destbox contains indices outside the domain we need to specify an appropriate ngrow that covers the amount of ghost cells that we want to copy.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtos</td><td>An index mapping that maps indices from destination space to source space and from source space to destination space.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>A transformation function that might change the data when it is being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the CommMetaData object that can be cached for future calls to ParallelCopy. </dd></dl>

</div>
</div>
<a id="a5984b6f2bffd16fd4a1737326e32aef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5984b6f2bffd16fd4a1737326e32aef0">&#9670;&nbsp;</a></span>ParallelCopy() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS  = Identity, typename Proj  = Identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::ParallelCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>srccomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>destcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>numcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em> = <code>DTOS{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call ParallelCopy_nowait followed by ParallelCopy_finish. </p>
<p>This function overload uses an already cached CommMetaData. This CommMetaData needs to be compatible with the specified DTOS and projection, otherwise undefined behaviour occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The Multifab that is going to be filled with received data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The Multifab that is used to fill the send buffers.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The communication meta data object holds spatial information about FAB boxes that need to be filled and copied from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srccomp</td><td>The first component in src that will be copied to dest.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destcomp</td><td>The first component in dest that will get written by src.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncomp</td><td>The number of successive components that will be copied.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtos</td><td>An index mapping that maps indices from destination space to source space and from source space to destination space.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>A transformation function that might change the data when it is being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a9c2fff17888a770c492a1c014fee2b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2fff17888a770c492a1c014fee2b73">&#9670;&nbsp;</a></span>ParallelCopy() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS  = Identity, typename Proj  = Identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::ParallelCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SrcComp.html">SrcComp</a>&#160;</td>
          <td class="paramname"><em>srccomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1DestComp.html">DestComp</a>&#160;</td>
          <td class="paramname"><em>destcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NumComps.html">NumComps</a>&#160;</td>
          <td class="paramname"><em>numcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em> = <code>DTOS{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call ParallelCopy_nowait followed by ParallelCopy_finish, strong typed version. </p>
<p>This function overload uses an already cached CommMetaData. This CommMetaData needs to be compatible with the specified DTOS and projection, otherwise undefined behaviour occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The Multifab that is going to be filled with received data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The Multifab that is used to fill the send buffers.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The communication meta data object holds spatial information about FAB boxes that need to be filled and copied from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srccomp</td><td>The first component in src that will be copied to dest.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destcomp</td><td>The first component in dest that will get written by src.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncomp</td><td>The number of successive components that will be copied.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtos</td><td>An index mapping that maps indices from destination space to source space and from source space to destination space.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>A transformation function that might change the data when it is being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="ab11bf269e7aebae89bdc5d7d178bb12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11bf269e7aebae89bdc5d7d178bb12f">&#9670;&nbsp;</a></span>ParallelCopy() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData.html">MultiBlockCommMetaData</a> amrex::NonLocalBC::ParallelCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; <a class="el" href="classamrex_1_1FArrayBox.html">FArrayBox</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>destbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; <a class="el" href="classamrex_1_1FArrayBox.html">FArrayBox</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>destcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>srccomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>numcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1IntVect.html">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>ngrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1MultiBlockIndexMapping.html">MultiBlockIndexMapping</a> const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1Identity.html">Identity</a> const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f46a71c7807b33fa3fac96c36e8d09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f46a71c7807b33fa3fac96c36e8d09b">&#9670;&nbsp;</a></span>ParallelCopy_finish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DataPacking &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsDataPacking.html">IsDataPacking</a>&lt;DataPacking, FAB&gt;)&gt; amrex::NonLocalBC::ParallelCopy_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1DoLocalCopy.html">DoLocalCopy</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataPacking &amp;&#160;</td>
          <td class="paramname"><em>data_packing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blockingly wait for all communication to be done and fill the local FABs with received data.</p>
<p>This function overload performs local copies, i.e. from this MPI process to itself. It will block the current thread until all MPI recv and send requests are done and calls the DataPacking object to unpack the received buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The Multifab that is going to be filled with received data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The Multifab that is used to get the data for the local copies from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>This object holds all data buffers that need to be kept alive as long as the data transaction is not done.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The communication meta data object holds spatial information about FAB boxes that need to be filled.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_packing</td><td>A CPO that controls behaviour of unpacking the received data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a51fb0add78ab242015474585b0f7207e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fb0add78ab242015474585b0f7207e">&#9670;&nbsp;</a></span>ParallelCopy_finish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DataPacking &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsDataPacking.html">IsDataPacking</a>&lt;DataPacking, FAB&gt;)&gt; amrex::NonLocalBC::ParallelCopy_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataPacking &amp;&#160;</td>
          <td class="paramname"><em>data_packing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blockingly wait for all communication to be done and fill the local FABs with received data.</p>
<p>This function overload performs no local copies, i.e. from this MPI process to itself. It will block the current thread until all MPI recv and send requests are done and calls the DataPacking object to unpack the received buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The Multifab that is going to be filled with received data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>This object holds all data buffers that need to be kept alive as long as the data transaction is not done.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The communication meta data object holds spatial information about FAB boxes that need to be filled.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_packing</td><td>A CPO that controls behaviour of unpacking the received buffer to the destination <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing. </dd></dl>

</div>
</div>
<a id="a57dca62d2b38257c9da61d6a1f0ed9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dca62d2b38257c9da61d6a1f0ed9d8">&#9670;&nbsp;</a></span>ParallelCopy_nowait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DataPacking , typename  = std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;, typename  = std::enable_if_t&lt;IsDataPacking&lt;DataPacking, FAB&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMReX__Extension_8H.html#a8cfb0291f150c6676f99a0b6c4578717">AMREX_NODISCARD</a> <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a> amrex::NonLocalBC::ParallelCopy_nowait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataPacking &amp;&#160;</td>
          <td class="paramname"><em>data_packing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiate recv and send calls for MPI and return after doing local work.</p>
<p>DataPacking is a customization point object to control the behaviour of packing and unpacking send or recv data buffers. It is used to perform interpolation or data transformations on either sender or receiver side.</p>
<p>This function performs a data packing on sender side and we expect a call to Parallel_finish that performs data unpacking on the receiver side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The Multifab that is going to be filled with received data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The Multifab that is used to fill the send buffers.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The communication meta data object holds spatial information about FAB boxes that need to be filled and copied from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_packing</td><td>A CPO that controls behaviour of preparing buffers and packing the source data into the send buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html" title="This class stores both recv and send buffers with an associated MPI tag.">CommHandler</a> object that owns context and memory buffers for the whole life time of the MPI transaction. </dd></dl>

</div>
</div>
<a id="a7bf19b06a9bab53ac6dea6bfa875af9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf19b06a9bab53ac6dea6bfa875af9d">&#9670;&nbsp;</a></span>ParallelCopy_nowait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DataPacking , typename  = std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;, typename  = std::enable_if_t&lt;IsDataPacking&lt;DataPacking, FAB&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AMReX__Extension_8H.html#a8cfb0291f150c6676f99a0b6c4578717">AMREX_NODISCARD</a> <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html">CommHandler</a> amrex::NonLocalBC::ParallelCopy_nowait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1NoLocalCopy.html">NoLocalCopy</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1FabArrayBase_1_1CommMetaData.html">FabArrayBase::CommMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataPacking &amp;&#160;</td>
          <td class="paramname"><em>data_packing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiate recv and send calls for MPI and immediately return without doing any work.</p>
<p>DataPacking is a customization point object to control the behaviour of packing and unpacking send or recv data buffers. It is used to perform interpolation or data transformations on either sender or receiver side.</p>
<p>This function performs a data packing on sender side and we expect a call to Parallel_finish that performs data unpacking on the receiver side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>The Multifab that is going to be filled with received data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The Multifab that is used to fill the send buffers.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The communication meta data object holds spatial information about FAB boxes that need to be filled and copied from.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_packing</td><td>A CPO that controls behaviour of preparing buffers and packing the source data into the send buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="structamrex_1_1NonLocalBC_1_1CommHandler.html" title="This class stores both recv and send buffers with an associated MPI tag.">CommHandler</a> object that owns context and memory buffers for the whole life time of the MPI transaction. </dd></dl>

</div>
</div>
<a id="a62685cb385ba3363c973d758cbb7cde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62685cb385ba3363c973d758cbb7cde8">&#9670;&nbsp;</a></span>PostRecvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void amrex::NonLocalBC::PostRecvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;&#160;</td>
          <td class="paramname"><em>recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>mpi_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate all recvieves with MPI_Irecv calls associated with tag mpi_tag. </p>

</div>
</div>
<a id="a5ccb53a5bfee4c68f588b17d3642c2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccb53a5bfee4c68f588b17d3642c2c5">&#9670;&nbsp;</a></span>PostSends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void amrex::NonLocalBC::PostSends </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>mpi_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate all sends with MPI_Isend calls associated with tag mpi_tag. </p>

</div>
</div>
<a id="a303b8c034244500930c9f5ead86a22bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303b8c034244500930c9f5ead86a22bf">&#9670;&nbsp;</a></span>PrepareCommBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void amrex::NonLocalBC::PrepareCommBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArrayBase.html#aa36883196eb7b1d039fd1941966a4310">FabArrayBase::MapOfCopyComTagContainers</a> &amp;&#160;</td>
          <td class="paramname"><em>cctc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>n_components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>object_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill all class member variables of comm but the request and the stats vector. </p>

</div>
</div>
<a id="a101b2f07560880fda8bab055214f3222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101b2f07560880fda8bab055214f3222">&#9670;&nbsp;</a></span>PrepareRecvBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::PrepareRecvBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArrayBase.html#aa36883196eb7b1d039fd1941966a4310">FabArrayBase::MapOfCopyComTagContainers</a> &amp;&#160;</td>
          <td class="paramname"><em>cctc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls PrepareComBuffers. </p>

</div>
</div>
<a id="a5e37435a999c0eb51e29139501d7ca49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e37435a999c0eb51e29139501d7ca49">&#9670;&nbsp;</a></span>PrepareSendBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::PrepareSendBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1FabArrayBase.html#aa36883196eb7b1d039fd1941966a4310">FabArrayBase::MapOfCopyComTagContainers</a> &amp;&#160;</td>
          <td class="paramname"><em>cctc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls PrepareComBuffers. </p>

</div>
</div>
<a id="ad6b5ad1aeccc1b34a6874b4609654e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b5ad1aeccc1b34a6874b4609654e14">&#9670;&nbsp;</a></span>Rotate180() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::Rotate180 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35b23e1690efb2d7f63af0118739d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b23e1690efb2d7f63af0118739d12e">&#9670;&nbsp;</a></span>Rotate180() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::Rotate180 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1IntVect.html">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33354739811ccff59e69722da63a9f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33354739811ccff59e69722da63a9f5c">&#9670;&nbsp;</a></span>Rotate90() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::Rotate90 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d9ef1abd51b6a59a2938c4aefbe3456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9ef1abd51b6a59a2938c4aefbe3456">&#9670;&nbsp;</a></span>Rotate90() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::Rotate90 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1IntVect.html">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Box.html">Box</a> const &amp;&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4039bcfeee7e444019168686df8dfe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4039bcfeee7e444019168686df8dfe36">&#9670;&nbsp;</a></span>unpack_recv_buffer_cpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB , class DTOS  = Identity, class Proj  = Identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::unpack_recv_buffer_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>dcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; char * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; std::size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>recv_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> const * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>recv_cctc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em> = <code>DTOS{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6a98a57dd1e0440eac5dee97d79d326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a98a57dd1e0440eac5dee97d79d326">&#9670;&nbsp;</a></span>unpack_recv_buffer_gpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB , class DTOS  = Identity, class Proj  = Identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;) &amp;&amp; <a class="el" href="structamrex_1_1IsCallableR.html">IsCallableR</a>&lt;<a class="el" href="structamrex_1_1Dim3.html">Dim3</a>, DTOS, <a class="el" href="structamrex_1_1Dim3.html">Dim3</a>&gt;) &amp;&amp; <a class="el" href="structamrex_1_1NonLocalBC_1_1IsFabProjection.html">IsFabProjection</a>&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::unpack_recv_buffer_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>mf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#ad2e8127753e9be0ebf531435c6511937">int</a>&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; char * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>recv_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; std::size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>recv_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="classamrex_1_1FabArrayBase.html#a9bdd65ce61ce9ee5ca52c6b387dd4800">FabArrayBase::CopyComTagsContainer</a> const * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>recv_cctc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DTOS const &amp;&#160;</td>
          <td class="paramname"><em>dtos</em> = <code>DTOS{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj const &amp;&#160;</td>
          <td class="paramname"><em>proj</em> = <code>Proj{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1af16f3ccbf44b758a852b190bedd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1af16f3ccbf44b758a852b190bedd33">&#9670;&nbsp;</a></span>UnpackRecvBuffers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB , typename DTOS , typename FabProj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::UnpackRecvBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever.html">ApplyDtosAndProjectionOnReciever</a>&lt; DTOS, FabProj &gt; &amp;&#160;</td>
          <td class="paramname"><em>packing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy from received data in the buffer to destination FABs using DTOS and projection. </p>

</div>
</div>
<a id="a9dad3936d4a2ede70ac57d5d2d3b6e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dad3936d4a2ede70ac57d5d2d3b6e2e">&#9670;&nbsp;</a></span>UnpackRecvBuffers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt;FAB&gt;::value&gt; amrex::NonLocalBC::UnpackRecvBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1PackComponents.html">PackComponents</a> &amp;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; FAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structamrex_1_1NonLocalBC_1_1CommData.html">CommData</a> &amp;&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-serializes FAB data without any knowledge of a DTOS nor a projection. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa0174cdbe72e2968e46f0293c2ecab73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0174cdbe72e2968e46f0293c2ecab73">&#9670;&nbsp;</a></span>do_local_copy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr struct <a class="el" href="structamrex_1_1NonLocalBC_1_1DoLocalCopy.html">amrex::NonLocalBC::DoLocalCopy</a> amrex::NonLocalBC::do_local_copy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb7cd050d6dd1aef7603048eeccd7ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7cd050d6dd1aef7603048eeccd7ded">&#9670;&nbsp;</a></span>identity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structamrex_1_1NonLocalBC_1_1Identity.html">Identity</a> amrex::NonLocalBC::identity {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad604544d2fd60b6d9fb7a8b75f95ffe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad604544d2fd60b6d9fb7a8b75f95ffe0">&#9670;&nbsp;</a></span>no_local_copy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr struct <a class="el" href="structamrex_1_1NonLocalBC_1_1NoLocalCopy.html">amrex::NonLocalBC::NoLocalCopy</a> amrex::NonLocalBC::no_local_copy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a618f8d1f0b1258ad4931eb6a5ae65ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618f8d1f0b1258ad4931eb6a5ae65ebc">&#9670;&nbsp;</a></span>swap_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int I, int J&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structamrex_1_1NonLocalBC_1_1SwapComponents.html">SwapComponents</a>&lt;I, J&gt; amrex::NonLocalBC::swap_indices {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceamrex.html">amrex</a></li><li class="navelem"><a class="el" href="namespaceamrex_1_1NonLocalBC.html">NonLocalBC</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
