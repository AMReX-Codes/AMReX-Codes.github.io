<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!--title>AMReX: Communication for Distributed Fab Data</title-->
<title>AMReX: Block-Structured AMR Software Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="amrex_logo_tiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Block-Structured AMR Software Framework
   </div>
   <!--div id="projectbrief">Block-Structured AMR Software Framework</div-->
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__amrex__fabarray__communication.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Communication for Distributed Fab Data<div class="ingroups"><a class="el" href="group__amrex__data__containers.html">Data Containers</a> &raquo; <a class="el" href="group__amrex__multifab__containers.html">Distributed Fab Data</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>MPI data movement operations for <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a> based containers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3991ba7fcd5f937da838387b027ce7ef" id="r_ga3991ba7fcd5f937da838387b027ce7ef"><td class="memTemplParams" colspan="2">template&lt;typename BUF  = value_type&gt; </td></tr>
<tr class="memitem:ga3991ba7fcd5f937da838387b027ce7ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga3991ba7fcd5f937da838387b027ce7ef">amrex::FabArray&lt; FAB &gt;::FillBoundary</a> (bool cross=false)</td></tr>
<tr class="memdesc:ga3991ba7fcd5f937da838387b027ce7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy on intersection within a <a class="el" href="classamrex_1_1FabArray.html" title="An Array of FortranArrayBox(FAB)-like Objects.">FabArray</a>.  <br /></td></tr>
<tr class="separator:ga3991ba7fcd5f937da838387b027ce7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c4ba8aa5ed4620734ba6bbc09bfa6b" id="r_ga73c4ba8aa5ed4620734ba6bbc09bfa6b"><td class="memTemplParams" colspan="2">template&lt;typename BUF  = value_type&gt; </td></tr>
<tr class="memitem:ga73c4ba8aa5ed4620734ba6bbc09bfa6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga73c4ba8aa5ed4620734ba6bbc09bfa6b">amrex::FabArray&lt; FAB &gt;::FillBoundary</a> (const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period, bool cross=false)</td></tr>
<tr class="separator:ga73c4ba8aa5ed4620734ba6bbc09bfa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3bcb50994c05df7dbfcd3d63a41249" id="r_ga7c3bcb50994c05df7dbfcd3d63a41249"><td class="memTemplParams" colspan="2">template&lt;typename BUF  = value_type&gt; </td></tr>
<tr class="memitem:ga7c3bcb50994c05df7dbfcd3d63a41249"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga7c3bcb50994c05df7dbfcd3d63a41249">amrex::FabArray&lt; FAB &gt;::FillBoundary</a> (int scomp, int ncomp, bool cross=false)</td></tr>
<tr class="separator:ga7c3bcb50994c05df7dbfcd3d63a41249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a03b23f179e0c50e162387e35ea00b" id="r_gae0a03b23f179e0c50e162387e35ea00b"><td class="memTemplParams" colspan="2">template&lt;typename BUF  = value_type&gt; </td></tr>
<tr class="memitem:gae0a03b23f179e0c50e162387e35ea00b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gae0a03b23f179e0c50e162387e35ea00b">amrex::FabArray&lt; FAB &gt;::FillBoundary</a> (int scomp, int ncomp, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period, bool cross=false)</td></tr>
<tr class="separator:gae0a03b23f179e0c50e162387e35ea00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c47cdc663d31e529ec89d3a10c2969" id="r_ga59c47cdc663d31e529ec89d3a10c2969"><td class="memTemplParams" colspan="2">template&lt;typename BUF  = value_type&gt; </td></tr>
<tr class="memitem:ga59c47cdc663d31e529ec89d3a10c2969"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga59c47cdc663d31e529ec89d3a10c2969">amrex::FabArray&lt; FAB &gt;::FillBoundary</a> (int scomp, int ncomp, const <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> &amp;nghost, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period, bool cross=false)</td></tr>
<tr class="separator:ga59c47cdc663d31e529ec89d3a10c2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ce4d97367dcb2da8be8bddfac2ef4e" id="r_ga84ce4d97367dcb2da8be8bddfac2ef4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga84ce4d97367dcb2da8be8bddfac2ef4e">amrex::FabArray&lt; FAB &gt;::FillBoundaryAndSync</a> (const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period=<a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>())</td></tr>
<tr class="memdesc:ga84ce4d97367dcb2da8be8bddfac2ef4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill ghost cells and synchronize nodal data.  <br /></td></tr>
<tr class="separator:ga84ce4d97367dcb2da8be8bddfac2ef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a2ee6a93d9d13d4f4a1f864f3c767cb" id="r_ga6a2ee6a93d9d13d4f4a1f864f3c767cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga6a2ee6a93d9d13d4f4a1f864f3c767cb">amrex::FabArray&lt; FAB &gt;::FillBoundaryAndSync</a> (int scomp, int ncomp, const <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> &amp;nghost, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period)</td></tr>
<tr class="memdesc:ga6a2ee6a93d9d13d4f4a1f864f3c767cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill ghost cells and synchronize nodal data.  <br /></td></tr>
<tr class="separator:ga6a2ee6a93d9d13d4f4a1f864f3c767cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37eadd5f219d50c8f1c3422f2fa81eb2" id="r_ga37eadd5f219d50c8f1c3422f2fa81eb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga37eadd5f219d50c8f1c3422f2fa81eb2">amrex::FabArray&lt; FAB &gt;::OverrideSync</a> (const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period=<a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>())</td></tr>
<tr class="memdesc:ga37eadd5f219d50c8f1c3422f2fa81eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize nodal data.  <br /></td></tr>
<tr class="separator:ga37eadd5f219d50c8f1c3422f2fa81eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7ee90203e2af36c474d9b2234c8cae" id="r_ga4f7ee90203e2af36c474d9b2234c8cae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga4f7ee90203e2af36c474d9b2234c8cae">amrex::FabArray&lt; FAB &gt;::OverrideSync</a> (int scomp, int ncomp, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period)</td></tr>
<tr class="memdesc:ga4f7ee90203e2af36c474d9b2234c8cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize nodal data.  <br /></td></tr>
<tr class="separator:ga4f7ee90203e2af36c474d9b2234c8cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f916865d887cd0dd92e99e919f3059" id="r_gaa3f916865d887cd0dd92e99e919f3059"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gaa3f916865d887cd0dd92e99e919f3059">amrex::FabArray&lt; FAB &gt;::SumBoundary</a> (const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period=<a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>(), bool deterministic=false)</td></tr>
<tr class="memdesc:gaa3f916865d887cd0dd92e99e919f3059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum values in overlapped cells.  <br /></td></tr>
<tr class="separator:gaa3f916865d887cd0dd92e99e919f3059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga311f4acae65c8d6b9b720ab687a67635" id="r_ga311f4acae65c8d6b9b720ab687a67635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga311f4acae65c8d6b9b720ab687a67635">amrex::FabArray&lt; FAB &gt;::SumBoundary</a> (int scomp, int ncomp, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period=<a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>(), bool deterministic=false)</td></tr>
<tr class="separator:ga311f4acae65c8d6b9b720ab687a67635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33de3e606d07252276a70684a25bc3da" id="r_ga33de3e606d07252276a70684a25bc3da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga33de3e606d07252276a70684a25bc3da">amrex::FabArray&lt; FAB &gt;::SumBoundary</a> (int scomp, int ncomp, <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;nghost, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period=<a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>(), bool deterministic=false)</td></tr>
<tr class="memdesc:ga33de3e606d07252276a70684a25bc3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum values in overlapped cells.  <br /></td></tr>
<tr class="separator:ga33de3e606d07252276a70684a25bc3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeaac94eb6e3e1e1a836c096053186c4" id="r_gaaeaac94eb6e3e1e1a836c096053186c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gaaeaac94eb6e3e1e1a836c096053186c4">amrex::FabArray&lt; FAB &gt;::SumBoundary</a> (int scomp, int ncomp, <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;src_nghost, <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;dst_nghost, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period=<a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>(), bool deterministic=false)</td></tr>
<tr class="memdesc:gaaeaac94eb6e3e1e1a836c096053186c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum values in overlapped cells.  <br /></td></tr>
<tr class="separator:gaaeaac94eb6e3e1e1a836c096053186c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb282b42c0eb97cbb55037bc7bdea04a" id="r_gadb282b42c0eb97cbb55037bc7bdea04a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gadb282b42c0eb97cbb55037bc7bdea04a">amrex::FabArray&lt; FAB &gt;::EnforcePeriodicity</a> (const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period)</td></tr>
<tr class="memdesc:gadb282b42c0eb97cbb55037bc7bdea04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill ghost cells with values from their corresponding cells across periodic boundaries, regardless of whether the corresponding cells are valid.  <br /></td></tr>
<tr class="separator:gadb282b42c0eb97cbb55037bc7bdea04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf0e342dcbe19b9bb23e73c326155ff" id="r_gaecf0e342dcbe19b9bb23e73c326155ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gaecf0e342dcbe19b9bb23e73c326155ff">amrex::FabArray&lt; FAB &gt;::EnforcePeriodicity</a> (int scomp, int ncomp, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period)</td></tr>
<tr class="separator:gaecf0e342dcbe19b9bb23e73c326155ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076781df7b9077c51fecd6a62172ed74" id="r_ga076781df7b9077c51fecd6a62172ed74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga076781df7b9077c51fecd6a62172ed74">amrex::FabArray&lt; FAB &gt;::EnforcePeriodicity</a> (int scomp, int ncomp, const <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> &amp;nghost, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period)</td></tr>
<tr class="separator:ga076781df7b9077c51fecd6a62172ed74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48dc35bc87c8b41129bdff1e0cf9af05" id="r_ga48dc35bc87c8b41129bdff1e0cf9af05"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">F</a>  = FAB, std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">F</a> &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga48dc35bc87c8b41129bdff1e0cf9af05"><td class="memTemplItemLeft" align="right" valign="top">F::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga48dc35bc87c8b41129bdff1e0cf9af05">amrex::FabArray&lt; FAB &gt;::norminf</a> (int comp, int ncomp, <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;nghost, bool local=false, bool ignore_covered=false) const</td></tr>
<tr class="memdesc:ga48dc35bc87c8b41129bdff1e0cf9af05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return infinity norm.  <br /></td></tr>
<tr class="separator:ga48dc35bc87c8b41129bdff1e0cf9af05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea595d71e8f04b18bc48aaca29acfe77" id="r_gaea595d71e8f04b18bc48aaca29acfe77"><td class="memTemplParams" colspan="2">template&lt;typename IFAB , typename <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">F</a>  = FAB, std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">F</a> &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gaea595d71e8f04b18bc48aaca29acfe77"><td class="memTemplItemLeft" align="right" valign="top">F::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gaea595d71e8f04b18bc48aaca29acfe77">amrex::FabArray&lt; FAB &gt;::norminf</a> (<a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; IFAB &gt; const &amp;<a class="el" href="AMReX__InterpFaceRegister_8cpp.html#a5b2221de12a27f0d22ceec3ecf3fc430">mask</a>, int comp, int ncomp, <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;nghost, bool local=false) const</td></tr>
<tr class="memdesc:gaea595d71e8f04b18bc48aaca29acfe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return infinity norm in masked region.  <br /></td></tr>
<tr class="separator:gaea595d71e8f04b18bc48aaca29acfe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d57175907c89a969b9b5392631e65cf" id="r_ga9d57175907c89a969b9b5392631e65cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga9d57175907c89a969b9b5392631e65cf">amrex::MultiFab::norminf</a> (int comp=0, int nghost=0, bool local=false, bool ignore_covered=false) const</td></tr>
<tr class="separator:ga9d57175907c89a969b9b5392631e65cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7329288ae6f73f8fd7eda95e49b8ba" id="r_gabc7329288ae6f73f8fd7eda95e49b8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gabc7329288ae6f73f8fd7eda95e49b8ba">amrex::MultiFab::norminf</a> (const <a class="el" href="classamrex_1_1iMultiFab.html">iMultiFab</a> &amp;<a class="el" href="AMReX__InterpFaceRegister_8cpp.html#a5b2221de12a27f0d22ceec3ecf3fc430">mask</a>, int comp=0, int nghost=0, bool local=false) const</td></tr>
<tr class="separator:gabc7329288ae6f73f8fd7eda95e49b8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3280950fb8a9b1ed17e73ee5df3c43" id="r_ga7d3280950fb8a9b1ed17e73ee5df3c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga7d3280950fb8a9b1ed17e73ee5df3c43">amrex::MultiFab::norminf</a> (const <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; int &gt; &amp;comps, int nghost=0, bool local=false, bool ignore_covered=false) const</td></tr>
<tr class="separator:ga7d3280950fb8a9b1ed17e73ee5df3c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcdc4aaf73896a44ad364520af9a7398" id="r_gafcdc4aaf73896a44ad364520af9a7398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gafcdc4aaf73896a44ad364520af9a7398">amrex::MultiFab::norm1</a> (int comp=0, int ngrow=0, bool local=false) const</td></tr>
<tr class="memdesc:gafcdc4aaf73896a44ad364520af9a7398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L1 norm of component <code>comp</code> over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. <code>ngrow</code> ghost cells are used.  <br /></td></tr>
<tr class="separator:gafcdc4aaf73896a44ad364520af9a7398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ba8fc4756c0621e3872055ffce31b0" id="r_gae4ba8fc4756c0621e3872055ffce31b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gae4ba8fc4756c0621e3872055ffce31b0">amrex::MultiFab::norm1</a> (const <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; int &gt; &amp;comps, int ngrow=0, bool local=false) const</td></tr>
<tr class="memdesc:gae4ba8fc4756c0621e3872055ffce31b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L1 norm of each component of "comps" over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. ngrow ghost cells are used.  <br /></td></tr>
<tr class="separator:gae4ba8fc4756c0621e3872055ffce31b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b6bb4fb2ee206356cd613ed8458b8f" id="r_gaa0b6bb4fb2ee206356cd613ed8458b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gaa0b6bb4fb2ee206356cd613ed8458b8f">amrex::MultiFab::norm2</a> (int comp=0) const</td></tr>
<tr class="memdesc:gaa0b6bb4fb2ee206356cd613ed8458b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L2 norm of component <code>comp</code> over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. No ghost cells are used.  <br /></td></tr>
<tr class="separator:gaa0b6bb4fb2ee206356cd613ed8458b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc29a136f07efb39a2d9acafc04cf9e1" id="r_gacc29a136f07efb39a2d9acafc04cf9e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gacc29a136f07efb39a2d9acafc04cf9e1">amrex::MultiFab::norm2</a> (int comp, int numcomp) const</td></tr>
<tr class="memdesc:gacc29a136f07efb39a2d9acafc04cf9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L2 norm of <code>numcomp</code> components starting from <code>comp</code> component over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. No ghost cells are used.  <br /></td></tr>
<tr class="separator:gacc29a136f07efb39a2d9acafc04cf9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0982c02422dcb603d1c5129d744d6611" id="r_ga0982c02422dcb603d1c5129d744d6611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga0982c02422dcb603d1c5129d744d6611">amrex::MultiFab::norm2</a> (int comp, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period) const</td></tr>
<tr class="memdesc:ga0982c02422dcb603d1c5129d744d6611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L2 norm of component <code>comp</code> over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. No ghost cells are used. This version has no double counting for nodal data.  <br /></td></tr>
<tr class="separator:ga0982c02422dcb603d1c5129d744d6611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933d1dd75c4441bf922f8c5baa931be4" id="r_ga933d1dd75c4441bf922f8c5baa931be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga933d1dd75c4441bf922f8c5baa931be4">amrex::MultiFab::norm2</a> (const <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; int &gt; &amp;comps) const</td></tr>
<tr class="memdesc:ga933d1dd75c4441bf922f8c5baa931be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L2 norm of each component of "comps" over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. No ghost cells are used.  <br /></td></tr>
<tr class="separator:ga933d1dd75c4441bf922f8c5baa931be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62669a27ec4a577f0bef72dc2a1243aa" id="r_ga62669a27ec4a577f0bef72dc2a1243aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga62669a27ec4a577f0bef72dc2a1243aa">amrex::MultiFab::sum</a> (int comp=0, bool local=false) const</td></tr>
<tr class="memdesc:ga62669a27ec4a577f0bef72dc2a1243aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of component "comp" over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a> &ndash; no ghost cells are included.  <br /></td></tr>
<tr class="separator:ga62669a27ec4a577f0bef72dc2a1243aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623e2f01e2a7695e835d258d1a8067b7" id="r_ga623e2f01e2a7695e835d258d1a8067b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga623e2f01e2a7695e835d258d1a8067b7">amrex::MultiFab::sum</a> (<a class="el" href="namespaceamrex.html#a5e922fb76ff2eb645844783ad65d1490">Box</a> const &amp;region, int comp=0, bool local=false) const</td></tr>
<tr class="memdesc:ga623e2f01e2a7695e835d258d1a8067b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of component "comp" in the given "region". &ndash; no ghost cells are included.  <br /></td></tr>
<tr class="separator:ga623e2f01e2a7695e835d258d1a8067b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe7c47dff8cf8e0fb550d0e78c7b5375" id="r_gafe7c47dff8cf8e0fb550d0e78c7b5375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gafe7c47dff8cf8e0fb550d0e78c7b5375">amrex::MultiFab::sum_unique</a> (int comp=0, bool local=false, const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;period=<a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>()) const</td></tr>
<tr class="memdesc:gafe7c47dff8cf8e0fb550d0e78c7b5375"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structamrex_1_1Same.html">Same</a> as sum with <code>local</code> =false, but for non-cell-centered data, this only adds non-unique points that are owned by multiple boxes once.  <br /></td></tr>
<tr class="separator:gafe7c47dff8cf8e0fb550d0e78c7b5375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab351d9250414508cf086635f54e2e2ce" id="r_gab351d9250414508cf086635f54e2e2ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#gab351d9250414508cf086635f54e2e2ce">amrex::MultiFab::minIndex</a> (int comp, int nghost=0) const</td></tr>
<tr class="separator:gab351d9250414508cf086635f54e2e2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga642f844c834d6fb714e3e0fc6eb75e56" id="r_ga642f844c834d6fb714e3e0fc6eb75e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga642f844c834d6fb714e3e0fc6eb75e56">amrex::MultiFab::maxIndex</a> (int comp, int nghost=0) const</td></tr>
<tr class="separator:ga642f844c834d6fb714e3e0fc6eb75e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5397e3c5e4cbb69279db604d3f1f2a60" id="r_ga5397e3c5e4cbb69279db604d3f1f2a60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga5397e3c5e4cbb69279db604d3f1f2a60">amrex::MultiFab::Dot</a> (const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;<a class="el" href="namespaceamrex.html#a8de829410ed15dbc56e4dafc9bc6ea69a9dd4e461268c8034f5c8564e155c67a6">x</a>, int xcomp, const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;<a class="el" href="namespaceamrex.html#a8de829410ed15dbc56e4dafc9bc6ea69a415290769594460e2e485922904f345d">y</a>, int ycomp, int numcomp, int nghost, bool local=false)</td></tr>
<tr class="memdesc:ga5397e3c5e4cbb69279db604d3f1f2a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of two MultiFabs.  <br /></td></tr>
<tr class="separator:ga5397e3c5e4cbb69279db604d3f1f2a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87437456f64f8610e6d34d17929fdb4f" id="r_ga87437456f64f8610e6d34d17929fdb4f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga87437456f64f8610e6d34d17929fdb4f">amrex::MultiFab::Dot</a> (const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;<a class="el" href="namespaceamrex.html#a8de829410ed15dbc56e4dafc9bc6ea69a9dd4e461268c8034f5c8564e155c67a6">x</a>, int xcomp, int numcomp, int nghost, bool local=false)</td></tr>
<tr class="memdesc:ga87437456f64f8610e6d34d17929fdb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of a <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a> with itself.  <br /></td></tr>
<tr class="separator:ga87437456f64f8610e6d34d17929fdb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115acdf454f3e0732ee54de9d5ff2057" id="r_ga115acdf454f3e0732ee54de9d5ff2057"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__amrex__fabarray__communication.html#ga115acdf454f3e0732ee54de9d5ff2057">amrex::MultiFab::Dot</a> (const <a class="el" href="classamrex_1_1iMultiFab.html">iMultiFab</a> &amp;<a class="el" href="AMReX__InterpFaceRegister_8cpp.html#a5b2221de12a27f0d22ceec3ecf3fc430">mask</a>, const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;<a class="el" href="namespaceamrex.html#a8de829410ed15dbc56e4dafc9bc6ea69a9dd4e461268c8034f5c8564e155c67a6">x</a>, int xcomp, const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;<a class="el" href="namespaceamrex.html#a8de829410ed15dbc56e4dafc9bc6ea69a415290769594460e2e485922904f345d">y</a>, int ycomp, int numcomp, int nghost, bool local=false)</td></tr>
<tr class="separator:ga115acdf454f3e0732ee54de9d5ff2057"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>MPI data movement operations for <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a> based containers. </p>
<p>These operations may use MPI when AMReX is built with MPI support. Central interfaces include:</p><ul>
<li><a class="el" href="group__amrex__fabarray__communication.html#ga3991ba7fcd5f937da838387b027ce7ef">amrex::FabArray::FillBoundary</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#ga84ce4d97367dcb2da8be8bddfac2ef4e">amrex::FabArray::FillBoundaryAndSync</a></li>
<li><a class="el" href="classamrex_1_1FabArray.html#a0f2716c666d8cd0546009503e890f807">amrex::FabArray::ParallelCopy</a></li>
<li><a class="el" href="classamrex_1_1FabArray.html#a4e8ff0027c22d9451a6edff7272fb29a">amrex::FabArray::ParallelAdd</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#gaa3f916865d887cd0dd92e99e919f3059">amrex::FabArray::SumBoundary</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#ga37eadd5f219d50c8f1c3422f2fa81eb2">amrex::FabArray::OverrideSync</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#gadb282b42c0eb97cbb55037bc7bdea04a">amrex::FabArray::EnforcePeriodicity</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#ga48dc35bc87c8b41129bdff1e0cf9af05">amrex::FabArray::norminf</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#ga9d57175907c89a969b9b5392631e65cf">amrex::MultiFab::norminf</a></li>
<li><a class="el" href="classamrex_1_1MultiFab.html#a5879f0308ed537286037a041e32fd810">amrex::MultiFab::norm1</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#gaa0b6bb4fb2ee206356cd613ed8458b8f">amrex::MultiFab::norm2</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#ga62669a27ec4a577f0bef72dc2a1243aa">amrex::MultiFab::sum</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#gafe7c47dff8cf8e0fb550d0e78c7b5375">amrex::MultiFab::sum_unique</a></li>
<li><a class="el" href="classamrex_1_1MultiFab.html#abb92462276ca55cd70f16507118f63ad">amrex::MultiFab::max</a></li>
<li><a class="el" href="classamrex_1_1MultiFab.html#a540eb1714a5eece782de2a4afdd62c8e">amrex::MultiFab::min</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#ga5397e3c5e4cbb69279db604d3f1f2a60">amrex::MultiFab::Dot</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#gab351d9250414508cf086635f54e2e2ce">amrex::MultiFab::minIndex</a></li>
<li><a class="el" href="group__amrex__fabarray__communication.html#ga642f844c834d6fb714e3e0fc6eb75e56">amrex::MultiFab::maxIndex</a> </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga115acdf454f3e0732ee54de9d5ff2057" name="ga115acdf454f3e0732ee54de9d5ff2057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga115acdf454f3e0732ee54de9d5ff2057">&#9670;&#160;</a></span>Dot() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1iMultiFab.html">iMultiFab</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ycomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5397e3c5e4cbb69279db604d3f1f2a60" name="ga5397e3c5e4cbb69279db604d3f1f2a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5397e3c5e4cbb69279db604d3f1f2a60">&#9670;&#160;</a></span>Dot() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ycomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of two MultiFabs. </p>

</div>
</div>
<a id="ga87437456f64f8610e6d34d17929fdb4f" name="ga87437456f64f8610e6d34d17929fdb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87437456f64f8610e6d34d17929fdb4f">&#9670;&#160;</a></span>Dot() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1MultiFab.html">MultiFab</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numcomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of a <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a> with itself. </p>

</div>
</div>
<a id="gadb282b42c0eb97cbb55037bc7bdea04a" name="gadb282b42c0eb97cbb55037bc7bdea04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb282b42c0eb97cbb55037bc7bdea04a">&#9670;&#160;</a></span>EnforcePeriodicity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::EnforcePeriodicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill ghost cells with values from their corresponding cells across periodic boundaries, regardless of whether the corresponding cells are valid. </p>
<p>This differs from FillBoundary, which only fills from valid cells, and does not fill from ghost cells. The <a class="el" href="classamrex_1_1BoxArray.html" title="A collection of Boxes stored in an Array.">BoxArray</a> is allowed to be overlapping. </p>

</div>
</div>
<a id="ga076781df7b9077c51fecd6a62172ed74" name="ga076781df7b9077c51fecd6a62172ed74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga076781df7b9077c51fecd6a62172ed74">&#9670;&#160;</a></span>EnforcePeriodicity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::EnforcePeriodicity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaecf0e342dcbe19b9bb23e73c326155ff" name="gaecf0e342dcbe19b9bb23e73c326155ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecf0e342dcbe19b9bb23e73c326155ff">&#9670;&#160;</a></span>EnforcePeriodicity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::EnforcePeriodicity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3991ba7fcd5f937da838387b027ce7ef" name="ga3991ba7fcd5f937da838387b027ce7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3991ba7fcd5f937da838387b027ce7ef">&#9670;&#160;</a></span>FillBoundary() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
<div class="memtemplate">
template&lt;typename BUF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::FillBoundary </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cross</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy on intersection within a <a class="el" href="classamrex_1_1FabArray.html" title="An Array of FortranArrayBox(FAB)-like Objects.">FabArray</a>. </p>
<p>Data is copied from valid regions to intersecting regions of definition. The purpose is to fill in the boundary regions of each FAB in the <a class="el" href="classamrex_1_1FabArray.html" title="An Array of FortranArrayBox(FAB)-like Objects.">FabArray</a>. If cross=true, corner cells are not filled. If the length of periodic is provided, periodic boundaries are also filled. Note that <a class="el" href="classamrex_1_1FabArray.html" title="An Array of FortranArrayBox(FAB)-like Objects.">FabArray</a> itself does not contains any periodicity information. FillBoundary expects that its cell-centered version of its <a class="el" href="classamrex_1_1BoxArray.html" title="A collection of Boxes stored in an Array.">BoxArray</a> is non-overlapping. </p>

</div>
</div>
<a id="ga73c4ba8aa5ed4620734ba6bbc09bfa6b" name="ga73c4ba8aa5ed4620734ba6bbc09bfa6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73c4ba8aa5ed4620734ba6bbc09bfa6b">&#9670;&#160;</a></span>FillBoundary() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
<div class="memtemplate">
template&lt;typename BUF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::FillBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cross</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7c3bcb50994c05df7dbfcd3d63a41249" name="ga7c3bcb50994c05df7dbfcd3d63a41249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c3bcb50994c05df7dbfcd3d63a41249">&#9670;&#160;</a></span>FillBoundary() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
<div class="memtemplate">
template&lt;typename BUF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::FillBoundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cross</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structamrex_1_1Same.html">Same</a> as <a class="el" href="classamrex_1_1FabArrayBase.html#ae11e4187caa383605cab8f4d54ce115c">FillBoundary()</a>, but only copies ncomp components starting at scomp. </p>

</div>
</div>
<a id="ga59c47cdc663d31e529ec89d3a10c2969" name="ga59c47cdc663d31e529ec89d3a10c2969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59c47cdc663d31e529ec89d3a10c2969">&#9670;&#160;</a></span>FillBoundary() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
<div class="memtemplate">
template&lt;typename BUF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::FillBoundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cross</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae0a03b23f179e0c50e162387e35ea00b" name="gae0a03b23f179e0c50e162387e35ea00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a03b23f179e0c50e162387e35ea00b">&#9670;&#160;</a></span>FillBoundary() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
<div class="memtemplate">
template&lt;typename BUF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::FillBoundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cross</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga84ce4d97367dcb2da8be8bddfac2ef4e" name="ga84ce4d97367dcb2da8be8bddfac2ef4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84ce4d97367dcb2da8be8bddfac2ef4e">&#9670;&#160;</a></span>FillBoundaryAndSync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::FillBoundaryAndSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em> = <code><a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill ghost cells and synchronize nodal data. </p>
<p>Ghost regions are filled with data from the intersecting valid regions. The synchronization will override valid regions by the intersecting valid regions with a higher precedence. The smaller the global box index is, the higher precedence the box has. With periodic boundaries, for cells in the same box, those near the lower corner have higher precedence than those near the upper corner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>periodic length if it's non-zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a2ee6a93d9d13d4f4a1f864f3c767cb" name="ga6a2ee6a93d9d13d4f4a1f864f3c767cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a2ee6a93d9d13d4f4a1f864f3c767cb">&#9670;&#160;</a></span>FillBoundaryAndSync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::FillBoundaryAndSync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill ghost cells and synchronize nodal data. </p>
<p>Ghost regions are filled with data from the intersecting valid regions. The synchronization will override valid regions by the intersecting valid regions with a higher precedence. The smaller the global box index is, the higher precedence the box has. With periodic boundaries, for cells in the same box, those near the lower corner have higher precedence than those near the upper corner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scomp</td><td>starting component </td></tr>
    <tr><td class="paramname">ncomp</td><td>number of components </td></tr>
    <tr><td class="paramname">nghost</td><td>number of ghost cells to fill </td></tr>
    <tr><td class="paramname">period</td><td>periodic length if it's non-zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga642f844c834d6fb714e3e0fc6eb75e56" name="ga642f844c834d6fb714e3e0fc6eb75e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga642f844c834d6fb714e3e0fc6eb75e56">&#9670;&#160;</a></span>maxIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> amrex::MultiFab::maxIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nghost</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab351d9250414508cf086635f54e2e2ce" name="gab351d9250414508cf086635f54e2e2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab351d9250414508cf086635f54e2e2ce">&#9670;&#160;</a></span>minIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> amrex::MultiFab::minIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nghost</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae4ba8fc4756c0621e3872055ffce31b0" name="gae4ba8fc4756c0621e3872055ffce31b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ba8fc4756c0621e3872055ffce31b0">&#9670;&#160;</a></span>norm1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> &gt; amrex::MultiFab::norm1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>comps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ngrow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the L1 norm of each component of "comps" over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. ngrow ghost cells are used. </p>

</div>
</div>
<a id="gafcdc4aaf73896a44ad364520af9a7398" name="gafcdc4aaf73896a44ad364520af9a7398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcdc4aaf73896a44ad364520af9a7398">&#9670;&#160;</a></span>norm1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::norm1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ngrow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the L1 norm of component <code>comp</code> over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. <code>ngrow</code> ghost cells are used. </p>

</div>
</div>
<a id="ga933d1dd75c4441bf922f8c5baa931be4" name="ga933d1dd75c4441bf922f8c5baa931be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga933d1dd75c4441bf922f8c5baa931be4">&#9670;&#160;</a></span>norm2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> &gt; amrex::MultiFab::norm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>comps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the L2 norm of each component of "comps" over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. No ghost cells are used. </p>

</div>
</div>
<a id="ga0982c02422dcb603d1c5129d744d6611" name="ga0982c02422dcb603d1c5129d744d6611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0982c02422dcb603d1c5129d744d6611">&#9670;&#160;</a></span>norm2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::norm2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the L2 norm of component <code>comp</code> over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. No ghost cells are used. This version has no double counting for nodal data. </p>

</div>
</div>
<a id="gacc29a136f07efb39a2d9acafc04cf9e1" name="gacc29a136f07efb39a2d9acafc04cf9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc29a136f07efb39a2d9acafc04cf9e1">&#9670;&#160;</a></span>norm2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::norm2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numcomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the L2 norm of <code>numcomp</code> components starting from <code>comp</code> component over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. No ghost cells are used. </p>

</div>
</div>
<a id="gaa0b6bb4fb2ee206356cd613ed8458b8f" name="gaa0b6bb4fb2ee206356cd613ed8458b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0b6bb4fb2ee206356cd613ed8458b8f">&#9670;&#160;</a></span>norm2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::norm2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the L2 norm of component <code>comp</code> over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a>. No ghost cells are used. </p>

</div>
</div>
<a id="gabc7329288ae6f73f8fd7eda95e49b8ba" name="gabc7329288ae6f73f8fd7eda95e49b8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc7329288ae6f73f8fd7eda95e49b8ba">&#9670;&#160;</a></span>norminf() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::norminf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1iMultiFab.html">iMultiFab</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nghost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7d3280950fb8a9b1ed17e73ee5df3c43" name="ga7d3280950fb8a9b1ed17e73ee5df3c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d3280950fb8a9b1ed17e73ee5df3c43">&#9670;&#160;</a></span>norminf() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> &gt; amrex::MultiFab::norminf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Vector.html">Vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>comps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nghost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_covered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaea595d71e8f04b18bc48aaca29acfe77" name="gaea595d71e8f04b18bc48aaca29acfe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea595d71e8f04b18bc48aaca29acfe77">&#9670;&#160;</a></span>norminf() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
<div class="memtemplate">
template&lt;typename IFAB , typename <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">F</a> , std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">F</a> &gt;::value, int &gt; FOO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">F::value_type <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::norminf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classamrex_1_1FabArray.html">FabArray</a>&lt; IFAB &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return infinity norm in masked region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>only mask=true region is included </td></tr>
    <tr><td class="paramname">comp</td><td>starting component </td></tr>
    <tr><td class="paramname">ncomp</td><td>number of components </td></tr>
    <tr><td class="paramname">nghost</td><td>number of ghost cells </td></tr>
    <tr><td class="paramname">local</td><td>If true, MPI communication is skipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48dc35bc87c8b41129bdff1e0cf9af05" name="ga48dc35bc87c8b41129bdff1e0cf9af05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48dc35bc87c8b41129bdff1e0cf9af05">&#9670;&#160;</a></span>norminf() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">F</a> , std::enable_if_t&lt; <a class="el" href="structamrex_1_1IsBaseFab.html">IsBaseFab</a>&lt; <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">F</a> &gt;::value, int &gt; FOO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">F::value_type <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::norminf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_covered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return infinity norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>starting component </td></tr>
    <tr><td class="paramname">ncomp</td><td>number of components </td></tr>
    <tr><td class="paramname">nghost</td><td>number of ghost cells </td></tr>
    <tr><td class="paramname">local</td><td>If true, MPI communication is skipped. </td></tr>
    <tr><td class="paramname">ignore_covered</td><td>ignore covered cells. Only relevant for cell-centered EB data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d57175907c89a969b9b5392631e65cf" name="ga9d57175907c89a969b9b5392631e65cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d57175907c89a969b9b5392631e65cf">&#9670;&#160;</a></span>norminf() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::norminf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nghost</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_covered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga37eadd5f219d50c8f1c3422f2fa81eb2" name="ga37eadd5f219d50c8f1c3422f2fa81eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37eadd5f219d50c8f1c3422f2fa81eb2">&#9670;&#160;</a></span>OverrideSync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::OverrideSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em> = <code><a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize nodal data. </p>
<p>The synchronization will override valid regions by the intersecting valid regions with a higher precedence. The smaller the global box index is, the higher precedence the box has. With periodic boundaries, for cells in the same box, those near the lower corner have higher precedence than those near the upper corner.</p>
<p>Example: Suppose there is a valid point that is shared by 4 boxes. Some operation assigns values a, b, c, and d to the 4 points in the 4 boxes. We then call SumBoundary to add the 4 values and store the result in the 4 boxes. The value in box 0 might be the result of a+b+c+d, the value in box 1 might be the result of b+c+d+a, etc. The resulting data could be out of sync across boxes due to roundoff errors. OverrideSync synchronizes the data by overriding all values with one value (e.g., the value from box 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>periodic length if it's non-zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f7ee90203e2af36c474d9b2234c8cae" name="ga4f7ee90203e2af36c474d9b2234c8cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f7ee90203e2af36c474d9b2234c8cae">&#9670;&#160;</a></span>OverrideSync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::OverrideSync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize nodal data. </p>
<p>The synchronization will override valid regions by the intersecting valid regions with a higher precedence. The smaller the global box index is, the higher precedence the box has. With periodic boundaries, for cells in the same box, those near the lower corner have higher precedence than those near the upper corner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scomp</td><td>starting component </td></tr>
    <tr><td class="paramname">ncomp</td><td>number of components </td></tr>
    <tr><td class="paramname">period</td><td>periodic length if it's non-zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga623e2f01e2a7695e835d258d1a8067b7" name="ga623e2f01e2a7695e835d258d1a8067b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga623e2f01e2a7695e835d258d1a8067b7">&#9670;&#160;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#a5e922fb76ff2eb645844783ad65d1490">Box</a> const &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sum of component "comp" in the given "region". &ndash; no ghost cells are included. </p>

</div>
</div>
<a id="ga62669a27ec4a577f0bef72dc2a1243aa" name="ga62669a27ec4a577f0bef72dc2a1243aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62669a27ec4a577f0bef72dc2a1243aa">&#9670;&#160;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::sum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sum of component "comp" over the <a class="el" href="classamrex_1_1MultiFab.html" title="A collection (stored as an array) of FArrayBox objects.">MultiFab</a> &ndash; no ghost cells are included. </p>

</div>
</div>
<a id="gafe7c47dff8cf8e0fb550d0e78c7b5375" name="gafe7c47dff8cf8e0fb550d0e78c7b5375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe7c47dff8cf8e0fb550d0e78c7b5375">&#9670;&#160;</a></span>sum_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__amrex__arithmetic__types.html#ga00d9113947d2ea92bbdbfe7db24d81f2">Real</a> amrex::MultiFab::sum_unique </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>local</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em> = <code><a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structamrex_1_1Same.html">Same</a> as sum with <code>local</code> =false, but for non-cell-centered data, this only adds non-unique points that are owned by multiple boxes once. </p>

</div>
</div>
<a id="gaa3f916865d887cd0dd92e99e919f3059" name="gaa3f916865d887cd0dd92e99e919f3059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f916865d887cd0dd92e99e919f3059">&#9670;&#160;</a></span>SumBoundary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::SumBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em> = <code><a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum values in overlapped cells. </p>
<p>The destination is limited to valid cells. Note that being deterministic is not the same as data consistency on shared nodes. If you want data consistency on shared nodes, you can call OverrideSync after this. Sometimes, you can also wait till you need to do ghost cell exchanges, and you can then call FillBoundaryAndSync to do both. </p>

</div>
</div>
<a id="ga311f4acae65c8d6b9b720ab687a67635" name="ga311f4acae65c8d6b9b720ab687a67635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga311f4acae65c8d6b9b720ab687a67635">&#9670;&#160;</a></span>SumBoundary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::SumBoundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em> = <code><a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga33de3e606d07252276a70684a25bc3da" name="ga33de3e606d07252276a70684a25bc3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33de3e606d07252276a70684a25bc3da">&#9670;&#160;</a></span>SumBoundary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::SumBoundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em> = <code><a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum values in overlapped cells. </p>
<p>The destination is limited to valid + ngrow cells. Note that being deterministic is not the same as data consistency on shared nodes. If you want data consistency on shared nodes, you can call OverrideSync after this. Sometimes, you can also wait till you need to do ghost cell exchanges, and you can then call FillBoundaryAndSync to do both. </p>

</div>
</div>
<a id="gaaeaac94eb6e3e1e1a836c096053186c4" name="gaaeaac94eb6e3e1e1a836c096053186c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeaac94eb6e3e1e1a836c096053186c4">&#9670;&#160;</a></span>SumBoundary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classamrex_1_1FabArray.html">amrex::FabArray</a>&lt; FAB &gt;::SumBoundary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>src_nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceamrex.html#a95101764f5ec64cd1dd6e55614702cdb">IntVect</a> const &amp;&#160;</td>
          <td class="paramname"><em>dst_nghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classamrex_1_1Periodicity.html">Periodicity</a> &amp;&#160;</td>
          <td class="paramname"><em>period</em> = <code><a class="el" href="classamrex_1_1Periodicity.html#a194e779bf59d1700830a35cecb5271a5">Periodicity::NonPeriodic</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deterministic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum values in overlapped cells. </p>
<p>For computing the overlap, the dst is grown by dst_ngrow, while the src uses src_ngrow. Note that being deterministic is not the same as data consistency on shared nodes. If you want data consistency on shared nodes, you can call OverrideSync after this. Sometimes, you can also wait till you need to do ghost cell exchanges, and you can then call FillBoundaryAndSync to do both. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
