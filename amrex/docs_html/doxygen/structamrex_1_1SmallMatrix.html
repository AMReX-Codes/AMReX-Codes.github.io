<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!--title>AMReX: amrex::SmallMatrix&lt; T, NRows, NCols, ORDER, StartIndex &gt; Struct Template Reference</title-->
<title>AMReX: Block-Structured AMR Software Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="amrex_logo_tiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Block-Structured AMR Software Framework
   </div>
   <!--div id="projectbrief">Block-Structured AMR Software Framework</div-->
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structamrex_1_1SmallMatrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structamrex_1_1SmallMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">amrex::SmallMatrix&lt; T, NRows, NCols, ORDER, StartIndex &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Matrix class with compile-time size.  
 <a href="structamrex_1_1SmallMatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AMReX__SmallMatrix_8H_source.html">AMReX_SmallMatrix.H</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab0850c542b077a67c59dae912e0549d9" id="r_ab0850c542b077a67c59dae912e0549d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#ab0850c542b077a67c59dae912e0549d9">value_type</a> = T</td></tr>
<tr class="separator:ab0850c542b077a67c59dae912e0549d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54d9be19be0cf11747349876041d803" id="r_ae54d9be19be0cf11747349876041d803"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#ae54d9be19be0cf11747349876041d803">reference_type</a> = T &amp;</td></tr>
<tr class="separator:ae54d9be19be0cf11747349876041d803"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a34d563a23b3567200219039bed2afb89" id="r_a34d563a23b3567200219039bed2afb89"><td class="memItemLeft" align="right" valign="top">__host__ __device__ constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a34d563a23b3567200219039bed2afb89">SmallMatrix</a> ()=default</td></tr>
<tr class="memdesc:a34d563a23b3567200219039bed2afb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a34d563a23b3567200219039bed2afb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f0758c96388a0bb1b2cfb389c1444f" id="r_ae8f0758c96388a0bb1b2cfb389c1444f"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, int MM = NRows, int NN = NCols, std::enable_if_t&lt; MM==1||NN==1, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae8f0758c96388a0bb1b2cfb389c1444f"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#ae8f0758c96388a0bb1b2cfb389c1444f">SmallMatrix</a> (Ts... vs)</td></tr>
<tr class="memdesc:ae8f0758c96388a0bb1b2cfb389c1444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs column- or row-vector.  <br /></td></tr>
<tr class="separator:ae8f0758c96388a0bb1b2cfb389c1444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eda12573c4539f33c4f0dc15df35b1" id="r_a84eda12573c4539f33c4f0dc15df35b1"><td class="memItemLeft" align="right" valign="top">__host__ __device__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a84eda12573c4539f33c4f0dc15df35b1">SmallMatrix</a> (std::initializer_list&lt; std::initializer_list&lt; T &gt; &gt; const &amp;init)</td></tr>
<tr class="memdesc:a84eda12573c4539f33c4f0dc15df35b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="structamrex_1_1SmallMatrix.html" title="Matrix class with compile-time size.">SmallMatrix</a> with nested std::initializer_list.  <br /></td></tr>
<tr class="separator:a84eda12573c4539f33c4f0dc15df35b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e9bfe0af34a5d28fe66069f2bcd4b6" id="r_a46e9bfe0af34a5d28fe66069f2bcd4b6"><td class="memItemLeft" align="right" valign="top">__host__ __device__ const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a46e9bfe0af34a5d28fe66069f2bcd4b6">operator()</a> (int i, int j) const noexcept</td></tr>
<tr class="memdesc:a46e9bfe0af34a5d28fe66069f2bcd4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the element at row i and column j.  <br /></td></tr>
<tr class="separator:a46e9bfe0af34a5d28fe66069f2bcd4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace190f3e6fc72450fed3d30bf186c4c3" id="r_ace190f3e6fc72450fed3d30bf186c4c3"><td class="memItemLeft" align="right" valign="top">__host__ __device__ T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#ace190f3e6fc72450fed3d30bf186c4c3">operator()</a> (int i, int j) noexcept</td></tr>
<tr class="memdesc:ace190f3e6fc72450fed3d30bf186c4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at row i and column j.  <br /></td></tr>
<tr class="separator:ace190f3e6fc72450fed3d30bf186c4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087f14af55ca0a7f41d538344fb1fb2e" id="r_a087f14af55ca0a7f41d538344fb1fb2e"><td class="memTemplParams" colspan="2">template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt;(MM==1||NN==1), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a087f14af55ca0a7f41d538344fb1fb2e"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a087f14af55ca0a7f41d538344fb1fb2e">operator()</a> (int i) const noexcept</td></tr>
<tr class="memdesc:a087f14af55ca0a7f41d538344fb1fb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to element i of a vector.  <br /></td></tr>
<tr class="separator:a087f14af55ca0a7f41d538344fb1fb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bb5f342e3c38cdbab0b462f65a0b2b" id="r_a02bb5f342e3c38cdbab0b462f65a0b2b"><td class="memTemplParams" colspan="2">template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt;(MM==1||NN==1), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a02bb5f342e3c38cdbab0b462f65a0b2b"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a02bb5f342e3c38cdbab0b462f65a0b2b">operator()</a> (int i) noexcept</td></tr>
<tr class="memdesc:a02bb5f342e3c38cdbab0b462f65a0b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i of a vector.  <br /></td></tr>
<tr class="separator:a02bb5f342e3c38cdbab0b462f65a0b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e7ae4638428051d116ea0a9d1c8e60" id="r_ad9e7ae4638428051d116ea0a9d1c8e60"><td class="memTemplParams" colspan="2">template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt;(MM==1||NN==1), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad9e7ae4638428051d116ea0a9d1c8e60"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#ad9e7ae4638428051d116ea0a9d1c8e60">operator[]</a> (int i) const noexcept</td></tr>
<tr class="memdesc:ad9e7ae4638428051d116ea0a9d1c8e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to element i of a vector.  <br /></td></tr>
<tr class="separator:ad9e7ae4638428051d116ea0a9d1c8e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab1da13035682f8fb41ffddca830c01" id="r_a1ab1da13035682f8fb41ffddca830c01"><td class="memTemplParams" colspan="2">template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt;(MM==1||NN==1), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1ab1da13035682f8fb41ffddca830c01"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a1ab1da13035682f8fb41ffddca830c01">operator[]</a> (int i) noexcept</td></tr>
<tr class="memdesc:a1ab1da13035682f8fb41ffddca830c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to element i of a vector.  <br /></td></tr>
<tr class="separator:a1ab1da13035682f8fb41ffddca830c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38230944df9f142ad8f9944c1cc6529" id="r_ae38230944df9f142ad8f9944c1cc6529"><td class="memItemLeft" align="right" valign="top">__host__ __device__ const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#ae38230944df9f142ad8f9944c1cc6529">begin</a> () const noexcept</td></tr>
<tr class="separator:ae38230944df9f142ad8f9944c1cc6529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068f7e326d1f10b48803c3f28ae5270a" id="r_a068f7e326d1f10b48803c3f28ae5270a"><td class="memItemLeft" align="right" valign="top">__host__ __device__ const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a068f7e326d1f10b48803c3f28ae5270a">end</a> () const noexcept</td></tr>
<tr class="separator:a068f7e326d1f10b48803c3f28ae5270a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a41957efe024ff23058daafdecaee2e" id="r_a7a41957efe024ff23058daafdecaee2e"><td class="memItemLeft" align="right" valign="top">__host__ __device__ T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a7a41957efe024ff23058daafdecaee2e">begin</a> () noexcept</td></tr>
<tr class="separator:a7a41957efe024ff23058daafdecaee2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751813e95a762b0a812a06c2d45a5f71" id="r_a751813e95a762b0a812a06c2d45a5f71"><td class="memItemLeft" align="right" valign="top">__host__ __device__ T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a751813e95a762b0a812a06c2d45a5f71">end</a> () noexcept</td></tr>
<tr class="separator:a751813e95a762b0a812a06c2d45a5f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9ec93c4d479484b15037a50db13fe8" id="r_aad9ec93c4d479484b15037a50db13fe8"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#aad9ec93c4d479484b15037a50db13fe8">setVal</a> (T val)</td></tr>
<tr class="memdesc:aad9ec93c4d479484b15037a50db13fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all elements in the matrix to the given value.  <br /></td></tr>
<tr class="separator:aad9ec93c4d479484b15037a50db13fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bb6b2a2877664a689394e5f38fcd8a" id="r_af2bb6b2a2877664a689394e5f38fcd8a"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NCols, NRows, ORDER, StartIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#af2bb6b2a2877664a689394e5f38fcd8a">transpose</a> () const</td></tr>
<tr class="memdesc:af2bb6b2a2877664a689394e5f38fcd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns transposed matrix.  <br /></td></tr>
<tr class="separator:af2bb6b2a2877664a689394e5f38fcd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea23bea08425e0b9547e6ba07c7c4ece" id="r_aea23bea08425e0b9547e6ba07c7c4ece"><td class="memTemplParams" colspan="2">template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt; MM==NN, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aea23bea08425e0b9547e6ba07c7c4ece"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#aea23bea08425e0b9547e6ba07c7c4ece">transposeInPlace</a> ()</td></tr>
<tr class="memdesc:aea23bea08425e0b9547e6ba07c7c4ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a square matrix in-place.  <br /></td></tr>
<tr class="separator:aea23bea08425e0b9547e6ba07c7c4ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17491e0fd25a2e75e1568378d3df641e" id="r_a17491e0fd25a2e75e1568378d3df641e"><td class="memItemLeft" align="right" valign="top">__host__ __device__ T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a17491e0fd25a2e75e1568378d3df641e">product</a> () const</td></tr>
<tr class="memdesc:a17491e0fd25a2e75e1568378d3df641e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of all elements in the matrix.  <br /></td></tr>
<tr class="separator:a17491e0fd25a2e75e1568378d3df641e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb49e6e02e8f4bb0df7838e68234cf9" id="r_aefb49e6e02e8f4bb0df7838e68234cf9"><td class="memItemLeft" align="right" valign="top">__host__ __device__ T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#aefb49e6e02e8f4bb0df7838e68234cf9">sum</a> () const</td></tr>
<tr class="memdesc:aefb49e6e02e8f4bb0df7838e68234cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements in the matrix.  <br /></td></tr>
<tr class="separator:aefb49e6e02e8f4bb0df7838e68234cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9322fe4816b3831489f605466449c1b2" id="r_a9322fe4816b3831489f605466449c1b2"><td class="memTemplParams" colspan="2">template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt; MM==NN, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9322fe4816b3831489f605466449c1b2"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a9322fe4816b3831489f605466449c1b2">trace</a> () const</td></tr>
<tr class="memdesc:a9322fe4816b3831489f605466449c1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of a square matrix.  <br /></td></tr>
<tr class="separator:a9322fe4816b3831489f605466449c1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e60c8a74c226b712f8e94cf739dd31f" id="r_a6e60c8a74c226b712f8e94cf739dd31f"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a6e60c8a74c226b712f8e94cf739dd31f">operator+=</a> (<a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a6e60c8a74c226b712f8e94cf739dd31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator += performing matrix addition as in (*this) += rhs.  <br /></td></tr>
<tr class="separator:a6e60c8a74c226b712f8e94cf739dd31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f793ff591a97c1883c7f77a94235ce9" id="r_a3f793ff591a97c1883c7f77a94235ce9"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a3f793ff591a97c1883c7f77a94235ce9">operator-=</a> (<a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a3f793ff591a97c1883c7f77a94235ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator -= performing matrix subtraction as in (*this) -= rhs.  <br /></td></tr>
<tr class="separator:a3f793ff591a97c1883c7f77a94235ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafeb6825947155f77218e8116d9093a1" id="r_aafeb6825947155f77218e8116d9093a1"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#aafeb6825947155f77218e8116d9093a1">operator-</a> () const</td></tr>
<tr class="memdesc:aafeb6825947155f77218e8116d9093a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator.  <br /></td></tr>
<tr class="separator:aafeb6825947155f77218e8116d9093a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b10a3505aab67c6c7587fc2f7d22fa8" id="r_a8b10a3505aab67c6c7587fc2f7d22fa8"><td class="memItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a8b10a3505aab67c6c7587fc2f7d22fa8">operator*=</a> (T a)</td></tr>
<tr class="memdesc:a8b10a3505aab67c6c7587fc2f7d22fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator *= that scales this matrix in place by a scalar.  <br /></td></tr>
<tr class="separator:a8b10a3505aab67c6c7587fc2f7d22fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3eaa4aab88dde733f24b73954dfae1" id="r_ada3eaa4aab88dde733f24b73954dfae1"><td class="memItemLeft" align="right" valign="top">__host__ __device__ T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#ada3eaa4aab88dde733f24b73954dfae1">dot</a> (<a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;rhs) const</td></tr>
<tr class="memdesc:ada3eaa4aab88dde733f24b73954dfae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of two vectors.  <br /></td></tr>
<tr class="separator:ada3eaa4aab88dde733f24b73954dfae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997feb74890732d6cd717bfddfc554cf" id="r_a997feb74890732d6cd717bfddfc554cf"><td class="memTemplParams" colspan="2">template&lt;int N, std::enable_if_t&lt;(N&lt; NRows *NCols), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a997feb74890732d6cd717bfddfc554cf"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ constexpr T const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a997feb74890732d6cd717bfddfc554cf">get</a> () const</td></tr>
<tr class="separator:a997feb74890732d6cd717bfddfc554cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b190ed6ee5791bcaa8fc244c1f95fda" id="r_a1b190ed6ee5791bcaa8fc244c1f95fda"><td class="memTemplParams" colspan="2">template&lt;int N, std::enable_if_t&lt;(N&lt; NRows *NCols), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1b190ed6ee5791bcaa8fc244c1f95fda"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a1b190ed6ee5791bcaa8fc244c1f95fda">get</a> ()</td></tr>
<tr class="separator:a1b190ed6ee5791bcaa8fc244c1f95fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a81b984b88b86c8fb73373ca9ade02aee" id="r_a81b984b88b86c8fb73373ca9ade02aee"><td class="memTemplParams" colspan="2">template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt; MM==NN, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81b984b88b86c8fb73373ca9ade02aee"><td class="memTemplItemLeft" align="right" valign="top">static constexpr __host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a81b984b88b86c8fb73373ca9ade02aee">Identity</a> () noexcept</td></tr>
<tr class="memdesc:a81b984b88b86c8fb73373ca9ade02aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity matrix.  <br /></td></tr>
<tr class="separator:a81b984b88b86c8fb73373ca9ade02aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c425962e7338c912dad47c861187a1d" id="r_a5c425962e7338c912dad47c861187a1d"><td class="memItemLeft" align="right" valign="top">static constexpr __host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a5c425962e7338c912dad47c861187a1d">Zero</a> () noexcept</td></tr>
<tr class="memdesc:a5c425962e7338c912dad47c861187a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix initialized with zeros.  <br /></td></tr>
<tr class="separator:a5c425962e7338c912dad47c861187a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a16884af63d24ace53c32c2b304f28cb1" id="r_a16884af63d24ace53c32c2b304f28cb1"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a16884af63d24ace53c32c2b304f28cb1">row_size</a> = NRows</td></tr>
<tr class="separator:a16884af63d24ace53c32c2b304f28cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27953e4ba231ae72eee1d04bfcbad71" id="r_ad27953e4ba231ae72eee1d04bfcbad71"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#ad27953e4ba231ae72eee1d04bfcbad71">column_size</a> = NCols</td></tr>
<tr class="separator:ad27953e4ba231ae72eee1d04bfcbad71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a52e4625ed98c93b816e56a376e283a" id="r_a3a52e4625ed98c93b816e56a376e283a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a3a52e4625ed98c93b816e56a376e283a">ordering</a> = ORDER</td></tr>
<tr class="separator:a3a52e4625ed98c93b816e56a376e283a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c3d4215f2fdfccfcd326386572f1f2" id="r_a54c3d4215f2fdfccfcd326386572f1f2"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a54c3d4215f2fdfccfcd326386572f1f2">starting_index</a> = StartIndex</td></tr>
<tr class="separator:a54c3d4215f2fdfccfcd326386572f1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a32448f0826904fa7d77c008793cbc0f1" id="r_a32448f0826904fa7d77c008793cbc0f1"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a32448f0826904fa7d77c008793cbc0f1">m_mat</a> [NRows *NCols]</td></tr>
<tr class="separator:a32448f0826904fa7d77c008793cbc0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adff9083c0609d04bf3c1fb5a6cc0db4d" id="r_adff9083c0609d04bf3c1fb5a6cc0db4d"><td class="memItemLeft" align="right" valign="top">__host__ __device__ friend <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#adff9083c0609d04bf3c1fb5a6cc0db4d">operator+</a> (<a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; lhs, <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:adff9083c0609d04bf3c1fb5a6cc0db4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator + returning the result of maxtrix addition, lhs+rhs.  <br /></td></tr>
<tr class="separator:adff9083c0609d04bf3c1fb5a6cc0db4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7c289ab070ae26303253e161b3bdba" id="r_a2c7c289ab070ae26303253e161b3bdba"><td class="memItemLeft" align="right" valign="top">__host__ __device__ friend <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a2c7c289ab070ae26303253e161b3bdba">operator-</a> (<a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; lhs, <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a2c7c289ab070ae26303253e161b3bdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary operator - returning the result of maxtrix subtraction, lhs-rhs.  <br /></td></tr>
<tr class="separator:a2c7c289ab070ae26303253e161b3bdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1efe177196901819180cd38a419c96" id="r_a1f1efe177196901819180cd38a419c96"><td class="memItemLeft" align="right" valign="top">__host__ __device__ friend <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a1f1efe177196901819180cd38a419c96">operator*</a> (<a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; m, T a)</td></tr>
<tr class="memdesc:a1f1efe177196901819180cd38a419c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of a matrix and a scalar.  <br /></td></tr>
<tr class="separator:a1f1efe177196901819180cd38a419c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffe7215b8c4f470f8baa3111ab12369" id="r_a9ffe7215b8c4f470f8baa3111ab12369"><td class="memItemLeft" align="right" valign="top">__host__ __device__ friend <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a9ffe7215b8c4f470f8baa3111ab12369">operator*</a> (T a, <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; m)</td></tr>
<tr class="memdesc:a9ffe7215b8c4f470f8baa3111ab12369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of a scalar and a matrix.  <br /></td></tr>
<tr class="separator:a9ffe7215b8c4f470f8baa3111ab12369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff11d7db8679060cf879748039c0a6a" id="r_a9ff11d7db8679060cf879748039c0a6a"><td class="memTemplParams" colspan="2">template&lt;class U , class V , int N1, int N2, int N3, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> Ord, int SI&gt; </td></tr>
<tr class="memitem:a9ff11d7db8679060cf879748039c0a6a"><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ friend decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structamrex_1_1SmallMatrix.html#a9ff11d7db8679060cf879748039c0a6a">operator*</a> (<a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; U, N1, N2, Ord, SI &gt; const &amp;lhs, <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; V, N2, N3, Ord, SI &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a9ff11d7db8679060cf879748039c0a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns matrix product of two matrices.  <br /></td></tr>
<tr class="separator:a9ff11d7db8679060cf879748039c0a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt;<br />
struct amrex::SmallMatrix&lt; T, NRows, NCols, ORDER, StartIndex &gt;</div><p>Matrix class with compile-time size. </p>
<p>Note that column vectors and row vectors are special cases of a Matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Matrix element data type. </td></tr>
    <tr><td class="paramname">NRows</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">NCols</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">ORDER</td><td>Memory layout order. <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012">Order::F</a> (i.e., column-major) by default. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>Starting index. Either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae54d9be19be0cf11747349876041d803" name="ae54d9be19be0cf11747349876041d803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54d9be19be0cf11747349876041d803">&#9670;&#160;</a></span>reference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::reference_type =  T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0850c542b077a67c59dae912e0549d9" name="ab0850c542b077a67c59dae912e0549d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0850c542b077a67c59dae912e0549d9">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a34d563a23b3567200219039bed2afb89" name="a34d563a23b3567200219039bed2afb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d563a23b3567200219039bed2afb89">&#9670;&#160;</a></span>SmallMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ constexpr <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::SmallMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The data are uninitialized by default. If you want to initialize to zero, you can do <code><a class="el" href="structamrex_1_1SmallMatrix.html" title="Matrix class with compile-time size.">SmallMatrix</a>&lt;T,NRows,NCols&gt; M{};</code>. </p>

</div>
</div>
<a id="ae8f0758c96388a0bb1b2cfb389c1444f" name="ae8f0758c96388a0bb1b2cfb389c1444f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f0758c96388a0bb1b2cfb389c1444f">&#9670;&#160;</a></span>SmallMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;typename... Ts, int MM = NRows, int NN = NCols, std::enable_if_t&lt; MM==1||NN==1, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ constexpr <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::SmallMatrix </td>
          <td>(</td>
          <td class="paramtype">Ts...&#160;</td>
          <td class="paramname"><em>vs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs column- or row-vector. </p>
<p>The data are initialized with the given variadic arguments. If the number of argument is less than the size of the vector, the rest of the vector is initialized to zero. </p>

</div>
</div>
<a id="a84eda12573c4539f33c4f0dc15df35b1" name="a84eda12573c4539f33c4f0dc15df35b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84eda12573c4539f33c4f0dc15df35b1">&#9670;&#160;</a></span>SmallMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::SmallMatrix </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; T &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="structamrex_1_1SmallMatrix.html" title="Matrix class with compile-time size.">SmallMatrix</a> with nested std::initializer_list. </p>
<p>The initializer list is assumed to be in row-major order, even when the ordering for the <a class="el" href="structamrex_1_1SmallMatrix.html" title="Matrix class with compile-time size.">SmallMatrix</a> object is colum-major. Below is an example of constructing a matrix with 2 rows and 3 columns. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structamrex_1_1SmallMatrix.html">SmallMatrix&lt;double,2,3&gt;</a> M{{11., 12., 13.},</div>
<div class="line">                          {21., 22., 23.}};</div>
<div class="ttc" id="astructamrex_1_1SmallMatrix_html"><div class="ttname"><a href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a></div><div class="ttdoc">Matrix class with compile-time size.</div><div class="ttdef"><b>Definition</b> AMReX_SmallMatrix.H:36</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae38230944df9f142ad8f9944c1cc6529" name="ae38230944df9f142ad8f9944c1cc6529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38230944df9f142ad8f9944c1cc6529">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ const T * <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code>const</code> pointer address to the first element of the <a class="el" href="structamrex_1_1SmallMatrix.html" title="Matrix class with compile-time size.">SmallMatrix</a> object, as if the object is treated as one-dimensional. </p>

</div>
</div>
<a id="a7a41957efe024ff23058daafdecaee2e" name="a7a41957efe024ff23058daafdecaee2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a41957efe024ff23058daafdecaee2e">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T * <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer address to the first element of the <a class="el" href="structamrex_1_1SmallMatrix.html" title="Matrix class with compile-time size.">SmallMatrix</a> object, as if the object is treated as one-dimensional. </p>

</div>
</div>
<a id="ada3eaa4aab88dde733f24b73954dfae1" name="ada3eaa4aab88dde733f24b73954dfae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3eaa4aab88dde733f24b73954dfae1">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of two vectors. </p>

</div>
</div>
<a id="a068f7e326d1f10b48803c3f28ae5270a" name="a068f7e326d1f10b48803c3f28ae5270a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068f7e326d1f10b48803c3f28ae5270a">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ const T * <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code>const</code> pointer address right after the last element of the <a class="el" href="structamrex_1_1SmallMatrix.html" title="Matrix class with compile-time size.">SmallMatrix</a> object, as if the object is treated as one-dimensional. </p>

</div>
</div>
<a id="a751813e95a762b0a812a06c2d45a5f71" name="a751813e95a762b0a812a06c2d45a5f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751813e95a762b0a812a06c2d45a5f71">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T * <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer address right after the last element of the <a class="el" href="structamrex_1_1SmallMatrix.html" title="Matrix class with compile-time size.">SmallMatrix</a> object, as if the object is treated as one-dimensional. </p>

</div>
</div>
<a id="a1b190ed6ee5791bcaa8fc244c1f95fda" name="a1b190ed6ee5791bcaa8fc244c1f95fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b190ed6ee5791bcaa8fc244c1f95fda">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int N, std::enable_if_t&lt;(N&lt; NRows *NCols), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ constexpr T &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a997feb74890732d6cd717bfddfc554cf" name="a997feb74890732d6cd717bfddfc554cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997feb74890732d6cd717bfddfc554cf">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int N, std::enable_if_t&lt;(N&lt; NRows *NCols), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ constexpr T const  &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81b984b88b86c8fb73373ca9ade02aee" name="a81b984b88b86c8fb73373ca9ade02aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b984b88b86c8fb73373ca9ade02aee">&#9670;&#160;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt; MM==NN, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr __host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity matrix. </p>

</div>
</div>
<a id="a087f14af55ca0a7f41d538344fb1fb2e" name="a087f14af55ca0a7f41d538344fb1fb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087f14af55ca0a7f41d538344fb1fb2e">&#9670;&#160;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt;(MM==1||NN==1), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ const T &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to element i of a vector. </p>

</div>
</div>
<a id="a02bb5f342e3c38cdbab0b462f65a0b2b" name="a02bb5f342e3c38cdbab0b462f65a0b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bb5f342e3c38cdbab0b462f65a0b2b">&#9670;&#160;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt;(MM==1||NN==1), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i of a vector. </p>

</div>
</div>
<a id="a46e9bfe0af34a5d28fe66069f2bcd4b6" name="a46e9bfe0af34a5d28fe66069f2bcd4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e9bfe0af34a5d28fe66069f2bcd4b6">&#9670;&#160;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ const T &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the element at row i and column j. </p>

</div>
</div>
<a id="ace190f3e6fc72450fed3d30bf186c4c3" name="ace190f3e6fc72450fed3d30bf186c4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace190f3e6fc72450fed3d30bf186c4c3">&#9670;&#160;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at row i and column j. </p>

</div>
</div>
<a id="a8b10a3505aab67c6c7587fc2f7d22fa8" name="a8b10a3505aab67c6c7587fc2f7d22fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b10a3505aab67c6c7587fc2f7d22fa8">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator *= that scales this matrix in place by a scalar. </p>

</div>
</div>
<a id="a6e60c8a74c226b712f8e94cf739dd31f" name="a6e60c8a74c226b712f8e94cf739dd31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e60c8a74c226b712f8e94cf739dd31f">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator += performing matrix addition as in (*this) += rhs. </p>

</div>
</div>
<a id="aafeb6825947155f77218e8116d9093a1" name="aafeb6825947155f77218e8116d9093a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafeb6825947155f77218e8116d9093a1">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator. </p>

</div>
</div>
<a id="a3f793ff591a97c1883c7f77a94235ce9" name="a3f793ff591a97c1883c7f77a94235ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f793ff591a97c1883c7f77a94235ce9">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator -= performing matrix subtraction as in (*this) -= rhs. </p>

</div>
</div>
<a id="ad9e7ae4638428051d116ea0a9d1c8e60" name="ad9e7ae4638428051d116ea0a9d1c8e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e7ae4638428051d116ea0a9d1c8e60">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt;(MM==1||NN==1), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ const T &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to element i of a vector. </p>

</div>
</div>
<a id="a1ab1da13035682f8fb41ffddca830c01" name="a1ab1da13035682f8fb41ffddca830c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab1da13035682f8fb41ffddca830c01">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt;(MM==1||NN==1), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to element i of a vector. </p>

</div>
</div>
<a id="a17491e0fd25a2e75e1568378d3df641e" name="a17491e0fd25a2e75e1568378d3df641e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17491e0fd25a2e75e1568378d3df641e">&#9670;&#160;</a></span>product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of all elements in the matrix. </p>

</div>
</div>
<a id="aad9ec93c4d479484b15037a50db13fe8" name="aad9ec93c4d479484b15037a50db13fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9ec93c4d479484b15037a50db13fe8">&#9670;&#160;</a></span>setVal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::setVal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all elements in the matrix to the given value. </p>

</div>
</div>
<a id="aefb49e6e02e8f4bb0df7838e68234cf9" name="aefb49e6e02e8f4bb0df7838e68234cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb49e6e02e8f4bb0df7838e68234cf9">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of all elements in the matrix. </p>

</div>
</div>
<a id="a9322fe4816b3831489f605466449c1b2" name="a9322fe4816b3831489f605466449c1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9322fe4816b3831489f605466449c1b2">&#9670;&#160;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt; MM==NN, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the trace of a square matrix. </p>

</div>
</div>
<a id="af2bb6b2a2877664a689394e5f38fcd8a" name="af2bb6b2a2877664a689394e5f38fcd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bb6b2a2877664a689394e5f38fcd8a">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NCols, NRows, ORDER, StartIndex &gt; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns transposed matrix. </p>

</div>
</div>
<a id="aea23bea08425e0b9547e6ba07c7c4ece" name="aea23bea08425e0b9547e6ba07c7c4ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea23bea08425e0b9547e6ba07c7c4ece">&#9670;&#160;</a></span>transposeInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;int MM = NRows, int NN = NCols, std::enable_if_t&lt; MM==NN, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; &amp; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::transposeInPlace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes a square matrix in-place. </p>

</div>
</div>
<a id="a5c425962e7338c912dad47c861187a1d" name="a5c425962e7338c912dad47c861187a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c425962e7338c912dad47c861187a1d">&#9670;&#160;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr __host__ __device__ <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a matrix initialized with zeros. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a1f1efe177196901819180cd38a419c96" name="a1f1efe177196901819180cd38a419c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1efe177196901819180cd38a419c96">&#9670;&#160;</a></span>operator* <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ friend <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of a matrix and a scalar. </p>

</div>
</div>
<a id="a9ff11d7db8679060cf879748039c0a6a" name="a9ff11d7db8679060cf879748039c0a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff11d7db8679060cf879748039c0a6a">&#9670;&#160;</a></span>operator* <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<div class="memtemplate">
template&lt;class U , class V , int N1, int N2, int N3, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> Ord, int SI&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ friend decltype(auto) operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; U, N1, N2, Ord, SI &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; V, N2, N3, Ord, SI &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns matrix product of two matrices. </p>

</div>
</div>
<a id="a9ffe7215b8c4f470f8baa3111ab12369" name="a9ffe7215b8c4f470f8baa3111ab12369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffe7215b8c4f470f8baa3111ab12369">&#9670;&#160;</a></span>operator* <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ friend <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of a scalar and a matrix. </p>

</div>
</div>
<a id="adff9083c0609d04bf3c1fb5a6cc0db4d" name="adff9083c0609d04bf3c1fb5a6cc0db4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff9083c0609d04bf3c1fb5a6cc0db4d">&#9670;&#160;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ friend <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary operator + returning the result of maxtrix addition, lhs+rhs. </p>

</div>
</div>
<a id="a2c7c289ab070ae26303253e161b3bdba" name="a2c7c289ab070ae26303253e161b3bdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7c289ab070ae26303253e161b3bdba">&#9670;&#160;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ friend <a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary operator - returning the result of maxtrix subtraction, lhs-rhs. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad27953e4ba231ae72eee1d04bfcbad71" name="ad27953e4ba231ae72eee1d04bfcbad71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27953e4ba231ae72eee1d04bfcbad71">&#9670;&#160;</a></span>column_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::column_size = NCols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32448f0826904fa7d77c008793cbc0f1" name="a32448f0826904fa7d77c008793cbc0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32448f0826904fa7d77c008793cbc0f1">&#9670;&#160;</a></span>m_mat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::m_mat[NRows *NCols]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a52e4625ed98c93b816e56a376e283a" name="a3a52e4625ed98c93b816e56a376e283a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a52e4625ed98c93b816e56a376e283a">&#9670;&#160;</a></span>ordering</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::ordering = ORDER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16884af63d24ace53c32c2b304f28cb1" name="a16884af63d24ace53c32c2b304f28cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16884af63d24ace53c32c2b304f28cb1">&#9670;&#160;</a></span>row_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::row_size = NRows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54c3d4215f2fdfccfcd326386572f1f2" name="a54c3d4215f2fdfccfcd326386572f1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c3d4215f2fdfccfcd326386572f1f2">&#9670;&#160;</a></span>starting_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int NRows, int NCols, <a class="el" href="namespaceamrex.html#a1e470da9cdaa55f3e887edb813385d20">Order</a> ORDER = Order::F, int StartIndex = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="structamrex_1_1SmallMatrix.html">amrex::SmallMatrix</a>&lt; T, NRows, NCols, ORDER, StartIndex &gt;::starting_index = StartIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/runner/work/amrex/amrex/Src/Base/<a class="el" href="AMReX__SmallMatrix_8H_source.html">AMReX_SmallMatrix.H</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceamrex.html">amrex</a></li><li class="navelem"><a class="el" href="structamrex_1_1SmallMatrix.html">SmallMatrix</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
