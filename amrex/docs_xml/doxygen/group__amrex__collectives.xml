<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="group__amrex__collectives" kind="group">
    <compoundname>amrex_collectives</compoundname>
    <title>Reductions and Scans</title>
    <innerclass refid="structamrex_1_1ReduceOpSum" prot="public">amrex::ReduceOpSum</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpMin" prot="public">amrex::ReduceOpMin</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpMax" prot="public">amrex::ReduceOpMax</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpLogicalAnd" prot="public">amrex::ReduceOpLogicalAnd</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpLogicalOr" prot="public">amrex::ReduceOpLogicalOr</innerclass>
    <innerclass refid="classamrex_1_1ReduceData" prot="public">amrex::ReduceData</innerclass>
    <innerclass refid="classamrex_1_1ReduceOps" prot="public">amrex::ReduceOps</innerclass>
    <innerclass refid="classamrex_1_1Reducer" prot="public">amrex::Reducer</innerclass>
    <sectiondef kind="func">
      <memberdef kind="function" id="group__amrex__collectives_1gafac1250d786b98bab8d8d2cf5c06411e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Reduce::Sum</definition>
        <argsstring>(N n, T const *v, T init_val=0)</argsstring>
        <name>Sum</name>
        <qualifiedname>amrex::Reduce::Sum</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T const *</type>
          <declname>v</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init_val</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Compute the sum of an array of values. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local reduction that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the reduction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the input data array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_val</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value (default: 0). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the sum. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="927" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="927" bodyend="935" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="38" declcolumn="3"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1gae179b14741cc532f08816fceabea24f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt; &amp;&amp;!std::is_same_v&lt; T *, std::decay_t&lt; F &gt; &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Reduce::Sum</definition>
        <argsstring>(N n, F const &amp;f, T init_val=0)</argsstring>
        <name>Sum</name>
        <qualifiedname>amrex::Reduce::Sum</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>F const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init_val</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Compute the sum of values generated by a callable. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local reduction that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the reduction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type with the signature <computeroutput>T(N)</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object invoked as <computeroutput>f(i)</computeroutput>. For GPU builds, this needs to be a device lambda function or functor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_val</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value (default: 0). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the sum. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="940" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="940" bodyend="948" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="59" declcolumn="3"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1ga07365bcdfaa9fe246330e8d91f71ecc0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Reduce::Min</definition>
        <argsstring>(N n, T const *v, T init_val=std::numeric_limits&lt; T &gt;::max())</argsstring>
        <name>Min</name>
        <qualifiedname>amrex::Reduce::Min</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T const *</type>
          <declname>v</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init_val</declname>
          <defval>std::numeric_limits&lt; T &gt;::max()</defval>
        </param>
        <briefdescription>
<para>Compute the minimum of an array of values. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local reduction that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the reduction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the input data array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_val</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value (default: <computeroutput>std::numeric_limits&lt;T&gt;::max()</computeroutput>). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the minimum. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="952" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="952" bodyend="960" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="77" declcolumn="3"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1ga8e8a5dd1862e4f8c8eb70e4601edd281" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt; &amp;&amp;!std::is_same_v&lt; T *, std::decay_t&lt; F &gt; &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Reduce::Min</definition>
        <argsstring>(N n, F const &amp;f, T init_val=std::numeric_limits&lt; T &gt;::max())</argsstring>
        <name>Min</name>
        <qualifiedname>amrex::Reduce::Min</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>F const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init_val</declname>
          <defval>std::numeric_limits&lt; T &gt;::max()</defval>
        </param>
        <briefdescription>
<para>Compute the minimum of values generated by a callable. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local reduction that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the reduction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type with the signature <computeroutput>T(N)</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object invoked as <computeroutput>f(i)</computeroutput>. For GPU builds, this needs to be a device lambda function or functor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_val</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value (default: <computeroutput>std::numeric_limits&lt;T&gt;::max()</computeroutput>). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the minimum. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="965" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="965" bodyend="973" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="98" declcolumn="3"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1ga7ac8075282193aef5024b3a7092a0f3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Reduce::Max</definition>
        <argsstring>(N n, T const *v, T init_val=std::numeric_limits&lt; T &gt;::lowest())</argsstring>
        <name>Max</name>
        <qualifiedname>amrex::Reduce::Max</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T const *</type>
          <declname>v</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init_val</declname>
          <defval>std::numeric_limits&lt; T &gt;::lowest()</defval>
        </param>
        <briefdescription>
<para>Compute the maximum of an array of values. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local reduction that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the reduction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the input data array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_val</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value (default: <computeroutput>std::numeric_limits&lt;T&gt;::lowest()</computeroutput>). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the maximum. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="977" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="977" bodyend="985" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="116" declcolumn="3"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1gabb357d8fcc6dd0426249ee962166fdd3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt; &amp;&amp;!std::is_same_v&lt; T *, std::decay_t&lt; F &gt; &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Reduce::Max</definition>
        <argsstring>(N n, F const &amp;f, T init_val=std::numeric_limits&lt; T &gt;::lowest())</argsstring>
        <name>Max</name>
        <qualifiedname>amrex::Reduce::Max</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>F const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init_val</declname>
          <defval>std::numeric_limits&lt; T &gt;::lowest()</defval>
        </param>
        <briefdescription>
<para>Compute the maximum of values generated by a callable. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local reduction that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the reduction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type with the signature <computeroutput>T(N)</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object invoked as <computeroutput>f(i)</computeroutput>. For GPU builds, this needs to be a device lambda function or functor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init_val</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value (default: <computeroutput>std::numeric_limits&lt;T&gt;::lowest()</computeroutput>). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the maximum. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="990" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="990" bodyend="998" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="137" declcolumn="3"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1gadae163b6d167d018ba6ec7cf821b97a8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; T, T &gt;</type>
        <definition>std::pair&lt; T, T &gt; amrex::Reduce::MinMax</definition>
        <argsstring>(N n, T const *v)</argsstring>
        <name>MinMax</name>
        <qualifiedname>amrex::Reduce::MinMax</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T const *</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Compute the minimum and maximum of an array of values. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local reduction that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the reduction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the input data array. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the pair of minimum and maximum. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="1002" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="1002" bodyend="1012" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="154" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1gac1dab3efd41294be3534dceac0c145b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt; &amp;&amp;!std::is_same_v&lt; T *, std::decay_t&lt; F &gt; &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; T, T &gt;</type>
        <definition>std::pair&lt; T, T &gt; amrex::Reduce::MinMax</definition>
        <argsstring>(N n, F const &amp;f)</argsstring>
        <name>MinMax</name>
        <qualifiedname>amrex::Reduce::MinMax</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>F const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Compute the minimum and maximum of values generated by a callable. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local reduction that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the reduction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type with the signature <computeroutput>T(N)</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object invoked as <computeroutput>f(i)</computeroutput>. For GPU builds, this needs to be a device lambda function or functor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the pair of minimum and maximum. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="1017" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="1017" bodyend="1028" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="174" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1gaf362eac7caa17fd8a2f7ee3831236367" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; N &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::Reduce::AnyOf</definition>
        <argsstring>(N n, T const *v, P const &amp;pred)</argsstring>
        <name>AnyOf</name>
        <qualifiedname>amrex::Reduce::AnyOf</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T const *</type>
          <declname>v</declname>
        </param>
        <param>
          <type>P const &amp;</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Test whether any element in an array satisfies a unary predicate. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local test that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type of the elements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>integral index type. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to test. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the input data array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>unary predicate object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the test result. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="1032" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="1032" bodyend="1085" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="193" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1ga1f8f5e42f31c1af5afd5655bf9e92fe5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::Reduce::AnyOf</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, P const &amp;pred)</argsstring>
        <name>AnyOf</name>
        <qualifiedname>amrex::Reduce::AnyOf</qualifiedname>
        <param>
          <type>BoxND&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>P const &amp;</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>Test whether the predicate is true for any index in a Box. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that this is local test that does not involve MPI.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dim</parametername>
</parameternamelist>
<parameterdescription>
<para>dimension of the box </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>box</parametername>
</parameternamelist>
<parameterdescription>
<para>index region for the loop </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object with the signature of <computeroutput>bool(int,int,int)</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the test result. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="1088" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="1088" bodyend="1148" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" declline="209" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1gad7ef336709704a3b8b05b00b9432059d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename FIN</type>
          </param>
          <param>
            <type>typename FOUT</type>
          </param>
          <param>
            <type>typename TYPE</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;N&gt; &amp;&amp;                                      (std::is_same&lt;std::decay_t&lt;TYPE&gt;,Type::Inclusive&gt;::value ||                                       std::is_same&lt;std::decay_t&lt;TYPE&gt;,Type::Exclusive&gt;::value)&gt;</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Scan::PrefixSum</definition>
        <argsstring>(N n, FIN const &amp;fin, FOUT const &amp;fout, TYPE, RetSum a_ret_sum=retSum)</argsstring>
        <name>PrefixSum</name>
        <qualifiedname>amrex::Scan::PrefixSum</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>FIN const &amp;</type>
          <declname>fin</declname>
        </param>
        <param>
          <type>FOUT const &amp;</type>
          <declname>fout</declname>
        </param>
        <param>
          <type>TYPE</type>
        </param>
        <param>
          <type>RetSum</type>
          <declname>a_ret_sum</declname>
          <defval>retSum</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" line="963" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" bodystart="963" bodyend="1203"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1ga252adc550a6d7b6ff5e31b6be3b2f12f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;N&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Scan::InclusiveSum</definition>
        <argsstring>(N n, T const *in, T *out, RetSum a_ret_sum=retSum)</argsstring>
        <name>InclusiveSum</name>
        <qualifiedname>amrex::Scan::InclusiveSum</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T const *</type>
          <declname>in</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>out</declname>
        </param>
        <param>
          <type>RetSum</type>
          <declname>a_ret_sum</declname>
          <defval>retSum</defval>
        </param>
        <briefdescription>
<para>Inclusive sum. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>in</parametername>
</parameternamelist>
<parameterdescription>
<para>input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>output </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_ret_sum</parametername>
</parameternamelist>
<parameterdescription>
<para>control the return value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>return the total sum if <computeroutput>a_ret_sum</computeroutput> is true </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" line="1219" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" bodystart="1219" bodyend="1276"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1ga375a3f04c8c0b11c577d168dbff3c9fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;N&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Scan::ExclusiveSum</definition>
        <argsstring>(N n, T const *in, T *out, RetSum a_ret_sum=retSum)</argsstring>
        <name>ExclusiveSum</name>
        <qualifiedname>amrex::Scan::ExclusiveSum</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T const *</type>
          <declname>in</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>out</declname>
        </param>
        <param>
          <type>RetSum</type>
          <declname>a_ret_sum</declname>
          <defval>retSum</defval>
        </param>
        <briefdescription>
<para>Exclusive sum. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>in</parametername>
</parameternamelist>
<parameterdescription>
<para>input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>output </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_ret_sum</parametername>
</parameternamelist>
<parameterdescription>
<para>control the return value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>return the total sum if <computeroutput>a_ret_sum</computeroutput> is true </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" line="1290" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" bodystart="1290" bodyend="1360"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1gab4e0fa80e6873e53208d917854f37129" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InIter</type>
          </param>
          <param>
            <type>class OutIter</type>
          </param>
        </templateparamlist>
        <type>OutIter</type>
        <definition>OutIter amrex::Gpu::inclusive_scan</definition>
        <argsstring>(InIter begin, InIter end, OutIter result)</argsstring>
        <name>inclusive_scan</name>
        <qualifiedname>amrex::Gpu::inclusive_scan</qualifiedname>
        <param>
          <type>InIter</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>InIter</type>
          <declname>end</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" line="1422" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" bodystart="1422" bodyend="1436"/>
      </memberdef>
      <memberdef kind="function" id="group__amrex__collectives_1ga3f116832e254a3422729b3455b22f18c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class InIter</type>
          </param>
          <param>
            <type>class OutIter</type>
          </param>
        </templateparamlist>
        <type>OutIter</type>
        <definition>OutIter amrex::Gpu::exclusive_scan</definition>
        <argsstring>(InIter begin, InIter end, OutIter result)</argsstring>
        <name>exclusive_scan</name>
        <qualifiedname>amrex::Gpu::exclusive_scan</qualifiedname>
        <param>
          <type>InIter</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>InIter</type>
          <declname>end</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" line="1440" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Scan.H" bodystart="1440" bodyend="1463"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Performance-portable reduction and scan operations in AMReX. </para>
    </briefdescription>
    <detaileddescription>
<para>These interfaces provide reductions (e.g., sum, min, max) and scan operations (prefix sums) over index spaces and ranges on both CPUs and GPUs. They do not use MPI and operate on data local to the process.</para>
<para>Key functions and classes include:<itemizedlist>
<listitem><para><ref refid="classamrex_1_1Reducer" kindref="compound">amrex::Reducer</ref></para>
</listitem><listitem><para><ref refid="structamrex_1_1ReduceOpSum" kindref="compound">amrex::ReduceOpSum</ref></para>
</listitem><listitem><para><ref refid="structamrex_1_1ReduceOpMin" kindref="compound">amrex::ReduceOpMin</ref></para>
</listitem><listitem><para><ref refid="structamrex_1_1ReduceOpMax" kindref="compound">amrex::ReduceOpMax</ref></para>
</listitem><listitem><para><ref refid="structamrex_1_1ReduceOpLogicalAnd" kindref="compound">amrex::ReduceOpLogicalAnd</ref></para>
</listitem><listitem><para><ref refid="structamrex_1_1ReduceOpLogicalOr" kindref="compound">amrex::ReduceOpLogicalOr</ref></para>
</listitem><listitem><para><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps</ref></para>
</listitem><listitem><para><ref refid="classamrex_1_1ReduceData" kindref="compound">amrex::ReduceData</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1gafac1250d786b98bab8d8d2cf5c06411e" kindref="member">amrex::Reduce::Sum</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1ga07365bcdfaa9fe246330e8d91f71ecc0" kindref="member">amrex::Reduce::Min</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1ga7ac8075282193aef5024b3a7092a0f3c" kindref="member">amrex::Reduce::Max</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1gadae163b6d167d018ba6ec7cf821b97a8" kindref="member">amrex::Reduce::MinMax</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1gaf362eac7caa17fd8a2f7ee3831236367" kindref="member">amrex::Reduce::AnyOf</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1gad7ef336709704a3b8b05b00b9432059d" kindref="member">amrex::Scan::PrefixSum</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1ga252adc550a6d7b6ff5e31b6be3b2f12f" kindref="member">amrex::Scan::InclusiveSum</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1ga375a3f04c8c0b11c577d168dbff3c9fd" kindref="member">amrex::Scan::ExclusiveSum</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1gab4e0fa80e6873e53208d917854f37129" kindref="member">amrex::Gpu::inclusive_scan</ref></para>
</listitem><listitem><para><ref refid="group__amrex__collectives_1ga3f116832e254a3422729b3455b22f18c" kindref="member">amrex::Gpu::exclusive_scan</ref> </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
  </compounddef>
</doxygen>
