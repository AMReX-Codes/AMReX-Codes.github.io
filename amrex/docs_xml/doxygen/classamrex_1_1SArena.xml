<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="classamrex_1_1SArena" kind="class" language="C++" prot="public">
    <compoundname>amrex::SArena</compoundname>
    <basecompoundref refid="classamrex_1_1Arena" prot="public" virt="non-virtual">amrex::Arena</basecompoundref>
    <includes refid="AMReX__SArena_8H" local="no">AMReX_SArena.H</includes>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classamrex_1_1SArena_1a63fbaa7486f66f7b06d529b3519739b3" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>void *</type>
        <definition>void * amrex::SArena::alloc</definition>
        <argsstring>(std::size_t sz) final</argsstring>
        <name>alloc</name>
        <qualifiedname>amrex::SArena::alloc</qualifiedname>
        <reimplements refid="classamrex_1_1Arena_1a0fa2cdc35eb9da4a03fedf53f6484c86">alloc</reimplements>
        <param>
          <type>std::size_t</type>
          <declname>sz</declname>
        </param>
        <briefdescription>
<para>Allocates dynamic memory from the arena of size sz. Returns a pointer to this memory. The memory can be used immediately by both the CPU and GPU with any stream. This function may synchronize all GPU streams to free up memory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="36" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.cpp" bodystart="5" bodyend="10"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1SArena_1abda3405739a036b7779e1bbeda674214" prot="public" static="no" const="no" explicit="no" inline="no" final="yes" virt="virtual">
        <type>void</type>
        <definition>void amrex::SArena::free</definition>
        <argsstring>(void *pt) final</argsstring>
        <name>free</name>
        <qualifiedname>amrex::SArena::free</qualifiedname>
        <reimplements refid="classamrex_1_1Arena_1a0c7e0730574c98febb6ddca2712cb515">free</reimplements>
        <param>
          <type>void *</type>
          <declname>pt</declname>
        </param>
        <briefdescription>
<para>Deletes the arena pointed to by pt. After this function is called, the memory can still be used by already launched GPU kernels on the currently active stream. This function may synchronize the currently active GPU stream to free up memory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="43" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.cpp" bodystart="13" bodyend="17"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1SArena_1aaa0854148c714974dce539a67e499e90" prot="public" static="no" const="yes" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool amrex::SArena::isDeviceAccessible</definition>
        <argsstring>() const final</argsstring>
        <name>isDeviceAccessible</name>
        <qualifiedname>amrex::SArena::isDeviceAccessible</qualifiedname>
        <reimplements refid="classamrex_1_1Arena_1afa7c9e223346f671eb055b3ce8580e56">isDeviceAccessible</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check whether the memory is accessible on the device. Note that isDeviceAccessible and isHostAccessible can both be true. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="45" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.cpp" bodystart="20" bodyend="23"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1SArena_1adfc84281671869bfbefe478e79bba72b" prot="public" static="no" const="yes" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool amrex::SArena::isHostAccessible</definition>
        <argsstring>() const final</argsstring>
        <name>isHostAccessible</name>
        <qualifiedname>amrex::SArena::isHostAccessible</qualifiedname>
        <reimplements refid="classamrex_1_1Arena_1a40d897685d407918d2d6143b5301a525">isHostAccessible</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check whether the memory is accessible on the host. Note that isDeviceAccessible and isHostAccessible can both be true. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="46" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.cpp" bodystart="26" bodyend="29"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1SArena_1a713f870b4126336039e89e0773266c48" prot="public" static="no" const="yes" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool amrex::SArena::isManaged</definition>
        <argsstring>() const final</argsstring>
        <name>isManaged</name>
        <qualifiedname>amrex::SArena::isManaged</qualifiedname>
        <reimplements refid="classamrex_1_1Arena_1a7119489f4464f902d907f6dfe9716909">isManaged</reimplements>
        <briefdescription>
<para>Check whether it is managed GPU memory. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that isManaged, isDevice and isPinned are mutually exclusive. For memory allocated by cudaMalloc* etc. in GPU builds, one of them returns true. For CPU builds, they are always false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="48" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.cpp" bodystart="32" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1SArena_1a2d9ae3373f2632620f535715ddbdecc1" prot="public" static="no" const="yes" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool amrex::SArena::isDevice</definition>
        <argsstring>() const final</argsstring>
        <name>isDevice</name>
        <qualifiedname>amrex::SArena::isDevice</qualifiedname>
        <reimplements refid="classamrex_1_1Arena_1aa45555e396ee74158b0c6f3331ce5536">isDevice</reimplements>
        <briefdescription>
<para>Check whether it is non-managed GPU device memory. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that isManaged, isDevice and isPinned are mutually exclusive. For memory allocated by cudaMalloc* etc. in GPU builds, one of them returns true. For CPU builds, they are always false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="49" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.cpp" bodystart="38" bodyend="41"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1SArena_1a8b7b7aebf6d7b6db4017d483baccc467" prot="public" static="no" const="yes" explicit="no" inline="no" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool amrex::SArena::isPinned</definition>
        <argsstring>() const final</argsstring>
        <name>isPinned</name>
        <qualifiedname>amrex::SArena::isPinned</qualifiedname>
        <reimplements refid="classamrex_1_1Arena_1a336e271c5a07296e4c2866d194111784">isPinned</reimplements>
        <briefdescription>
<para>Check whether it is pinned host memory. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that isManaged, isDevice and isPinned are mutually exclusive. For memory allocated by cudaMalloc* etc. in GPU builds, one of them returns true. For CPU builds, they are always false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="50" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.cpp" bodystart="44" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1SArena_1a5be263ca54c9b151254035bec28d7214" prot="public" static="no" const="yes" explicit="no" inline="yes" final="yes" virt="virtual">
        <type>bool</type>
        <definition>bool amrex::SArena::isStreamOrderedArena</definition>
        <argsstring>() const final</argsstring>
        <name>isStreamOrderedArena</name>
        <qualifiedname>amrex::SArena::isStreamOrderedArena</qualifiedname>
        <reimplements refid="classamrex_1_1Arena_1a45cb8a8f57250c6858412296275c8dbb">isStreamOrderedArena</reimplements>
        <briefdescription>
<para>Is this a GPU stream ordered memory allocator? </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="54" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" bodystart="54" bodyend="54"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>A STREAM-ordered memory arena. </para>
    </briefdescription>
    <detaileddescription>
<para>This <ref refid="classamrex_1_1Arena" kindref="compound">Arena</ref> is implemented as a wrapper around <ref refid="group__amrex__memory_1gae3d1414946b992f39ca41f135f12a0d1" kindref="member">amrex::The_Arena()</ref> where the <ref refid="classamrex_1_1SArena_1abda3405739a036b7779e1bbeda674214" kindref="member">free()</ref> function calls <ref refid="namespaceamrex_1_1Gpu_1a2e573a00e2c0d0bff8097bd9f3dd422e" kindref="member">amrex::Gpu::freeAsync()</ref>. This allows memory to be used by GPU kernels that were launched before <ref refid="classamrex_1_1SArena_1abda3405739a036b7779e1bbeda674214" kindref="member">free()</ref> was called but may execute afterward, without calling <ref refid="namespaceamrex_1_1Gpu_1a67a618504ee5fb94bd65a5d393e344b4" kindref="member">amrex::Gpu::streamSynchronize()</ref>. These kernels need to use the same GPU stream that is active when <ref refid="classamrex_1_1SArena_1abda3405739a036b7779e1bbeda674214" kindref="member">free()</ref> is called, otherwise explicit synchronization is needed.</para>
<para>This is achieved by holding freed memory in a temporary buffer until the next time the GPU stream is synchronized. In case too much memory is held up in this buffer or if The_Arena needs more memory, the stream is automatically synchronized to clear the buffer. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>amrex::Arena</label>
        <link refid="classamrex_1_1Arena"/>
      </node>
      <node id="1">
        <label>amrex::SArena</label>
        <link refid="classamrex_1_1SArena"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>amrex::Arena</label>
        <link refid="classamrex_1_1Arena"/>
        <childnode refid="3" relation="usage">
          <edgelabel>arena_info</edgelabel>
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>m_profiler</edgelabel>
        </childnode>
      </node>
      <node id="4">
        <label>amrex::Arena::ArenaProfiler</label>
        <link refid="structamrex_1_1Arena_1_1ArenaProfiler"/>
        <childnode refid="5" relation="usage">
          <edgelabel>m_arena_profiler_mutex</edgelabel>
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>m_profiling_stats</edgelabel>
        </childnode>
        <childnode refid="10" relation="usage">
          <edgelabel>m_currently_allocated</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>amrex::ArenaInfo</label>
        <link refid="structamrex_1_1ArenaInfo"/>
      </node>
      <node id="9">
        <label>amrex::MemStat</label>
        <link refid="structamrex_1_1MemStat"/>
      </node>
      <node id="1">
        <label>amrex::SArena</label>
        <link refid="classamrex_1_1SArena"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>std::map&lt; std::string, amrex::MemStat &gt;</label>
        <childnode refid="7" relation="usage">
          <edgelabel>keys</edgelabel>
        </childnode>
        <childnode refid="9" relation="usage">
          <edgelabel>elements</edgelabel>
        </childnode>
      </node>
      <node id="8">
        <label>std::basic_string&lt; Char &gt;</label>
      </node>
      <node id="5">
        <label>std::mutex</label>
      </node>
      <node id="7">
        <label>std::string</label>
        <childnode refid="8" relation="public-inheritance">
        </childnode>
      </node>
      <node id="10">
        <label>std::unordered_map&lt; void *, std::pair&lt; amrex::MemStat *, std::size_t &gt; &gt;</label>
      </node>
    </collaborationgraph>
    <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" line="25" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SArena.H" bodystart="28" bodyend="56"/>
    <listofallmembers>
      <member refid="classamrex_1_1Arena_1a253c417e0bd2863509c75d6250468a4e" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>align</name></member>
      <member refid="classamrex_1_1Arena_1a4b2f3b31e81e52426aef615cb2aaa7b7" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>align_size</name></member>
      <member refid="classamrex_1_1SArena_1a63fbaa7486f66f7b06d529b3519739b3" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>alloc</name></member>
      <member refid="classamrex_1_1Arena_1a872ba01b7389ba36beb402641df3f2b9" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>alloc_in_place</name></member>
      <member refid="classamrex_1_1Arena_1afc721e195430f79b2d1b287c490ef0fb" prot="protected" virt="non-virtual"><scope>amrex::SArena</scope><name>allocate_system</name></member>
      <member refid="classamrex_1_1Arena_1a2e2407d56d1710a0029928c776b27682" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>Arena</name></member>
      <member refid="classamrex_1_1Arena_1a57de8f5ef86cceadc9f1c00bc7ea7790" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>Arena</name></member>
      <member refid="classamrex_1_1Arena_1a3e2c87e60ea734fe6be6e49d124d5a76" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>Arena</name></member>
      <member refid="classamrex_1_1Arena_1aeb2158ba443c9b23ba0d12bcf38a66e1" prot="protected" virt="non-virtual"><scope>amrex::SArena</scope><name>arena_info</name></member>
      <member refid="classamrex_1_1Arena_1a6cf1a7926c2ee38d82fab5fadef8e4d0" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>arenaInfo</name></member>
      <member refid="classamrex_1_1Arena_1ac07ba8cda253cddee3cab1168ac65694" prot="protected" virt="non-virtual"><scope>amrex::SArena</scope><name>deallocate_system</name></member>
      <member refid="classamrex_1_1Arena_1a76f2f99b3aa712fe5da7b00610c07385" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>deregisterFromProfiling</name></member>
      <member refid="classamrex_1_1Arena_1a06dd6197d2081d7dd4c1bed308edd387" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>Finalize</name></member>
      <member refid="classamrex_1_1SArena_1abda3405739a036b7779e1bbeda674214" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>free</name></member>
      <member refid="classamrex_1_1Arena_1ae58dbb9ab6bb4e8d980b384b0d8804e5" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>freeUnused</name></member>
      <member refid="classamrex_1_1Arena_1a881f97d5676c4784f52d6f4c702da696" prot="protected" virt="virtual"><scope>amrex::SArena</scope><name>freeUnused_protected</name></member>
      <member refid="classamrex_1_1Arena_1abd6b026129f35157aa2b3945a37bdbd3" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>hasFreeDeviceMemory</name></member>
      <member refid="classamrex_1_1Arena_1ad3c30247b7f738cc4e292f781a503ce9" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>Initialize</name></member>
      <member refid="classamrex_1_1SArena_1a2d9ae3373f2632620f535715ddbdecc1" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>isDevice</name></member>
      <member refid="classamrex_1_1SArena_1aaa0854148c714974dce539a67e499e90" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>isDeviceAccessible</name></member>
      <member refid="classamrex_1_1SArena_1adfc84281671869bfbefe478e79bba72b" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>isHostAccessible</name></member>
      <member refid="classamrex_1_1SArena_1a713f870b4126336039e89e0773266c48" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>isManaged</name></member>
      <member refid="classamrex_1_1SArena_1a8b7b7aebf6d7b6db4017d483baccc467" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>isPinned</name></member>
      <member refid="classamrex_1_1SArena_1a5be263ca54c9b151254035bec28d7214" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>isStreamOrderedArena</name></member>
      <member refid="classamrex_1_1Arena_1ad136b691382e7a7d8fba158837416b98" prot="protected" virt="non-virtual"><scope>amrex::SArena</scope><name>m_profiler</name></member>
      <member refid="classamrex_1_1Arena_1a79c958fa2bc911b683c1bb312b54ef13" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>operator=</name></member>
      <member refid="classamrex_1_1Arena_1a23c2b2614dcafe7437bdba8ac8cbe163" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>operator=</name></member>
      <member refid="classamrex_1_1Arena_1a87a617ddebe957a11b9614915640d912" prot="protected" virt="non-virtual"><scope>amrex::SArena</scope><name>out_of_memory_abort</name></member>
      <member refid="classamrex_1_1Arena_1ada0c93d4aa3a9adce127ba381c652ac6" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>PrintUsage</name></member>
      <member refid="classamrex_1_1Arena_1aa1cfbcfa1c41ac7e45bf469e93db7402" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>PrintUsageToFiles</name></member>
      <member refid="classamrex_1_1Arena_1af8dfd674efa1da179629083236d2ad50" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>PrintUsageToStream</name></member>
      <member refid="classamrex_1_1Arena_1a99982885760cd861e6e860dea40ea64f" prot="public" virt="non-virtual"><scope>amrex::SArena</scope><name>registerForProfiling</name></member>
      <member refid="classamrex_1_1Arena_1a3f1783f675e9c483705081a695f9cedf" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>ResetMaxUsageCounter</name></member>
      <member refid="classamrex_1_1Arena_1aceacbbe5395a8671cc571063d51ee7e2" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>shrink_in_place</name></member>
      <member refid="classamrex_1_1Arena_1a327e7541e6291ce735c03392b21931b6" prot="public" virt="virtual"><scope>amrex::SArena</scope><name>~Arena</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
