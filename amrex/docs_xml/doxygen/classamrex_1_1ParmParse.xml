<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classamrex_1_1ParmParse" kind="class" language="C++" prot="public">
    <compoundname>amrex::ParmParse</compoundname>
    <includes refid="AMReX__ParmParse_8H" local="no">AMReX_ParmParse.H</includes>
    <innerclass refid="structamrex_1_1ParmParse_1_1PP__entry" prot="public">amrex::ParmParse::PP_entry</innerclass>
      <sectiondef kind="public-type">
      <memberdef kind="enum" id="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6" prot="public" static="no" strong="no">
        <type></type>
        <name>@0</name>
        <enumvalue id="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a42c200ba823b0b1a3c16c437a264ce9e" prot="public">
          <name>LAST</name>
          <initializer>= -1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" prot="public">
          <name>FIRST</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" prot="public">
          <name>ALL</name>
          <initializer>= -1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="289" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="289" bodyend="289"/>
      </memberdef>
      <memberdef kind="typedef" id="classamrex_1_1ParmParse_1af823116cc58b501d9f158fa5635c1498" prot="public" static="no">
        <type>std::unordered_map&lt; std::string, <ref refid="structamrex_1_1ParmParse_1_1PP__entry" kindref="compound">PP_entry</ref> &gt;</type>
        <definition>using amrex::ParmParse::Table =  std::unordered_map&lt;std::string, PP_entry&gt;</definition>
        <argsstring></argsstring>
        <name>Table</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1147" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1147" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1a44318f1c5a43d3c6ef6cd9f0fda99ea2" prot="public" static="yes" mutable="no">
        <type>std::string const</type>
        <definition>std::string const amrex::ParmParse::FileKeyword</definition>
        <argsstring></argsstring>
        <name>FileKeyword</name>
        <initializer>= &quot;FILE&quot;</initializer>
        <briefdescription>
<para>keyword for files to load </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1152" column="30" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1152" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1a4e18537921b1737edf7819d2a3b51f90" prot="public" static="yes" mutable="no">
        <type>std::string</type>
        <definition>std::string amrex::ParmParse::ParserPrefix</definition>
        <argsstring></argsstring>
        <name>ParserPrefix</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1154" column="24" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1154" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1a941314412b0921ba802f4620404cf33c" prot="protected" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string amrex::ParmParse::m_prefix</definition>
        <argsstring></argsstring>
        <name>m_prefix</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1160" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1160" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1ac6d6405babd810179e1e69872b4075fb" prot="protected" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string amrex::ParmParse::m_parser_prefix</definition>
        <argsstring></argsstring>
        <name>m_parser_prefix</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1161" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1161" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1abe4e8f257927686a878e5be81358b213" prot="protected" static="no" mutable="no">
        <type><ref refid="classamrex_1_1ParmParse_1af823116cc58b501d9f158fa5635c1498" kindref="member">Table</ref> *</type>
        <definition>Table* amrex::ParmParse::m_table</definition>
        <argsstring></argsstring>
        <name>m_table</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1162" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1162" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aedc024f9fcd3a2e180a860412c3ad745" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>amrex::ParmParse::ParmParse</definition>
        <argsstring>(std::string prefix=std::string(), std::string parser_prefix=std::string())</argsstring>
        <name>ParmParse</name>
        <param>
          <type>std::string</type>
          <declname>prefix</declname>
          <defval>std::string()</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>parser_prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para>Construct an additional <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object sharing the same internal table as any other such objects in existence. If prefix is specified, load this string as the code prefix for this particular <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object. If parser_prefix is specified, it will be used as prefixed in math expression evaluations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="297" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="37" bodyend="41"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a0998fb701a17bbba399ee68049848346" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::ParmParse::contains</definition>
        <argsstring>(const char *name) const</argsstring>
        <name>contains</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Returns true if name is in table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="301" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1835" bodyend="1848"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac6d9a4fda6c8de819a90ba19c327dfe4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::countval</definition>
        <argsstring>(const char *name, int n=LAST) const</argsstring>
        <name>countval</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>n</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a42c200ba823b0b1a3c16c437a264ce9e" kindref="member">LAST</ref></defval>
        </param>
        <briefdescription>
<para>Returns the number of values associated with nth occurrence of name (prepended with the prefix) in the table. n == -1 implies the last occurrence. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="307" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1191" bodyend="1199"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a941bdb12544ce537066604b716f8950c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::countname</definition>
        <argsstring>(const std::string &amp;name) const</argsstring>
        <name>countname</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Returns the number of times the given name (prepended with prefix) appears in the table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="312" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1819" bodyend="1828"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, bool &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a bool and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to an bool, an error message is output and the program halts. Note that ival == 0 is the first value in the list. <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> converte the value &apos;true&apos;, and non-zero integers or floats to bool(true), and bool(false) for &apos;false&apos; or zero integer or float values. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="324" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1203" bodyend="1209"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a24db67f875cbc2a56406c66f48d60b8a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, bool &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="329" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1212" bodyend="1217"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, bool &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="339" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1220" bodyend="1226"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa98ab18bc26692876f9590316af5b1fa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, bool &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="344" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1229" bodyend="1234"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a855bd3038fb81532b3f43211ea7cef22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, bool val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="348" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1237" bodyend="1241"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a121a56d0a3d64fe23a990ed9e09bb490" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, int &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to an int and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="358" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1245" bodyend="1248"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a26252e98bdffbce5baf1695ca817cb30" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, int &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="364" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1251" bodyend="1254"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9e3959cb195fa123e622917e01f60bac" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, int &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="374" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1257" bodyend="1260"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8bdcdf34553e38a882d7a15195678e3d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, int &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="379" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1263" bodyend="1266"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a0b94dee7f826e69376afb89409e90c72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, int val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="383" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1269" bodyend="1272"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac31c5d065e80c23103cb04b1592c7b7d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, long &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to an int and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="393" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1311" bodyend="1314"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a3a48f359b6d8c12b019b3e1b7c097f72" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, long &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="398" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1317" bodyend="1320"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a157be8cfc61a470961922c4ae7922d43" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, long &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="408" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1323" bodyend="1326"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae016a438a820d522e4d529ef8b7371f4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, long &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="413" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1329" bodyend="1332"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab2a937f4d5b0ac8a998bac849bd4b3af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, long val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="417" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1335" bodyend="1339"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a2dc42d1cc9657c5dfa235e485944390c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, long long &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to an int and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="427" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1377" bodyend="1380"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a54183310926451315930c0a0a09f1475" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, long long &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="432" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1383" bodyend="1386"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a10f4ac6bfd190ba12a9dcd3ff0a2f69c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, long long &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="442" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1389" bodyend="1392"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a499a57138bca367b609ce98da58e4039" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, long long &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="447" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1395" bodyend="1398"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aba7905ce1fcfcd4e46d3deebf7aa59c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, long long val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long long</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="451" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1401" bodyend="1404"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a987610163c3981e856ddd928180851d4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, float &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a float and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a float, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="461" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1442" bodyend="1445"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac4efb98e8b17112650c2d0034a9681ef" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, float &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="466" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1448" bodyend="1451"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a01751e72ed3ec33b42ca1816a5479b0a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, float &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="476" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1454" bodyend="1457"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1afc1a9af4970db8434b613c551eadc55a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, float &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="481" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1460" bodyend="1463"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a74c001d6b4af7f72e812a65064e52fe7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, float val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>float</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="485" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1466" bodyend="1469"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1abf1dd9e920a2496279d5d4d0c5ce90d5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, double &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a double and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a double, an error message is output and the program halts. Note that ival = 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="495" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1509" bodyend="1512"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae902806780e0a1daed6a161b95178435" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, double &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="500" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1515" bodyend="1518"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad0715ccf731c6b244f2258b4811761fd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, double &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="510" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1521" bodyend="1524"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af205ea927f7888a00aebcdc95d55f432" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, double &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="515" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1527" bodyend="1530"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aaa78e0361b000a8fe6fc4898720ece32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, double val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="519" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1533" bodyend="1536"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a880e5679710b84f6773ef402d357a0f4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, std::string &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a std::string and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a std::string, an error message is output and the program halts. Note that ival = 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="529" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1576" bodyend="1579"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae2021776ee6ddf9a139d8a0af42785a9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, std::string &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="535" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1582" bodyend="1585"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a47f9f968f7dacc5910d553ea21e22ae2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, std::string &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="545" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1588" bodyend="1591"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a1d9687e5856d5fb2d6bd4e4f027212ae" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, std::string &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="550" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1594" bodyend="1597"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a28d0faa2a576d6488b738ef309c11f44" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, const std::string &amp;val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="554" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1600" bodyend="1603"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a642956703fef48b48a1e23f7429b3a64" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, IntVect &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to an IntVect and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a IntVect, an error message is output and the program halts. Note that ival = 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="565" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1643" bodyend="1646"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a31599e95400a726459b3ea9b4ccce720" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, IntVect &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="570" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1649" bodyend="1652"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a69c311ca977470146f9151f1d7ca3a6e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, IntVect &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="580" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1655" bodyend="1658"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a53f7e6ff29566e9c9606874b27f64c17" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, IntVect &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="585" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1661" bodyend="1664"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af8b8124367b52af3f6f29ca09bbdff1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, const IntVect &amp;val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="589" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1667" bodyend="1670"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a41c797456b4d13b1783474e26202ecf4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(const char *name, int k, Box &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a <ref refid="classamrex_1_1Box" kindref="compound">Box</ref>, an error message is output and the program halts. Note that ival = 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="599" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1708" bodyend="1711"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac246c039fd27b9a2bdccfc99d68062a6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, Box &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="604" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1714" bodyend="1717"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af336f03191de5b0d144bf1f04cf6f61d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(const char *name, int k, Box &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="614" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1720" bodyend="1723"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5ed7725f4552397edff794e471dc2f2c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, Box &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="619" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1726" bodyend="1729"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6ec39cadf536be90cdf7bf66c00ca164" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(const char *name, const Box &amp;val)</argsstring>
        <name>add</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos;with value &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="623" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1732" bodyend="1735"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; int &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;int&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to an int and stored in the std::vector&lt;int&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;int&gt;[0], std::vector&lt;int&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to an int, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="636" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1275" bodyend="1279"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a643cc1f0359446a7ba0a997e949af928" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, std::vector&lt; int &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="642" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1282" bodyend="1286"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; int &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="647" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1289" bodyend="1293"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a54307dd658a96ac490ce75a3f74defe2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, std::vector&lt; int &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="653" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1296" bodyend="1300"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a2418bfbd15221554ebc65184b7d62977" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(const char *name, const std::vector&lt; int &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="658" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1303" bodyend="1306"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ada3137eb2cf941b65a7e7ec75127fb4b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;long&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to a long and stored in the std::vector&lt;long&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;long&gt;[0], std::vector&lt;long&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to a long, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="672" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1342" bodyend="1346"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a00541ac93c3550160a154e9d5a3d5ec1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, std::vector&lt; long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="678" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1349" bodyend="1353"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a23023a0b2b6eedf3820d116aed2ebed7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="683" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1356" bodyend="1360"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a4c806fe5e4fce3feda120702a3c9c1be" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, std::vector&lt; long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="689" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1363" bodyend="1367"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a47720549d3906f3b957edb4846efe953" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(const char *name, const std::vector&lt; long &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="694" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1370" bodyend="1373"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a3a8a963df03fadd42bb22a0d3dcf4d86" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; long long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;long long&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to a long long and stored in the std::vector&lt;long long&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;long long&gt;[0], std::vector&lt;long long&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to a long long, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="708" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1407" bodyend="1411"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6a244245bc791095e6f4bbbfcf9835b8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, std::vector&lt; long long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="714" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1414" bodyend="1418"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a40e347b786c7023a58e8441d39be89b7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; long long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="719" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1421" bodyend="1425"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af319284107e54297e79df230aeb7cba0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, std::vector&lt; long long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="725" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1428" bodyend="1432"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a878f1fc21821ccde76f7591c6924150b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(const char *name, const std::vector&lt; long long &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="730" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1435" bodyend="1438"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a98496ea33eae3e43168da0c5d530f9d0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; float &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;float&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to a float and stored in the std::vector&lt;float&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;float&gt;[0], std::vector&lt;float&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to a float, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="744" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1472" bodyend="1476"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a97c86c6556b58ff6d5fbef7dd33d7f67" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, std::vector&lt; float &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="750" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1479" bodyend="1483"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a823e28939aa5e1fa940bb46e1c0204d0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; float &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="755" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1486" bodyend="1490"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae69bd8d0d57d6bca949efd1d5b376fdf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, std::vector&lt; float &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="761" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1493" bodyend="1497"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa820880136eb73c213775820cb4f4afe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(const char *name, const std::vector&lt; float &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="766" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1500" bodyend="1503"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad295e0055ca48f33fd46c918f7f65807" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; double &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;double&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to a double and stored in the std::vector&lt;double&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;double&gt;[0], std::vector&lt;double&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to a double, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="779" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1539" bodyend="1543"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ade3bfcf7b3561484c56556d12d7fa7c7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, std::vector&lt; double &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="785" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1546" bodyend="1550"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a978c77a2a299403038d51adae2c330d5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; double &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="790" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1553" bodyend="1557"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a87e9486383563a4bfd29fa8a92eab0f9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, std::vector&lt; double &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="796" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1560" bodyend="1564"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1adc6f5c7fab1d1af4a1ab64091996910d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(const char *name, const std::vector&lt; double &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="801" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1567" bodyend="1570"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a51fbaa30ce635b4022c14f8479adb59b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; std::string &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;std::string&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to an std::string and stored in the std::vector&lt;std::string&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;std::string&gt;[0], std::vector&lt;std::string&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to an std::string, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="814" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1606" bodyend="1610"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6284a27596e92c72f1eac4a6515c2c5d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, std::vector&lt; std::string &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="820" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1613" bodyend="1617"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6e6c42c0329b3346c6fd85f1af871e91" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; std::string &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="825" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1620" bodyend="1624"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a63d99f0de131b0023eb14f5efd91e169" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, std::vector&lt; std::string &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> but searches for last occurrence of name.2. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="831" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1627" bodyend="1631"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a35cb7c9eb21ba31bfd1d47026ff6dc72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(const char *name, const std::vector&lt; std::string &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="836" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1634" bodyend="1637"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a43d727ee62e630148cd9ad44c76ee198" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; IntVect &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;IntVect&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to an IntVect and stored in the std::vector&lt;IntVect&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;IntVect&gt;[0], std::vector&lt;IntVect&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to an IntVect, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="849" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1673" bodyend="1677"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1afc26369b48fec28271dfbc3a44924647" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, std::vector&lt; IntVect &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="855" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1680" bodyend="1684"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a861088668a40bd77d8a8e8200678778e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; IntVect &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="860" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1687" bodyend="1691"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a137e09253266871d5369176288e9425b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, std::vector&lt; IntVect &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> but searches for last occurrence of name.2. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="866" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1694" bodyend="1698"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5ce6e0dbb45b0d784d0b4056b28e84ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(const char *name, const std::vector&lt; IntVect &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="871" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1701" bodyend="1704"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a2bfcc04882e77f0ab692e6cc1b3ee471" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; Box &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;<ref refid="classamrex_1_1Box" kindref="compound">Box</ref>&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to an <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> and stored in the std::vector&lt;<ref refid="classamrex_1_1Box" kindref="compound">Box</ref>&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;<ref refid="classamrex_1_1Box" kindref="compound">Box</ref>&gt;[0], std::vector&lt;<ref refid="classamrex_1_1Box" kindref="compound">Box</ref>&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to an <ref refid="classamrex_1_1Box" kindref="compound">Box</ref>, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="884" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1738" bodyend="1742"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1acd6b161e8e6dea4c7379ef469d73d193" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, std::vector&lt; Box &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="890" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1745" bodyend="1749"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a064a1ac48146a99bd401b985c6307805" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(const char *name, int k, std::vector&lt; Box &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="895" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1752" bodyend="1756"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a2d33c474853891761ac959cbf6299bcf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, std::vector&lt; Box &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" kindref="member">queryktharr()</ref> but searches for last occurrence of name.2. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="901" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1759" bodyend="1763"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a4cb250da023bdcc8375cf3f6d64a777b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(const char *name, const std::vector&lt; Box &gt; &amp;refd)</argsstring>
        <name>addarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt; &amp;</type>
          <declname>refd</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="906" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1766" bodyend="1769"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae080a87279c2061a2125da5a6ba296c8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, IntVect &amp;ref) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="914" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1773" bodyend="1782"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9079c4384e7d33b2c8f92436a350b563" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, IntVect &amp;ref) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8792201c856a367dda275e09047daa33" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="922" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1785" bodyend="1791"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad1ecfb0a30edc452d3ac10061a899a5c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(const char *name, RealVect &amp;ref) const</argsstring>
        <name>queryarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1RealVect" kindref="compound">RealVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Query <ref refid="classamrex_1_1RealVect" kindref="compound">RealVect</ref> from array. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="925" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1794" bodyend="1803"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ace7abd71171ae6fdfe0aea25e616e323" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(const char *name, RealVect &amp;ref) const</argsstring>
        <name>getarr</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1RealVect" kindref="compound">RealVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Get <ref refid="classamrex_1_1RealVect" kindref="compound">RealVect</ref> from array. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="928" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1806" bodyend="1812"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a24eb7bf5d0d06251bf15a44b8a8a1a4f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *name, std::array&lt; T, N &gt; &amp;ref) const</argsstring>
        <name>get</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::array&lt; T, N &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="931" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="931" bodyend="938"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6f039d5c787ec3b27a25a290c659c42d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *name, std::array&lt; T, N &gt; &amp;ref) const</argsstring>
        <name>query</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::array&lt; T, N &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="941" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="941" bodyend="951"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5a524b8c11f99e8ef86fd6bbc1a33493" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!IsStdVector&lt; T &gt;::value, <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(const char *name, T &amp;ref)</argsstring>
        <name>queryAdd</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>If <computeroutput>name</computeroutput> is found, the value in the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database will be stored in the <computeroutput>ref</computeroutput> argument. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates if it existed previously. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="960" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="960" bodyend="966"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad30debcf129ee05319df05c1d54844fe" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(const char *name, std::string &amp;ref)</argsstring>
        <name>queryAdd</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="968" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="968" bodyend="974"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8208293906e1d9c1b2d5089c05b5bd16" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(const char *name, std::vector&lt; T &gt; &amp;ref)</argsstring>
        <name>queryAdd</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>If <computeroutput>name</computeroutput> is found, the value in the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database will be stored in the <computeroutput>ref</computeroutput> argument. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates if it existed previously. </para>
        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>name</computeroutput> is found, then the ref argument will be reallocated (and resized) according to the number of values in the inputs. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="986" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="986" bodyend="996"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5cb7b5e428f4991e8a1fba87649ee6c3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(const char *name, std::vector&lt; T &gt; &amp;ref, int num_val)</argsstring>
        <name>queryAdd</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>num_val</declname>
        </param>
        <briefdescription>
<para>If <computeroutput>name</computeroutput> is found, the value in the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database will be stored in the <computeroutput>ref</computeroutput> argument. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates if it existed previously. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1005" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1005" bodyend="1011"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aface68d73330646265cf631654dfd05f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(const char *name, std::array&lt; T, N &gt; &amp;ref)</argsstring>
        <name>queryAdd</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::array&lt; T, N &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>If <computeroutput>name</computeroutput> is found, the value in the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database will be stored in the <computeroutput>ref</computeroutput> argument. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates if it existed previously. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1020" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1020" bodyend="1036"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aaeca337d70d382eac6713629fe19cba9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(const char *name, int &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Query with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. If <computeroutput>name</computeroutput> is found, this uses <ref refid="classamrex_1_1Parser" kindref="compound">amrex::Parser</ref> to parse the entire list of empty space separated values as a single scalar. The return value indicates whether it&apos;s found. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1043" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1879" bodyend="1882"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aceee232cad65ad2d2060e7d12490b02d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(const char *name, long &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1044" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1885" bodyend="1888"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa83dae580e475c698d1af8498f2e1727" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(const char *name, long long &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1045" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1891" bodyend="1894"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab59ae2e9496bc7defa4bb88f7232ec38" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(const char *name, float &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1046" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1897" bodyend="1900"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1abdedd9feb166f0795fc49d8248e1d531" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(const char *name, double &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1047" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1903" bodyend="1906"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae458cb55bb8229f48767c3ae1f581696" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt;||std::is_same_v&lt; T, long &gt;||std::is_same_v&lt; T, long long &gt;||std::is_same_v&lt; T, float &gt;||std::is_same_v&lt; T, double &gt;, <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::queryAddWithParser</definition>
        <argsstring>(const char *name, T &amp;ref) const</argsstring>
        <name>queryAddWithParser</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Query with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. If <computeroutput>name</computeroutput> is found, this uses <ref refid="classamrex_1_1Parser" kindref="compound">amrex::Parser</ref> to parse the entire list of empty space separated values as a single scalar. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates whether it&apos;s found. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1060" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1060" bodyend="1067"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a65f0fdc57c6d3d630b040d096a17afee" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt;||std::is_same_v&lt; T, long &gt;||std::is_same_v&lt; T, long long &gt;||std::is_same_v&lt; T, float &gt;||std::is_same_v&lt; T, double &gt;, <ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref> &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::getWithParser</definition>
        <argsstring>(const char *name, T &amp;ref) const</argsstring>
        <name>getWithParser</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Get with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. If <computeroutput>name</computeroutput> is found, this uses <ref refid="classamrex_1_1Parser" kindref="compound">amrex::Parser</ref> to parse the entire list of empty space separated values as a single scalar. If not, it&apos;s a runtime error. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1079" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1079" bodyend="1085"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6657f8c789a5b37f79bc4219dd6e3a81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::remove</definition>
        <argsstring>(const char *name)</argsstring>
        <name>remove</name>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Remove given name from the table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1088" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1851" bodyend="1856"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6a0e28c45ee942f30c9f5c50f338e203" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref></type>
        <definition>Parser amrex::ParmParse::makeParser</definition>
        <argsstring>(std::string const &amp;func, Vector&lt; std::string &gt; const &amp;vars) const</argsstring>
        <name>makeParser</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; const &amp;</type>
          <declname>vars</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref> using given string <computeroutput>func</computeroutput> as function body and <computeroutput>vars</computeroutput> as variable names. Constants known to <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> will be set. It&apos;s a runtime error, if there are unknown symbols in <computeroutput>func</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1093" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1909" bodyend="1913"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1afac8d3383aa70acfdd3cd22a8df79539" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1IParser" kindref="compound">IParser</ref></type>
        <definition>IParser amrex::ParmParse::makeIParser</definition>
        <argsstring>(std::string const &amp;func, Vector&lt; std::string &gt; const &amp;vars) const</argsstring>
        <name>makeIParser</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; const &amp;</type>
          <declname>vars</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make <ref refid="classamrex_1_1IParser" kindref="compound">IParser</ref> using given string <computeroutput>func</computeroutput> as function body and <computeroutput>vars</computeroutput> as variable names. Constants known to <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> will be set. It&apos;s a runtime error, if there are unknown symbols in <computeroutput>func</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1099" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1916" bodyend="1920"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab4f43a6024e50a1c5f9110d29ae42904" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classamrex_1_1ParmParse_1af823116cc58b501d9f158fa5635c1498" kindref="member">Table</ref> &amp;</type>
        <definition>const Table&amp; amrex::ParmParse::table</definition>
        <argsstring>() const</argsstring>
        <name>table</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1149" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1149" bodyend="1149"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a302162fcd495ffd22ab0ebb8d8f36a05" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::Initialize</definition>
        <argsstring>(int argc, char **argv, const char *parfile)</argsstring>
        <name>Initialize</name>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>parfile</declname>
        </param>
        <briefdescription>
<para>Construct an initial <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object from the argc and argv passed in to <ref refid="CheckDecomposition_8c_1a0ddf1224851353fc92bfbff6f499fa97" kindref="member">main()</ref>. An error will be signalled if another <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object currently exists. If parfile is specified, read the parameters in from that file first and then append those derived from argv to the table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1109" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1035" bodyend="1049"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9283fab7556352eeff908ca26cd440be" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::Finalize</definition>
        <argsstring>()</argsstring>
        <name>Finalize</name>
        <briefdescription>
<para>The destructor. The internal static table will only be deleted if there are no other <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> objects in existence. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1114" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1134" bodyend="1157"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa1549749aa28417bed7bb7a9d5a99810" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::SetParserPrefix</definition>
        <argsstring>(std::string a_prefix)</argsstring>
        <name>SetParserPrefix</name>
        <param>
          <type>std::string</type>
          <declname>a_prefix</declname>
        </param>
        <briefdescription>
<para>Set prefix used by math expression <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1117" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1160" bodyend="1163"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a4fe2b9e6e5a2c039c7684f364a5c8bb2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
        <definition>int amrex::ParmParse::Verbose</definition>
        <argsstring>()</argsstring>
        <name>Verbose</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1119" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1116" bodyend="1125"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a50ba1e91e9681699bf5c1a32be2814e6" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::SetVerbose</definition>
        <argsstring>(int v)</argsstring>
        <name>SetVerbose</name>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1120" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1128" bodyend="1131"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad5376a2e65027c356b38efbef3180c28" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::dumpTable</definition>
        <argsstring>(std::ostream &amp;os, bool prettyPrint=false)</argsstring>
        <name>dumpTable</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>prettyPrint</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Write the contents of the table in ASCII to the ostream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1123" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1166" bodyend="1188"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a3403a33aa6274309f3d1b5313fb28b46" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addfile</definition>
        <argsstring>(std::string const &amp;filename)</argsstring>
        <name>addfile</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
<para>Add keys and values from a file to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1126" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1021" bodyend="1032"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a821d000e2b1d1aa6dc9e18d0b54e0df7" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::ParmParse::QueryUnusedInputs</definition>
        <argsstring>()</argsstring>
        <name>QueryUnusedInputs</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1128" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1052" bodyend="1064"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a65ec105f3594e14160a631083a1bce59" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::ParmParse::hasUnusedInputs</definition>
        <argsstring>(const std::string &amp;prefix=std::string())</argsstring>
        <name>hasUnusedInputs</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1Any" kindref="compound">Any</ref> unused [prefix.]* parameters? </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1131" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1067" bodyend="1070"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa4c1dbee984103cd1102514d70c954a3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; amrex::ParmParse::getUnusedInputs</definition>
        <argsstring>(const std::string &amp;prefix=std::string())</argsstring>
        <name>getUnusedInputs</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para>Returns unused [prefix.]* parameters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1134" column="25" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1073" bodyend="1100"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1add7b8b32755bc2ffd24623957b797d23" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::set&lt; std::string &gt;</type>
        <definition>std::set&lt; std::string &gt; amrex::ParmParse::getEntries</definition>
        <argsstring>(const std::string &amp;prefix=std::string())</argsstring>
        <name>getEntries</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para>Returns [prefix.]* parameters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1137" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1103" bodyend="1113"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9acf57232096dc7488995a49627924eb" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::ParmParse::prefixedName</definition>
        <argsstring>(const std::string_view &amp;str) const</argsstring>
        <name>prefixedName</name>
        <param>
          <type>const std::string_view &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1158" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1007" bodyend="1018"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Parse Parameters From Command Line and Input Files. </para>
    </briefdescription>
    <detaileddescription>
<para>The <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> class is used to interpret parameters passed in to a program from the command line and an arbitrary collection of input files. The parameters are stored in static table that can be queried by any object of type <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref>. A parameter is a &quot;definition&quot;. A definition is of the form &quot;\&lt;name\&gt; = \&lt;value\&gt;\&lt;value\&gt;...\&lt;value\&gt;&quot;. It is stored in the table as a name, value-list pair.</para>
<para>In the following example, niter is a definition with the single integer value 10; name is a definition with the string value &quot;big
 code&quot; and dx is a definition with the two floating point values 0.5 and 0.75 and iv is an IntVect(5,4)</para>
<para>prog niter = 10 name = &quot;big code&quot; dx = 0.5 0.75 iv=(5,4)</para>
<para>The <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> class has two constructors. The first is responsible for building the table and is usually called by the main routine of an application. It has arguments for the command line argc and argv parameters, as well as an optional filename argument for reading definitions from an input file. The table is built by reading the input file first (if it exists) with the command line arguments added to the end of the table. The order of a definition in the table is significant, so command line parameters can be used to override definitions in the input file. A definition of the explicit form: FILE=&lt;filename&gt; is not added to the table but is a directive to include the named file at that point in the table.</para>
<para>The second constructor is generally used by other classes in the code. It permits access to the table via a large collection of query functions. Both constructors have an optional prefix argument that narrows the search to entries in the table with the same prefix. For example, let PlanR be a <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object with code prefix &quot;ope&quot;. PlanR.get(&quot;val&quot;,v) will look for an entry in the parameter list of the form: ope.val==&lt;value&gt;, and will reject all entries not starting with the correct code prefix.</para>
<para>The query functions search the table for definition names that match a given string (and prefix) and return values from the corresponding value list. The values can be returned as ints, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt;int&gt;s, floats, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt;float&gt;s, doubles, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt;double&gt;s, std::strings, or <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt;aSring&gt;s. All values in the table are stored as std::string objects, but if an int, float, or double is requested, the translation is done automatically. In the previous example, the value of niter could be returned as either an std::string, an int, a double, or a float. The values of dx can be returned as std::strings, floats, or doubles, but the value of name can be returned only as an std::string.</para>
<para>Comments in an input file include all text from a # character to the end of the line. Here is a sample input file:</para>
<para>niter = 100</para>
<para>title = &quot;Double Wammy&quot;</para>
<para>cell_size = 0.5 0.75</para>
<para>plot.var = Density 1 10</para>
<para>plot.var = Energy 5 12</para>
<para>bigarray = 1 2 3 4 5 6 7 8 \ 9 10 11 12</para>
<para>multi_line_string = &quot;This is a
                         multi-line string.&quot;</para>
<para>aBox = ((0,0) (5,5))</para>
<para>test = apple &quot;boy blue&quot; 10 20 30 40</para>
<para>FILE = prob_file</para>
<para>Preprocessing of AMREX_SPACEDIM is supported. It supports <ref refid="amrex__parser_8lex_8nolint_8H_1ad4a65b873df5c05570846b5413b41dfd" kindref="member">if</ref>, #elif, #else, and #endif. The condition must be <computeroutput>AMREX_SPACEDIM op D</computeroutput>, where op is &gt;, &lt;, &gt;=, &lt;=, or ==, and D is 1, 2, or 3. The parentheses around the condition are optional. Some examples are shown below.</para>
<para><ref refid="amrex__parser_8lex_8nolint_8H_1ad4a65b873df5c05570846b5413b41dfd" kindref="member">if</ref> (AMREX_SPACEDIM == 1) n_cell = 256 #elif (AMREX_SPACEDIM == 2) n_cell = 128 128 #else n_cell = 64 64 64 #endif</para>
<para><ref refid="amrex__parser_8lex_8nolint_8H_1ad4a65b873df5c05570846b5413b41dfd" kindref="member">if</ref> AMREX_SPACEDIM &gt;= 2 t = 0.5 #else t = 1.5 #endif</para>
<para><ref refid="namespaceamrex_1_1Math" kindref="compound">Math</ref> expression is supported for integers and reals. For example</para>
<para>n_cell = 128 amrex.n_cell = n_cell*2 8 16**2</para>
<para>becomes</para>
<para>n_cell = 128 amrex.n_cell = 256 8 256</para>
<para>More details can be found at <ulink url="https://amrex-codes.github.io/amrex/docs_html/Basics.html#parmparse">https://amrex-codes.github.io/amrex/docs_html/Basics.html#parmparse</ulink> </para>
    </detaileddescription>
    <collaborationgraph>
      <node id="1">
        <label>amrex::ParmParse</label>
        <link refid="classamrex_1_1ParmParse"/>
        <childnode refid="2" relation="usage">
          <edgelabel>FileKeyword</edgelabel>
          <edgelabel>ParserPrefix</edgelabel>
          <edgelabel>m_parser_prefix</edgelabel>
          <edgelabel>m_prefix</edgelabel>
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>m_table</edgelabel>
        </childnode>
      </node>
      <node id="5">
        <label>K</label>
      </node>
      <node id="6">
        <label>T</label>
      </node>
      <node id="4">
        <label>std::unordered_map&lt; K, T &gt;</label>
        <childnode refid="5" relation="usage">
          <edgelabel>keys</edgelabel>
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>elements</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>std::basic_string&lt; Char &gt;</label>
      </node>
      <node id="2">
        <label>std::string</label>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="286" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="287" bodyend="1163"/>
    <listofallmembers>
      <member refid="classamrex_1_1ParmParse_1a855bd3038fb81532b3f43211ea7cef22" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a0b94dee7f826e69376afb89409e90c72" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1ab2a937f4d5b0ac8a998bac849bd4b3af" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1aba7905ce1fcfcd4e46d3deebf7aa59c9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a74c001d6b4af7f72e812a65064e52fe7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1aaa78e0361b000a8fe6fc4898720ece32" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a28d0faa2a576d6488b738ef309c11f44" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1af8b8124367b52af3f6f29ca09bbdff1b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a6ec39cadf536be90cdf7bf66c00ca164" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a2418bfbd15221554ebc65184b7d62977" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a47720549d3906f3b957edb4846efe953" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a878f1fc21821ccde76f7591c6924150b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1aa820880136eb73c213775820cb4f4afe" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1adc6f5c7fab1d1af4a1ab64091996910d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a35cb7c9eb21ba31bfd1d47026ff6dc72" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a5ce6e0dbb45b0d784d0b4056b28e84ba" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a4cb250da023bdcc8375cf3f6d64a777b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a3403a33aa6274309f3d1b5313fb28b46" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addfile</name></member>
      <member refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>ALL</name></member>
      <member refid="classamrex_1_1ParmParse_1a0998fb701a17bbba399ee68049848346" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>contains</name></member>
      <member refid="classamrex_1_1ParmParse_1a941bdb12544ce537066604b716f8950c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>countname</name></member>
      <member refid="classamrex_1_1ParmParse_1ac6d9a4fda6c8de819a90ba19c327dfe4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>countval</name></member>
      <member refid="classamrex_1_1ParmParse_1ad5376a2e65027c356b38efbef3180c28" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>dumpTable</name></member>
      <member refid="classamrex_1_1ParmParse_1a44318f1c5a43d3c6ef6cd9f0fda99ea2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>FileKeyword</name></member>
      <member refid="classamrex_1_1ParmParse_1a9283fab7556352eeff908ca26cd440be" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Finalize</name></member>
      <member refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>FIRST</name></member>
      <member refid="classamrex_1_1ParmParse_1a24db67f875cbc2a56406c66f48d60b8a" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a26252e98bdffbce5baf1695ca817cb30" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a3a48f359b6d8c12b019b3e1b7c097f72" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a54183310926451315930c0a0a09f1475" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1ac4efb98e8b17112650c2d0034a9681ef" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1ae902806780e0a1daed6a161b95178435" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1ae2021776ee6ddf9a139d8a0af42785a9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a31599e95400a726459b3ea9b4ccce720" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1ac246c039fd27b9a2bdccfc99d68062a6" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a24eb7bf5d0d06251bf15a44b8a8a1a4f" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a643cc1f0359446a7ba0a997e949af928" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a00541ac93c3550160a154e9d5a3d5ec1" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a6a244245bc791095e6f4bbbfcf9835b8" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a97c86c6556b58ff6d5fbef7dd33d7f67" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ade3bfcf7b3561484c56556d12d7fa7c7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a6284a27596e92c72f1eac4a6515c2c5d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1afc26369b48fec28271dfbc3a44924647" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1acd6b161e8e6dea4c7379ef469d73d193" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a9079c4384e7d33b2c8f92436a350b563" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ace7abd71171ae6fdfe0aea25e616e323" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1add7b8b32755bc2ffd24623957b797d23" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getEntries</name></member>
      <member refid="classamrex_1_1ParmParse_1a757bd795e26efa90e0001e42d3720538" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a121a56d0a3d64fe23a990ed9e09bb490" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1ac31c5d065e80c23103cb04b1592c7b7d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a2dc42d1cc9657c5dfa235e485944390c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a987610163c3981e856ddd928180851d4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1abf1dd9e920a2496279d5d4d0c5ce90d5" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a880e5679710b84f6773ef402d357a0f4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a642956703fef48b48a1e23f7429b3a64" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a41c797456b4d13b1783474e26202ecf4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a897613a49a650ce10780c02157b056fd" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1ada3137eb2cf941b65a7e7ec75127fb4b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a3a8a963df03fadd42bb22a0d3dcf4d86" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a98496ea33eae3e43168da0c5d530f9d0" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1ad295e0055ca48f33fd46c918f7f65807" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a51fbaa30ce635b4022c14f8479adb59b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a43d727ee62e630148cd9ad44c76ee198" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a2bfcc04882e77f0ab692e6cc1b3ee471" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1aa4c1dbee984103cd1102514d70c954a3" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getUnusedInputs</name></member>
      <member refid="classamrex_1_1ParmParse_1a65f0fdc57c6d3d630b040d096a17afee" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a65ec105f3594e14160a631083a1bce59" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>hasUnusedInputs</name></member>
      <member refid="classamrex_1_1ParmParse_1a302162fcd495ffd22ab0ebb8d8f36a05" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Initialize</name></member>
      <member refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a42c200ba823b0b1a3c16c437a264ce9e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>LAST</name></member>
      <member refid="classamrex_1_1ParmParse_1ac6d6405babd810179e1e69872b4075fb" prot="protected" virt="non-virtual"><scope>amrex::ParmParse</scope><name>m_parser_prefix</name></member>
      <member refid="classamrex_1_1ParmParse_1a941314412b0921ba802f4620404cf33c" prot="protected" virt="non-virtual"><scope>amrex::ParmParse</scope><name>m_prefix</name></member>
      <member refid="classamrex_1_1ParmParse_1abe4e8f257927686a878e5be81358b213" prot="protected" virt="non-virtual"><scope>amrex::ParmParse</scope><name>m_table</name></member>
      <member refid="classamrex_1_1ParmParse_1afac8d3383aa70acfdd3cd22a8df79539" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>makeIParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a6a0e28c45ee942f30c9f5c50f338e203" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>makeParser</name></member>
      <member refid="classamrex_1_1ParmParse_1aedc024f9fcd3a2e180a860412c3ad745" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>ParmParse</name></member>
      <member refid="classamrex_1_1ParmParse_1a4e18537921b1737edf7819d2a3b51f90" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>ParserPrefix</name></member>
      <member refid="classamrex_1_1ParmParse_1a9acf57232096dc7488995a49627924eb" prot="protected" virt="non-virtual"><scope>amrex::ParmParse</scope><name>prefixedName</name></member>
      <member refid="classamrex_1_1ParmParse_1aa98ab18bc26692876f9590316af5b1fa" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a8bdcdf34553e38a882d7a15195678e3d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1ae016a438a820d522e4d529ef8b7371f4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a499a57138bca367b609ce98da58e4039" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1afc1a9af4970db8434b613c551eadc55a" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1af205ea927f7888a00aebcdc95d55f432" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a1d9687e5856d5fb2d6bd4e4f027212ae" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a53f7e6ff29566e9c9606874b27f64c17" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a5ed7725f4552397edff794e471dc2f2c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a6f039d5c787ec3b27a25a290c659c42d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a5a524b8c11f99e8ef86fd6bbc1a33493" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1ad30debcf129ee05319df05c1d54844fe" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1a8208293906e1d9c1b2d5089c05b5bd16" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1a5cb7b5e428f4991e8a1fba87649ee6c3" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1aface68d73330646265cf631654dfd05f" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1ae458cb55bb8229f48767c3ae1f581696" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAddWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a54307dd658a96ac490ce75a3f74defe2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a4c806fe5e4fce3feda120702a3c9c1be" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1af319284107e54297e79df230aeb7cba0" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ae69bd8d0d57d6bca949efd1d5b376fdf" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a87e9486383563a4bfd29fa8a92eab0f9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a63d99f0de131b0023eb14f5efd91e169" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a137e09253266871d5369176288e9425b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a2d33c474853891761ac959cbf6299bcf" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ae080a87279c2061a2125da5a6ba296c8" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ad1ecfb0a30edc452d3ac10061a899a5c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1acb8471c7f04ad416c55d696c53b87e98" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a9e3959cb195fa123e622917e01f60bac" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a157be8cfc61a470961922c4ae7922d43" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a10f4ac6bfd190ba12a9dcd3ff0a2f69c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a01751e72ed3ec33b42ca1816a5479b0a" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1ad0715ccf731c6b244f2258b4811761fd" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a47f9f968f7dacc5910d553ea21e22ae2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a69c311ca977470146f9151f1d7ca3a6e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1af336f03191de5b0d144bf1f04cf6f61d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a7e15c246accd5c8be1a296c55c7f2c8e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a23023a0b2b6eedf3820d116aed2ebed7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a40e347b786c7023a58e8441d39be89b7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a823e28939aa5e1fa940bb46e1c0204d0" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a978c77a2a299403038d51adae2c330d5" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a6e6c42c0329b3346c6fd85f1af871e91" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a861088668a40bd77d8a8e8200678778e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a064a1ac48146a99bd401b985c6307805" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a821d000e2b1d1aa6dc9e18d0b54e0df7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>QueryUnusedInputs</name></member>
      <member refid="classamrex_1_1ParmParse_1aaeca337d70d382eac6713629fe19cba9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1aceee232cad65ad2d2060e7d12490b02d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1aa83dae580e475c698d1af8498f2e1727" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1ab59ae2e9496bc7defa4bb88f7232ec38" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1abdedd9feb166f0795fc49d8248e1d531" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a6657f8c789a5b37f79bc4219dd6e3a81" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>remove</name></member>
      <member refid="classamrex_1_1ParmParse_1aa1549749aa28417bed7bb7a9d5a99810" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>SetParserPrefix</name></member>
      <member refid="classamrex_1_1ParmParse_1a50ba1e91e9681699bf5c1a32be2814e6" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>SetVerbose</name></member>
      <member refid="classamrex_1_1ParmParse_1ab4f43a6024e50a1c5f9110d29ae42904" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>table</name></member>
      <member refid="classamrex_1_1ParmParse_1af823116cc58b501d9f158fa5635c1498" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Table</name></member>
      <member refid="classamrex_1_1ParmParse_1a4fe2b9e6e5a2c039c7684f364a5c8bb2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Verbose</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
