<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="classamrex_1_1ParmParse" kind="class" language="C++" prot="public">
    <compoundname>amrex::ParmParse</compoundname>
    <includes refid="AMReX__ParmParse_8H" local="no">AMReX_ParmParse.H</includes>
    <innerclass refid="structamrex_1_1ParmParse_1_1PP__entry" prot="public">amrex::ParmParse::PP_entry</innerclass>
    <sectiondef kind="public-type">
      <memberdef kind="enum" id="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6" prot="public" static="no" strong="no">
        <type></type>
        <name></name>
        <qualifiedname>amrex::ParmParse</qualifiedname>
        <enumvalue id="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a42c200ba823b0b1a3c16c437a264ce9e" prot="public">
          <name>LAST</name>
          <initializer>= -1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" prot="public">
          <name>FIRST</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" prot="public">
          <name>ALL</name>
          <initializer>= -1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="345" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="345" bodyend="345"/>
      </memberdef>
      <memberdef kind="typedef" id="classamrex_1_1ParmParse_1af823116cc58b501d9f158fa5635c1498" prot="public" static="no">
        <type>std::unordered_map&lt; std::string, <ref refid="structamrex_1_1ParmParse_1_1PP__entry" kindref="compound">PP_entry</ref> &gt;</type>
        <definition>using amrex::ParmParse::Table =  std::unordered_map&lt;std::string, PP_entry&gt;</definition>
        <argsstring></argsstring>
        <name>Table</name>
        <qualifiedname>amrex::ParmParse::Table</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1715" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1715" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1a44318f1c5a43d3c6ef6cd9f0fda99ea2" prot="public" static="yes" mutable="no">
        <type>std::string const</type>
        <definition>std::string const amrex::ParmParse::FileKeyword</definition>
        <argsstring></argsstring>
        <name>FileKeyword</name>
        <qualifiedname>amrex::ParmParse::FileKeyword</qualifiedname>
        <initializer>= &quot;FILE&quot;</initializer>
        <briefdescription>
<para>keyword for files to load </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1720" column="30" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1720" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1a4e18537921b1737edf7819d2a3b51f90" prot="public" static="yes" mutable="no">
        <type>std::string</type>
        <definition>std::string amrex::ParmParse::ParserPrefix</definition>
        <argsstring></argsstring>
        <name>ParserPrefix</name>
        <qualifiedname>amrex::ParmParse::ParserPrefix</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1722" column="24" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1722" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1a941314412b0921ba802f4620404cf33c" prot="protected" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string amrex::ParmParse::m_prefix</definition>
        <argsstring></argsstring>
        <name>m_prefix</name>
        <qualifiedname>amrex::ParmParse::m_prefix</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1730" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1730" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1ac6d6405babd810179e1e69872b4075fb" prot="protected" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string amrex::ParmParse::m_parser_prefix</definition>
        <argsstring></argsstring>
        <name>m_parser_prefix</name>
        <qualifiedname>amrex::ParmParse::m_parser_prefix</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1731" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1731" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classamrex_1_1ParmParse_1abe4e8f257927686a878e5be81358b213" prot="protected" static="no" mutable="no">
        <type><ref refid="classamrex_1_1ParmParse_1af823116cc58b501d9f158fa5635c1498" kindref="member">Table</ref> *</type>
        <definition>Table* amrex::ParmParse::m_table</definition>
        <argsstring></argsstring>
        <name>m_table</name>
        <qualifiedname>amrex::ParmParse::m_table</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1732" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1732" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aedc024f9fcd3a2e180a860412c3ad745" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>amrex::ParmParse::ParmParse</definition>
        <argsstring>(std::string prefix=std::string(), std::string parser_prefix=std::string())</argsstring>
        <name>ParmParse</name>
        <qualifiedname>amrex::ParmParse::ParmParse</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>prefix</declname>
          <defval>std::string()</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>parser_prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para>Construct an additional <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object sharing the same internal table as any other such objects in existence. If prefix is specified, load this string as the code prefix for this particular <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object. If parser_prefix is specified, it will be used as prefixed in math expression evaluations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="353" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="41" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8d400aaa7e8f1e2af9df8c45d1b43efe" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::ParmParse::contains</definition>
        <argsstring>(std::string_view name) const</argsstring>
        <name>contains</name>
        <qualifiedname>amrex::ParmParse::contains</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Returns true if name is in table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="357" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2193" bodyend="2206"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1afcacc12ab5b245f14489a5c047b1f730" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::countval</definition>
        <argsstring>(std::string_view name, int n=LAST) const</argsstring>
        <name>countval</name>
        <qualifiedname>amrex::ParmParse::countval</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a42c200ba823b0b1a3c16c437a264ce9e" kindref="member">LAST</ref></defval>
        </param>
        <briefdescription>
<para>Returns the number of values associated with nth occurrence of name (prepended with the prefix) in the table. n == -1 implies the last occurrence. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="363" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1355" bodyend="1363"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a1050130622c167d73df27f12ebf307c5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::countname</definition>
        <argsstring>(std::string_view name) const</argsstring>
        <name>countname</name>
        <qualifiedname>amrex::ParmParse::countname</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Returns the number of times the given name (prepended with prefix) appears in the table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="368" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2177" bodyend="2186"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, bool &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a bool and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to an bool, an error message is output and the program halts. Note that ival == 0 is the first value in the list. <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> converts the value &apos;true&apos;, and non-zero integers or floats to bool(true), and bool(false) for &apos;false&apos; or zero integer or float values. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="380" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1367" bodyend="1373"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af686a981034f742b4c9e0f627ba3d351" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, bool &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="385" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1376" bodyend="1381"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, bool &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="395" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1384" bodyend="1390"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af14555ab6859c064cc3ca2860cdfa378" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, bool &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="400" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1393" bodyend="1398"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1accf1b553a99c0c28b33f80ff4197bfd2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, bool val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="404" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1401" bodyend="1405"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a7d11cd7b2a3787a0d29766295a51f26b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, int &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to an int and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="414" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1409" bodyend="1415"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a7f440f432809213d4f053a8deb575df1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, int &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="420" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1418" bodyend="1423"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae461d1e8bf8a631dce729c86eb41e0b2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, int &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="430" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1426" bodyend="1432"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa7d4949f92a599b9961a91e8952ce3b4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, int &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="435" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1435" bodyend="1440"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a19241026c4f2654f951404dce86785e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, int val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="439" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1443" bodyend="1447"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad41c8858115a1978092d6cff46990318" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, long &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to an int and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="449" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1497" bodyend="1503"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a0289a02c4a54d2e2f2f03ec55cc6a43e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, long &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="454" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1506" bodyend="1511"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa4cf34bfb7093d32be2e999b9a0e0cc6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, long &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="464" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1514" bodyend="1520"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8d7b535661101c055ed8cde1a1d996b4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, long &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="469" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1523" bodyend="1528"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a1aee06fbd17916b54603aca28189d95f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, long val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="473" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1531" bodyend="1535"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a3aa9765d6044677fbf5db23237d9dd5f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, long long &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to an int and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to an int, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="483" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1583" bodyend="1589"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac34f5c1c656fbfb184ce2e12c7888cd1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, long long &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="488" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1592" bodyend="1597"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a05d9471e76a7f9345cc0cccc140cca9f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, long long &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="498" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1600" bodyend="1606"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a15d7c0bf32c978043ddc5ecc0fbaf0f2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, long long &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="503" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1609" bodyend="1614"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a0dd75517a78caef27f6e62e3aa560511" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, long long val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long long</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="507" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1617" bodyend="1621"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1afa087f50096d71cac2f58cb8bd64e29e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, float &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a float and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a float, an error message is output and the program halts. Note that ival == 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="517" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1670" bodyend="1676"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af044b2691fd1f2bf4dd2543ac4576f3c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, float &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="522" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1679" bodyend="1684"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6fb336bc0d02911ad1ed347345c31a10" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, float &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="532" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1687" bodyend="1693"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a051fd8800370be2b60288b16a480471e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, float &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="537" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1696" bodyend="1701"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a292703c4b4f1b3cba89127ff555319ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, float val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>float</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="541" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1704" bodyend="1708"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab8bf5622af52844a95c6d12313cfdc33" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, double &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a double and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a double, an error message is output and the program halts. Note that ival = 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="551" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1759" bodyend="1765"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a4a2085f935e1057e6ee555367dafd4a9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, double &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="556" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1768" bodyend="1773"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a980070c222bcc10d8d28d1735770b886" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, double &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="566" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1776" bodyend="1782"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a335d1bc50f8341c871f14d84dc237ebe" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, double &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="571" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1785" bodyend="1790"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a22bab90c2879c4cd53c41b0a0a93d75e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, double val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>double</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="575" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1793" bodyend="1797"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a282cbdeeb3a13fd969174ad763538304" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, std::string &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a std::string and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a std::string, an error message is output and the program halts. Note that ival = 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="585" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1848" bodyend="1854"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8574c3b0cefc4d2ea10521c75feac45c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, std::string &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="591" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1857" bodyend="1862"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a28ec93f530c8939d043975da777afe9b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, std::string &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="601" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1865" bodyend="1871"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a370122e1380da8675490943021ccede1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, std::string &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="606" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1874" bodyend="1879"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad651a6c836f3eb3a87e835b436715bbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, const std::string &amp;val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="610" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1882" bodyend="1886"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a827ae94f60d7e44b48dd20980c6adbcd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getline</definition>
        <argsstring>(std::string_view name, std::string &amp;ref) const</argsstring>
        <name>getline</name>
        <qualifiedname>amrex::ParmParse::getline</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1af686a981034f742b4c9e0f627ba3d351" kindref="member">get()</ref> but store the whole line including empty spaces in the middle if present as a single string. For example, <computeroutput>foo = a b c</computeroutput> is treated by this function as a single string &quot;a b c&quot;, whereas <ref refid="classamrex_1_1ParmParse_1af686a981034f742b4c9e0f627ba3d351" kindref="member">get()</ref> will give only &quot;a&quot; and <ref refid="classamrex_1_1ParmParse_1a85d984ee8232a42f83f7ab68e66e54e2" kindref="member">getarr()</ref> will store the results in <computeroutput>std::vectcor&lt;std::string&gt;</computeroutput>. Note this does not preserve the number of empty spaces, because of how <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> parses the line. For example, <computeroutput>a b c</computeroutput> with two spaces between <computeroutput>b</computeroutput> and <computeroutput>c</computeroutput> will become &quot;a
b c&quot;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="621" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2154" bodyend="2159"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a0dcd1420b3402a7e7eb769c6dcb87928" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryline</definition>
        <argsstring>(std::string_view name, std::string &amp;ref) const</argsstring>
        <name>queryline</name>
        <qualifiedname>amrex::ParmParse::queryline</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1af14555ab6859c064cc3ca2860cdfa378" kindref="member">query()</ref> but store the whole line including empty spaces in the middle if present as a single string. For example, <computeroutput>foo = a b c</computeroutput> is treated by this function as a single string &quot;a b c&quot;, whereas <ref refid="classamrex_1_1ParmParse_1af14555ab6859c064cc3ca2860cdfa378" kindref="member">query()</ref> will give only &quot;a&quot; and <ref refid="classamrex_1_1ParmParse_1aaaa34a7e283b84a0c41b9b5fb4d965aa" kindref="member">queryarr()</ref> will store the results in <computeroutput>std::vectcor&lt;std::string&gt;</computeroutput>. Note this does not preserve the number of empty spaces, because of how <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> parses the line. For example, <computeroutput>a b c</computeroutput> with two spaces between <computeroutput>b</computeroutput> and <computeroutput>c</computeroutput> will become &quot;a
b c&quot;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="631" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2162" bodyend="2170"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5321c11d55f3a17cf388a9217813f997" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, IntVect &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to an IntVect and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a IntVect, an error message is output and the program halts. Note that ival = 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="642" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1937" bodyend="1943"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9cd5f7a0b302092e2f9923b3ad72a5b0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, IntVect &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="647" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1946" bodyend="1951"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a73f9d1647938fa355524fb7a64721a62" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, IntVect &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="657" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1954" bodyend="1960"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af24517dc524bfd113c17a0f422abae0c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, IntVect &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="662" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1963" bodyend="1968"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a80ffd9abf64c20038cb94c45fd7728b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, const IntVect &amp;val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="666" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1971" bodyend="1975"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac95b8e5422c10df6f8ee5795d09719c3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getkth</definition>
        <argsstring>(std::string_view name, int k, Box &amp;ref, int ival=FIRST) const</argsstring>
        <name>getkth</name>
        <qualifiedname>amrex::ParmParse::getkth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Get the ival&apos;th value of kth occurrence of the requested name. If successful, the value is converted to a Box and stored in reference ref. If the kth occurrence does not exist or ival&apos;th value does not exist, or if the printed representation of the value cannot be converted to a Box, an error message is output and the program halts. Note that ival = 0 is the first value in the list. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="676" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2024" bodyend="2030"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af59b0808fb917b273cf11ec35f26f8b5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, Box &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="681" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2033" bodyend="2038"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a1718f31880c498c3ae18595cb7db3e98" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querykth</definition>
        <argsstring>(std::string_view name, int k, Box &amp;ref, int ival=FIRST) const</argsstring>
        <name>querykth</name>
        <qualifiedname>amrex::ParmParse::querykth</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>Similar to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref> but returns 0 if there is no kth occurrence of name. If successful, it returns 1 and stores the value in ref. If the kth occurrence exists, but ival&apos;th value of that occurrence does not, or if there is a type mismatch, then the program signals an error and halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="691" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2041" bodyend="2047"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac43c8ed7039f60bbe3bc6b249f390229" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, Box &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> but searches for the last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="696" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2050" bodyend="2055"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae9d18e04be03cc0b1040a3ec7afe30ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::add</definition>
        <argsstring>(std::string_view name, const Box &amp;val)</argsstring>
        <name>add</name>
        <qualifiedname>amrex::ParmParse::add</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with value &apos;val&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="700" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2058" bodyend="2062"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; int &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <qualifiedname>amrex::ParmParse::getktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; int &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;int&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to an int and stored in the std::vector&lt;int&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;int&gt;[0], std::vector&lt;int&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to an int, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="713" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1450" bodyend="1457"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a85d984ee8232a42f83f7ab68e66e54e2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; int &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; int &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="719" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1460" bodyend="1466"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; int &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <qualifiedname>amrex::ParmParse::queryktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; int &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="724" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1469" bodyend="1476"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aaaa34a7e283b84a0c41b9b5fb4d965aa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; int &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; int &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="730" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1479" bodyend="1485"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa61af07addec9bba0d1f9919e8043180" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(std::string_view name, const std::vector&lt; int &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <qualifiedname>amrex::ParmParse::addarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="735" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1488" bodyend="1492"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa712f10741a47c1728383536c79ffb39" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <qualifiedname>amrex::ParmParse::getktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;long&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to a long and stored in the std::vector&lt;long&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;long&gt;[0], std::vector&lt;long&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to a long, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="749" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1538" bodyend="1545"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab1a5af859c35b2e2112a1885ef8064d0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="755" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1548" bodyend="1554"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1acbf6fe9e229b326a9740a1d2e4ae64c3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <qualifiedname>amrex::ParmParse::queryktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="760" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1557" bodyend="1564"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a33e783f4854ba243fc9d462c3515e8a4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="766" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1567" bodyend="1573"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a12256efc7af7f26d3cf1436d53f315d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(std::string_view name, const std::vector&lt; long &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <qualifiedname>amrex::ParmParse::addarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="771" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1576" bodyend="1579"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8b35ea9cdf79ed50f1cdc1e2985358bd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; long long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <qualifiedname>amrex::ParmParse::getktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;long long&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to a long long and stored in the std::vector&lt;long long&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;long long&gt;[0], std::vector&lt;long long&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to a long long, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="785" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1624" bodyend="1631"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aec8ebfd3ccb7ba6f4311fb13a34db1c2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; long long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="791" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1634" bodyend="1640"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad62fb8d4547521e1084b166b991a66d5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; long long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <qualifiedname>amrex::ParmParse::queryktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="796" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1643" bodyend="1650"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aed1fae916d9755266d625a5610fee857" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; long long &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="802" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1653" bodyend="1659"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a7378ac3ac9f98d9b85e7cdbdf1e16305" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(std::string_view name, const std::vector&lt; long long &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <qualifiedname>amrex::ParmParse::addarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; long long &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="807" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1662" bodyend="1666"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6117a4cc75d9f335824fe887fddb6dcb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; float &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <qualifiedname>amrex::ParmParse::getktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;float&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to a float and stored in the std::vector&lt;float&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;float&gt;[0], std::vector&lt;float&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to a float, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="821" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1711" bodyend="1718"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a36339ab36e19da088d3a870913a359a3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; float &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="827" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1721" bodyend="1727"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a1caf3afdec04fbc1df7d7283eae01ba4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; float &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <qualifiedname>amrex::ParmParse::queryktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="832" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1730" bodyend="1737"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a24e1680268d7ae9cce52e22f8b7d80a4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; float &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="838" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1740" bodyend="1746"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a7ab6d21b45b055e97c50137b0c6e6762" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(std::string_view name, const std::vector&lt; float &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <qualifiedname>amrex::ParmParse::addarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; float &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="843" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1749" bodyend="1753"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a7465595467ab1f3789d5a03c5a31ed9c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; double &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <qualifiedname>amrex::ParmParse::getktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;double&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to a double and stored in the std::vector&lt;double&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;double&gt;[0], std::vector&lt;double&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to a double, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="856" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1800" bodyend="1807"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa41ab32d62ac10c8973bec8a12442d92" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; double &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="862" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1810" bodyend="1816"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a2b7193727090b11a43d20fa69503768b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; double &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <qualifiedname>amrex::ParmParse::queryktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="867" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1819" bodyend="1826"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab717febc04288ee14889c70e8c1462a9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; double &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="873" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1829" bodyend="1835"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af42585578aed7c21b5d72009862dccea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(std::string_view name, const std::vector&lt; double &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <qualifiedname>amrex::ParmParse::addarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="878" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1838" bodyend="1842"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a23f27ef2b7ca26c3a79ff1682f94508b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; std::string &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <qualifiedname>amrex::ParmParse::getktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;std::string&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to an std::string and stored in the std::vector&lt;std::string&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;std::string&gt;[0], std::vector&lt;std::string&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to an std::string, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="891" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1889" bodyend="1896"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a41821674f6acfae5bc9780cad1c35469" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; std::string &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="897" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1899" bodyend="1905"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1affe46bb1025380358df8ece603a5ac7d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; std::string &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <qualifiedname>amrex::ParmParse::queryktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="902" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1908" bodyend="1915"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5d0c41e413aa70b842a097291d4740d1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; std::string &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> but searches for last occurrence of name.2. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="908" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1918" bodyend="1924"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5d7d488d3365fc1dc85791e9507b485d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(std::string_view name, const std::vector&lt; std::string &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <qualifiedname>amrex::ParmParse::addarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="913" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1927" bodyend="1931"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aee763470094d7cb75b8787b3c83757a6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; IntVect &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <qualifiedname>amrex::ParmParse::getktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;IntVect&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to an IntVect and stored in the std::vector&lt;IntVect&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;IntVect&gt;[0], std::vector&lt;IntVect&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to an IntVect, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="926" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1978" bodyend="1985"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a059393b77c51ee63d490808bc643de47" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; IntVect &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="932" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1988" bodyend="1994"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aae8abc37eec7cb3d102db7e1620a191a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; IntVect &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <qualifiedname>amrex::ParmParse::queryktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="937" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1997" bodyend="2004"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a7ca579bd16204241bef40ee4943f1601" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; IntVect &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> but searches for last occurrence of name.2. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="943" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2007" bodyend="2013"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad924392157f74851f24edb90bde4887a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(std::string_view name, const std::vector&lt; IntVect &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <qualifiedname>amrex::ParmParse::addarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="948" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2016" bodyend="2020"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5db50d7426da874944b177e8605fa0c4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; Box &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getktharr</name>
        <qualifiedname>amrex::ParmParse::getktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Gets an std::vector&lt;Box&gt; of num_val values from kth occurrence of given name. If successful, the values are converted to an Box and stored in the std::vector&lt;Box&gt; object ref. ref is resized (if necessary) to hold num_val values. The value in the list indexed by start_ix is copied into std::vector&lt;Box&gt;[0], std::vector&lt;Box&gt;[1] holds start_ix+1, etc. If the kth occurrence does not exist or there are fewer than start_ix + num_val values associated with the kth occurrence, or if some of the values cannot be converted to an Box, an error message is reported and the program halts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="961" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2065" bodyend="2072"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a0bded2795babf2d74febfb53e05ef757" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; Box &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> but searches for last occurrence of name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="967" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2075" bodyend="2081"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa7df771a461d593addd85b57e96346f6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryktharr</definition>
        <argsstring>(std::string_view name, int k, std::vector&lt; Box &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryktharr</name>
        <qualifiedname>amrex::ParmParse::queryktharr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" kindref="member">querykth()</ref> as <ref refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" kindref="member">getktharr()</ref> is to <ref refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" kindref="member">getkth()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="972" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2084" bodyend="2091"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac9ba007b2631e2ac5165934f40d16544" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; Box &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as <ref refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" kindref="member">queryktharr()</ref> but searches for last occurrence of name.2. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="978" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2094" bodyend="2100"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a92bf823f92a3e3537f209010df60f2fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addarr</definition>
        <argsstring>(std::string_view name, const std::vector&lt; Box &gt; &amp;ref)</argsstring>
        <name>addarr</name>
        <qualifiedname>amrex::ParmParse::addarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Add a key &apos;name&apos; with vector of values &apos;ref&apos; to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="983" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2103" bodyend="2107"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a0f59b40ef4683f71180918865b6e615b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, IntVect &amp;ref) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="991" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2111" bodyend="2121"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a04ec2ceb5b8415b2072265fa6d9c27d1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, IntVect &amp;ref) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="999" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2124" bodyend="2130"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a261572cfea63f2c1895b081dd583f814" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, RealVect &amp;ref) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a9a66cb310efdbc12b9b4d5f170470726" kindref="member">RealVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Query RealVect from array. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1002" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2133" bodyend="2142"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9066a648395fcfb3a2b1e4b035860571" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, RealVect &amp;ref) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a9a66cb310efdbc12b9b4d5f170470726" kindref="member">RealVect</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Get RealVect from array. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1005" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2145" bodyend="2151"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8e9f0864d7c1524822dbc8ab967eef70" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, std::array&lt; T, N &gt; &amp;ref) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::array&lt; T, N &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1008" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1008" bodyend="1015"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a224c7cde1b6bb68c320910b5bb19c735" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, std::array&lt; T, N &gt; &amp;ref) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::array&lt; T, N &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1018" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1018" bodyend="1028"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa4f131652756eb9e07f7791b740f753d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!IsStdVector&lt; T &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(std::string_view name, T &amp;ref)</argsstring>
        <name>queryAdd</name>
        <qualifiedname>amrex::ParmParse::queryAdd</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>If <computeroutput>name</computeroutput> is found, the value in the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database will be stored in the <computeroutput>ref</computeroutput> argument. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates if it existed previously. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1037" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1037" bodyend="1043"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6c7a4da859606ed5f5bf2539f82b3d5b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(std::string_view name, std::string &amp;ref)</argsstring>
        <name>queryAdd</name>
        <qualifiedname>amrex::ParmParse::queryAdd</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1045" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1045" bodyend="1051"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a13c39d0336c0d16eec7716d5f80103ae" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(std::string_view name, std::vector&lt; T &gt; &amp;ref)</argsstring>
        <name>queryAdd</name>
        <qualifiedname>amrex::ParmParse::queryAdd</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>If <computeroutput>name</computeroutput> is found, the value in the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database will be stored in the <computeroutput>ref</computeroutput> argument. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates if it existed previously. </para>
        </briefdescription>
        <detaileddescription>
<para>If <computeroutput>name</computeroutput> is found, then the ref argument will be reallocated (and resized) according to the number of values in the inputs. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1063" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1063" bodyend="1073"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a933a4225276737d40bf1234683c57c78" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(std::string_view name, std::vector&lt; T &gt; &amp;ref, int num_val)</argsstring>
        <name>queryAdd</name>
        <qualifiedname>amrex::ParmParse::queryAdd</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
        </param>
        <briefdescription>
<para>If <computeroutput>name</computeroutput> is found, the value in the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database will be stored in the <computeroutput>ref</computeroutput> argument. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates if it existed previously. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1082" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1082" bodyend="1088"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab91ffc0c5afee1e60bd8f62a61862c21" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryAdd</definition>
        <argsstring>(std::string_view name, std::array&lt; T, N &gt; &amp;ref)</argsstring>
        <name>queryAdd</name>
        <qualifiedname>amrex::ParmParse::queryAdd</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::array&lt; T, N &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>If <computeroutput>name</computeroutput> is found, the value in the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database will be stored in the <computeroutput>ref</computeroutput> argument. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates if it existed previously. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1097" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1097" bodyend="1113"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa3b4ec007f593fef0da494811ced5351" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(std::string_view name, bool &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <qualifiedname>amrex::ParmParse::queryWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Query with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. If <computeroutput>name</computeroutput> is found, this uses <ref refid="classamrex_1_1Parser" kindref="compound">amrex::Parser</ref> to parse the entire list of empty space separated values as a single scalar. The return value indicates whether it&apos;s found. Note that queryWithParser will be used recursively for unresolved symbols. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1121" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2257" bodyend="2260"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1afe7de9b31d973a0fad16d1e3f04de71d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(std::string_view name, int &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <qualifiedname>amrex::ParmParse::queryWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1122" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2263" bodyend="2266"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a7cd1c8dbe135d88051244bb278b91cd2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(std::string_view name, long &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <qualifiedname>amrex::ParmParse::queryWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1123" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2269" bodyend="2272"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae4aae501bd2f9c6d8e09d90165864165" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(std::string_view name, long long &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <qualifiedname>amrex::ParmParse::queryWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>long long &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1124" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2275" bodyend="2278"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9cb1f363db4fe33d9beeab460c021809" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(std::string_view name, float &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <qualifiedname>amrex::ParmParse::queryWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1125" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2281" bodyend="2284"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a88ff5accb455cd990b2bbba806aeaf83" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryWithParser</definition>
        <argsstring>(std::string_view name, double &amp;ref) const</argsstring>
        <name>queryWithParser</name>
        <qualifiedname>amrex::ParmParse::queryWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1126" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2287" bodyend="2290"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1abfa0eabbb875722227ffa136c27797cc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, bool *ptr) const</argsstring>
        <name>queryarrWithParser</name>
        <qualifiedname>amrex::ParmParse::queryarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Query with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. The return value indicates whether it&apos;s found. Note that queryWithParser will be used for unresolved symbols. If the number of elements in the input does not equal to <computeroutput>nvals</computeroutput>, it&apos;s a runtime error. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1134" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2293" bodyend="2296"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aaa3e2c26aa2bb7ed5ff42a8eddff57a7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, int *ptr) const</argsstring>
        <name>queryarrWithParser</name>
        <qualifiedname>amrex::ParmParse::queryarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1135" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2299" bodyend="2302"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5d4d9d891cf000a81c8ea848a2a97c3f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, long *ptr) const</argsstring>
        <name>queryarrWithParser</name>
        <qualifiedname>amrex::ParmParse::queryarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>long *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1136" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2305" bodyend="2308"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8e21b3af1df63608cc7b49fb97e3b445" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, long long *ptr) const</argsstring>
        <name>queryarrWithParser</name>
        <qualifiedname>amrex::ParmParse::queryarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>long long *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1137" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2311" bodyend="2314"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a666f9ef5b0e17a0a3226168761c708aa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, float *ptr) const</argsstring>
        <name>queryarrWithParser</name>
        <qualifiedname>amrex::ParmParse::queryarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>float *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1138" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2317" bodyend="2320"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a44e8c7e4ff321bdade48e6952598c111" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::queryarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, double *ptr) const</argsstring>
        <name>queryarrWithParser</name>
        <qualifiedname>amrex::ParmParse::queryarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1139" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2323" bodyend="2326"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a12b6a9310541c84e79cb64fbe014529e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, bool &gt;||std::is_same_v&lt; T, int &gt;||std::is_same_v&lt; T, long &gt;||std::is_same_v&lt; T, long long &gt;||std::is_same_v&lt; T, float &gt;||std::is_same_v&lt; T, double &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, std::vector&lt; T &gt; &amp;ref) const</argsstring>
        <name>queryarrWithParser</name>
        <qualifiedname>amrex::ParmParse::queryarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1146" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1146" bodyend="1154"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a97e1b5853258d4859e4b29158d860dd9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, bool &gt;||std::is_same_v&lt; T, int &gt;||std::is_same_v&lt; T, long &gt;||std::is_same_v&lt; T, long long &gt;||std::is_same_v&lt; T, float &gt;||std::is_same_v&lt; T, double &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryAddWithParser</definition>
        <argsstring>(std::string_view name, T &amp;ref)</argsstring>
        <name>queryAddWithParser</name>
        <qualifiedname>amrex::ParmParse::queryAddWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Query with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. If <computeroutput>name</computeroutput> is found, this uses <ref refid="classamrex_1_1Parser" kindref="compound">amrex::Parser</ref> to parse the entire list of empty space separated values as a single scalar. If not, the value in <computeroutput>ref</computeroutput> will be added to the <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> database. The return value indicates whether it&apos;s found. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1168" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1168" bodyend="1175"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a196eece9b69302a5ed35bd2997a341b9" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, bool &gt;||std::is_same_v&lt; T, int &gt;||std::is_same_v&lt; T, long &gt;||std::is_same_v&lt; T, long long &gt;||std::is_same_v&lt; T, float &gt;||std::is_same_v&lt; T, double &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::getWithParser</definition>
        <argsstring>(std::string_view name, T &amp;ref) const</argsstring>
        <name>getWithParser</name>
        <qualifiedname>amrex::ParmParse::getWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Get with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. If <computeroutput>name</computeroutput> is found, this uses <ref refid="classamrex_1_1Parser" kindref="compound">amrex::Parser</ref> to parse the entire list of empty space separated values as a single scalar. If not, it&apos;s a runtime error. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1188" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1188" bodyend="1194"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a87d5f90696a72a98a3ee69105da00e82" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, bool &gt;||std::is_same_v&lt; T, int &gt;||std::is_same_v&lt; T, long &gt;||std::is_same_v&lt; T, long long &gt;||std::is_same_v&lt; T, float &gt;||std::is_same_v&lt; T, double &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::getarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, T *ptr) const</argsstring>
        <name>getarrWithParser</name>
        <qualifiedname>amrex::ParmParse::getarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Get with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. If <computeroutput>name</computeroutput> is not found, it&apos;s a runtime error. If the number of elements does not equal to <computeroutput>nvals</computeroutput>, it&apos;s also a runtime error. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1207" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1207" bodyend="1213"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aea0f850513020908727643a151883156" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, bool &gt;||std::is_same_v&lt; T, int &gt;||std::is_same_v&lt; T, long &gt;||std::is_same_v&lt; T, long long &gt;||std::is_same_v&lt; T, float &gt;||std::is_same_v&lt; T, double &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::getarrWithParser</definition>
        <argsstring>(std::string_view name, int nvals, std::vector&lt; T &gt; &amp;ref) const</argsstring>
        <name>getarrWithParser</name>
        <qualifiedname>amrex::ParmParse::getarrWithParser</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Get with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. If <computeroutput>name</computeroutput> is not found, it&apos;s a runtime error. If the number of elements does not equal to <computeroutput>nvals</computeroutput>, it&apos;s also a runtime error. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1226" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1226" bodyend="1232"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a85725ada8b311feda5f7c55611e7c3ed" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, bool &gt;||std::is_same_v&lt; T, int &gt;||std::is_same_v&lt; T, long &gt;||std::is_same_v&lt; T, long long &gt;||std::is_same_v&lt; T, float &gt;||std::is_same_v&lt; T, double &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::ParmParse::eval</definition>
        <argsstring>(std::string const &amp;expr) const</argsstring>
        <name>eval</name>
        <qualifiedname>amrex::ParmParse::eval</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>expr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1245" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1245" bodyend="1256"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1abbdc989daab71c4cb0101e87c1515689" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(const char *new_name, const char *old_name, T &amp;ref)</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>new_name</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>old_name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1265" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1265" bodyend="1269"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a52b882dec70bfeb4ccf32cd859e148f3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(const char *new_name, const char *old_name, T &amp;ref)</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>new_name</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>old_name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Get using two names. </para>
        </briefdescription>
        <detaileddescription>
<para>This function queries with <computeroutput>new_name</computeroutput> first, If it&apos;s not found, it will try again with <computeroutput>old_name</computeroutput>. It&apos;s an error if neither name is found. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1279" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1279" bodyend="1288"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a5189f0f4ea7529f029b2fdd0c0a182e0" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::query</definition>
        <argsstring>(std::string_view name, T &amp;ref, int ival=FIRST) const</argsstring>
        <name>query</name>
        <qualifiedname>amrex::ParmParse::query</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>. Query enum value using given name. </para>
        </briefdescription>
        <detaileddescription>
<para>Here T is an enum class defined by AMREX_ENUM. The return value indicates if <computeroutput>name</computeroutput> is found. An exception is thrown, if the found string associated with the name cannot be converted to an enumerator (i.e., the string does not match any names in the definition of T). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1300" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1300" bodyend="1316"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a2a4c4ffdde1bc4485b03055846709097" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::get</definition>
        <argsstring>(std::string_view name, T &amp;ref, int ival=FIRST) const</argsstring>
        <name>get</name>
        <qualifiedname>amrex::ParmParse::get</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>. Get enum value using given name. </para>
        </briefdescription>
        <detaileddescription>
<para>Here T is an enum class defined by AMREX_ENUM. It&apos;s a runtime error, if <computeroutput>name</computeroutput> is not found. An exception is thrown, if the found string associated with the name cannot be converted to an enumerator (i.e., the string does not match any names in the definition of T). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1328" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1328" bodyend="1341"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab0fdcb339938512b02973fe3c34242d2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; T &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>queryarr</name>
        <qualifiedname>amrex::ParmParse::queryarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Query an array of enum values using given name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1346" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1346" bodyend="1368"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a32cb19f6ef52cb47e0ae09a526549d56" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::getarr</definition>
        <argsstring>(std::string_view name, std::vector&lt; T &gt; &amp;ref, int start_ix=FIRST, int num_val=ALL) const</argsstring>
        <name>getarr</name>
        <qualifiedname>amrex::ParmParse::getarr</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; T &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_ix</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <param>
          <type>int</type>
          <declname>num_val</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" kindref="member">ALL</ref></defval>
        </param>
        <briefdescription>
<para>Get an array of enum values using given name. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1373" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1373" bodyend="1392"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6fc837f8d0b8fb3ae6a68934f56a90f7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::query_enum_case_insensitive</definition>
        <argsstring>(std::string_view name, T &amp;ref, int ival=FIRST) const</argsstring>
        <name>query_enum_case_insensitive</name>
        <qualifiedname>amrex::ParmParse::query_enum_case_insensitive</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>. Query enum value using given name. </para>
        </briefdescription>
        <detaileddescription>
<para>Here T is an enum class defined by AMREX_ENUM. The return value indicates if <computeroutput>name</computeroutput> is found. An exception is thrown, if the found string associated with the name cannot be case-insensitively converted to an enumerator (i.e., the found string, not <computeroutput>name</computeroutput>, does not case-insensitively match any names in the definition of T). If there are multiple matches, the first one is used. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1406" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1406" bodyend="1422"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1acd07704e6f093de3dea81e1698c0b55f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::get_enum_case_insensitive</definition>
        <argsstring>(std::string_view name, T &amp;ref, int ival=FIRST) const</argsstring>
        <name>get_enum_case_insensitive</name>
        <qualifiedname>amrex::ParmParse::get_enum_case_insensitive</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>. Get enum value using given name. </para>
        </briefdescription>
        <detaileddescription>
<para>Here T is an enum class defined by AMREX_ENUM. It&apos;s a runtime error, if <computeroutput>name</computeroutput> is not found. An exception is thrown, if the found string associated with the name cannot be case-insensitively converted to an enumerator (i.e., the found string, not <computeroutput>name</computeroutput>, does not case-insensitively match any names in the definition of T). If there are multiple matches, the first one is used. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1436" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1436" bodyend="1445"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1af3373b96989f0fe265d166cfcf9c75ea" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::query_enum_sloppy</definition>
        <argsstring>(std::string_view name, T &amp;ref, std::string_view const &amp;ignores, int ival=FIRST) const</argsstring>
        <name>query_enum_sloppy</name>
        <qualifiedname>amrex::ParmParse::query_enum_sloppy</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>std::string_view const &amp;</type>
          <declname>ignores</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>. Query enum value using given name. </para>
        </briefdescription>
        <detaileddescription>
<para>Here T is an enum class defined by AMREX_ENUM. The return value indicates if <computeroutput>name</computeroutput> is found. An exception is thrown, if the found string associated with the name cannot be case-insensitively converted to an enumerator (i.e., the found string, not <computeroutput>name</computeroutput>, does not case-insensitively match any names in the definition of T). If there are multiple matches, the first one is used. Characters in <computeroutput>ignores</computeroutput> will be ignored as if they don&apos;t exist in the value part of ParamParse entries (e.g., <computeroutput>name = value</computeroutput>). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1461" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1461" bodyend="1482"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a4902948839a7aeaa172befda8263d8d4" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::get_enum_sloppy</definition>
        <argsstring>(std::string_view name, T &amp;ref, std::string_view const &amp;ignores, int ival=FIRST) const</argsstring>
        <name>get_enum_sloppy</name>
        <qualifiedname>amrex::ParmParse::get_enum_sloppy</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>std::string_view const &amp;</type>
          <declname>ignores</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ival</declname>
          <defval><ref refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" kindref="member">FIRST</ref></defval>
        </param>
        <briefdescription>
<para>. Get enum value using given name. </para>
        </briefdescription>
        <detaileddescription>
<para>Here T is an enum class defined by AMREX_ENUM. It&apos;s a runtime error, if <computeroutput>name</computeroutput> is not found. An exception is thrown, if the found string associated with the name cannot be case-insensitively converted to an enumerator (i.e., the found string, not <computeroutput>name</computeroutput>, does not case-insensitively match any names in the definition of T). If there are multiple matches, the first one is used. Characters in <computeroutput>ignores</computeroutput> will be ignored as if they don&apos;t exist in the value part of ParamParse entries (e.g., <computeroutput>name = value</computeroutput>). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1498" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1498" bodyend="1508"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8219e1330b9bee958c9f21771654902a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespaceamrex_1_1ppdetail_1ae3062fc5ca3dda7517b74219ee21f684" kindref="member">ppdetail::IsArithmeticOptional_v</ref>&lt; T &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryAsDouble</definition>
        <argsstring>(std::string_view name, T &amp;ref) const</argsstring>
        <name>queryAsDouble</name>
        <qualifiedname>amrex::ParmParse::queryAsDouble</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Query T with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>, but treat the number as double precision during parsing. </para>
        </briefdescription>
        <detaileddescription>
<para>The final result is cast to T. It may result in a runtime error if the conversion is not safe. T is either arithmetic type or std::optional of arithmetic type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1519" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1519" bodyend="1537"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8db338e5ec5063b9f9463eb8a4a56bd9" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespaceamrex_1_1ppdetail_1ae3062fc5ca3dda7517b74219ee21f684" kindref="member">ppdetail::IsArithmeticOptional_v</ref>&lt; T &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::ParmParse::queryarrAsDouble</definition>
        <argsstring>(std::string_view name, int nvals, T *ptr) const</argsstring>
        <name>queryarrAsDouble</name>
        <qualifiedname>amrex::ParmParse::queryarrAsDouble</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Query T array with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>, but treat the number as double precision during parsing. </para>
        </briefdescription>
        <detaileddescription>
<para>The final result is cast to T&apos;s. It may result in a runtime error if the conversion is not safe. T is either arithmetic type or std::optional of arithmetic type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1548" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1548" bodyend="1568"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a8c5cfdb8b319e8d564fcc33fcde77933" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespaceamrex_1_1ppdetail_1ae3062fc5ca3dda7517b74219ee21f684" kindref="member">ppdetail::IsArithmeticOptional_v</ref>&lt; T &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::getAsDouble</definition>
        <argsstring>(std::string_view name, T &amp;ref) const</argsstring>
        <name>getAsDouble</name>
        <qualifiedname>amrex::ParmParse::getAsDouble</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Get T with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>, but treat the number as double precision during parsing. </para>
        </briefdescription>
        <detaileddescription>
<para>The final result is cast to T. It may result in a runtime error if the conversion is not safe. T is either arithmetic type or std::optional of arithmetic type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1579" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1579" bodyend="1585"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac287be11ef36585608c6b44b5e338595" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespaceamrex_1_1ppdetail_1ae3062fc5ca3dda7517b74219ee21f684" kindref="member">ppdetail::IsArithmeticOptional_v</ref>&lt; T &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::getarrAsDouble</definition>
        <argsstring>(std::string_view name, int nvals, T *ptr) const</argsstring>
        <name>getarrAsDouble</name>
        <qualifiedname>amrex::ParmParse::getarrAsDouble</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nvals</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Get T array with <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>, but treat the number as double precision during parsing. </para>
        </briefdescription>
        <detaileddescription>
<para>The final result is cast to T&apos;s. It may result in a runtime error if the conversion is not safe. T is either arithmetic type or std::optional of arithmetic type. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1596" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1596" bodyend="1602"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa779227a7006a8408506327917fd16c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::remove</definition>
        <argsstring>(std::string_view name)</argsstring>
        <name>remove</name>
        <qualifiedname>amrex::ParmParse::remove</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Remove given name from the table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1605" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2209" bodyend="2214"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a6a0e28c45ee942f30c9f5c50f338e203" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref></type>
        <definition>Parser amrex::ParmParse::makeParser</definition>
        <argsstring>(std::string const &amp;func, Vector&lt; std::string &gt; const &amp;vars) const</argsstring>
        <name>makeParser</name>
        <qualifiedname>amrex::ParmParse::makeParser</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; const &amp;</type>
          <declname>vars</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref> using given string <computeroutput>func</computeroutput> as function body and <computeroutput>vars</computeroutput> as variable names. Constants known to <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> will be set. It&apos;s a runtime error, if there are unknown symbols in <computeroutput>func</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1610" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2329" bodyend="2333"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1afac8d3383aa70acfdd3cd22a8df79539" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1IParser" kindref="compound">IParser</ref></type>
        <definition>IParser amrex::ParmParse::makeIParser</definition>
        <argsstring>(std::string const &amp;func, Vector&lt; std::string &gt; const &amp;vars) const</argsstring>
        <name>makeIParser</name>
        <qualifiedname>amrex::ParmParse::makeIParser</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; const &amp;</type>
          <declname>vars</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make <ref refid="classamrex_1_1IParser" kindref="compound">IParser</ref> using given string <computeroutput>func</computeroutput> as function body and <computeroutput>vars</computeroutput> as variable names. Constants known to <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> will be set. It&apos;s a runtime error, if there are unknown symbols in <computeroutput>func</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1616" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2336" bodyend="2340"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a1d8b1d795e0960eba2cdb7feb4a746ab" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querytable</definition>
        <argsstring>(std::string_view name, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;ref) const</argsstring>
        <name>querytable</name>
        <qualifiedname>amrex::ParmParse::querytable</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; double &gt; &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Query vector of vector. The return value indicates whether it&apos;s found. The table (i.e., vector of vector) is in the format of <computeroutput>{{a00, a01, a02...} {a10, a11, a12...} ...}</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1624" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2411" bodyend="2419"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a63899edcc14bb7907d12b60bd1774ba9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querytable</definition>
        <argsstring>(std::string_view name, std::vector&lt; std::vector&lt; float &gt; &gt; &amp;ref) const</argsstring>
        <name>querytable</name>
        <qualifiedname>amrex::ParmParse::querytable</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; float &gt; &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1625" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2421" bodyend="2429"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ac43a4072f63ba2ec52685fb367c615ea" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::querytable</definition>
        <argsstring>(std::string_view name, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;ref) const</argsstring>
        <name>querytable</name>
        <qualifiedname>amrex::ParmParse::querytable</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1626" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="2431" bodyend="2439"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a1b6a1271f30934afb21a3fbac8bb7478" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParmParse::gettable</definition>
        <argsstring>(std::string_view name, std::vector&lt; std::vector&lt; T &gt; &gt; &amp;ref) const</argsstring>
        <name>gettable</name>
        <qualifiedname>amrex::ParmParse::gettable</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
<para>Get vector of vector. It&apos;s an error if it is not found. The table (i.e., vector of vector) is in the format of <computeroutput>{{a00, a01, * a02...} {a10, a11, a12...} ...}</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1634" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1634" bodyend="1642"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a957fdca08b9590837d67ea30d507f148" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classamrex_1_1ParmParse_1af823116cc58b501d9f158fa5635c1498" kindref="member">Table</ref> &amp;</type>
        <definition>const Table &amp; amrex::ParmParse::table</definition>
        <argsstring>() const</argsstring>
        <name>table</name>
        <qualifiedname>amrex::ParmParse::table</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1717" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1717" bodyend="1717"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa6631c8bb7546e8418283f0f6d35c83d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string const &amp;</type>
        <definition>std::string const  &amp; amrex::ParmParse::getPrefix</definition>
        <argsstring>() const</argsstring>
        <name>getPrefix</name>
        <qualifiedname>amrex::ParmParse::getPrefix</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1724" column="24" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1095" bodyend="1098"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ae89d7f22059ca7008a10790e6d5dda58" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::ParmParse::prefixedName</definition>
        <argsstring>(std::string_view str) const</argsstring>
        <name>prefixedName</name>
        <qualifiedname>amrex::ParmParse::prefixedName</qualifiedname>
        <param>
          <type>std::string_view</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1726" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1101" bodyend="1112"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a302162fcd495ffd22ab0ebb8d8f36a05" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::Initialize</definition>
        <argsstring>(int argc, char **argv, const char *parfile)</argsstring>
        <name>Initialize</name>
        <qualifiedname>amrex::ParmParse::Initialize</qualifiedname>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>parfile</declname>
        </param>
        <briefdescription>
<para>Construct an initial <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object from the argc and argv passed in to main(). An error will be signalled if another <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object currently exists. If parfile is specified, read the parameters in from that file first and then append those derived from argv to the table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1651" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1140" bodyend="1154"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ab480e0eaf8f4c94d2cb5f03a97c55bc5" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void amrex::ParmParse::Initialize</definition>
        <argsstring>(int argc, char **argv, const std::string &amp;parfile)</argsstring>
        <name>Initialize</name>
        <qualifiedname>amrex::ParmParse::Initialize</qualifiedname>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>parfile</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1652" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="1652" bodyend="1654"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9283fab7556352eeff908ca26cd440be" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::Finalize</definition>
        <argsstring>()</argsstring>
        <name>Finalize</name>
        <qualifiedname>amrex::ParmParse::Finalize</qualifiedname>
        <briefdescription>
<para>The destructor. The internal static table will only be deleted if there are no other <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> objects in existence. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1659" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1240" bodyend="1264"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa1549749aa28417bed7bb7a9d5a99810" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::SetParserPrefix</definition>
        <argsstring>(std::string a_prefix)</argsstring>
        <name>SetParserPrefix</name>
        <qualifiedname>amrex::ParmParse::SetParserPrefix</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>a_prefix</declname>
        </param>
        <briefdescription>
<para>Set prefix used by math expression <ref refid="classamrex_1_1Parser" kindref="compound">Parser</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1662" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1267" bodyend="1270"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a4fe2b9e6e5a2c039c7684f364a5c8bb2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::ParmParse::Verbose</definition>
        <argsstring>()</argsstring>
        <name>Verbose</name>
        <qualifiedname>amrex::ParmParse::Verbose</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1664" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1221" bodyend="1231"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a50ba1e91e9681699bf5c1a32be2814e6" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::SetVerbose</definition>
        <argsstring>(int v)</argsstring>
        <name>SetVerbose</name>
        <qualifiedname>amrex::ParmParse::SetVerbose</qualifiedname>
        <param>
          <type>int</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1665" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1234" bodyend="1237"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad5376a2e65027c356b38efbef3180c28" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::dumpTable</definition>
        <argsstring>(std::ostream &amp;os, bool prettyPrint=false)</argsstring>
        <name>dumpTable</name>
        <qualifiedname>amrex::ParmParse::dumpTable</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>prettyPrint</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Write the contents of the table in ASCII to the ostream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1668" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1273" bodyend="1295"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a25e20319d7e653849733bf39d7416437" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::prettyPrintTable</definition>
        <argsstring>(std::ostream &amp;os)</argsstring>
        <name>prettyPrintTable</name>
        <qualifiedname>amrex::ParmParse::prettyPrintTable</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write all entries in the table in a pretty way to the ostream. If there are duplicates, only the last one is printed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1672" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1337" bodyend="1340"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1ad9c8a23815fd21810e9f736a5ec3de97" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::prettyPrintUnusedInputs</definition>
        <argsstring>(std::ostream &amp;os)</argsstring>
        <name>prettyPrintUnusedInputs</name>
        <qualifiedname>amrex::ParmParse::prettyPrintUnusedInputs</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write unused inputs in a pretty way to the ostream. If there are duplicates, only the last one is printed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1676" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1343" bodyend="1346"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a9216f6edda8e16c30796f4929fb28892" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::prettyPrintUsedInputs</definition>
        <argsstring>(std::ostream &amp;os)</argsstring>
        <name>prettyPrintUsedInputs</name>
        <qualifiedname>amrex::ParmParse::prettyPrintUsedInputs</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write used inputs in a pretty way to the ostream. If there are duplicates, only the last one is printed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1680" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1349" bodyend="1352"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a3403a33aa6274309f3d1b5313fb28b46" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParmParse::addfile</definition>
        <argsstring>(std::string const &amp;filename)</argsstring>
        <name>addfile</name>
        <qualifiedname>amrex::ParmParse::addfile</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
<para>Add keys and values from a file to the end of the PP table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1683" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1115" bodyend="1137"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a821d000e2b1d1aa6dc9e18d0b54e0df7" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::ParmParse::QueryUnusedInputs</definition>
        <argsstring>()</argsstring>
        <name>QueryUnusedInputs</name>
        <qualifiedname>amrex::ParmParse::QueryUnusedInputs</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1685" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1157" bodyend="1169"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1a65ec105f3594e14160a631083a1bce59" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::ParmParse::hasUnusedInputs</definition>
        <argsstring>(const std::string &amp;prefix=std::string())</argsstring>
        <name>hasUnusedInputs</name>
        <qualifiedname>amrex::ParmParse::hasUnusedInputs</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1Any" kindref="compound">Any</ref> unused [prefix.]* parameters? </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1688" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1172" bodyend="1175"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1aa4c1dbee984103cd1102514d70c954a3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; amrex::ParmParse::getUnusedInputs</definition>
        <argsstring>(const std::string &amp;prefix=std::string())</argsstring>
        <name>getUnusedInputs</name>
        <qualifiedname>amrex::ParmParse::getUnusedInputs</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para>Returns unused [prefix.]* parameters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1691" column="25" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1178" bodyend="1205"/>
      </memberdef>
      <memberdef kind="function" id="classamrex_1_1ParmParse_1add7b8b32755bc2ffd24623957b797d23" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::set&lt; std::string &gt;</type>
        <definition>std::set&lt; std::string &gt; amrex::ParmParse::getEntries</definition>
        <argsstring>(const std::string &amp;prefix=std::string())</argsstring>
        <name>getEntries</name>
        <qualifiedname>amrex::ParmParse::getEntries</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para>Returns [prefix.]* parameters. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="1694" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.cpp" bodystart="1208" bodyend="1218"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Parse Parameters From Command Line and Input Files. </para>
    </briefdescription>
    <detaileddescription>
<para>The <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> class is used to interpret parameters passed in to a program from the command line and an arbitrary collection of input files. The parameters are stored in static table that can be queried by any object of type <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref>. A parameter is a &quot;definition&quot;. A definition is of the form &quot;\&lt;name\&gt; = \&lt;value\&gt;\&lt;value\&gt;...\&lt;value\&gt;&quot;. It is stored in the table as a name, value-list pair.</para>
<para>In the following example, niter is a definition with the single integer value 10; name is a definition with the string value &quot;big
 code&quot; and dx is a definition with the two floating point values 0.5 and 0.75 and iv is an <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect(5,4)</ref></para>
<para><programlisting><codeline><highlight class="normal">executable<sp/>niter<sp/>=<sp/>10<sp/><ref refid="namespaceamrex_1_1Machine_1a578c9b214c4e8dfa2f753181f21d5720" kindref="member">name</ref><sp/>=<sp/></highlight><highlight class="stringliteral">&quot;big<sp/>code&quot;</highlight><highlight class="normal"><sp/>dx<sp/>=<sp/>0.5<sp/>0.75<sp/>iv=(5,4)</highlight></codeline>
</programlisting></para>
<para>The <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> class has two constructors. The first is responsible for building the table and is usually called by the main routine of an application. It has arguments for the command line argc and argv parameters, as well as an optional filename argument for reading definitions from an input file. The table is built by reading the input file first (if it exists) with the command line arguments added to the end of the table. The order of a definition in the table is significant, so command line parameters can be used to override definitions in the input file. A definition of the explicit form: FILE=&lt;filename&gt; is not added to the table but is a directive to include the named file at that point in the table.</para>
<para>The second constructor is generally used by other classes in the code. It permits access to the table via a large collection of query functions. Both constructors have an optional prefix argument that narrows the search to entries in the table with the same prefix. For example, let PlanR be a <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> object with code prefix &quot;ope&quot;. PlanR.get(&quot;val&quot;,v) will look for an entry in the parameter list of the form: ope.val==&lt;value&gt;, and will reject all entries not starting with the correct code prefix.</para>
<para>The query functions search the table for definition names that match a given string (and prefix) and return values from the corresponding value list. The values can be returned as ints, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt;int&gt;s, floats, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt;float&gt;s, doubles, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt;double&gt;s, std::strings, or <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt;aSring&gt;s. All values in the table are stored as std::string objects, but if an int, float, or double is requested, the translation is done automatically. In the previous example, the value of niter could be returned as either an std::string, an int, a double, or a float. The values of dx can be returned as std::strings, floats, or doubles, but the value of name can be returned only as an std::string.</para>
<para>Comments in an input file include all text from a # character to the end of the line. Here is a sample input file:</para>
<para><programlisting><codeline><highlight class="normal">niter<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">title<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;Double<sp/>Wammy&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">cell_size<sp/>=<sp/>0.5<sp/>0.75</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">plot.var<sp/>=<sp/>Density<sp/>1<sp/>10</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">plot.var<sp/>=<sp/>Energy<sp/><sp/>5<sp/>12</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">bigarray<sp/>=<sp/>1<sp/>2<sp/>3<sp/>4<sp/>5<sp/>6<sp/>7<sp/>8<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>9<sp/>10<sp/>11<sp/>12</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">multi_line_string<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>a</highlight></codeline>
<codeline><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>multi-line<sp/>string.&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">aBox<sp/><sp/><sp/><sp/>=<sp/>((0,0)<sp/>(5,5))</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">test<sp/>=<sp/>apple<sp/></highlight><highlight class="stringliteral">&quot;boy<sp/>blue&quot;</highlight><highlight class="normal"><sp/>10<sp/>20<sp/>30<sp/>40</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FILE<sp/>=<sp/>prob_file</highlight></codeline>
</programlisting></para>
<para>Preprocessing of AMREX_SPACEDIM is supported. It supports <computeroutput>#if</computeroutput>, <computeroutput>#elif</computeroutput>, <computeroutput>#else</computeroutput>, and <computeroutput>#endif</computeroutput>. The condition must be <computeroutput>AMREX_SPACEDIM op D</computeroutput>, where op is &gt;, &lt;, &gt;=, &lt;=, or ==, and D is 1, 2, or 3. The parentheses around the condition are optional. Some examples are shown below.</para>
<para><programlisting><codeline><highlight class="preprocessor">#if<sp/>(AMREX_SPACEDIM<sp/>==<sp/>1)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">n_cell<sp/>=<sp/>256</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>(AMREX_SPACEDIM<sp/>==<sp/>2)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">n_cell<sp/>=<sp/>128<sp/>128</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">n_cell<sp/>=<sp/>64<sp/>64<sp/>64</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>AMREX_SPACEDIM<sp/>&gt;=<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">t<sp/>=<sp/>0.5</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">t<sp/>=<sp/>1.5</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
</programlisting></para>
<para><ref refid="namespaceamrex_1_1Math" kindref="compound">Math</ref> expression is supported for integers and reals. For example</para>
<para><programlisting><codeline><highlight class="normal">n_cell<sp/>=<sp/>128</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex" kindref="compound">amrex</ref>.n_cell<sp/>=<sp/>n_cell*2<sp/>8<sp/>16**2</highlight></codeline>
</programlisting></para>
<para>becomes</para>
<para><programlisting><codeline><highlight class="normal">n_cell<sp/>=<sp/>128</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex" kindref="compound">amrex</ref>.n_cell<sp/>=<sp/>256<sp/>8<sp/>256</highlight></codeline>
</programlisting></para>
<para>More details can be found at <ulink url="https://amrex-codes.github.io/amrex/docs_html/Basics.html#parmparse">https://amrex-codes.github.io/amrex/docs_html/Basics.html#parmparse</ulink> </para>
    </detaileddescription>
    <collaborationgraph>
      <node id="5">
        <label>K</label>
      </node>
      <node id="6">
        <label>T</label>
      </node>
      <node id="1">
        <label>amrex::ParmParse</label>
        <link refid="classamrex_1_1ParmParse"/>
        <childnode refid="2" relation="usage">
          <edgelabel>FileKeyword</edgelabel>
          <edgelabel>ParserPrefix</edgelabel>
          <edgelabel>m_parser_prefix</edgelabel>
          <edgelabel>m_prefix</edgelabel>
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>m_table</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>std::basic_string&lt; Char &gt;</label>
      </node>
      <node id="2">
        <label>std::string</label>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>std::unordered_map&lt; K, T &gt;</label>
        <childnode refid="5" relation="usage">
          <edgelabel>keys</edgelabel>
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>elements</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="342" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="343" bodyend="1733"/>
    <listofallmembers>
      <member refid="classamrex_1_1ParmParse_1accf1b553a99c0c28b33f80ff4197bfd2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a19241026c4f2654f951404dce86785e3" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a1aee06fbd17916b54603aca28189d95f" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a0dd75517a78caef27f6e62e3aa560511" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a292703c4b4f1b3cba89127ff555319ff" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a22bab90c2879c4cd53c41b0a0a93d75e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1ad651a6c836f3eb3a87e835b436715bbf" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1a80ffd9abf64c20038cb94c45fd7728b7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1ae9d18e04be03cc0b1040a3ec7afe30ca" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>add</name></member>
      <member refid="classamrex_1_1ParmParse_1aa61af07addec9bba0d1f9919e8043180" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a12256efc7af7f26d3cf1436d53f315d5" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a7378ac3ac9f98d9b85e7cdbdf1e16305" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a7ab6d21b45b055e97c50137b0c6e6762" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1af42585578aed7c21b5d72009862dccea" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a5d7d488d3365fc1dc85791e9507b485d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ad924392157f74851f24edb90bde4887a" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a92bf823f92a3e3537f209010df60f2fc" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a3403a33aa6274309f3d1b5313fb28b46" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>addfile</name></member>
      <member refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6aa7f34dde2e3de7cf5daa245b61e9b329" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>ALL</name></member>
      <member refid="classamrex_1_1ParmParse_1a8d400aaa7e8f1e2af9df8c45d1b43efe" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>contains</name></member>
      <member refid="classamrex_1_1ParmParse_1a1050130622c167d73df27f12ebf307c5" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>countname</name></member>
      <member refid="classamrex_1_1ParmParse_1afcacc12ab5b245f14489a5c047b1f730" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>countval</name></member>
      <member refid="classamrex_1_1ParmParse_1ad5376a2e65027c356b38efbef3180c28" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>dumpTable</name></member>
      <member refid="classamrex_1_1ParmParse_1a85725ada8b311feda5f7c55611e7c3ed" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>eval</name></member>
      <member refid="classamrex_1_1ParmParse_1a44318f1c5a43d3c6ef6cd9f0fda99ea2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>FileKeyword</name></member>
      <member refid="classamrex_1_1ParmParse_1a9283fab7556352eeff908ca26cd440be" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Finalize</name></member>
      <member refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a0f0d0333ed203bc31cd4c28900c2d77c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>FIRST</name></member>
      <member refid="classamrex_1_1ParmParse_1af686a981034f742b4c9e0f627ba3d351" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a7f440f432809213d4f053a8deb575df1" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a0289a02c4a54d2e2f2f03ec55cc6a43e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1ac34f5c1c656fbfb184ce2e12c7888cd1" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1af044b2691fd1f2bf4dd2543ac4576f3c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a4a2085f935e1057e6ee555367dafd4a9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a8574c3b0cefc4d2ea10521c75feac45c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a9cd5f7a0b302092e2f9923b3ad72a5b0" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1af59b0808fb917b273cf11ec35f26f8b5" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a8e9f0864d7c1524822dbc8ab967eef70" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a52b882dec70bfeb4ccf32cd859e148f3" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1a2a4c4ffdde1bc4485b03055846709097" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get</name></member>
      <member refid="classamrex_1_1ParmParse_1acd07704e6f093de3dea81e1698c0b55f" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get_enum_case_insensitive</name></member>
      <member refid="classamrex_1_1ParmParse_1a4902948839a7aeaa172befda8263d8d4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>get_enum_sloppy</name></member>
      <member refid="classamrex_1_1ParmParse_1a85d984ee8232a42f83f7ab68e66e54e2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ab1a5af859c35b2e2112a1885ef8064d0" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1aec8ebfd3ccb7ba6f4311fb13a34db1c2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a36339ab36e19da088d3a870913a359a3" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1aa41ab32d62ac10c8973bec8a12442d92" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a41821674f6acfae5bc9780cad1c35469" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a059393b77c51ee63d490808bc643de47" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a0bded2795babf2d74febfb53e05ef757" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a04ec2ceb5b8415b2072265fa6d9c27d1" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a9066a648395fcfb3a2b1e4b035860571" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a32cb19f6ef52cb47e0ae09a526549d56" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ac287be11ef36585608c6b44b5e338595" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarrAsDouble</name></member>
      <member refid="classamrex_1_1ParmParse_1a87d5f90696a72a98a3ee69105da00e82" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1aea0f850513020908727643a151883156" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a8c5cfdb8b319e8d564fcc33fcde77933" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getAsDouble</name></member>
      <member refid="classamrex_1_1ParmParse_1add7b8b32755bc2ffd24623957b797d23" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getEntries</name></member>
      <member refid="classamrex_1_1ParmParse_1a8c4a65bc28d69a4756f3a93bce0440ad" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a7d11cd7b2a3787a0d29766295a51f26b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1ad41c8858115a1978092d6cff46990318" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a3aa9765d6044677fbf5db23237d9dd5f" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1afa087f50096d71cac2f58cb8bd64e29e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1ab8bf5622af52844a95c6d12313cfdc33" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a282cbdeeb3a13fd969174ad763538304" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1a5321c11d55f3a17cf388a9217813f997" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1ac95b8e5422c10df6f8ee5795d09719c3" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getkth</name></member>
      <member refid="classamrex_1_1ParmParse_1ad8ceda3e044b1d05c8e3a93df53997a1" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1aa712f10741a47c1728383536c79ffb39" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a8b35ea9cdf79ed50f1cdc1e2985358bd" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a6117a4cc75d9f335824fe887fddb6dcb" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a7465595467ab1f3789d5a03c5a31ed9c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a23f27ef2b7ca26c3a79ff1682f94508b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1aee763470094d7cb75b8787b3c83757a6" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a5db50d7426da874944b177e8605fa0c4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a827ae94f60d7e44b48dd20980c6adbcd" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getline</name></member>
      <member refid="classamrex_1_1ParmParse_1aa6631c8bb7546e8418283f0f6d35c83d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getPrefix</name></member>
      <member refid="classamrex_1_1ParmParse_1a1b6a1271f30934afb21a3fbac8bb7478" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>gettable</name></member>
      <member refid="classamrex_1_1ParmParse_1aa4c1dbee984103cd1102514d70c954a3" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getUnusedInputs</name></member>
      <member refid="classamrex_1_1ParmParse_1a196eece9b69302a5ed35bd2997a341b9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>getWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a65ec105f3594e14160a631083a1bce59" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>hasUnusedInputs</name></member>
      <member refid="classamrex_1_1ParmParse_1a302162fcd495ffd22ab0ebb8d8f36a05" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Initialize</name></member>
      <member refid="classamrex_1_1ParmParse_1ab480e0eaf8f4c94d2cb5f03a97c55bc5" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Initialize</name></member>
      <member refid="classamrex_1_1ParmParse_1aab7d9931789f57c8612f4b55f457a0c6a42c200ba823b0b1a3c16c437a264ce9e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>LAST</name></member>
      <member refid="classamrex_1_1ParmParse_1ac6d6405babd810179e1e69872b4075fb" prot="protected" virt="non-virtual"><scope>amrex::ParmParse</scope><name>m_parser_prefix</name></member>
      <member refid="classamrex_1_1ParmParse_1a941314412b0921ba802f4620404cf33c" prot="protected" virt="non-virtual"><scope>amrex::ParmParse</scope><name>m_prefix</name></member>
      <member refid="classamrex_1_1ParmParse_1abe4e8f257927686a878e5be81358b213" prot="protected" virt="non-virtual"><scope>amrex::ParmParse</scope><name>m_table</name></member>
      <member refid="classamrex_1_1ParmParse_1afac8d3383aa70acfdd3cd22a8df79539" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>makeIParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a6a0e28c45ee942f30c9f5c50f338e203" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>makeParser</name></member>
      <member refid="classamrex_1_1ParmParse_1aedc024f9fcd3a2e180a860412c3ad745" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>ParmParse</name></member>
      <member refid="classamrex_1_1ParmParse_1a4e18537921b1737edf7819d2a3b51f90" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>ParserPrefix</name></member>
      <member refid="classamrex_1_1ParmParse_1ae89d7f22059ca7008a10790e6d5dda58" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>prefixedName</name></member>
      <member refid="classamrex_1_1ParmParse_1a25e20319d7e653849733bf39d7416437" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>prettyPrintTable</name></member>
      <member refid="classamrex_1_1ParmParse_1ad9c8a23815fd21810e9f736a5ec3de97" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>prettyPrintUnusedInputs</name></member>
      <member refid="classamrex_1_1ParmParse_1a9216f6edda8e16c30796f4929fb28892" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>prettyPrintUsedInputs</name></member>
      <member refid="classamrex_1_1ParmParse_1af14555ab6859c064cc3ca2860cdfa378" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1aa7d4949f92a599b9961a91e8952ce3b4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a8d7b535661101c055ed8cde1a1d996b4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a15d7c0bf32c978043ddc5ecc0fbaf0f2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a051fd8800370be2b60288b16a480471e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a335d1bc50f8341c871f14d84dc237ebe" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a370122e1380da8675490943021ccede1" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1af24517dc524bfd113c17a0f422abae0c" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1ac43c8ed7039f60bbe3bc6b249f390229" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a224c7cde1b6bb68c320910b5bb19c735" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1abbdc989daab71c4cb0101e87c1515689" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a5189f0f4ea7529f029b2fdd0c0a182e0" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query</name></member>
      <member refid="classamrex_1_1ParmParse_1a6fc837f8d0b8fb3ae6a68934f56a90f7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query_enum_case_insensitive</name></member>
      <member refid="classamrex_1_1ParmParse_1af3373b96989f0fe265d166cfcf9c75ea" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>query_enum_sloppy</name></member>
      <member refid="classamrex_1_1ParmParse_1aa4f131652756eb9e07f7791b740f753d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1a6c7a4da859606ed5f5bf2539f82b3d5b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1a13c39d0336c0d16eec7716d5f80103ae" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1a933a4225276737d40bf1234683c57c78" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1ab91ffc0c5afee1e60bd8f62a61862c21" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAdd</name></member>
      <member refid="classamrex_1_1ParmParse_1a97e1b5853258d4859e4b29158d860dd9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAddWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1aaaa34a7e283b84a0c41b9b5fb4d965aa" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a33e783f4854ba243fc9d462c3515e8a4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1aed1fae916d9755266d625a5610fee857" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a24e1680268d7ae9cce52e22f8b7d80a4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ab717febc04288ee14889c70e8c1462a9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a5d0c41e413aa70b842a097291d4740d1" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a7ca579bd16204241bef40ee4943f1601" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ac9ba007b2631e2ac5165934f40d16544" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a0f59b40ef4683f71180918865b6e615b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a261572cfea63f2c1895b081dd583f814" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1ab0fdcb339938512b02973fe3c34242d2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarr</name></member>
      <member refid="classamrex_1_1ParmParse_1a8db338e5ec5063b9f9463eb8a4a56bd9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarrAsDouble</name></member>
      <member refid="classamrex_1_1ParmParse_1abfa0eabbb875722227ffa136c27797cc" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1aaa3e2c26aa2bb7ed5ff42a8eddff57a7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a5d4d9d891cf000a81c8ea848a2a97c3f" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a8e21b3af1df63608cc7b49fb97e3b445" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a666f9ef5b0e17a0a3226168761c708aa" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a44e8c7e4ff321bdade48e6952598c111" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a12b6a9310541c84e79cb64fbe014529e" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryarrWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a8219e1330b9bee958c9f21771654902a" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryAsDouble</name></member>
      <member refid="classamrex_1_1ParmParse_1a9b2661e7df9c4ff236c49a26dc04482f" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1ae461d1e8bf8a631dce729c86eb41e0b2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1aa4cf34bfb7093d32be2e999b9a0e0cc6" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a05d9471e76a7f9345cc0cccc140cca9f" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a6fb336bc0d02911ad1ed347345c31a10" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a980070c222bcc10d8d28d1735770b886" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a28ec93f530c8939d043975da777afe9b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a73f9d1647938fa355524fb7a64721a62" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a1718f31880c498c3ae18595cb7db3e98" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querykth</name></member>
      <member refid="classamrex_1_1ParmParse_1a79fffb6041ec248aeebdaccf3fa5485b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1acbf6fe9e229b326a9740a1d2e4ae64c3" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1ad62fb8d4547521e1084b166b991a66d5" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a1caf3afdec04fbc1df7d7283eae01ba4" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a2b7193727090b11a43d20fa69503768b" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1affe46bb1025380358df8ece603a5ac7d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1aae8abc37eec7cb3d102db7e1620a191a" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1aa7df771a461d593addd85b57e96346f6" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryktharr</name></member>
      <member refid="classamrex_1_1ParmParse_1a0dcd1420b3402a7e7eb769c6dcb87928" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryline</name></member>
      <member refid="classamrex_1_1ParmParse_1a1d8b1d795e0960eba2cdb7feb4a746ab" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querytable</name></member>
      <member refid="classamrex_1_1ParmParse_1a63899edcc14bb7907d12b60bd1774ba9" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querytable</name></member>
      <member refid="classamrex_1_1ParmParse_1ac43a4072f63ba2ec52685fb367c615ea" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>querytable</name></member>
      <member refid="classamrex_1_1ParmParse_1a821d000e2b1d1aa6dc9e18d0b54e0df7" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>QueryUnusedInputs</name></member>
      <member refid="classamrex_1_1ParmParse_1aa3b4ec007f593fef0da494811ced5351" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1afe7de9b31d973a0fad16d1e3f04de71d" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a7cd1c8dbe135d88051244bb278b91cd2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1ae4aae501bd2f9c6d8e09d90165864165" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a9cb1f363db4fe33d9beeab460c021809" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1a88ff5accb455cd990b2bbba806aeaf83" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>queryWithParser</name></member>
      <member refid="classamrex_1_1ParmParse_1aa779227a7006a8408506327917fd16c1" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>remove</name></member>
      <member refid="classamrex_1_1ParmParse_1aa1549749aa28417bed7bb7a9d5a99810" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>SetParserPrefix</name></member>
      <member refid="classamrex_1_1ParmParse_1a50ba1e91e9681699bf5c1a32be2814e6" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>SetVerbose</name></member>
      <member refid="classamrex_1_1ParmParse_1a957fdca08b9590837d67ea30d507f148" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>table</name></member>
      <member refid="classamrex_1_1ParmParse_1af823116cc58b501d9f158fa5635c1498" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Table</name></member>
      <member refid="classamrex_1_1ParmParse_1a4fe2b9e6e5a2c039c7684f364a5c8bb2" prot="public" virt="non-virtual"><scope>amrex::ParmParse</scope><name>Verbose</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
