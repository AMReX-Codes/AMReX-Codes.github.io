<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="namespaceamrex" kind="namespace" language="C++">
    <compoundname>amrex</compoundname>
    <innerclass refid="classamrex_1_1AlgPartition" prot="public">amrex::AlgPartition</innerclass>
    <innerclass refid="classamrex_1_1AlgVector" prot="public">amrex::AlgVector</innerclass>
    <innerclass refid="classamrex_1_1AllPrint" prot="public">amrex::AllPrint</innerclass>
    <innerclass refid="classamrex_1_1AllPrintToFile" prot="public">amrex::AllPrintToFile</innerclass>
    <innerclass refid="classamrex_1_1Amr" prot="public">amrex::Amr</innerclass>
    <innerclass refid="structamrex_1_1AmrAssignGrid" prot="public">amrex::AmrAssignGrid</innerclass>
    <innerclass refid="classamrex_1_1AmrCore" prot="public">amrex::AmrCore</innerclass>
    <innerclass refid="classamrex_1_1AMRErrorTag" prot="public">amrex::AMRErrorTag</innerclass>
    <innerclass refid="structamrex_1_1AMRErrorTagInfo" prot="public">amrex::AMRErrorTagInfo</innerclass>
    <innerclass refid="classamrex_1_1AMReX" prot="public">amrex::AMReX</innerclass>
    <innerclass refid="structamrex_1_1AmrInfo" prot="public">amrex::AmrInfo</innerclass>
    <innerclass refid="classamrex_1_1AmrLevel" prot="public">amrex::AmrLevel</innerclass>
    <innerclass refid="classamrex_1_1AmrMesh" prot="public">amrex::AmrMesh</innerclass>
    <innerclass refid="classamrex_1_1AmrParGDB" prot="public">amrex::AmrParGDB</innerclass>
    <innerclass refid="classamrex_1_1AmrParticleContainer__impl" prot="public">amrex::AmrParticleContainer_impl</innerclass>
    <innerclass refid="classamrex_1_1AmrParticleLocator" prot="public">amrex::AmrParticleLocator</innerclass>
    <innerclass refid="classamrex_1_1AmrTracerParticleContainer" prot="public">amrex::AmrTracerParticleContainer</innerclass>
    <innerclass refid="classamrex_1_1Any" prot="public">amrex::Any</innerclass>
    <innerclass refid="classamrex_1_1Arena" prot="public">amrex::Arena</innerclass>
    <innerclass refid="classamrex_1_1ArenaAllocator" prot="public">amrex::ArenaAllocator</innerclass>
    <innerclass refid="structamrex_1_1ArenaAllocatorBase" prot="public">amrex::ArenaAllocatorBase</innerclass>
    <innerclass refid="structamrex_1_1ArenaInfo" prot="public">amrex::ArenaInfo</innerclass>
    <innerclass refid="structamrex_1_1ArenaWrapper" prot="public">amrex::ArenaWrapper</innerclass>
    <innerclass refid="structamrex_1_1Array1D" prot="public">amrex::Array1D</innerclass>
    <innerclass refid="structamrex_1_1Array2D" prot="public">amrex::Array2D</innerclass>
    <innerclass refid="structamrex_1_1Array3D" prot="public">amrex::Array3D</innerclass>
    <innerclass refid="structamrex_1_1Array4BoxOffsetTag" prot="public">amrex::Array4BoxOffsetTag</innerclass>
    <innerclass refid="structamrex_1_1Array4BoxOrientationTag" prot="public">amrex::Array4BoxOrientationTag</innerclass>
    <innerclass refid="structamrex_1_1Array4BoxTag" prot="public">amrex::Array4BoxTag</innerclass>
    <innerclass refid="structamrex_1_1Array4BoxValTag" prot="public">amrex::Array4BoxValTag</innerclass>
    <innerclass refid="structamrex_1_1Array4CopyTag" prot="public">amrex::Array4CopyTag</innerclass>
    <innerclass refid="structamrex_1_1Array4MaskCopyTag" prot="public">amrex::Array4MaskCopyTag</innerclass>
    <innerclass refid="structamrex_1_1Array4PairTag" prot="public">amrex::Array4PairTag</innerclass>
    <innerclass refid="structamrex_1_1Array4Tag" prot="public">amrex::Array4Tag</innerclass>
    <innerclass refid="structamrex_1_1ArrayND" prot="public">amrex::ArrayND</innerclass>
    <innerclass refid="classamrex_1_1ArrayOfStructs" prot="public">amrex::ArrayOfStructs</innerclass>
    <innerclass refid="structamrex_1_1AssignGrid" prot="public">amrex::AssignGrid</innerclass>
    <innerclass refid="structamrex_1_1AssignGridFilter" prot="public">amrex::AssignGridFilter</innerclass>
    <innerclass refid="classamrex_1_1AsyncArenaAllocator" prot="public">amrex::AsyncArenaAllocator</innerclass>
    <innerclass refid="structamrex_1_1AsyncArenaWrapper" prot="public">amrex::AsyncArenaWrapper</innerclass>
    <innerclass refid="classamrex_1_1AuxBoundaryData" prot="public">amrex::AuxBoundaryData</innerclass>
    <innerclass refid="classamrex_1_1BackgroundThread" prot="public">amrex::BackgroundThread</innerclass>
    <innerclass refid="classamrex_1_1BArena" prot="public">amrex::BArena</innerclass>
    <innerclass refid="classamrex_1_1BaseFab" prot="public">amrex::BaseFab</innerclass>
    <innerclass refid="classamrex_1_1BCRec" prot="public">amrex::BCRec</innerclass>
    <innerclass refid="structamrex_1_1BinIterator" prot="public">amrex::BinIterator</innerclass>
    <innerclass refid="structamrex_1_1BinMapper" prot="public">amrex::BinMapper</innerclass>
    <innerclass refid="structamrex_1_1BLBackTrace" prot="public">amrex::BLBackTrace</innerclass>
    <innerclass refid="classamrex_1_1BLBTer" prot="public">amrex::BLBTer</innerclass>
    <innerclass refid="structamrex_1_1BlockMutex" prot="public">amrex::BlockMutex</innerclass>
    <innerclass refid="classamrex_1_1BLProfiler" prot="public">amrex::BLProfiler</innerclass>
    <innerclass refid="classamrex_1_1BndryDataT" prot="public">amrex::BndryDataT</innerclass>
    <innerclass refid="classamrex_1_1BndryFuncArray" prot="public">amrex::BndryFuncArray</innerclass>
    <innerclass refid="classamrex_1_1BndryRegisterT" prot="public">amrex::BndryRegisterT</innerclass>
    <innerclass refid="classamrex_1_1BoundCond" prot="public">amrex::BoundCond</innerclass>
    <innerclass refid="classamrex_1_1BoxArray" prot="public">amrex::BoxArray</innerclass>
    <innerclass refid="classamrex_1_1BoxConverter" prot="public">amrex::BoxConverter</innerclass>
    <innerclass refid="classamrex_1_1BoxDomain" prot="public">amrex::BoxDomain</innerclass>
    <innerclass refid="structamrex_1_1BoxIndexerND" prot="public">amrex::BoxIndexerND</innerclass>
    <innerclass refid="structamrex_1_1BoxIndexerND_3_011_01_4" prot="public">amrex::BoxIndexerND&lt; 1 &gt;</innerclass>
    <innerclass refid="classamrex_1_1BoxIteratorND" prot="public">amrex::BoxIteratorND</innerclass>
    <innerclass refid="classamrex_1_1BoxList" prot="public">amrex::BoxList</innerclass>
    <innerclass refid="classamrex_1_1BoxND" prot="public">amrex::BoxND</innerclass>
    <innerclass refid="classamrex_1_1CArena" prot="public">amrex::CArena</innerclass>
    <innerclass refid="classamrex_1_1CellBilinear" prot="public">amrex::CellBilinear</innerclass>
    <innerclass refid="classamrex_1_1CellConservativeLinear" prot="public">amrex::CellConservativeLinear</innerclass>
    <innerclass refid="classamrex_1_1CellConservativeProtected" prot="public">amrex::CellConservativeProtected</innerclass>
    <innerclass refid="classamrex_1_1CellConservativeQuartic" prot="public">amrex::CellConservativeQuartic</innerclass>
    <innerclass refid="structamrex_1_1CellData" prot="public">amrex::CellData</innerclass>
    <innerclass refid="structamrex_1_1CellIndexEnum" prot="public">amrex::CellIndexEnum</innerclass>
    <innerclass refid="classamrex_1_1CellQuadratic" prot="public">amrex::CellQuadratic</innerclass>
    <innerclass refid="classamrex_1_1CellQuartic" prot="public">amrex::CellQuartic</innerclass>
    <innerclass refid="classamrex_1_1Cluster" prot="public">amrex::Cluster</innerclass>
    <innerclass refid="classamrex_1_1ClusterList" prot="public">amrex::ClusterList</innerclass>
    <innerclass refid="structamrex_1_1CommRecvBufTag" prot="public">amrex::CommRecvBufTag</innerclass>
    <innerclass refid="structamrex_1_1CommSendBufTag" prot="public">amrex::CommSendBufTag</innerclass>
    <innerclass refid="structamrex_1_1CompileTimeOptions" prot="public">amrex::CompileTimeOptions</innerclass>
    <innerclass refid="structamrex_1_1Conjunction" prot="public">amrex::Conjunction</innerclass>
    <innerclass refid="structamrex_1_1Conjunction_3_01B1_01_4" prot="public">amrex::Conjunction&lt; B1 &gt;</innerclass>
    <innerclass refid="structamrex_1_1Conjunction_3_01B1_00_01Bn_8_8_8_01_4" prot="public">amrex::Conjunction&lt; B1, Bn... &gt;</innerclass>
    <innerclass refid="structamrex_1_1ConstParticleCPUWrapper" prot="public">amrex::ConstParticleCPUWrapper</innerclass>
    <innerclass refid="structamrex_1_1ConstParticleIDWrapper" prot="public">amrex::ConstParticleIDWrapper</innerclass>
    <innerclass refid="structamrex_1_1ConstParticleTileData" prot="public">amrex::ConstParticleTileData</innerclass>
    <innerclass refid="structamrex_1_1ConstSoAParticle" prot="public">amrex::ConstSoAParticle</innerclass>
    <innerclass refid="classamrex_1_1CoordSys" prot="public">amrex::CoordSys</innerclass>
    <innerclass refid="classamrex_1_1CpuBndryFuncFab" prot="public">amrex::CpuBndryFuncFab</innerclass>
    <innerclass refid="classamrex_1_1CutFab" prot="public">amrex::CutFab</innerclass>
    <innerclass refid="structamrex_1_1DataAllocator" prot="public">amrex::DataAllocator</innerclass>
    <innerclass refid="structamrex_1_1DataDeleter" prot="public">amrex::DataDeleter</innerclass>
    <innerclass refid="structamrex_1_1DataLayoutPolicy" prot="public">amrex::DataLayoutPolicy</innerclass>
    <innerclass refid="structamrex_1_1DataLayoutPolicy_3_01ContainerType_00_01ParticleType_3_01Types_8_8_8_01_4_00_01DataLayout_1_1AoS_01_4" prot="public">amrex::DataLayoutPolicy&lt; ContainerType, ParticleType&lt; Types... &gt;, DataLayout::AoS &gt;</innerclass>
    <innerclass refid="structamrex_1_1DataLayoutPolicy_3_01ContainerType_00_01ParticleType_3_01Types_8_8_8_01_4_00_01DataLayout_1_1SoA_01_4" prot="public">amrex::DataLayoutPolicy&lt; ContainerType, ParticleType&lt; Types... &gt;, DataLayout::SoA &gt;</innerclass>
    <innerclass refid="structamrex_1_1DataLayoutPolicyRaw" prot="public">amrex::DataLayoutPolicyRaw</innerclass>
    <innerclass refid="structamrex_1_1DataLayoutPolicyRaw_3_01ParticleType_3_01Types_8_8_8_01_4_00_01DataLayout_1_1AoS_01_4" prot="public">amrex::DataLayoutPolicyRaw&lt; ParticleType&lt; Types... &gt;, DataLayout::AoS &gt;</innerclass>
    <innerclass refid="structamrex_1_1DataLayoutPolicyRaw_3_01ParticleType_3_01Types_8_8_8_01_4_00_01DataLayout_1_1SoA_01_4" prot="public">amrex::DataLayoutPolicyRaw&lt; ParticleType&lt; Types... &gt;, DataLayout::SoA &gt;</innerclass>
    <innerclass refid="structamrex_1_1DefaultAssignor" prot="public">amrex::DefaultAssignor</innerclass>
    <innerclass refid="classamrex_1_1DefaultFabFactory" prot="public">amrex::DefaultFabFactory</innerclass>
    <innerclass refid="structamrex_1_1DefinitelyNotHostRunnable" prot="public">amrex::DefinitelyNotHostRunnable</innerclass>
    <innerclass refid="structamrex_1_1DenseBinIteratorFactory" prot="public">amrex::DenseBinIteratorFactory</innerclass>
    <innerclass refid="classamrex_1_1DenseBins" prot="public">amrex::DenseBins</innerclass>
    <innerclass refid="classamrex_1_1DeriveList" prot="public">amrex::DeriveList</innerclass>
    <innerclass refid="classamrex_1_1DeriveRec" prot="public">amrex::DeriveRec</innerclass>
    <innerclass refid="classamrex_1_1DescriptorList" prot="public">amrex::DescriptorList</innerclass>
    <innerclass refid="structamrex_1_1DestComp" prot="public">amrex::DestComp</innerclass>
    <innerclass refid="classamrex_1_1DeviceArenaAllocator" prot="public">amrex::DeviceArenaAllocator</innerclass>
    <innerclass refid="structamrex_1_1DeviceArenaWrapper" prot="public">amrex::DeviceArenaWrapper</innerclass>
    <innerclass refid="structamrex_1_1Dim3" prot="public">amrex::Dim3</innerclass>
    <innerclass refid="structamrex_1_1Disjunction" prot="public">amrex::Disjunction</innerclass>
    <innerclass refid="structamrex_1_1Disjunction_3_01B1_01_4" prot="public">amrex::Disjunction&lt; B1 &gt;</innerclass>
    <innerclass refid="structamrex_1_1Disjunction_3_01B1_00_01Bn_8_8_8_01_4" prot="public">amrex::Disjunction&lt; B1, Bn... &gt;</innerclass>
    <innerclass refid="classamrex_1_1distFcnElement2d" prot="public">amrex::distFcnElement2d</innerclass>
    <innerclass refid="classamrex_1_1DistributionMapping" prot="public">amrex::DistributionMapping</innerclass>
    <innerclass refid="structamrex_1_1Divides" prot="public">amrex::Divides</innerclass>
    <innerclass refid="structamrex_1_1DynamicTiling" prot="public">amrex::DynamicTiling</innerclass>
    <innerclass refid="classamrex_1_1EBCellConservativeLinear" prot="public">amrex::EBCellConservativeLinear</innerclass>
    <innerclass refid="classamrex_1_1EBCellFlag" prot="public">amrex::EBCellFlag</innerclass>
    <innerclass refid="classamrex_1_1EBCellFlagFab" prot="public">amrex::EBCellFlagFab</innerclass>
    <innerclass refid="structamrex_1_1EBData" prot="public">amrex::EBData</innerclass>
    <innerclass refid="classamrex_1_1EBDataCollection" prot="public">amrex::EBDataCollection</innerclass>
    <innerclass refid="classamrex_1_1EBFArrayBox" prot="public">amrex::EBFArrayBox</innerclass>
    <innerclass refid="classamrex_1_1EBFArrayBoxFactory" prot="public">amrex::EBFArrayBoxFactory</innerclass>
    <innerclass refid="classamrex_1_1EBFluxRegister" prot="public">amrex::EBFluxRegister</innerclass>
    <innerclass refid="classamrex_1_1EBMFCellConsLinInterp" prot="public">amrex::EBMFCellConsLinInterp</innerclass>
    <innerclass refid="classamrex_1_1EBToPVD" prot="public">amrex::EBToPVD</innerclass>
    <innerclass refid="classamrex_1_1EdgeFluxRegister" prot="public">amrex::EdgeFluxRegister</innerclass>
    <innerclass refid="classamrex_1_1ErrorList" prot="public">amrex::ErrorList</innerclass>
    <innerclass refid="classamrex_1_1ErrorRec" prot="public">amrex::ErrorRec</innerclass>
    <innerclass refid="classamrex_1_1expect" prot="public">amrex::expect</innerclass>
    <innerclass refid="classamrex_1_1FabArray" prot="public">amrex::FabArray</innerclass>
    <innerclass refid="classamrex_1_1FabArrayBase" prot="public">amrex::FabArrayBase</innerclass>
    <innerclass refid="classamrex_1_1FabArrayCopyDescriptor" prot="public">amrex::FabArrayCopyDescriptor</innerclass>
    <innerclass refid="classamrex_1_1FabArrayId" prot="public">amrex::FabArrayId</innerclass>
    <innerclass refid="structamrex_1_1FabCopyDescriptor" prot="public">amrex::FabCopyDescriptor</innerclass>
    <innerclass refid="structamrex_1_1FabCopyTag" prot="public">amrex::FabCopyTag</innerclass>
    <innerclass refid="structamrex_1_1FabDataType" prot="public">amrex::FabDataType</innerclass>
    <innerclass refid="structamrex_1_1FabDataType_3_01T_00_01std_1_1enable__if__t_3_01IsMultiFabLike__v_3_01T_01_4_01_4_01_4" prot="public">amrex::FabDataType&lt; T, std::enable_if_t&lt; IsMultiFabLike_v&lt; T &gt; &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1FabDataType_3_01T_00_01std_1_1enable__if__t_3_01IsMultiFabLike__v_3_01typename_01T_1_1value__type_01_4_01_4_01_4" prot="public">amrex::FabDataType&lt; T, std::enable_if_t&lt; IsMultiFabLike_v&lt; typename T::value_type &gt; &gt; &gt;</innerclass>
    <innerclass refid="classamrex_1_1FabFactory" prot="public">amrex::FabFactory</innerclass>
    <innerclass refid="structamrex_1_1FabFillNoOp" prot="public">amrex::FabFillNoOp</innerclass>
    <innerclass refid="structamrex_1_1FabInfo" prot="public">amrex::FabInfo</innerclass>
    <innerclass refid="classamrex_1_1FABio" prot="public">amrex::FABio</innerclass>
    <innerclass refid="classamrex_1_1FABio__8bit" prot="public">amrex::FABio_8bit</innerclass>
    <innerclass refid="classamrex_1_1FABio__ascii" prot="public">amrex::FABio_ascii</innerclass>
    <innerclass refid="classamrex_1_1FABio__binary" prot="public">amrex::FABio_binary</innerclass>
    <innerclass refid="classamrex_1_1FabSetIter" prot="public">amrex::FabSetIter</innerclass>
    <innerclass refid="classamrex_1_1FabSetT" prot="public">amrex::FabSetT</innerclass>
    <innerclass refid="classamrex_1_1FaceConservativeLinear" prot="public">amrex::FaceConservativeLinear</innerclass>
    <innerclass refid="classamrex_1_1FaceDivFree" prot="public">amrex::FaceDivFree</innerclass>
    <innerclass refid="classamrex_1_1FaceLinear" prot="public">amrex::FaceLinear</innerclass>
    <innerclass refid="classamrex_1_1FArrayBox" prot="public">amrex::FArrayBox</innerclass>
    <innerclass refid="structamrex_1_1FatPtr" prot="public">amrex::FatPtr</innerclass>
    <innerclass refid="structamrex_1_1FBData" prot="public">amrex::FBData</innerclass>
    <innerclass refid="classamrex_1_1FEIntegrator" prot="public">amrex::FEIntegrator</innerclass>
    <innerclass refid="classamrex_1_1FillBoxId" prot="public">amrex::FillBoxId</innerclass>
    <innerclass refid="classamrex_1_1FillPatcher" prot="public">amrex::FillPatcher</innerclass>
    <innerclass refid="classamrex_1_1FillPatchIterator" prot="public">amrex::FillPatchIterator</innerclass>
    <innerclass refid="classamrex_1_1FillPatchIteratorHelper" prot="public">amrex::FillPatchIteratorHelper</innerclass>
    <innerclass refid="structamrex_1_1FilterPositiveID" prot="public">amrex::FilterPositiveID</innerclass>
    <innerclass refid="structamrex_1_1FilterVirt" prot="public">amrex::FilterVirt</innerclass>
    <innerclass refid="classamrex_1_1FluxRegister" prot="public">amrex::FluxRegister</innerclass>
    <innerclass refid="classamrex_1_1ForkJoin" prot="public">amrex::ForkJoin</innerclass>
    <innerclass refid="classamrex_1_1FPC" prot="public">amrex::FPC</innerclass>
    <innerclass refid="classamrex_1_1Geometry" prot="public">amrex::Geometry</innerclass>
    <innerclass refid="structamrex_1_1GeometryData" prot="public">amrex::GeometryData</innerclass>
    <innerclass refid="structamrex_1_1GetBucket" prot="public">amrex::GetBucket</innerclass>
    <innerclass refid="structamrex_1_1GetParticleBin" prot="public">amrex::GetParticleBin</innerclass>
    <innerclass refid="structamrex_1_1GetPID" prot="public">amrex::GetPID</innerclass>
    <innerclass refid="structamrex_1_1GetSendBufferOffset" prot="public">amrex::GetSendBufferOffset</innerclass>
    <innerclass refid="classamrex_1_1GMRES" prot="public">amrex::GMRES</innerclass>
    <innerclass refid="classamrex_1_1GMRES__MV" prot="public">amrex::GMRES_MV</innerclass>
    <innerclass refid="classamrex_1_1GMRESMLMGT" prot="public">amrex::GMRESMLMGT</innerclass>
    <innerclass refid="structamrex_1_1GPUable" prot="public">amrex::GPUable</innerclass>
    <innerclass refid="structamrex_1_1GpuArray" prot="public">amrex::GpuArray</innerclass>
    <innerclass refid="classamrex_1_1GpuBndryFuncFab" prot="public">amrex::GpuBndryFuncFab</innerclass>
    <innerclass refid="structamrex_1_1GpuComplex" prot="public">amrex::GpuComplex</innerclass>
    <innerclass refid="classamrex_1_1GpuTuple" prot="public">amrex::GpuTuple</innerclass>
    <innerclass refid="structamrex_1_1GpuTupleElement" prot="public">amrex::GpuTupleElement</innerclass>
    <innerclass refid="structamrex_1_1GpuTupleElement_3_010_00_01GpuTuple_3_01Head_00_01Tail_8_8_8_01_4_01_4" prot="public">amrex::GpuTupleElement&lt; 0, GpuTuple&lt; Head, Tail... &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1GpuTupleElement_3_01I_00_01GpuTuple_3_01Head_00_01Tail_8_8_8_01_4_01_4" prot="public">amrex::GpuTupleElement&lt; I, GpuTuple&lt; Head, Tail... &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1GpuTupleSize" prot="public">amrex::GpuTupleSize</innerclass>
    <innerclass refid="structamrex_1_1GpuTupleSize_3_01GpuTuple_3_01Ts_8_8_8_01_4_01_4" prot="public">amrex::GpuTupleSize&lt; GpuTuple&lt; Ts... &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1HasAtomicAdd" prot="public">amrex::HasAtomicAdd</innerclass>
    <innerclass refid="structamrex_1_1HasAtomicAdd_3_01double_01_4" prot="public">amrex::HasAtomicAdd&lt; double &gt;</innerclass>
    <innerclass refid="structamrex_1_1HasAtomicAdd_3_01float_01_4" prot="public">amrex::HasAtomicAdd&lt; float &gt;</innerclass>
    <innerclass refid="structamrex_1_1HasAtomicAdd_3_01int_01_4" prot="public">amrex::HasAtomicAdd&lt; int &gt;</innerclass>
    <innerclass refid="structamrex_1_1HasAtomicAdd_3_01long_01_4" prot="public">amrex::HasAtomicAdd&lt; long &gt;</innerclass>
    <innerclass refid="structamrex_1_1HasAtomicAdd_3_01unsigned_01int_01_4" prot="public">amrex::HasAtomicAdd&lt; unsigned int &gt;</innerclass>
    <innerclass refid="structamrex_1_1HasAtomicAdd_3_01unsigned_01long_01long_01_4" prot="public">amrex::HasAtomicAdd&lt; unsigned long long &gt;</innerclass>
    <innerclass refid="structamrex_1_1HasMultiComp" prot="public">amrex::HasMultiComp</innerclass>
    <innerclass refid="structamrex_1_1HasMultiComp_3_01B_00_01std_1_1enable__if__t_3_01B_07_08_8size_07_08_01_4_0a1_01_4" prot="public">amrex::HasMultiComp&lt; B, std::enable_if_t&lt; B().size() &gt;=1 &gt;</innerclass>
    <innerclass refid="classamrex_1_1Hypre" prot="public">amrex::Hypre</innerclass>
    <innerclass refid="classamrex_1_1HypreABecLap" prot="public">amrex::HypreABecLap</innerclass>
    <innerclass refid="classamrex_1_1HypreABecLap2" prot="public">amrex::HypreABecLap2</innerclass>
    <innerclass refid="classamrex_1_1HypreABecLap3" prot="public">amrex::HypreABecLap3</innerclass>
    <innerclass refid="classamrex_1_1HypreIJIface" prot="public">amrex::HypreIJIface</innerclass>
    <innerclass refid="classamrex_1_1HypreMLABecLap" prot="public">amrex::HypreMLABecLap</innerclass>
    <innerclass refid="classamrex_1_1HypreNodeLap" prot="public">amrex::HypreNodeLap</innerclass>
    <innerclass refid="classamrex_1_1HypreSolver" prot="public">amrex::HypreSolver</innerclass>
    <innerclass refid="classamrex_1_1IArrayBox" prot="public">amrex::IArrayBox</innerclass>
    <innerclass refid="classamrex_1_1IFABio" prot="public">amrex::IFABio</innerclass>
    <innerclass refid="classamrex_1_1iMultiFab" prot="public">amrex::iMultiFab</innerclass>
    <innerclass refid="classamrex_1_1IndexTypeND" prot="public">amrex::IndexTypeND</innerclass>
    <innerclass refid="classamrex_1_1IntDescriptor" prot="public">amrex::IntDescriptor</innerclass>
    <innerclass refid="classamrex_1_1IntegratorBase" prot="public">amrex::IntegratorBase</innerclass>
    <innerclass refid="structamrex_1_1IntegratorOps" prot="public">amrex::IntegratorOps</innerclass>
    <innerclass refid="structamrex_1_1IntegratorOps_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of__v_3_01amre4a8b722c501826628c0ce0b931e91134" prot="public">amrex::IntegratorOps&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; amrex::ParticleContainerBase, T &gt; &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IntegratorOps_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__same__v_3_01amrex_1_1MultiFab_00_01T_01_4_01_4_01_4" prot="public">amrex::IntegratorOps&lt; T, std::enable_if_t&lt; std::is_same_v&lt; amrex::MultiFab, T &gt; &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IntegratorOps_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__same__v_3_01amrex_1_ad28940895bb617a00768ed755461047" prot="public">amrex::IntegratorOps&lt; T, std::enable_if_t&lt; std::is_same_v&lt; amrex::Vector&lt; amrex::MultiFab &gt;, T &gt; &gt; &gt;</innerclass>
    <innerclass refid="classamrex_1_1InterpBase" prot="public">amrex::InterpBase</innerclass>
    <innerclass refid="classamrex_1_1InterpBndryDataT" prot="public">amrex::InterpBndryDataT</innerclass>
    <innerclass refid="classamrex_1_1InterpFaceRegister" prot="public">amrex::InterpFaceRegister</innerclass>
    <innerclass refid="classamrex_1_1Interpolater" prot="public">amrex::Interpolater</innerclass>
    <innerclass refid="classamrex_1_1InterpolaterBoxCoarsener" prot="public">amrex::InterpolaterBoxCoarsener</innerclass>
    <innerclass refid="classamrex_1_1IntVectND" prot="public">amrex::IntVectND</innerclass>
    <innerclass refid="classamrex_1_1IOFormatSaver" prot="public">amrex::IOFormatSaver</innerclass>
    <innerclass refid="classamrex_1_1IParser" prot="public">amrex::IParser</innerclass>
    <innerclass refid="structamrex_1_1IParserExecutor" prot="public">amrex::IParserExecutor</innerclass>
    <innerclass refid="structamrex_1_1is__soa__particle" prot="public">amrex::is_soa_particle</innerclass>
    <innerclass refid="structamrex_1_1IsAddAssignable" prot="public">amrex::IsAddAssignable</innerclass>
    <innerclass refid="structamrex_1_1IsAddAssignable_3_01T_00_01std_1_1void__t_3_01decltype_07std_1_1declval_3_01T_01_7db52e59378635f71f087c923eca3035" prot="public">amrex::IsAddAssignable&lt; T, std::void_t&lt; decltype(std::declval&lt; T &amp; &gt;()+=std::declval&lt; T &gt;())&gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IsAlgVector" prot="public">amrex::IsAlgVector</innerclass>
    <innerclass refid="structamrex_1_1IsAlgVector_3_01V_00_01std_1_1enable__if__t_3_01std_1_1is__same__v_3_01AlgVector_b40b2816d789aedc6f50e789de689e7c" prot="public">amrex::IsAlgVector&lt; V, std::enable_if_t&lt; std::is_same_v&lt; AlgVector&lt; typename V::value_type, typename V::allocator_type &gt;, V &gt; &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IsArenaAllocator" prot="public">amrex::IsArenaAllocator</innerclass>
    <innerclass refid="structamrex_1_1IsArenaAllocator_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of__v_3_01A3a0553dd1fe92c460e3e2edf71ec41f7" prot="public">amrex::IsArenaAllocator&lt; T, std::enable_if_t&lt; std::is_base_of_v&lt; ArenaAllocatorBase&lt; typename T::value_type, typename T::arena_wrapper_type &gt;, T &gt; &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IsBaseFab" prot="public">amrex::IsBaseFab</innerclass>
    <innerclass refid="structamrex_1_1IsBaseFab_3_01D_00_01std_1_1enable__if__t_3_01std_1_1is__base__of__v_3_01BaseFab_e919207a96f4ea216943219981685bdd" prot="public">amrex::IsBaseFab&lt; D, std::enable_if_t&lt; std::is_base_of_v&lt; BaseFab&lt; typename D::value_type &gt;, D &gt; &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IsCallable" prot="public">amrex::IsCallable</innerclass>
    <innerclass refid="structamrex_1_1IsCallableR" prot="public">amrex::IsCallableR</innerclass>
    <innerclass refid="structamrex_1_1IsConvertible" prot="public">amrex::IsConvertible</innerclass>
    <innerclass refid="structamrex_1_1IsFabArray" prot="public">amrex::IsFabArray</innerclass>
    <innerclass refid="structamrex_1_1IsFabArray_3_01D_00_01std_1_1enable__if__t_3_01std_1_1is__base__of__v_3_01FabArrae7a3c5405f8dbf92bbb678a85384720d" prot="public">amrex::IsFabArray&lt; D, std::enable_if_t&lt; std::is_base_of_v&lt; FabArray&lt; typename D::FABType::value_type &gt;, D &gt; &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IsMultiFabIterator" prot="public">amrex::IsMultiFabIterator</innerclass>
    <innerclass refid="structamrex_1_1IsMultiFabLike" prot="public">amrex::IsMultiFabLike</innerclass>
    <innerclass refid="structamrex_1_1IsMultiFabLike_3_01M_00_01std_1_1enable__if__t_3_01IsFabArray__v_3_01M_01_4_01_6_1b79f12933d87e47a77b2c36839b7d8d" prot="public">amrex::IsMultiFabLike&lt; M, std::enable_if_t&lt; IsFabArray_v&lt; M &gt; &amp;&amp;IsBaseFab_v&lt; typename M::fab_type &gt; &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IsNarrowingConversion" prot="public">amrex::IsNarrowingConversion</innerclass>
    <innerclass refid="structamrex_1_1IsParticleContainer" prot="public">amrex::IsParticleContainer</innerclass>
    <innerclass refid="structamrex_1_1IsParticleIterator" prot="public">amrex::IsParticleIterator</innerclass>
    <innerclass refid="structamrex_1_1IsPolymorphicArenaAllocator" prot="public">amrex::IsPolymorphicArenaAllocator</innerclass>
    <innerclass refid="structamrex_1_1IsPolymorphicArenaAllocator_3_01PolymorphicArenaAllocator_3_01T_01_4_01_4" prot="public">amrex::IsPolymorphicArenaAllocator&lt; PolymorphicArenaAllocator&lt; T &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1IsStoreAtomic" prot="public">amrex::IsStoreAtomic</innerclass>
    <innerclass refid="structamrex_1_1IsStoreAtomic_3_01EBCellFlag_01_4" prot="public">amrex::IsStoreAtomic&lt; EBCellFlag &gt;</innerclass>
    <innerclass refid="classamrex_1_1JacobiSmoother" prot="public">amrex::JacobiSmoother</innerclass>
    <innerclass refid="structamrex_1_1KeepValidFilter" prot="public">amrex::KeepValidFilter</innerclass>
    <innerclass refid="classamrex_1_1LayoutData" prot="public">amrex::LayoutData</innerclass>
    <innerclass refid="classamrex_1_1LevelBld" prot="public">amrex::LevelBld</innerclass>
    <innerclass refid="classamrex_1_1LineDistFcnElement2d" prot="public">amrex::LineDistFcnElement2d</innerclass>
    <innerclass refid="structamrex_1_1LinOpEnumType" prot="public">amrex::LinOpEnumType</innerclass>
    <innerclass refid="structamrex_1_1LogicalAnd" prot="public">amrex::LogicalAnd</innerclass>
    <innerclass refid="structamrex_1_1LogicalOr" prot="public">amrex::LogicalOr</innerclass>
    <innerclass refid="structamrex_1_1LPInfo" prot="public">amrex::LPInfo</innerclass>
    <innerclass refid="classamrex_1_1LUSolver" prot="public">amrex::LUSolver</innerclass>
    <innerclass refid="structamrex_1_1make__particle" prot="public">amrex::make_particle</innerclass>
    <innerclass refid="structamrex_1_1make__particle_3_01T__ParticleType_00_01std_1_1enable__if__t_3_01is__soa__particlc68a74db21db66e00f623afe9a792145" prot="public">amrex::make_particle&lt; T_ParticleType, std::enable_if_t&lt; is_soa_particle&lt; T_ParticleType &gt;::value &gt; &gt;</innerclass>
    <innerclass refid="classamrex_1_1ManagedArenaAllocator" prot="public">amrex::ManagedArenaAllocator</innerclass>
    <innerclass refid="structamrex_1_1ManagedArenaWrapper" prot="public">amrex::ManagedArenaWrapper</innerclass>
    <innerclass refid="classamrex_1_1Mask" prot="public">amrex::Mask</innerclass>
    <innerclass refid="structamrex_1_1Maximum" prot="public">amrex::Maximum</innerclass>
    <innerclass refid="structamrex_1_1MaybeDeviceRunnable" prot="public">amrex::MaybeDeviceRunnable</innerclass>
    <innerclass refid="structamrex_1_1MaybeHostDeviceRunnable" prot="public">amrex::MaybeHostDeviceRunnable</innerclass>
    <innerclass refid="classamrex_1_1MemProfiler" prot="public">amrex::MemProfiler</innerclass>
    <innerclass refid="structamrex_1_1MemStat" prot="public">amrex::MemStat</innerclass>
    <innerclass refid="classamrex_1_1MFCellBilinear" prot="public">amrex::MFCellBilinear</innerclass>
    <innerclass refid="classamrex_1_1MFCellConsLinInterp" prot="public">amrex::MFCellConsLinInterp</innerclass>
    <innerclass refid="classamrex_1_1MFCellConsLinMinmaxLimitInterp" prot="public">amrex::MFCellConsLinMinmaxLimitInterp</innerclass>
    <innerclass refid="structamrex_1_1MFInfo" prot="public">amrex::MFInfo</innerclass>
    <innerclass refid="classamrex_1_1MFInterpolater" prot="public">amrex::MFInterpolater</innerclass>
    <innerclass refid="classamrex_1_1MFIter" prot="public">amrex::MFIter</innerclass>
    <innerclass refid="structamrex_1_1MFItInfo" prot="public">amrex::MFItInfo</innerclass>
    <innerclass refid="classamrex_1_1MFNodeBilinear" prot="public">amrex::MFNodeBilinear</innerclass>
    <innerclass refid="classamrex_1_1MFPCInterp" prot="public">amrex::MFPCInterp</innerclass>
    <innerclass refid="structamrex_1_1Minimum" prot="public">amrex::Minimum</innerclass>
    <innerclass refid="structamrex_1_1Minus" prot="public">amrex::Minus</innerclass>
    <innerclass refid="classamrex_1_1MLABecLaplacianT" prot="public">amrex::MLABecLaplacianT</innerclass>
    <innerclass refid="classamrex_1_1MLALaplacianT" prot="public">amrex::MLALaplacianT</innerclass>
    <innerclass refid="classamrex_1_1MLCellABecLapT" prot="public">amrex::MLCellABecLapT</innerclass>
    <innerclass refid="classamrex_1_1MLCellLinOpT" prot="public">amrex::MLCellLinOpT</innerclass>
    <innerclass refid="classamrex_1_1MLCGSolverT" prot="public">amrex::MLCGSolverT</innerclass>
    <innerclass refid="classamrex_1_1MLCurlCurl" prot="public">amrex::MLCurlCurl</innerclass>
    <innerclass refid="classamrex_1_1MLEBABecLap" prot="public">amrex::MLEBABecLap</innerclass>
    <innerclass refid="classamrex_1_1MLEBNodeFDLaplacian" prot="public">amrex::MLEBNodeFDLaplacian</innerclass>
    <innerclass refid="classamrex_1_1MLEBTensorOp" prot="public">amrex::MLEBTensorOp</innerclass>
    <innerclass refid="classamrex_1_1MLLinOpT" prot="public">amrex::MLLinOpT</innerclass>
    <innerclass refid="structamrex_1_1MLMGABCEBTag" prot="public">amrex::MLMGABCEBTag</innerclass>
    <innerclass refid="classamrex_1_1MLMGBndryT" prot="public">amrex::MLMGBndryT</innerclass>
    <innerclass refid="classamrex_1_1MLMGT" prot="public">amrex::MLMGT</innerclass>
    <innerclass refid="classamrex_1_1MLNodeABecLaplacian" prot="public">amrex::MLNodeABecLaplacian</innerclass>
    <innerclass refid="classamrex_1_1MLNodeLaplacian" prot="public">amrex::MLNodeLaplacian</innerclass>
    <innerclass refid="classamrex_1_1MLNodeLinOp" prot="public">amrex::MLNodeLinOp</innerclass>
    <innerclass refid="classamrex_1_1MLNodeTensorLaplacian" prot="public">amrex::MLNodeTensorLaplacian</innerclass>
    <innerclass refid="classamrex_1_1MLPoissonT" prot="public">amrex::MLPoissonT</innerclass>
    <innerclass refid="classamrex_1_1MLTensorOp" prot="public">amrex::MLTensorOp</innerclass>
    <innerclass refid="structamrex_1_1MultiArray4" prot="public">amrex::MultiArray4</innerclass>
    <innerclass refid="classamrex_1_1MultiCutFab" prot="public">amrex::MultiCutFab</innerclass>
    <innerclass refid="classamrex_1_1MultiFab" prot="public">amrex::MultiFab</innerclass>
    <innerclass refid="classamrex_1_1MultiFabCopyDescriptor" prot="public">amrex::MultiFabCopyDescriptor</innerclass>
    <innerclass refid="classamrex_1_1MultiMask" prot="public">amrex::MultiMask</innerclass>
    <innerclass refid="classamrex_1_1MultiMaskIter" prot="public">amrex::MultiMaskIter</innerclass>
    <innerclass refid="structamrex_1_1Multiplies" prot="public">amrex::Multiplies</innerclass>
    <innerclass refid="structamrex_1_1NeighborCode" prot="public">amrex::NeighborCode</innerclass>
    <innerclass refid="structamrex_1_1NeighborData" prot="public">amrex::NeighborData</innerclass>
    <innerclass refid="classamrex_1_1NeighborList" prot="public">amrex::NeighborList</innerclass>
    <innerclass refid="classamrex_1_1NeighborParticleContainer" prot="public">amrex::NeighborParticleContainer</innerclass>
    <innerclass refid="structamrex_1_1Neighbors" prot="public">amrex::Neighbors</innerclass>
    <innerclass refid="structamrex_1_1NeighborUnpackPolicy" prot="public">amrex::NeighborUnpackPolicy</innerclass>
    <innerclass refid="classamrex_1_1NFilesIter" prot="public">amrex::NFilesIter</innerclass>
    <innerclass refid="classamrex_1_1NodeBilinear" prot="public">amrex::NodeBilinear</innerclass>
    <innerclass refid="structamrex_1_1NullInterpHook" prot="public">amrex::NullInterpHook</innerclass>
    <innerclass refid="structamrex_1_1NumComps" prot="public">amrex::NumComps</innerclass>
    <innerclass refid="classamrex_1_1OpenBCSolver" prot="public">amrex::OpenBCSolver</innerclass>
    <innerclass refid="classamrex_1_1Orientation" prot="public">amrex::Orientation</innerclass>
    <innerclass refid="classamrex_1_1OrientationIter" prot="public">amrex::OrientationIter</innerclass>
    <innerclass refid="classamrex_1_1ParConstIter__impl" prot="public">amrex::ParConstIter_impl</innerclass>
    <innerclass refid="classamrex_1_1PArena" prot="public">amrex::PArena</innerclass>
    <innerclass refid="classamrex_1_1ParGDB" prot="public">amrex::ParGDB</innerclass>
    <innerclass refid="classamrex_1_1ParGDBBase" prot="public">amrex::ParGDBBase</innerclass>
    <innerclass refid="classamrex_1_1ParIter__impl" prot="public">amrex::ParIter_impl</innerclass>
    <innerclass refid="classamrex_1_1ParIterBase__impl" prot="public">amrex::ParIterBase_impl</innerclass>
    <innerclass refid="classamrex_1_1ParmParse" prot="public">amrex::ParmParse</innerclass>
    <innerclass refid="classamrex_1_1Parser" prot="public">amrex::Parser</innerclass>
    <innerclass refid="structamrex_1_1ParserExecutor" prot="public">amrex::ParserExecutor</innerclass>
    <innerclass refid="structamrex_1_1Particle" prot="public">amrex::Particle</innerclass>
    <innerclass refid="structamrex_1_1ParticleArray" prot="public">amrex::ParticleArray</innerclass>
    <innerclass refid="structamrex_1_1ParticleArrayAccessor" prot="public">amrex::ParticleArrayAccessor</innerclass>
    <innerclass refid="structamrex_1_1ParticleBase" prot="public">amrex::ParticleBase</innerclass>
    <innerclass refid="structamrex_1_1ParticleBase_3_01T_00_010_00_010_01_4" prot="public">amrex::ParticleBase&lt; T, 0, 0 &gt;</innerclass>
    <innerclass refid="structamrex_1_1ParticleBase_3_01T_00_010_00_01NInt_01_4" prot="public">amrex::ParticleBase&lt; T, 0, NInt &gt;</innerclass>
    <innerclass refid="structamrex_1_1ParticleBase_3_01T_00_01NReal_00_010_01_4" prot="public">amrex::ParticleBase&lt; T, NReal, 0 &gt;</innerclass>
    <innerclass refid="classamrex_1_1ParticleBufferMap" prot="public">amrex::ParticleBufferMap</innerclass>
    <innerclass refid="structamrex_1_1ParticleCommData" prot="public">amrex::ParticleCommData</innerclass>
    <innerclass refid="classamrex_1_1ParticleContainer__impl" prot="public">amrex::ParticleContainer_impl</innerclass>
    <innerclass refid="classamrex_1_1ParticleContainerBase" prot="public">amrex::ParticleContainerBase</innerclass>
    <innerclass refid="structamrex_1_1ParticleCopyOp" prot="public">amrex::ParticleCopyOp</innerclass>
    <innerclass refid="structamrex_1_1ParticleCopyPlan" prot="public">amrex::ParticleCopyPlan</innerclass>
    <innerclass refid="structamrex_1_1ParticleCPUWrapper" prot="public">amrex::ParticleCPUWrapper</innerclass>
    <innerclass refid="structamrex_1_1ParticleIDWrapper" prot="public">amrex::ParticleIDWrapper</innerclass>
    <innerclass refid="structamrex_1_1ParticleInitType" prot="public">amrex::ParticleInitType</innerclass>
    <innerclass refid="classamrex_1_1ParticleLocator" prot="public">amrex::ParticleLocator</innerclass>
    <innerclass refid="structamrex_1_1ParticleLocData" prot="public">amrex::ParticleLocData</innerclass>
    <innerclass refid="structamrex_1_1ParticleTile" prot="public">amrex::ParticleTile</innerclass>
    <innerclass refid="structamrex_1_1ParticleTileData" prot="public">amrex::ParticleTileData</innerclass>
    <innerclass refid="structamrex_1_1PCData" prot="public">amrex::PCData</innerclass>
    <innerclass refid="classamrex_1_1PCInterp" prot="public">amrex::PCInterp</innerclass>
    <innerclass refid="classamrex_1_1Periodicity" prot="public">amrex::Periodicity</innerclass>
    <innerclass refid="classamrex_1_1PETScABecLap" prot="public">amrex::PETScABecLap</innerclass>
    <innerclass refid="classamrex_1_1PhysBCFunct" prot="public">amrex::PhysBCFunct</innerclass>
    <innerclass refid="classamrex_1_1PhysBCFunctNoOp" prot="public">amrex::PhysBCFunctNoOp</innerclass>
    <innerclass refid="classamrex_1_1PhysBCFunctUseCoarseGhost" prot="public">amrex::PhysBCFunctUseCoarseGhost</innerclass>
    <innerclass refid="classamrex_1_1PinnedArenaAllocator" prot="public">amrex::PinnedArenaAllocator</innerclass>
    <innerclass refid="structamrex_1_1PinnedArenaWrapper" prot="public">amrex::PinnedArenaWrapper</innerclass>
    <innerclass refid="classamrex_1_1PlotFileData" prot="public">amrex::PlotFileData</innerclass>
    <innerclass refid="classamrex_1_1PlotFileDataImpl" prot="public">amrex::PlotFileDataImpl</innerclass>
    <innerclass refid="structamrex_1_1Plus" prot="public">amrex::Plus</innerclass>
    <innerclass refid="classamrex_1_1PODVector" prot="public">amrex::PODVector</innerclass>
    <innerclass refid="classamrex_1_1PolymorphicArenaAllocator" prot="public">amrex::PolymorphicArenaAllocator</innerclass>
    <innerclass refid="structamrex_1_1PolymorphicArenaWrapper" prot="public">amrex::PolymorphicArenaWrapper</innerclass>
    <innerclass refid="structamrex_1_1PolymorphicArray4" prot="public">amrex::PolymorphicArray4</innerclass>
    <innerclass refid="classamrex_1_1Print" prot="public">amrex::Print</innerclass>
    <innerclass refid="classamrex_1_1PrintToFile" prot="public">amrex::PrintToFile</innerclass>
    <innerclass refid="structamrex_1_1RandomEngine" prot="public">amrex::RandomEngine</innerclass>
    <innerclass refid="classamrex_1_1RealBox" prot="public">amrex::RealBox</innerclass>
    <innerclass refid="classamrex_1_1RealDescriptor" prot="public">amrex::RealDescriptor</innerclass>
    <innerclass refid="classamrex_1_1RealVectND" prot="public">amrex::RealVectND</innerclass>
    <innerclass refid="structamrex_1_1RedistributeUnpackPolicy" prot="public">amrex::RedistributeUnpackPolicy</innerclass>
    <innerclass refid="classamrex_1_1ReduceData" prot="public">amrex::ReduceData</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpLogicalAnd" prot="public">amrex::ReduceOpLogicalAnd</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpLogicalOr" prot="public">amrex::ReduceOpLogicalOr</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpMax" prot="public">amrex::ReduceOpMax</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpMin" prot="public">amrex::ReduceOpMin</innerclass>
    <innerclass refid="classamrex_1_1ReduceOps" prot="public">amrex::ReduceOps</innerclass>
    <innerclass refid="structamrex_1_1ReduceOpSum" prot="public">amrex::ReduceOpSum</innerclass>
    <innerclass refid="classamrex_1_1ref__wrapper" prot="public">amrex::ref_wrapper</innerclass>
    <innerclass refid="classamrex_1_1RKIntegrator" prot="public">amrex::RKIntegrator</innerclass>
    <innerclass refid="structamrex_1_1RunOnGpu" prot="public">amrex::RunOnGpu</innerclass>
    <innerclass refid="structamrex_1_1RunOnGpu_3_01ArenaAllocator_3_01T_01_4_01_4" prot="public">amrex::RunOnGpu&lt; ArenaAllocator&lt; T &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1RunOnGpu_3_01AsyncArenaAllocator_3_01T_01_4_01_4" prot="public">amrex::RunOnGpu&lt; AsyncArenaAllocator&lt; T &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1RunOnGpu_3_01DeviceArenaAllocator_3_01T_01_4_01_4" prot="public">amrex::RunOnGpu&lt; DeviceArenaAllocator&lt; T &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1RunOnGpu_3_01ManagedArenaAllocator_3_01T_01_4_01_4" prot="public">amrex::RunOnGpu&lt; ManagedArenaAllocator&lt; T &gt; &gt;</innerclass>
    <innerclass refid="structamrex_1_1Same" prot="public">amrex::Same</innerclass>
    <innerclass refid="structamrex_1_1Same_3_01T_00_01U_01_4" prot="public">amrex::Same&lt; T, U &gt;</innerclass>
    <innerclass refid="classamrex_1_1SArena" prot="public">amrex::SArena</innerclass>
    <innerclass refid="structamrex_1_1SIMDindex" prot="public">amrex::SIMDindex</innerclass>
    <innerclass refid="structamrex_1_1SmallMatrix" prot="public">amrex::SmallMatrix</innerclass>
    <innerclass refid="structamrex_1_1SoAParticle" prot="public">amrex::SoAParticle</innerclass>
    <innerclass refid="structamrex_1_1SoAParticleBase" prot="public">amrex::SoAParticleBase</innerclass>
    <innerclass refid="structamrex_1_1SparseBinIteratorFactory" prot="public">amrex::SparseBinIteratorFactory</innerclass>
    <innerclass refid="classamrex_1_1SparseBins" prot="public">amrex::SparseBins</innerclass>
    <innerclass refid="classamrex_1_1SplineDistFcnElement2d" prot="public">amrex::SplineDistFcnElement2d</innerclass>
    <innerclass refid="classamrex_1_1SpMatrix" prot="public">amrex::SpMatrix</innerclass>
    <innerclass refid="structamrex_1_1SrcComp" prot="public">amrex::SrcComp</innerclass>
    <innerclass refid="structamrex_1_1Stack" prot="public">amrex::Stack</innerclass>
    <innerclass refid="classamrex_1_1StateData" prot="public">amrex::StateData</innerclass>
    <innerclass refid="classamrex_1_1StateDataPhysBCFunct" prot="public">amrex::StateDataPhysBCFunct</innerclass>
    <innerclass refid="classamrex_1_1StateDescriptor" prot="public">amrex::StateDescriptor</innerclass>
    <innerclass refid="classamrex_1_1STLtools" prot="public">amrex::STLtools</innerclass>
    <innerclass refid="classamrex_1_1StreamRetry" prot="public">amrex::StreamRetry</innerclass>
    <innerclass refid="structamrex_1_1StructOfArrays" prot="public">amrex::StructOfArrays</innerclass>
    <innerclass refid="classamrex_1_1SundialsIntegrator" prot="public">amrex::SundialsIntegrator</innerclass>
    <innerclass refid="structamrex_1_1SundialsUserData" prot="public">amrex::SundialsUserData</innerclass>
    <innerclass refid="structamrex_1_1Table1D" prot="public">amrex::Table1D</innerclass>
    <innerclass refid="structamrex_1_1Table2D" prot="public">amrex::Table2D</innerclass>
    <innerclass refid="structamrex_1_1Table3D" prot="public">amrex::Table3D</innerclass>
    <innerclass refid="structamrex_1_1Table4D" prot="public">amrex::Table4D</innerclass>
    <innerclass refid="classamrex_1_1TableData" prot="public">amrex::TableData</innerclass>
    <innerclass refid="classamrex_1_1TagBox" prot="public">amrex::TagBox</innerclass>
    <innerclass refid="classamrex_1_1TagBoxArray" prot="public">amrex::TagBoxArray</innerclass>
    <innerclass refid="structamrex_1_1TagVector" prot="public">amrex::TagVector</innerclass>
    <innerclass refid="structamrex_1_1TheFaArenaDeleter" prot="public">amrex::TheFaArenaDeleter</innerclass>
    <innerclass refid="structamrex_1_1ThisParticleTileHasNoAoS" prot="public">amrex::ThisParticleTileHasNoAoS</innerclass>
    <innerclass refid="structamrex_1_1ThisParticleTileHasNoParticleVector" prot="public">amrex::ThisParticleTileHasNoParticleVector</innerclass>
    <innerclass refid="structamrex_1_1TileSize" prot="public">amrex::TileSize</innerclass>
    <innerclass refid="classamrex_1_1TimeIntegrator" prot="public">amrex::TimeIntegrator</innerclass>
    <innerclass refid="classamrex_1_1TinyProfiler" prot="public">amrex::TinyProfiler</innerclass>
    <innerclass refid="classamrex_1_1TinyProfileRegion" prot="public">amrex::TinyProfileRegion</innerclass>
    <innerclass refid="classamrex_1_1TracerParticleContainer" prot="public">amrex::TracerParticleContainer</innerclass>
    <innerclass refid="structamrex_1_1TransformerGhost" prot="public">amrex::TransformerGhost</innerclass>
    <innerclass refid="structamrex_1_1TransformerVirt" prot="public">amrex::TransformerVirt</innerclass>
    <innerclass refid="structamrex_1_1TypeArray" prot="public">amrex::TypeArray</innerclass>
    <innerclass refid="structamrex_1_1TypeList" prot="public">amrex::TypeList</innerclass>
    <innerclass refid="structamrex_1_1ValLocPair" prot="public">amrex::ValLocPair</innerclass>
    <innerclass refid="classamrex_1_1Vector" prot="public">amrex::Vector</innerclass>
    <innerclass refid="structamrex_1_1VectorTag" prot="public">amrex::VectorTag</innerclass>
    <innerclass refid="classamrex_1_1VisMF" prot="public">amrex::VisMF</innerclass>
    <innerclass refid="classamrex_1_1VisMFBuffer" prot="public">amrex::VisMFBuffer</innerclass>
    <innerclass refid="structamrex_1_1VoidCopyTag" prot="public">amrex::VoidCopyTag</innerclass>
    <innerclass refid="structamrex_1_1XDim3" prot="public">amrex::XDim3</innerclass>
    <innerclass refid="classamrex_1_1YAFluxRegisterT" prot="public">amrex::YAFluxRegisterT</innerclass>
    <innernamespace refid="namespaceamrex_1_1algoim">amrex::algoim</innernamespace>
    <innernamespace refid="namespaceamrex_1_1AsyncOut">amrex::AsyncOut</innernamespace>
    <innernamespace refid="namespaceamrex_1_1BCType">amrex::BCType</innernamespace>
    <innernamespace refid="namespaceamrex_1_1BGColor">amrex::BGColor</innernamespace>
    <innernamespace refid="namespaceamrex_1_1BinPolicy">amrex::BinPolicy</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Cuda">amrex::Cuda</innernamespace>
    <innernamespace refid="namespaceamrex_1_1EB2">amrex::EB2</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Extrapolater">amrex::Extrapolater</innernamespace>
    <innernamespace refid="namespaceamrex_1_1FFT">amrex::FFT</innernamespace>
    <innernamespace refid="namespaceamrex_1_1FGColor">amrex::FGColor</innernamespace>
    <innernamespace refid="namespaceamrex_1_1FileSystem">amrex::FileSystem</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Font">amrex::Font</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Gpu">amrex::Gpu</innernamespace>
    <innernamespace refid="namespaceamrex_1_1HostDevice">amrex::HostDevice</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Lazy">amrex::Lazy</innernamespace>
    <innernamespace refid="namespaceamrex_1_1literals" inline="yes">amrex::literals</innernamespace>
    <innernamespace refid="namespaceamrex_1_1LongParticleIds">amrex::LongParticleIds</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Machine">amrex::Machine</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Math">amrex::Math</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Morton">amrex::Morton</innernamespace>
    <innernamespace refid="namespaceamrex_1_1mpidatatypes">amrex::mpidatatypes</innernamespace>
    <innernamespace refid="namespaceamrex_1_1MPMD">amrex::MPMD</innernamespace>
    <innernamespace refid="namespaceamrex_1_1NonLocalBC">amrex::NonLocalBC</innernamespace>
    <innernamespace refid="namespaceamrex_1_1openbc">amrex::openbc</innernamespace>
    <innernamespace refid="namespaceamrex_1_1OpenMP">amrex::OpenMP</innernamespace>
    <innernamespace refid="namespaceamrex_1_1ParallelAllGather">amrex::ParallelAllGather</innernamespace>
    <innernamespace refid="namespaceamrex_1_1ParallelAllReduce">amrex::ParallelAllReduce</innernamespace>
    <innernamespace refid="namespaceamrex_1_1ParallelContext">amrex::ParallelContext</innernamespace>
    <innernamespace refid="namespaceamrex_1_1ParallelDescriptor">amrex::ParallelDescriptor</innernamespace>
    <innernamespace refid="namespaceamrex_1_1ParallelGather">amrex::ParallelGather</innernamespace>
    <innernamespace refid="namespaceamrex_1_1ParallelReduce">amrex::ParallelReduce</innernamespace>
    <innernamespace refid="namespaceamrex_1_1particle__impl">amrex::particle_impl</innernamespace>
    <innernamespace refid="namespaceamrex_1_1ParticleIdCpus">amrex::ParticleIdCpus</innernamespace>
    <innernamespace refid="namespaceamrex_1_1ParticleInterpolator">amrex::ParticleInterpolator</innernamespace>
    <innernamespace refid="namespaceamrex_1_1PhysBCType">amrex::PhysBCType</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Reduce">amrex::Reduce</innernamespace>
    <innernamespace refid="namespaceamrex_1_1RungeKutta">amrex::RungeKutta</innernamespace>
    <innernamespace refid="namespaceamrex_1_1Scan">amrex::Scan</innernamespace>
    <innernamespace refid="namespaceamrex_1_1simd">amrex::simd</innernamespace>
    <innernamespace refid="namespaceamrex_1_1sundials">amrex::sundials</innernamespace>
    <innernamespace refid="namespaceamrex_1_1SundialsUserFun">amrex::SundialsUserFun</innernamespace>
    <innernamespace refid="namespaceamrex_1_1system">amrex::system</innernamespace>
    <innernamespace refid="namespaceamrex_1_1VectorGrowthStrategy">amrex::VectorGrowthStrategy</innernamespace>
    <sectiondef kind="user-defined">
      <memberdef kind="function" id="namespaceamrex_1_1literals_1a1861634be476a453e55e120446d5f5c3" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        <definition>constexpr Real amrex::literals::operator&quot;&quot;_rt</definition>
        <argsstring>(long double x)</argsstring>
        <name>operator&quot;&quot;_rt</name>
        <qualifiedname>amrex::literals::operator&quot;&quot;_rt</qualifiedname>
        <param>
          <type>long double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>C++ user literals <computeroutput>_rt</computeroutput> &amp; <computeroutput>_prt</computeroutput> for short-hand notations</para>
<para>Use this to properly add types to constant such as <programlisting filename=".C"><codeline><highlight class="normal"><sp/>++</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>mypi<sp/>=<sp/>3.14_rt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>sphere_volume<sp/>=<sp/>4_rt<sp/>/<sp/>3_rt<sp/>*<sp/><ref refid="namespaceamrex_1a2a686d717dfc09897ddca32c75e06300" kindref="member">pow</ref>(r,<sp/>3)<sp/>*<sp/>mypi;</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_REAL.H" line="108" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_REAL.H" bodystart="108" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1literals_1a2d338f06019dd9bb99be91a8b06afd8e" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        <definition>constexpr Real amrex::literals::operator&quot;&quot;_rt</definition>
        <argsstring>(unsigned long long int x)</argsstring>
        <name>operator&quot;&quot;_rt</name>
        <qualifiedname>amrex::literals::operator&quot;&quot;_rt</qualifiedname>
        <param>
          <type>unsigned long long int</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_REAL.H" line="114" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_REAL.H" bodystart="114" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1literals_1afa55b8b85820d2c1306ae0a65fedb680" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr <ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></type>
        <definition>constexpr ParticleReal amrex::literals::operator&quot;&quot;_prt</definition>
        <argsstring>(long double x)</argsstring>
        <name>operator&quot;&quot;_prt</name>
        <qualifiedname>amrex::literals::operator&quot;&quot;_prt</qualifiedname>
        <param>
          <type>long double</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_REAL.H" line="120" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_REAL.H" bodystart="120" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1literals_1aa5ea41090480dfcc8cf4081da0bbe5ef" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr <ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></type>
        <definition>constexpr ParticleReal amrex::literals::operator&quot;&quot;_prt</definition>
        <argsstring>(unsigned long long int x)</argsstring>
        <name>operator&quot;&quot;_prt</name>
        <qualifiedname>amrex::literals::operator&quot;&quot;_prt</qualifiedname>
        <param>
          <type>unsigned long long int</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_REAL.H" line="126" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_REAL.H" bodystart="126" bodyend="129"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="user-defined">
      <header>Arithmetic functions</header>
      <memberdef kind="function" id="namespaceamrex_1afceb776acb796d299ba7597ba55560dc" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::operator/</definition>
        <argsstring>(Real s, const RealVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator/</name>
        <qualifiedname>amrex::operator/</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> that is a <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> <emphasis>p</emphasis> with each component divided by a scalar <emphasis>s</emphasis>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1026" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1026" bodyend="1032"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a972e4551b06a16d8dc398565c6b85f1c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::operator+</definition>
        <argsstring>(Real s, const RealVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> that is a <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> <emphasis>p</emphasis> with a scalar <emphasis>s</emphasis> added to each component. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1040" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1040" bodyend="1046"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad9c1f941f70d6f8a024f24a0b6467733" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::operator-</definition>
        <argsstring>(Real s, const RealVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator-</name>
        <qualifiedname>amrex::operator-</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns <emphasis>s - p</emphasis>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1053" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1053" bodyend="1059"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a19a3806e4a2010a7faf23a93095312ee" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::operator*</definition>
        <argsstring>(Real s, const RealVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>amrex::operator*</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> that is a <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> <emphasis>p</emphasis> with each component multiplied by a scalar <emphasis>s</emphasis>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1067" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1067" bodyend="1073"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae5f4ef74ef823a578443fc28fe0c9ab6" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::operator/</definition>
        <argsstring>(const RealVectND&lt; dim &gt; &amp;s, const RealVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator/</name>
        <qualifiedname>amrex::operator/</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns component-wise quotient <emphasis>p / s</emphasis>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1080" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1080" bodyend="1086"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7cdceeecf5ea37e754e60705d00e1e16" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::operator+</definition>
        <argsstring>(const RealVectND&lt; dim &gt; &amp;s, const RealVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns component-wise sum of RealVectNDs <emphasis>s</emphasis> and <emphasis>p</emphasis>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1093" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1093" bodyend="1099"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abcbc9509415108a20ed902f523428ea4" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::operator-</definition>
        <argsstring>(const RealVectND&lt; dim &gt; &amp;s, const RealVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator-</name>
        <qualifiedname>amrex::operator-</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns <emphasis>s - p</emphasis>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1106" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1106" bodyend="1112"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a539a9142a422899ea4cbfcfb5f61c8ce" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::operator*</definition>
        <argsstring>(const RealVectND&lt; dim &gt; &amp;s, const RealVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>amrex::operator*</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns component-wise product of <emphasis>s</emphasis> and <emphasis>p</emphasis>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1119" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1119" bodyend="1125"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aca11dc3d307957eadf8d380ebf5cc38b" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::scale</definition>
        <argsstring>(const RealVectND&lt; dim &gt; &amp;p, Real s) noexcept</argsstring>
        <name>scale</name>
        <qualifiedname>amrex::scale</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> obtained by multiplying each of the components of the given <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> by a scalar. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1133" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1133" bodyend="1139"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1d825ed0dc6e2e83cdab3fa3c14edbe2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const RealVectND&lt; dim &gt; &amp;p)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1174" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1175" bodyend="1178"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aae45b8b99e4750cebf23c2ba9266aec5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, RealVectND&lt; dim &gt; &amp;p)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1182" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1182" bodyend="1185"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa67a8238696a99cff35b79626ce1bf14" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>d</declname>
            <defname>d</defname>
          </param>
          <param>
            <type>int...</type>
            <declname>dims</declname>
            <defname>dims</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; detail::get_sum&lt; d, dims... &gt;()&gt;</type>
        <definition>__host__ __device__ constexpr RealVectND&lt; detail::get_sum&lt; d, dims... &gt;()&gt; amrex::RealVectCat</definition>
        <argsstring>(const RealVectND&lt; d &gt; &amp;v, const RealVectND&lt; dims &gt; &amp;...vects) noexcept</argsstring>
        <name>RealVectCat</name>
        <qualifiedname>amrex::RealVectCat</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; d &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dims &gt; &amp;...</type>
          <declname>vects</declname>
        </param>
        <briefdescription>
<para>Returns a <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> obtained by concatenating the input RealVectNDs. The dimension of the return value equals the sum of the dimensions of the inputted RealVectNDs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1195" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1195" bodyend="1201"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa586c12919f1f3eed7413fd302e16d40" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>d</declname>
            <defname>d</defname>
          </param>
          <param>
            <type>int...</type>
            <declname>dims</declname>
            <defname>dims</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; d &gt;, <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dims &gt;... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; RealVectND&lt; d &gt;, RealVectND&lt; dims &gt;... &gt; amrex::RealVectSplit</definition>
        <argsstring>(const RealVectND&lt; detail::get_sum&lt; d, dims... &gt;()&gt; &amp;v) noexcept</argsstring>
        <name>RealVectSplit</name>
        <qualifiedname>amrex::RealVectSplit</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; detail::get_sum&lt; d, dims... &gt;()&gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Returns a tuple of <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> obtained by splitting the input <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> according to the dimensions specified by the template arguments. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1211" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1211" bodyend="1216"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae6f05984af2dc312573e7caef773610d" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr RealVectND&lt; new_dim &gt; amrex::RealVectShrink</definition>
        <argsstring>(const RealVectND&lt; old_dim &gt; &amp;iv) noexcept</argsstring>
        <name>RealVectShrink</name>
        <qualifiedname>amrex::RealVectShrink</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>iv</declname>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> of size new_dim and assigns the first new_dim values of iv to it. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1226" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1226" bodyend="1228"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a03347a48d7cb04abafb29ef9dd6e5490" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr RealVectND&lt; new_dim &gt; amrex::RealVectExpand</definition>
        <argsstring>(const RealVectND&lt; old_dim &gt; &amp;iv, Real fill_extra=0) noexcept</argsstring>
        <name>RealVectExpand</name>
        <qualifiedname>amrex::RealVectExpand</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>iv</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>fill_extra</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> of size new_dim and assigns all values of iv to it andfill_extra to the remaining elements. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1238" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1238" bodyend="1240"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa7815aa57d20ba7d7e4ce77467895a20" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr RealVectND&lt; new_dim &gt; amrex::RealVectResize</definition>
        <argsstring>(const RealVectND&lt; old_dim &gt; &amp;iv, Real fill_extra=0) noexcept</argsstring>
        <name>RealVectResize</name>
        <qualifiedname>amrex::RealVectResize</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>iv</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>fill_extra</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> of size new_dim by either shrinking or expanding iv. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1250" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1250" bodyend="1252"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="enum">
      <memberdef kind="enum" id="namespaceamrex_1a2f30e076962c1c148d279b63851d80df" prot="public" static="no" strong="no">
        <type></type>
        <name>InterpEM_t</name>
        <qualifiedname>amrex::InterpEM_t</qualifiedname>
        <enumvalue id="namespaceamrex_1a2f30e076962c1c148d279b63851d80dfaea241117e55edc2764d31a18a4740ff3" prot="public">
          <name>InterpE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a2f30e076962c1c148d279b63851d80dfa9d55599aaee42c677bcd175e50bebbca" prot="public">
          <name>InterpB</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" line="849" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" bodystart="849" bodyend="849"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" prot="public" static="no" strong="yes">
        <type>std::uint8_t</type>
        <name>FPExcept</name>
        <qualifiedname>amrex::FPExcept</qualifiedname>
        <enumvalue id="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2ca334c4a4c42fdb79d7ebc3e73b517e6f8" prot="public">
          <name>none</name>
          <initializer>= 0B0000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2cafedb2d84cafe20862cb4399751a8a7e3" prot="public">
          <name>invalid</name>
          <initializer>= 0B0001</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2cad02c4c4cde7ae76252540d116a40f23a" prot="public">
          <name>zero</name>
          <initializer>= 0B0010</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2ca0bd9f6dd716003f3818d15d2e211ee73" prot="public">
          <name>overflow</name>
          <initializer>= 0B0100</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2caa181a603769c1f98ad927e7367c7aa51" prot="public">
          <name>all</name>
          <initializer>= 0B0111</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="330" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="330" bodyend="336"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1abd2e3d292645433cefc947725585f87a" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>FabType</name>
        <qualifiedname>amrex::FabType</qualifiedname>
        <enumvalue id="namespaceamrex_1abd2e3d292645433cefc947725585f87aaa72ed46ebb1280e51746ce28ded53942" prot="public">
          <name>covered</name>
          <initializer>= -1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1abd2e3d292645433cefc947725585f87aaaf37d08ae228a87dc6b265fd1019c97d" prot="public">
          <name>regular</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1abd2e3d292645433cefc947725585f87aa928c4a180152a4857751871f38d5f9ef" prot="public">
          <name>singlevalued</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1abd2e3d292645433cefc947725585f87aaaf8a062dbd0dba47618be245dc266806" prot="public">
          <name>multivalued</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1abd2e3d292645433cefc947725585f87aa5e543256c480ac577d30f76f9120eb74" prot="public">
          <name>undefined</name>
          <initializer>= 100</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabFactory.H" line="18" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabFactory.H" bodystart="18" bodyend="24"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a9f13be15ca764e94680df68d8b9505d6" prot="public" static="no" strong="no">
        <type></type>
        <name>FillType</name>
        <qualifiedname>amrex::FillType</qualifiedname>
        <enumvalue id="namespaceamrex_1a9f13be15ca764e94680df68d8b9505d6a3de07fb14bde47411225509d67e0bda1" prot="public">
          <name>FillLocally</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9f13be15ca764e94680df68d8b9505d6a8d7828a9196bfb084013996640e84bd4" prot="public">
          <name>FillRemotely</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9f13be15ca764e94680df68d8b9505d6a86e193c43ac00a14b0943baf3433c6d0" prot="public">
          <name>Unfillable</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This enum and the <ref refid="structamrex_1_1FabCopyDescriptor" kindref="compound">FabCopyDescriptor</ref> class should really be nested in <ref refid="classamrex_1_1FabArrayCopyDescriptor" kindref="compound">FabArrayCopyDescriptor</ref> (not done for portability reasons). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FACopyDescriptor.H" line="16" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FACopyDescriptor.H" bodystart="16" bodyend="16"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a33bef6ea796972dbf046ba79277795d2" prot="public" static="no" strong="yes">
        <type></type>
        <name>RunOn</name>
        <qualifiedname>amrex::RunOn</qualifiedname>
        <enumvalue id="namespaceamrex_1a33bef6ea796972dbf046ba79277795d2a3432ca64f06615abf07ab44c10cada38" prot="public">
          <name>Gpu</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a33bef6ea796972dbf046ba79277795d2a54c82ef76ecbbd4c2293e09bae01b54e" prot="public">
          <name>Cpu</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a33bef6ea796972dbf046ba79277795d2ae0ac20adce6ffee48c7151b070aa5737" prot="public">
          <name>Device</name>
          <initializer>=Gpu</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a33bef6ea796972dbf046ba79277795d2ac2ca16d048ec66e04bca283eab048ec2" prot="public">
          <name>Host</name>
          <initializer>=Cpu</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuControl.H" line="69" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuControl.H" bodystart="69" bodyend="69"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a0a36c65d0681a832330b2812f16786a6" prot="public" static="no" strong="no">
        <type></type>
        <name>MakeType</name>
        <qualifiedname>amrex::MakeType</qualifiedname>
        <enumvalue id="namespaceamrex_1a0a36c65d0681a832330b2812f16786a6a1477998364b5f02d6ce68e3da29be1ba" prot="public">
          <name>make_alias</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a0a36c65d0681a832330b2812f16786a6a0a2bb4bcb2051ae3a06f94b5c1768e90" prot="public">
          <name>make_deep_copy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MakeType.H" line="7" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MakeType.H" bodystart="7" bodyend="7"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20" prot="public" static="no" strong="yes">
        <type></type>
        <name>Order</name>
        <qualifiedname>amrex::Order</qualifiedname>
        <enumvalue id="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a0d61f8370cad1d412f80b84d143e1257" prot="public">
          <name>C</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" prot="public">
          <name>F</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20abba47a7c03289a67ca347baa3f55be2f" prot="public">
          <name>RowMajor</name>
          <initializer>=C</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20af695e73139b1c1d06d77655104370f00" prot="public">
          <name>ColumnMajor</name>
          <initializer>=F</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Order.H" line="7" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Order.H" bodystart="7" bodyend="7"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>Direction</name>
        <qualifiedname>amrex::Direction</qualifiedname>
        <enumvalue id="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69a9dd4e461268c8034f5c8564e155c67a6" prot="public">
          <name>x</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69a415290769594460e2e485922904f345d" prot="public">
          <name>y</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69afbade9e36a3f36d3d676c1b808451dd7" prot="public">
          <name>z</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Orientation.H" line="14" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Orientation.H" bodystart="14" bodyend="14"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a65ab2bb30531f06fffb874d874125a5a" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>GrowthStrategy</name>
        <qualifiedname>amrex::GrowthStrategy</qualifiedname>
        <enumvalue id="namespaceamrex_1a65ab2bb30531f06fffb874d874125a5aadff200b0bb8d3c69fbd54cb43664cd7e" prot="public">
          <name>Poisson</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a65ab2bb30531f06fffb874d874125a5aa1649aed298f99d587e2eb30c1db5946b" prot="public">
          <name>Exact</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a65ab2bb30531f06fffb874d874125a5aaadf9f772a73f364e4ce6c52b9fae740d" prot="public">
          <name>Geometric</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PODVector.H" line="250" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PODVector.H" bodystart="250" bodyend="250"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1afa67f210f2e6c338d52553562f72c564" prot="public" static="no" strong="yes">
        <type></type>
        <name>ButcherTableauTypes</name>
        <qualifiedname>amrex::ButcherTableauTypes</qualifiedname>
        <enumvalue id="namespaceamrex_1afa67f210f2e6c338d52553562f72c564a8f9bfe9d1345237cb3b2b205864da075" prot="public">
          <name>User</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1afa67f210f2e6c338d52553562f72c564a779b3131986acb907c287cdaf371d578" prot="public">
          <name>ForwardEuler</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1afa67f210f2e6c338d52553562f72c564a7e7dd435b4cc7ba2b020d5a97856dc80" prot="public">
          <name>Trapezoid</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1afa67f210f2e6c338d52553562f72c564ab65603b0c54c1b7114d61811751ccf42" prot="public">
          <name>SSPRK3</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1afa67f210f2e6c338d52553562f72c564af81fe250c66aad887e2086f79364f2a8" prot="public">
          <name>RK4</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1afa67f210f2e6c338d52553562f72c564a86e30d8e0831512671e7ed103ad7c457" prot="public">
          <name>NumTypes</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RKIntegrator.H" line="11" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RKIntegrator.H" bodystart="11" bodyend="18"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1aad80b9cf2bc799f2905cc9a77e3a599e" prot="public" static="no" strong="yes">
        <type></type>
        <name>IntegratorTypes</name>
        <qualifiedname>amrex::IntegratorTypes</qualifiedname>
        <enumvalue id="namespaceamrex_1aad80b9cf2bc799f2905cc9a77e3a599ea779b3131986acb907c287cdaf371d578" prot="public">
          <name>ForwardEuler</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aad80b9cf2bc799f2905cc9a77e3a599ea0e3b15fe691c25fd194f13af33980845" prot="public">
          <name>ExplicitRungeKutta</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aad80b9cf2bc799f2905cc9a77e3a599eafd3bfec7c5048bfbd7655f7999c26f3d" prot="public">
          <name>Sundials</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TimeIntegrator.H" line="18" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TimeIntegrator.H" bodystart="18" bodyend="22"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>LinOpBCType</name>
        <qualifiedname>amrex::LinOpBCType</qualifiedname>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435ab79de4fb00edbedc3a2e300603b2be38" prot="public">
          <name>interior</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435abac152b762896edff34ed668ae1a546f" prot="public">
          <name>Dirichlet</name>
          <initializer>=  101</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435ab8537a769dbc90cb1762215441212152" prot="public">
          <name>Neumann</name>
          <initializer>=  102</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435a07d6d90bb05e400efe2060e963ae72d3" prot="public">
          <name>reflect_odd</name>
          <initializer>=  103</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435a1f37e0765dcd71fa0903b7a933b079ea" prot="public">
          <name>Marshak</name>
          <initializer>=  104</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435a69d261a097aef0c3275fed19b278eeab" prot="public">
          <name>SanchezPomraning</name>
          <initializer>=  105</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435ad37e67db17cfd059f2852e2673b9e8ef" prot="public">
          <name>inflow</name>
          <initializer>=  106</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435ac8a3f2dafe3d2cac8f54a832d5f3e50d" prot="public">
          <name>inhomogNeumann</name>
          <initializer>=  107</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435a22d5d814d801d8b3e1a1c3fc36796de9" prot="public">
          <name>Robin</name>
          <initializer>=  108</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435a40e712f30d56083318ab20a2402921d2" prot="public">
          <name>symmetry</name>
          <initializer>=  109</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435acdcc32a064503184053bd2018d1c0e7e" prot="public">
          <name>Periodic</name>
          <initializer>=  200</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435a90affbd9a1954ec9ff029b7ad7183a16" prot="public">
          <name>bogus</name>
          <initializer>=  1729</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_LO_BCTYPES.H" line="22" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_LO_BCTYPES.H" bodystart="22" bodyend="35"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>EBData_t</name>
        <qualifiedname>amrex::EBData_t</qualifiedname>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a0aca025084bb6b6cfc5574bee664851e" prot="public">
          <name>levelset</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a11d0adae08a2e6c695a438fb7f060c2d" prot="public">
          <name>volfrac</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a1401e7de3c16108d52d902869a7fb29f" prot="public">
          <name>centroid</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a37d3056e94c1d51b6a008f31df92069b" prot="public">
          <name>bndrycent</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7ab9cc5c5229ab9d2efae2fa4124a079b1" prot="public">
          <name>bndrynorm</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a07d03b0eb123c4f4a66a95320855bef2" prot="public">
          <name>bndryarea</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a91c7961fb393b168237a0a232b5c6f72" prot="public">
          <name>apx</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a179d9a9a68c2cdc936f35ed7657c88cd" prot="public">
          <name>apy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7ade108e19e410b0443c23eeac7dc64fb2" prot="public">
          <name>apz</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a3f604dc3a2da1ffc7be935e3738454a2" prot="public">
          <name>fcx</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7acff05319c59aeaccf13bce08d1b09b85" prot="public">
          <name>fcy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7aba006ba7669bb3b52655be17abaae963" prot="public">
          <name>fcz</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a8a6db67b3d979ffadc6b517b64239b6d" prot="public">
          <name>ecx</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a0c6b816b0ba125b691e3e0e3d0c17794" prot="public">
          <name>ecy</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7a3b5970a45c1023d62a8a7eced57725bc" prot="public">
          <name>ecz</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aea45874f350ec5ab95a6918255ecdba7ae8157b7557ca28ae739dad488092e66f" prot="public">
          <name>cellflag</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBData.H" line="11" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBData.H" bodystart="12" bodyend="23"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a7de82761ed632e5ee0b9f912c856aebc" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>EBSupport</name>
        <qualifiedname>amrex::EBSupport</qualifiedname>
        <enumvalue id="namespaceamrex_1a7de82761ed632e5ee0b9f912c856aebca334c4a4c42fdb79d7ebc3e73b517e6f8" prot="public">
          <name>none</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a7de82761ed632e5ee0b9f912c856aebcaf17aaabc20bfe045075927934fed52d2" prot="public">
          <name>basic</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para><ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref>. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a7de82761ed632e5ee0b9f912c856aebca210ab9e731c9c36c2c38db15c28a8d1c" prot="public">
          <name>volume</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><itemizedlist>
<listitem><para>volume fraction </para>
</listitem></itemizedlist>
</para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a7de82761ed632e5ee0b9f912c856aebcae9dc924f238fa6cc29465942875fe8f0" prot="public">
          <name>full</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><itemizedlist>
<listitem><para>area fraction, boundary centroids and face centroids </para>
</listitem></itemizedlist>
</para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBSupport.H" line="7" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBSupport.H" bodystart="7" bodyend="12"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1aefdd734c936908c2f841c65ee3bd16eb" prot="public" static="no" strong="yes">
        <type></type>
        <name>HypreSolverID</name>
        <qualifiedname>amrex::HypreSolverID</qualifiedname>
        <enumvalue id="namespaceamrex_1aefdd734c936908c2f841c65ee3bd16eba811f4c4b8bd73ca4249517d43fc1bfac" prot="public">
          <name>BoomerAMG</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1aefdd734c936908c2f841c65ee3bd16ebaedb458d93d1aa8663ae63f153d911a81" prot="public">
          <name>SSAMG</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HYPRE/AMReX_HypreMLABecLap.H" line="18" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HYPRE/AMReX_HypreMLABecLap.H" bodystart="18" bodyend="20"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>BottomSolver</name>
        <qualifiedname>amrex::BottomSolver</qualifiedname>
        <enumvalue id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4a7a1920d61156abc05a60135aefe8bc67" prot="public">
          <name>Default</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4aa24fa9dac0801f55f51de06cd8f9d132" prot="public">
          <name>smoother</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4ae123b37d2b5fd373237e049a1e68ca13" prot="public">
          <name>bicgstab</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4a6e9cf3eef65da697796cf33f27eb0f57" prot="public">
          <name>cg</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4a17ae71b06faf01831e130c5f94157064" prot="public">
          <name>bicgcg</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4a8d94447f423b03d332649d28ef49bfdb" prot="public">
          <name>cgbicg</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4a9d87b5177c778e77c47e29f2b536cd1b" prot="public">
          <name>hypre</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4a1c626ad40ecbe4497cfe809fbc98f31f" prot="public">
          <name>petsc</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLLinOp.H" line="31" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLLinOp.H" bodystart="31" bodyend="33"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1ad6568bc5df052e827cc522b2c19fd663" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>MLMGNormType</name>
        <qualifiedname>amrex::MLMGNormType</qualifiedname>
        <enumvalue id="namespaceamrex_1ad6568bc5df052e827cc522b2c19fd663a7b8dc4fb0fb55fc8eb69ff080c45ed7e" prot="public">
          <name>greater</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1ad6568bc5df052e827cc522b2c19fd663a6dd32a6bb73958d819ccc0459816a66f" prot="public">
          <name>bnorm</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1ad6568bc5df052e827cc522b2c19fd663a0966276f0cacce122761e4b56ba1ebb5" prot="public">
          <name>resnorm</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLMG.H" line="12" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLMG.H" bodystart="12" bodyend="12"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceamrex_1a83d03eb75adb29c552bae0a3d625895b" prot="public" static="no" strong="yes">
        <type></type>
        <name>DataLayout</name>
        <qualifiedname>amrex::DataLayout</qualifiedname>
        <enumvalue id="namespaceamrex_1a83d03eb75adb29c552bae0a3d625895ba16b9d7db01fae7828de9941a0736d3d0" prot="public">
          <name>AoS</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceamrex_1a83d03eb75adb29c552bae0a3d625895ba7df366f0036440c84928f057941f8dad" prot="public">
          <name>SoA</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A tag that defines the data layout policy used by particle tiles. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleArray.H" line="19" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleArray.H" bodystart="20" bodyend="23"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespaceamrex_1a6d59c8f105050712012082f8ce92f912" prot="public" static="no">
        <type>void(*)(<ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *data, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int *nvar, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *compdat, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int *ncomp, const int *lo, const int *hi, const int *domain_lo, const int *domain_hi, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *delta, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *xlo, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *time, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *dt, const int *bcrec, const int *level, const int *grid_no)</type>
        <definition>using amrex::DeriveFunc = typedef void (*)(amrex::Real* data, const int&amp;,const int&amp;,const int&amp;, const int&amp;,const int&amp;,const int&amp;, const int* nvar, const amrex::Real* compdat, const int&amp;,const int&amp;,const int&amp;, const int&amp;,const int&amp;,const int&amp;, const int* ncomp, const int* lo, const int* hi, const int* domain_lo, const int* domain_hi, const amrex::Real* delta, const amrex::Real* xlo, const amrex::Real* time, const amrex::Real* dt, const int* bcrec, const int* level, const int* grid_no)</definition>
        <argsstring></argsstring>
        <name>DeriveFunc</name>
        <qualifiedname>amrex::DeriveFunc</qualifiedname>
        <briefdescription>
<para>Type of extern &quot;C&quot; function called by <ref refid="classamrex_1_1DeriveRec" kindref="compound">DeriveRec</ref> to compute derived quantity. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that AMREX_ARLIM_P will be preprocessed into DIM const int&amp;&apos;s.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="AMReX__ArrayLim_8H_1af53c6334de4f960ca760f7ea802e1e98" kindref="member">AMREX_ARLIM_P(dlo)</ref></parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="AMReX__ArrayLim_8H_1af53c6334de4f960ca760f7ea802e1e98" kindref="member">AMREX_ARLIM_P(dhi)</ref></parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nvar</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>compdat</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="AMReX__ArrayLim_8H_1af53c6334de4f960ca760f7ea802e1e98" kindref="member">AMREX_ARLIM_P(compdat_lo)</ref></parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="AMReX__ArrayLim_8H_1af53c6334de4f960ca760f7ea802e1e98" kindref="member">AMREX_ARLIM_P(compdat_hi)</ref></parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>hi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain_lo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain_hi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delta</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xlo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dt</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcrec</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid_no</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Derive.H" line="44" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Derive.H" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a008867a6f88e4144e28dfb6a738f5549" prot="public" static="no">
        <type>void(*)(<ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *data, const int *dlo, const int *dhi, const int *nvar, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *compdat, const int *clo, const int *chi, const int *ncomp, const int *lo, const int *hi, const int *domain_lo, const int *domain_hi, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *delta, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *xlo, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *time, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *dt, const int *bcrec, const int *level, const int *grid_no)</type>
        <definition>using amrex::DeriveFunc3D = typedef void (*)(amrex::Real* data, const int* dlo, const int* dhi, const int* nvar, const amrex::Real* compdat, const int* clo, const int* chi, const int* ncomp, const int* lo, const int* hi, const int* domain_lo, const int* domain_hi, const amrex::Real* delta, const amrex::Real* xlo, const amrex::Real* time, const amrex::Real* dt, const int* bcrec, const int* level, const int* grid_no)</definition>
        <argsstring></argsstring>
        <name>DeriveFunc3D</name>
        <qualifiedname>amrex::DeriveFunc3D</qualifiedname>
        <briefdescription>
<para>This is dimension agnostic. For example, dlo always has three elements. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dlo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dhi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nvar</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>compdat</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>clo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>chi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>hi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain_lo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain_hi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>delta</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xlo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dt</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcrec</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>grid_no</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Derive.H" line="78" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Derive.H" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a7f6a90da175c5d3eb9612d6934849087" prot="public" static="no">
        <type>std::function&lt; void(const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> &amp;bx, <ref refid="classamrex_1_1FArrayBox" kindref="compound">amrex::FArrayBox</ref> &amp;derfab, int dcomp, int ncomp, const <ref refid="classamrex_1_1FArrayBox" kindref="compound">amrex::FArrayBox</ref> &amp;datafab, const <ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> &amp;geomdata, <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> time, const int *bcrec, int level)&gt;</type>
        <definition>using amrex::DeriveFuncFab = typedef std::function&lt;void(const amrex::Box&amp; bx, amrex::FArrayBox&amp; derfab, int dcomp, int ncomp, const amrex::FArrayBox&amp; datafab, const amrex::Geometry&amp; geomdata, amrex::Real time, const int* bcrec, int level)&gt;</definition>
        <argsstring></argsstring>
        <name>DeriveFuncFab</name>
        <qualifiedname>amrex::DeriveFuncFab</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Derive.H" line="88" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Derive.H" bodystart="90" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a2b6a7802e7f7b0f631825a2f669d0093" prot="public" static="no">
        <type>std::function&lt; void(<ref refid="classamrex_1_1MultiFab" kindref="compound">amrex::MultiFab</ref> &amp;der_mf, int dcomp, int ncomp, const <ref refid="classamrex_1_1MultiFab" kindref="compound">amrex::MultiFab</ref> &amp;data_mf, const <ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> &amp;geomdata, <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> time, const int *bcrec, int level)&gt;</type>
        <definition>using amrex::DeriveFuncMF = typedef std::function&lt;void(amrex::MultiFab&amp; der_mf, int dcomp, int ncomp, const amrex::MultiFab&amp; data_mf, const amrex::Geometry&amp; geomdata, amrex::Real time, const int* bcrec, int level)&gt;</definition>
        <argsstring></argsstring>
        <name>DeriveFuncMF</name>
        <qualifiedname>amrex::DeriveFuncMF</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Derive.H" line="92" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Derive.H" bodystart="94" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a33a085eaa4c95d211f6fce74e9440ff9" prot="public" static="no">
        <type>std::function&lt; void(<ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const  &amp;bx, <ref refid="classamrex_1_1FArrayBox" kindref="compound">FArrayBox</ref> &amp;data, int dcomp, int numcomp, <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const  &amp;geom, <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> time, const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;bcr, int bcomp, int scomp)&gt;</type>
        <definition>using amrex::BndryFuncFabDefault = typedef std::function&lt;void(Box const&amp; bx, FArrayBox&amp; data, int dcomp, int numcomp, Geometry const&amp; geom, Real time, const Vector&lt;BCRec&gt;&amp; bcr, int bcomp, int scomp)&gt;</definition>
        <argsstring></argsstring>
        <name>BndryFuncFabDefault</name>
        <qualifiedname>amrex::BndryFuncFabDefault</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_StateDescriptor.H" line="23" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Amr/AMReX_StateDescriptor.H" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a419832e55be898fd5de9051fdf08cb05" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>T_NStructReal</declname>
            <defname>T_NStructReal</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NStructInt</declname>
            <defname>T_NStructInt</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayReal</declname>
            <defname>T_NArrayReal</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayInt</declname>
            <defname>T_NArrayInt</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>template&lt; class &gt; class</type>
            <declname>Allocator</declname>
            <defname>Allocator</defname>
            <defval>DefaultAllocator</defval>
          </param>
          <param>
            <type>class CellAssignor</type>
            <defval>DefaultAssignor</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1AmrParticleContainer__impl" kindref="compound">AmrParticleContainer_impl</ref>&lt; <ref refid="structamrex_1_1Particle" kindref="compound">Particle</ref>&lt; T_NStructReal, T_NStructInt &gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor &gt;</type>
        <definition>using amrex::AmrParticleContainer = typedef AmrParticleContainer_impl&lt;Particle&lt;T_NStructReal, T_NStructInt&gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor&gt;</definition>
        <argsstring></argsstring>
        <name>AmrParticleContainer</name>
        <qualifiedname>amrex::AmrParticleContainer</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_AmrParticles.H" line="295" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_AmrParticles.H" bodystart="295" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a9be6354f5dc96fa5d12c32fc47fcbff1" prot="public" static="no">
        <type>void(*)(int *tag, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int *tagval, const int *clearval, <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *data, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int *lo, const int *hi, const int *nvar, const int *domain_lo, const int *domain_hi, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *dx, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *xlo, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *prob_lo, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *time, const int *level)</type>
        <definition>using amrex::ErrorFuncDefault = typedef void (*)(int* tag, const int&amp;,const int&amp;,const int&amp;, const int&amp;,const int&amp;,const int&amp;, const int* tagval, const int* clearval, amrex::Real* data, const int&amp;,const int&amp;,const int&amp;, const int&amp;,const int&amp;,const int&amp;, const int* lo, const int * hi, const int* nvar, const int* domain_lo, const int* domain_hi, const amrex::Real* dx, const amrex::Real* xlo, const amrex::Real* prob_lo, const amrex::Real* time, const int* level)</definition>
        <argsstring></argsstring>
        <name>ErrorFuncDefault</name>
        <qualifiedname>amrex::ErrorFuncDefault</qualifiedname>
        <briefdescription>
<para>Type of extern &quot;C&quot; function called by <ref refid="classamrex_1_1ErrorRec" kindref="compound">ErrorRec</ref> to do tagging of cells for refinement. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.H" line="26" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.H" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a0a9c33e947d3c4b36eeb8c382d9f66cc" prot="public" static="no">
        <type>void(*)(int *tag, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int *tagval, const int *clearval, <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *data, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int *lo, const int *hi, const int *nvar, const int *domain_lo, const int *domain_hi, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *dx, const int *level, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *avg)</type>
        <definition>using amrex::ErrorFunc2Default = typedef void (*)(int* tag, const int&amp;,const int&amp;,const int&amp;, const int&amp;,const int&amp;,const int&amp;, const int* tagval, const int* clearval, amrex::Real* data, const int&amp;,const int&amp;,const int&amp;, const int&amp;,const int&amp;,const int&amp;, const int* lo, const int * hi, const int* nvar, const int* domain_lo, const int* domain_hi, const amrex::Real* dx, const int* level, const amrex::Real* avg)</definition>
        <argsstring></argsstring>
        <name>ErrorFunc2Default</name>
        <qualifiedname>amrex::ErrorFunc2Default</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.H" line="35" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.H" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1ac3ef56858a7952a309061d5ddef6f86b" prot="public" static="no">
        <type>void(*)(int *tag, const int *tlo, const int *thi, const int *tagval, const int *clearval, <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *data, const int *data_lo, const int *data_hi, const int *lo, const int *hi, const int *nvar, const int *domain_lo, const int *domain_hi, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *dx, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *xlo, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *prob_lo, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> *time, const int *level)</type>
        <definition>using amrex::ErrorFunc3DDefault = typedef void (*)(int* tag, const int* tlo, const int* thi, const int* tagval, const int* clearval, amrex::Real* data, const int* data_lo, const int* data_hi, const int* lo, const int * hi, const int* nvar, const int* domain_lo, const int* domain_hi, const amrex::Real* dx, const amrex::Real* xlo, const amrex::Real* prob_lo, const amrex::Real* time, const int* level)</definition>
        <argsstring></argsstring>
        <name>ErrorFunc3DDefault</name>
        <qualifiedname>amrex::ErrorFunc3DDefault</qualifiedname>
        <briefdescription>
<para>Dimension agnostic version that always has three elements. Note that this is only implemented for the ErrorFunc class, not ErrorFunc2. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tlo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>thi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tagval</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>clearval</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data_lo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data_hi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>hi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nvar</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain_lo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain_hi</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dx</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xlo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prob_lo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.H" line="66" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.H" bodystart="73" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a364202ccae0ac53c5c0d1440b8c06dd2" prot="public" static="no">
        <type>void(*)()</type>
        <definition>using amrex::PTR_TO_VOID_FUNC = typedef void (*)()</definition>
        <argsstring></argsstring>
        <name>PTR_TO_VOID_FUNC</name>
        <qualifiedname>amrex::PTR_TO_VOID_FUNC</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="36" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1af6f45c130cacf67455811e9b4829f432" prot="public" static="no">
        <type>void(*)(const char *)</type>
        <definition>using amrex::ErrorHandler = typedef void (*)(const char*)</definition>
        <argsstring></argsstring>
        <name>ErrorHandler</name>
        <qualifiedname>amrex::ErrorHandler</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="37" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="37" bodyend="-1"/>
      </memberdef>
      <member refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kind="typedef"><name>Array</name></member>
      <memberdef kind="typedef" id="namespaceamrex_1aeb06fab72f85728954130adbe25c5397" prot="public" static="no">
        <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref>, 3 &gt;</type>
        <definition>using amrex::RealArray = typedef Array&lt;Real, 3&gt;</definition>
        <argsstring></argsstring>
        <name>RealArray</name>
        <qualifiedname>amrex::RealArray</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" line="27" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a09e5ad26a3e07988dc74fece187da7b0" prot="public" static="no">
        <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; int, 3 &gt;</type>
        <definition>using amrex::IntArray = typedef Array&lt;int , 3&gt;</definition>
        <argsstring></argsstring>
        <name>IntArray</name>
        <qualifiedname>amrex::IntArray</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" line="28" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" bodystart="28" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structamrex_1_1ArrayND" kindref="compound">ArrayND</ref>&lt; T, 4, true &gt;</type>
        <definition>using amrex::Array4 = typedef ArrayND&lt;T,4, true&gt;</definition>
        <argsstring></argsstring>
        <name>Array4</name>
        <qualifiedname>amrex::Array4</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="777" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" bodystart="777" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" prot="public" static="no">
        <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; 3 &gt;</type>
        <definition>typedef BoxND&lt; 3 &gt; amrex::Box</definition>
        <argsstring></argsstring>
        <name>Box</name>
        <qualifiedname>amrex::Box</qualifiedname>
        <briefdescription>
<para>Box is an alias for <ref refid="classamrex_1_1BoxND" kindref="compound">amrex::BoxND</ref> instantiated with <computeroutput>AMREX_SPACEDIM</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFwd.H" line="30" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFwd.H" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" prot="public" static="no">
        <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; 3 &gt;</type>
        <definition>typedef IntVectND&lt; 3 &gt; amrex::IntVect</definition>
        <argsstring></argsstring>
        <name>IntVect</name>
        <qualifiedname>amrex::IntVect</qualifiedname>
        <briefdescription>
<para>IntVect is an alias for <ref refid="classamrex_1_1IntVectND" kindref="compound">amrex::IntVectND</ref> instantiated with <computeroutput>AMREX_SPACEDIM</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFwd.H" line="33" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFwd.H" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a7e095993c9b3f5a4c2abddd839d800e2" prot="public" static="no">
        <type><ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; 3 &gt;</type>
        <definition>typedef IndexTypeND&lt; 3 &gt; amrex::IndexType</definition>
        <argsstring></argsstring>
        <name>IndexType</name>
        <qualifiedname>amrex::IndexType</qualifiedname>
        <briefdescription>
<para>IndexType is an alias for <ref refid="classamrex_1_1IndexTypeND" kindref="compound">amrex::IndexTypeND</ref> instantiated with <computeroutput>AMREX_SPACEDIM</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFwd.H" line="36" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFwd.H" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a84f6a9f0c716bec64ecbbae55ed83ae7" prot="public" static="no">
        <type><ref refid="structamrex_1_1BoxIndexerND" kindref="compound">BoxIndexerND</ref>&lt; 3 &gt;</type>
        <definition>using amrex::BoxIndexer = typedef BoxIndexerND&lt;3&gt;</definition>
        <argsstring></argsstring>
        <name>BoxIndexer</name>
        <qualifiedname>amrex::BoxIndexer</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2224" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2224" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1af2ed2dc1168064ab4409c918ad0dfce6" prot="public" static="no">
        <type>BATransformer</type>
        <definition>using amrex::BndryBATransformer = typedef BATransformer</definition>
        <argsstring></argsstring>
        <name>BndryBATransformer</name>
        <qualifiedname>amrex::BndryBATransformer</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" line="552" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" bodystart="552" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1ae0e92af73c506a4ab3bf4c4939d613f4" prot="public" static="no">
        <type><ref refid="classamrex_1_1BoxIteratorND" kindref="compound">BoxIteratorND</ref>&lt; 3 &gt;</type>
        <definition>using amrex::BoxIterator = typedef BoxIteratorND&lt;3&gt;</definition>
        <argsstring></argsstring>
        <name>BoxIterator</name>
        <qualifiedname>amrex::BoxIterator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxIterator.H" line="186" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxIterator.H" bodystart="186" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a8ea864a3a9595a340c24658e4bfa24a9" prot="public" static="no">
        <type><ref refid="structamrex_1_1DistributionMapping_1_1Ref" kindref="compound">DistributionMapping::Ref</ref></type>
        <definition>using amrex::DMRef = typedef DistributionMapping::Ref</definition>
        <argsstring></argsstring>
        <name>DMRef</name>
        <qualifiedname>amrex::DMRef</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.H" line="388" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.H" bodystart="388" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1ac3aaf3d47b0fc6e69f9405fcebcdc4fe" prot="public" static="no">
        <type>std::runtime_error</type>
        <definition>using amrex::RuntimeError = typedef std::runtime_error</definition>
        <argsstring></argsstring>
        <name>RuntimeError</name>
        <qualifiedname>amrex::RuntimeError</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Exception.H" line="9" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Exception.H" bodystart="9" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a2081a3d338ad899832ab632c44a12eb5" prot="public" static="no">
        <type>std::unique_ptr&lt; char, <ref refid="structamrex_1_1TheFaArenaDeleter" kindref="compound">TheFaArenaDeleter</ref> &gt;</type>
        <definition>using amrex::TheFaArenaPointer = typedef std::unique_ptr&lt;char, TheFaArenaDeleter&gt;</definition>
        <argsstring></argsstring>
        <name>TheFaArenaPointer</name>
        <qualifiedname>amrex::TheFaArenaPointer</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" line="104" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" bodystart="104" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a4289ef331ecdec2063953232e045534a" prot="public" static="no">
        <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; <ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &gt; &gt;</type>
        <definition>using amrex::cMultiFab = typedef FabArray&lt;BaseFab&lt;GpuComplex&lt;Real&gt; &gt; &gt;</definition>
        <argsstring></argsstring>
        <name>cMultiFab</name>
        <qualifiedname>amrex::cMultiFab</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" line="3995" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" bodystart="3995" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1abda821661019fb0a77eb3a9706dc7330" prot="public" static="no">
        <type><ref refid="classamrex_1_1DefaultFabFactory" kindref="compound">DefaultFabFactory</ref>&lt; <ref refid="classamrex_1_1FArrayBox" kindref="compound">FArrayBox</ref> &gt;</type>
        <definition>using amrex::FArrayBoxFactory = typedef DefaultFabFactory&lt;FArrayBox&gt;</definition>
        <argsstring></argsstring>
        <name>FArrayBoxFactory</name>
        <qualifiedname>amrex::FArrayBoxFactory</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FArrayBox.H" line="460" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FArrayBox.H" bodystart="460" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a179fafc569924202b166896b608cd5c2" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ArenaAllocator" kindref="compound">amrex::ArenaAllocator</ref>&lt; T &gt;</type>
        <definition>using amrex::DefaultAllocator = typedef amrex::ArenaAllocator&lt;T&gt;</definition>
        <argsstring></argsstring>
        <name>DefaultAllocator</name>
        <qualifiedname>amrex::DefaultAllocator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuAllocators.H" line="193" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuAllocators.H" bodystart="193" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a3e08759747455ff96c8f68e8673c2b19" prot="public" static="no">
        <type>cudaStream_t</type>
        <definition>using amrex::gpuStream_t = typedef cudaStream_t</definition>
        <argsstring></argsstring>
        <name>gpuStream_t</name>
        <qualifiedname>amrex::gpuStream_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuControl.H" line="83" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuControl.H" bodystart="83" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a2235406f46755fe4275db8b042b0da92" prot="public" static="no">
        <type>cudaDeviceProp</type>
        <definition>using amrex::gpuDeviceProp_t = typedef cudaDeviceProp</definition>
        <argsstring></argsstring>
        <name>gpuDeviceProp_t</name>
        <qualifiedname>amrex::gpuDeviceProp_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuDevice.H" line="28" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuDevice.H" bodystart="28" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a98a85f350a96eb36272d756d5a9c9a05" prot="public" static="no">
        <type>cudaError_t</type>
        <definition>using amrex::gpuError_t = typedef cudaError_t</definition>
        <argsstring></argsstring>
        <name>gpuError_t</name>
        <qualifiedname>amrex::gpuError_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuError.H" line="33" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuError.H" bodystart="33" bodyend="-1"/>
      </memberdef>
      <member refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kind="typedef"><name>Long</name></member>
      <member refid="group__amrex__arithmetic__types_1ga0ef9da92db8cd88b857393b3b7b611b7" kind="typedef"><name>ULong</name></member>
      <memberdef kind="typedef" id="namespaceamrex_1a55427a27e71c45e7066414b0accf4a9b" prot="public" static="no">
        <type><ref refid="classamrex_1_1FabArrayId" kindref="compound">FabArrayId</ref></type>
        <definition>using amrex::MultiFabId = typedef FabArrayId</definition>
        <argsstring></argsstring>
        <name>MultiFabId</name>
        <qualifiedname>amrex::MultiFabId</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFCopyDescriptor.H" line="13" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFCopyDescriptor.H" bodystart="13" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a1df3d6c5876d88132d2b3793984a6b7d" prot="public" static="no">
        <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; <ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; float &gt; &gt;</type>
        <definition>using amrex::fMultiFab = typedef FabArray&lt;BaseFab&lt;float&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>fMultiFab</name>
        <qualifiedname>amrex::fMultiFab</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFab.H" line="19" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFab.H" bodystart="19" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a9a66cb310efdbc12b9b4d5f170470726" prot="public" static="no">
        <type><ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; 3 &gt;</type>
        <definition>typedef RealVectND&lt; 3 &gt; amrex::RealVect</definition>
        <argsstring></argsstring>
        <name>RealVect</name>
        <qualifiedname>amrex::RealVect</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" line="35" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParmParse.H" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a26ea5196cb8a6a557d58495a7628207f" prot="public" static="no">
        <type>void(*)(<ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *data, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int &amp;, const int *dom_lo, const int *dom_hi, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *dx, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *grd_lo, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *time, const int *bc)</type>
        <definition>using amrex::BndryFuncDefault = typedef void (*)(Real* data, const int&amp;,const int&amp;,const int&amp;, const int&amp;,const int&amp;,const int&amp;, const int* dom_lo, const int* dom_hi, const Real* dx, const Real* grd_lo, const Real* time, const int* bc)</definition>
        <argsstring></argsstring>
        <name>BndryFuncDefault</name>
        <qualifiedname>amrex::BndryFuncDefault</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PhysBCFunct.H" line="18" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PhysBCFunct.H" bodystart="21" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a5e4a902f699c144a9823d30d6dbb7236" prot="public" static="no">
        <type>void(*)(<ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *data, const int *lo, const int *hi, const int *dom_lo, const int *dom_hi, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *dx, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *grd_lo, const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *time, const int *bc)</type>
        <definition>using amrex::BndryFunc3DDefault = typedef void (*)(Real* data, const int* lo, const int* hi, const int* dom_lo, const int* dom_hi, const Real* dx, const Real* grd_lo, const Real* time, const int* bc)</definition>
        <argsstring></argsstring>
        <name>BndryFunc3DDefault</name>
        <qualifiedname>amrex::BndryFunc3DDefault</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PhysBCFunct.H" line="22" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PhysBCFunct.H" bodystart="25" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a88781af4a5d3f8271de2b3129cc49393" prot="public" static="no">
        <type>void(*)(<ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const  &amp;bx, <ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const  &amp;dest, int dcomp, int numcomp, <ref refid="structamrex_1_1GeometryData" kindref="compound">GeometryData</ref> const  &amp;geom, <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> time, const <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> *bcr, int bcomp, int orig_comp)</type>
        <definition>using amrex::UserFillBox = typedef void (*)(Box const&amp; bx, Array4&lt;Real&gt; const&amp; dest, int dcomp, int numcomp, GeometryData const&amp; geom, Real time, const BCRec* bcr, int bcomp, int orig_comp)</definition>
        <argsstring></argsstring>
        <name>UserFillBox</name>
        <qualifiedname>amrex::UserFillBox</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PhysBCFunct.H" line="28" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PhysBCFunct.H" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1abbea0a87a768d8f4e8112b9cd673b124" prot="public" static="no">
        <type>curandState_t</type>
        <definition>using amrex::randState_t = typedef curandState_t</definition>
        <argsstring></argsstring>
        <name>randState_t</name>
        <qualifiedname>amrex::randState_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" line="58" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a72a585c8e383e98aab94c9141a27659a" prot="public" static="no">
        <type>curandGenerator_t</type>
        <definition>using amrex::randGenerator_t = typedef curandGenerator_t</definition>
        <argsstring></argsstring>
        <name>randGenerator_t</name>
        <qualifiedname>amrex::randGenerator_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" line="59" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" bodystart="59" bodyend="-1"/>
      </memberdef>
      <member refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kind="typedef"><name>Real</name></member>
      <member refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kind="typedef"><name>ParticleReal</name></member>
      <memberdef kind="typedef" id="namespaceamrex_1a997083e14ba3ff7ccab3146deb043490" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>int</type>
            <declname>StartIndex</declname>
            <defname>StartIndex</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="structamrex_1_1SmallMatrix" kindref="compound">SmallMatrix</ref>&lt; T, N, 1, <ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">Order::F</ref>, StartIndex &gt;</type>
        <definition>using amrex::SmallVector = typedef SmallMatrix&lt;T,N,1,Order::F,StartIndex&gt;</definition>
        <argsstring></argsstring>
        <name>SmallVector</name>
        <qualifiedname>amrex::SmallVector</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SmallMatrix.H" line="463" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SmallMatrix.H" bodystart="463" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a4d64676e39ab3e5cdb4c87722ee01001" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>int</type>
            <declname>StartIndex</declname>
            <defname>StartIndex</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="structamrex_1_1SmallMatrix" kindref="compound">SmallMatrix</ref>&lt; T, 1, N, <ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">Order::F</ref>, StartIndex &gt;</type>
        <definition>using amrex::SmallRowVector = typedef SmallMatrix&lt;T,1,N,Order::F,StartIndex&gt;</definition>
        <argsstring></argsstring>
        <name>SmallRowVector</name>
        <qualifiedname>amrex::SmallRowVector</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SmallMatrix.H" line="466" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SmallMatrix.H" bodystart="466" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a00604a127d1bcc6545bea88e8aa906c8" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>std::tuple&lt; Ts... &gt;</type>
        <definition>using amrex::Tuple = typedef std::tuple&lt;Ts...&gt;</definition>
        <argsstring></argsstring>
        <name>Tuple</name>
        <qualifiedname>amrex::Tuple</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="18" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a11fcc5e72789252d6182a7d15233725f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename detail::TypeListGet&lt; I, T &gt;::type</type>
        <definition>using amrex::TypeAt = typedef typename detail::TypeListGet&lt;I,T&gt;::type</definition>
        <argsstring></argsstring>
        <name>TypeAt</name>
        <qualifiedname>amrex::TypeAt</qualifiedname>
        <briefdescription>
<para>Type at position I of a <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" line="34" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1ad9a6d3e0ecd435bde5a280d288b185dc" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>TParam</declname>
            <defname>TParam</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Types</declname>
            <defname>Types</defname>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1a11fcc5e72789252d6182a7d15233725f" kindref="member">TypeAt</ref>&lt; 0, decltype(detail::TApply&lt; TParam &gt;((<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt;&gt;{}+...+detail::SingleTypeMultiplier(std::declval&lt; Types &gt;()))))&gt;</type>
        <definition>using amrex::TypeMultiplier = typedef TypeAt&lt;0, decltype(detail::TApply&lt;TParam&gt;( (TypeList&lt;&gt;{} + ... + detail::SingleTypeMultiplier(std::declval&lt;Types&gt;())) ))&gt;</definition>
        <argsstring></argsstring>
        <name>TypeMultiplier</name>
        <qualifiedname>amrex::TypeMultiplier</qualifiedname>
        <briefdescription>
<para>Return the first template argument with the later arguments applied to it. Types of the form T[N] are expanded to T, T, T, T, ... (N times with N &gt;= 1). Types of the form TypeArray&lt;T,N&gt; are expanded to T, T, T, T, ... (N times with N &gt;= 0). </para>
        </briefdescription>
        <detaileddescription>
<para>For example, TypeMultiplier&lt;ReduceData, Real[4], int[2], Long&gt; is an alias to the type ReduceData&lt;Real, Real, Real, Real, int, int, Long&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" line="218" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" bodystart="220" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1ae456dccc30b99d38aeeecd21adc7acfe" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>B</declname>
            <defname>B</defname>
          </param>
          <param>
            <type>class T</type>
            <defval>void</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; B, T &gt;</type>
        <definition>using amrex::EnableIf_t = typedef std::enable_if_t&lt;B,T&gt;</definition>
        <argsstring></argsstring>
        <name>EnableIf_t</name>
        <qualifiedname>amrex::EnableIf_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="53" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1af199566bf00a390cb47c2a0140b3fc67" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>typename detail::Detector&lt; detail::Nonesuch, void, Op, Args... &gt;::value_t</type>
        <definition>using amrex::IsDetected = typedef typename detail::Detector&lt;detail::Nonesuch, void, Op, Args...&gt;::value_t</definition>
        <argsstring></argsstring>
        <name>IsDetected</name>
        <qualifiedname>amrex::IsDetected</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="182" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="182" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a4c98b791b1f6442671e5cfa546a3df4f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>typename detail::Detector&lt; detail::Nonesuch, void, Op, Args... &gt;::type</type>
        <definition>using amrex::Detected_t = typedef typename detail::Detector&lt;detail::Nonesuch, void, Op, Args...&gt;::type</definition>
        <argsstring></argsstring>
        <name>Detected_t</name>
        <qualifiedname>amrex::Detected_t</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="185" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="185" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1abe72f840d81a1ce49a3811fe8295b222" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class Default</type>
          </param>
          <param>
            <type>template&lt; class... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>typename detail::Detector&lt; <ref refid="namespaceamrex_1a9303c93b47b7839de8ce552cb7cb21c4a7a1920d61156abc05a60135aefe8bc67" kindref="member">Default</ref>, void, Op, Args... &gt;::type</type>
        <definition>using amrex::DetectedOr = typedef typename detail::Detector&lt;Default, void, Op, Args...&gt;::type</definition>
        <argsstring></argsstring>
        <name>DetectedOr</name>
        <qualifiedname>amrex::DetectedOr</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="188" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="188" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1afcea7cdc6e03361f56c401b56d66a870" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class Expected</type>
          </param>
          <param>
            <type>template&lt; typename... &gt; class</type>
            <declname>Op</declname>
            <defname>Op</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>std::is_same&lt; Expected, <ref refid="namespaceamrex_1a4c98b791b1f6442671e5cfa546a3df4f" kindref="member">Detected_t</ref>&lt; Op, Args... &gt; &gt;</type>
        <definition>using amrex::IsDetectedExact = typedef std::is_same&lt;Expected, Detected_t&lt;Op, Args...&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>IsDetectedExact</name>
        <qualifiedname>amrex::IsDetectedExact</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="191" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="191" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a3d7af06ef9ce2e0a696e5c73f3e460aa" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class B</type>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !bool(B::value)&gt;</type>
        <definition>using amrex::Negation = typedef std::integral_constant&lt;bool, !bool(B::value)&gt;</definition>
        <argsstring></argsstring>
        <name>Negation</name>
        <qualifiedname>amrex::Negation</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="250" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="250" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a3e90f0304ff639b230b6b502e8546b88" prot="public" static="no">
        <type>std::conditional_t&lt; std::chrono::high_resolution_clock::is_steady, std::chrono::high_resolution_clock, std::chrono::steady_clock &gt;</type>
        <definition>using amrex::MaxResSteadyClock = typedef std::conditional_t&lt;std::chrono::high_resolution_clock::is_steady, std::chrono::high_resolution_clock, std::chrono::steady_clock&gt;</definition>
        <argsstring></argsstring>
        <name>MaxResSteadyClock</name>
        <qualifiedname>amrex::MaxResSteadyClock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="218" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="220" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a7dd6d3577db87cc950337b856e57f1f9" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename K</type>
          </param>
          <param>
            <type>typename V</type>
          </param>
        </templateparamlist>
        <type><ref refid="structamrex_1_1ValLocPair" kindref="compound">ValLocPair</ref>&lt; K, V &gt;</type>
        <definition>using amrex::KeyValuePair = typedef ValLocPair&lt;K,V&gt;</definition>
        <argsstring></argsstring>
        <name>KeyValuePair</name>
        <qualifiedname>amrex::KeyValuePair</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ValLocPair.H" line="38" column="15" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ValLocPair.H" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a9f6fb58eb396dd06df45ba7787548b32" prot="public" static="no">
        <type><ref refid="classamrex_1_1BndryDataT" kindref="compound">BndryDataT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::BndryData = typedef BndryDataT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>BndryData</name>
        <qualifiedname>amrex::BndryData</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_BndryData.H" line="304" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_BndryData.H" bodystart="304" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a24fbf2d04e7dac268f7f5cb3af96064e" prot="public" static="no">
        <type><ref refid="classamrex_1_1BndryDataT" kindref="compound">BndryDataT</ref>&lt; <ref refid="namespaceamrex_1a1df3d6c5876d88132d2b3793984a6b7d" kindref="member">fMultiFab</ref> &gt;</type>
        <definition>using amrex::fBndryData = typedef BndryDataT&lt;fMultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>fBndryData</name>
        <qualifiedname>amrex::fBndryData</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_BndryData.H" line="305" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_BndryData.H" bodystart="305" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a51a3951b54ca3db6bf891ebc2f867168" prot="public" static="no">
        <type><ref refid="classamrex_1_1BndryRegisterT" kindref="compound">BndryRegisterT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::BndryRegister = typedef BndryRegisterT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>BndryRegister</name>
        <qualifiedname>amrex::BndryRegister</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_BndryRegister.H" line="359" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_BndryRegister.H" bodystart="359" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1abe0f5b82795df17e723853b7c1b8ee7d" prot="public" static="no">
        <type><ref refid="classamrex_1_1BndryRegisterT" kindref="compound">BndryRegisterT</ref>&lt; <ref refid="namespaceamrex_1a1df3d6c5876d88132d2b3793984a6b7d" kindref="member">fMultiFab</ref> &gt;</type>
        <definition>using amrex::fBndryRegister = typedef BndryRegisterT&lt;fMultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>fBndryRegister</name>
        <qualifiedname>amrex::fBndryRegister</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_BndryRegister.H" line="360" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_BndryRegister.H" bodystart="360" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a15203068a5d8d4de2f3ff93e5e0f21d2" prot="public" static="no">
        <type><ref refid="classamrex_1_1FabSetT" kindref="compound">FabSetT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::FabSet = typedef FabSetT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>FabSet</name>
        <qualifiedname>amrex::FabSet</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_FabSet.H" line="410" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_FabSet.H" bodystart="410" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a25f205ddb2e9488505c2db83a92a5434" prot="public" static="no">
        <type><ref refid="classamrex_1_1FabSetT" kindref="compound">FabSetT</ref>&lt; <ref refid="namespaceamrex_1a1df3d6c5876d88132d2b3793984a6b7d" kindref="member">fMultiFab</ref> &gt;</type>
        <definition>using amrex::fFabSet = typedef FabSetT&lt;fMultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>fFabSet</name>
        <qualifiedname>amrex::fFabSet</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_FabSet.H" line="411" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_FabSet.H" bodystart="411" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a3d926e5fad46a5fd2da4b495b16f449d" prot="public" static="no">
        <type><ref refid="classamrex_1_1InterpBndryDataT" kindref="compound">InterpBndryDataT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::InterpBndryData = typedef InterpBndryDataT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>InterpBndryData</name>
        <qualifiedname>amrex::InterpBndryData</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_InterpBndryData.H" line="279" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_InterpBndryData.H" bodystart="279" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a56136e9147b36f3e7fcdf12c22760b58" prot="public" static="no">
        <type><ref refid="classamrex_1_1InterpBndryDataT" kindref="compound">InterpBndryDataT</ref>&lt; <ref refid="namespaceamrex_1a1df3d6c5876d88132d2b3793984a6b7d" kindref="member">fMultiFab</ref> &gt;</type>
        <definition>using amrex::fInterpBndryData = typedef InterpBndryDataT&lt;fMultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>fInterpBndryData</name>
        <qualifiedname>amrex::fInterpBndryData</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_InterpBndryData.H" line="280" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_InterpBndryData.H" bodystart="280" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a9418cfdd8457daebb1c971d4e38ceb17" prot="public" static="no">
        <type><ref refid="classamrex_1_1YAFluxRegisterT" kindref="compound">YAFluxRegisterT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::YAFluxRegister = typedef YAFluxRegisterT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>YAFluxRegister</name>
        <qualifiedname>amrex::YAFluxRegister</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_YAFluxRegister.H" line="580" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_YAFluxRegister.H" bodystart="580" bodyend="-1"/>
      </memberdef>
      <member refid="group__amrex__solver__gmres_1ga9fb859eb850cc164b1a83c9e4c7d53bb" kind="typedef"><name>GMRESMLMG</name></member>
      <member refid="group__amrex__solver__mlmg_1gaa9c032480d2659c266fb23d70800f6a5" kind="typedef"><name>MLABecLaplacian</name></member>
      <memberdef kind="typedef" id="namespaceamrex_1afd71b3eea629ca099ace90909350cc56" prot="public" static="no">
        <type><ref refid="classamrex_1_1MLALaplacianT" kindref="compound">MLALaplacianT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::MLALaplacian = typedef MLALaplacianT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>MLALaplacian</name>
        <qualifiedname>amrex::MLALaplacian</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLALaplacian.H" line="785" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLALaplacian.H" bodystart="785" bodyend="-1"/>
      </memberdef>
      <member refid="group__amrex__solver__mlmg_1ga2116fd8f117dd8ebb01e6a3b99c7947e" kind="typedef"><name>MLCellABecLap</name></member>
      <memberdef kind="typedef" id="namespaceamrex_1a6d2f435b4a824073e4ba2c714ff4770b" prot="public" static="no">
        <type><ref refid="classamrex_1_1MLCellLinOpT" kindref="compound">MLCellLinOpT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::MLCellLinOp = typedef MLCellLinOpT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>MLCellLinOp</name>
        <qualifiedname>amrex::MLCellLinOp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLCellLinOp.H" line="2236" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLCellLinOp.H" bodystart="2236" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1adc786fadc751afd641a3d05650467dfc" prot="public" static="no">
        <type><ref refid="classamrex_1_1MLCGSolverT" kindref="compound">MLCGSolverT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::MLCGSolver = typedef MLCGSolverT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>MLCGSolver</name>
        <qualifiedname>amrex::MLCGSolver</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLCGSolver.H" line="458" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLCGSolver.H" bodystart="458" bodyend="-1"/>
      </memberdef>
      <member refid="group__amrex__solver__mlmg_1ga6cfa07a78393bb456aa7d33ced04fb46" kind="typedef"><name>MLLinOp</name></member>
      <member refid="group__amrex__solver__mlmg_1ga77b48f471801c4f6a597804a89c3b543" kind="typedef"><name>MLMG</name></member>
      <memberdef kind="typedef" id="namespaceamrex_1a9214b7c07d9c296122f7418f73f798e9" prot="public" static="no">
        <type><ref refid="classamrex_1_1MLMGBndryT" kindref="compound">MLMGBndryT</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>using amrex::MLMGBndry = typedef MLMGBndryT&lt;MultiFab&gt;</definition>
        <argsstring></argsstring>
        <name>MLMGBndry</name>
        <qualifiedname>amrex::MLMGBndry</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLMGBndry.H" line="155" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLMGBndry.H" bodystart="155" bodyend="-1"/>
      </memberdef>
      <member refid="group__amrex__solver__mlmg_1ga339ac1b3381df4095a659ec2b7980cb3" kind="typedef"><name>MLPoisson</name></member>
      <member refid="group__amrex__particles_1ga7c419a2c3aef781f1415b7ebd1f138d0" kind="typedef"><name>ParticleContainer</name></member>
      <memberdef kind="typedef" id="namespaceamrex_1af211cc4c070c468f71e69fcdfaf4d1fa" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>is_const</declname>
            <defname>is_const</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NStructReal</declname>
            <defname>T_NStructReal</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NStructInt</declname>
            <defname>T_NStructInt</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayReal</declname>
            <defname>T_NArrayReal</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayInt</declname>
            <defname>T_NArrayInt</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>template&lt; class &gt; class</type>
            <declname>Allocator</declname>
            <defname>Allocator</defname>
            <defval>DefaultAllocator</defval>
          </param>
          <param>
            <type>class CellAssignor</type>
            <defval>DefaultAssignor</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ParIterBase__impl" kindref="compound">ParIterBase_impl</ref>&lt; is_const, <ref refid="structamrex_1_1Particle" kindref="compound">Particle</ref>&lt; T_NStructReal, T_NStructInt &gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor &gt;</type>
        <definition>using amrex::ParIterBase = typedef ParIterBase_impl&lt;is_const, Particle&lt;T_NStructReal, T_NStructInt&gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor&gt;</definition>
        <argsstring></argsstring>
        <name>ParIterBase</name>
        <qualifiedname>amrex::ParIterBase</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" line="216" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" bodystart="216" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1ac7120a52b1bfafe08e9d660d5c79f463" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>is_const</declname>
            <defname>is_const</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayReal</declname>
            <defname>T_NArrayReal</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayInt</declname>
            <defname>T_NArrayInt</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>template&lt; class &gt; class</type>
            <declname>Allocator</declname>
            <defname>Allocator</defname>
            <defval>DefaultAllocator</defval>
          </param>
          <param>
            <type>class CellAssignor</type>
            <defval>DefaultAssignor</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ParIterBase__impl" kindref="compound">ParIterBase_impl</ref>&lt; is_const, <ref refid="structamrex_1_1SoAParticle" kindref="compound">SoAParticle</ref>&lt; T_NArrayReal, T_NArrayInt &gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor &gt;</type>
        <definition>using amrex::ParIterBaseSoA = typedef ParIterBase_impl&lt;is_const,SoAParticle&lt;T_NArrayReal, T_NArrayInt&gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor&gt;</definition>
        <argsstring></argsstring>
        <name>ParIterBaseSoA</name>
        <qualifiedname>amrex::ParIterBaseSoA</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" line="220" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" bodystart="220" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a82b15f07c651f6c100348c6891b9d412" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>T_NStructReal</declname>
            <defname>T_NStructReal</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NStructInt</declname>
            <defname>T_NStructInt</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayReal</declname>
            <defname>T_NArrayReal</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayInt</declname>
            <defname>T_NArrayInt</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>template&lt; class &gt; class</type>
            <declname>Allocator</declname>
            <defname>Allocator</defname>
            <defval>DefaultAllocator</defval>
          </param>
          <param>
            <type>class CellAssignor</type>
            <defval>DefaultAssignor</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ParConstIter__impl" kindref="compound">ParConstIter_impl</ref>&lt; <ref refid="structamrex_1_1Particle" kindref="compound">Particle</ref>&lt; T_NStructReal, T_NStructInt &gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor &gt;</type>
        <definition>using amrex::ParConstIter = typedef ParConstIter_impl&lt;Particle&lt;T_NStructReal, T_NStructInt&gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor&gt;</definition>
        <argsstring></argsstring>
        <name>ParConstIter</name>
        <qualifiedname>amrex::ParConstIter</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" line="224" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" bodystart="224" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a3ee82e3bc9bfc0a2b726fa65240f7342" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>T_NArrayReal</declname>
            <defname>T_NArrayReal</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayInt</declname>
            <defname>T_NArrayInt</defname>
          </param>
          <param>
            <type>template&lt; class &gt; class</type>
            <declname>Allocator</declname>
            <defname>Allocator</defname>
            <defval>DefaultAllocator</defval>
          </param>
          <param>
            <type>class CellAssignor</type>
            <defval>DefaultAssignor</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ParConstIter__impl" kindref="compound">ParConstIter_impl</ref>&lt; <ref refid="structamrex_1_1SoAParticle" kindref="compound">SoAParticle</ref>&lt; T_NArrayReal, T_NArrayInt &gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor &gt;</type>
        <definition>using amrex::ParConstIterSoA = typedef ParConstIter_impl&lt;SoAParticle&lt;T_NArrayReal, T_NArrayInt&gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor&gt;</definition>
        <argsstring></argsstring>
        <name>ParConstIterSoA</name>
        <qualifiedname>amrex::ParConstIterSoA</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" line="227" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" bodystart="227" bodyend="-1"/>
      </memberdef>
      <member refid="group__amrex__particles_1ga2b24a534dc7f3adbd4e23acd6a71e154" kind="typedef"><name>ParIter</name></member>
      <memberdef kind="typedef" id="namespaceamrex_1a295f27dc56adb58daf37c77bc6f22d49" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>T_NArrayReal</declname>
            <defname>T_NArrayReal</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayInt</declname>
            <defname>T_NArrayInt</defname>
          </param>
          <param>
            <type>template&lt; class &gt; class</type>
            <declname>Allocator</declname>
            <defname>Allocator</defname>
            <defval>DefaultAllocator</defval>
          </param>
          <param>
            <type>class CellAssignor</type>
            <defval>DefaultAssignor</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ParIter__impl" kindref="compound">ParIter_impl</ref>&lt; <ref refid="structamrex_1_1SoAParticle" kindref="compound">SoAParticle</ref>&lt; T_NArrayReal, T_NArrayInt &gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor &gt;</type>
        <definition>using amrex::ParIterSoA = typedef ParIter_impl&lt;SoAParticle&lt;T_NArrayReal, T_NArrayInt&gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor&gt;</definition>
        <argsstring></argsstring>
        <name>ParIterSoA</name>
        <qualifiedname>amrex::ParIterSoA</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" line="235" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParIter.H" bodystart="235" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1adf16cda543680572b2d60a5518b7fb55" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>T_NArrayReal</declname>
            <defname>T_NArrayReal</defname>
          </param>
          <param>
            <type>int</type>
            <declname>T_NArrayInt</declname>
            <defname>T_NArrayInt</defname>
          </param>
          <param>
            <type>template&lt; class &gt; class</type>
            <declname>Allocator</declname>
            <defname>Allocator</defname>
            <defval>DefaultAllocator</defval>
          </param>
          <param>
            <type>class CellAssignor</type>
            <defval>DefaultAssignor</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ParticleContainer__impl" kindref="compound">ParticleContainer_impl</ref>&lt; <ref refid="structamrex_1_1SoAParticle" kindref="compound">SoAParticle</ref>&lt; T_NArrayReal, T_NArrayInt &gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor &gt;</type>
        <definition>using amrex::ParticleContainerPureSoA = typedef ParticleContainer_impl&lt;SoAParticle&lt;T_NArrayReal, T_NArrayInt&gt;, T_NArrayReal, T_NArrayInt, Allocator, CellAssignor&gt;</definition>
        <argsstring></argsstring>
        <name>ParticleContainerPureSoA</name>
        <qualifiedname>amrex::ParticleContainerPureSoA</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleContainer.H" line="1558" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleContainer.H" bodystart="1558" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1a9a10bcdea714489a34f5d28bc127c936" prot="public" static="no">
        <type><ref refid="group__amrex__particles_1ga2b24a534dc7f3adbd4e23acd6a71e154" kindref="member">ParIter</ref>&lt; 3 &gt;</type>
        <definition>using amrex::TracerParIter = typedef ParIter&lt;3&gt;</definition>
        <argsstring></argsstring>
        <name>TracerParIter</name>
        <qualifiedname>amrex::TracerParIter</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_TracerParticles.H" line="41" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_TracerParticles.H" bodystart="41" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespaceamrex_1afdf427459e2b9a7718975c38a36d8be2" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        <definition>constexpr Real amrex::INVALID_TIME</definition>
        <argsstring></argsstring>
        <name>INVALID_TIME</name>
        <qualifiedname>amrex::INVALID_TIME</qualifiedname>
        <initializer>= -1.0e200_rt</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_StateData.cpp" line="21" column="23" bodyfile="/home/runner/work/amrex/amrex/Src/Amr/AMReX_StateData.cpp" bodystart="21" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a77d7d152de71abe1856e19ee2122a24a" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>constexpr int</type>
        <definition>constexpr int amrex::MFNEWDATA</definition>
        <argsstring></argsstring>
        <name>MFNEWDATA</name>
        <qualifiedname>amrex::MFNEWDATA</qualifiedname>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_StateData.cpp" line="24" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Amr/AMReX_StateData.cpp" bodystart="24" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a22e5d2b124fbc2a101b2538d589e2899" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>constexpr int</type>
        <definition>constexpr int amrex::MFOLDDATA</definition>
        <argsstring></argsstring>
        <name>MFOLDDATA</name>
        <qualifiedname>amrex::MFOLDDATA</qualifiedname>
        <initializer>= 1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_StateData.cpp" line="25" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Amr/AMReX_StateData.cpp" bodystart="25" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1add23b3df81e9353cea327552654d630b" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1PCInterp" kindref="compound">PCInterp</ref></type>
        <definition>PCInterp amrex::pc_interp</definition>
        <argsstring></argsstring>
        <name>pc_interp</name>
        <qualifiedname>amrex::pc_interp</qualifiedname>
        <briefdescription>
<para>CONSTRUCT A GLOBAL OBJECT OF EACH VERSION. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="35" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="35" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="921" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a7655c2dbeff4b92d06ddf5d3f964e7b2" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1NodeBilinear" kindref="compound">NodeBilinear</ref></type>
        <definition>NodeBilinear amrex::node_bilinear_interp</definition>
        <argsstring></argsstring>
        <name>node_bilinear_interp</name>
        <qualifiedname>amrex::node_bilinear_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="36" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="36" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="922" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1af6271bbc97d9b2c15eb418a6e4024c76" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1FaceLinear" kindref="compound">FaceLinear</ref></type>
        <definition>FaceLinear amrex::face_linear_interp</definition>
        <argsstring></argsstring>
        <name>face_linear_interp</name>
        <qualifiedname>amrex::face_linear_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="37" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="37" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="924" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a5b91add54f85d8fe2a7b2c5113dbb461" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1FaceConservativeLinear" kindref="compound">FaceConservativeLinear</ref></type>
        <definition>FaceConservativeLinear amrex::face_cons_linear_interp</definition>
        <argsstring></argsstring>
        <name>face_cons_linear_interp</name>
        <qualifiedname>amrex::face_cons_linear_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="38" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="38" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="925" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a56316d7d561f65317664a3c83ab30efc" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1FaceDivFree" kindref="compound">FaceDivFree</ref></type>
        <definition>FaceDivFree amrex::face_divfree_interp</definition>
        <argsstring></argsstring>
        <name>face_divfree_interp</name>
        <qualifiedname>amrex::face_divfree_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="39" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="39" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="923" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1acdf3882926f66513ad7885b4cd468233" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1CellConservativeLinear" kindref="compound">CellConservativeLinear</ref></type>
        <definition>CellConservativeLinear amrex::lincc_interp</definition>
        <argsstring></argsstring>
        <name>lincc_interp</name>
        <qualifiedname>amrex::lincc_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="40" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="40" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="926" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a62c1aa7b301883dd9dead098a4ad933f" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1CellConservativeLinear" kindref="compound">CellConservativeLinear</ref></type>
        <definition>CellConservativeLinear amrex::cell_cons_interp</definition>
        <argsstring>(false)</argsstring>
        <name>cell_cons_interp</name>
        <qualifiedname>amrex::cell_cons_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="41" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" bodystart="927" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="927" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1aec5e350e7334dcbe6776eb60a1b77160" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1CellConservativeProtected" kindref="compound">CellConservativeProtected</ref></type>
        <definition>CellConservativeProtected amrex::protected_interp</definition>
        <argsstring></argsstring>
        <name>protected_interp</name>
        <qualifiedname>amrex::protected_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="42" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="42" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="929" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a2a5decb8ebeab1e499c7c66e78a0eb07" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1CellConservativeQuartic" kindref="compound">CellConservativeQuartic</ref></type>
        <definition>CellConservativeQuartic amrex::quartic_interp</definition>
        <argsstring></argsstring>
        <name>quartic_interp</name>
        <qualifiedname>amrex::quartic_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="43" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="43" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="930" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a5fa0044ab8f93865e1fc48bb78a6e5e8" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1CellBilinear" kindref="compound">CellBilinear</ref></type>
        <definition>CellBilinear amrex::cell_bilinear_interp</definition>
        <argsstring></argsstring>
        <name>cell_bilinear_interp</name>
        <qualifiedname>amrex::cell_bilinear_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="44" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="44" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="928" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1ad21d1e8d053cd312ae67d9bd79b598ac" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1CellQuadratic" kindref="compound">CellQuadratic</ref></type>
        <definition>CellQuadratic amrex::quadratic_interp</definition>
        <argsstring></argsstring>
        <name>quadratic_interp</name>
        <qualifiedname>amrex::quadratic_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="45" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="45" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="931" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a1278f3e834d5a42fbc946a82b45f53a2" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1CellQuartic" kindref="compound">CellQuartic</ref></type>
        <definition>CellQuartic amrex::cell_quartic_interp</definition>
        <argsstring></argsstring>
        <name>cell_quartic_interp</name>
        <qualifiedname>amrex::cell_quartic_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" line="46" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.cpp" bodystart="46" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_Interpolater.H" declline="932" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1aa9f1e8cdd602c47cbb2404151c0c7da9" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1MFPCInterp" kindref="compound">MFPCInterp</ref></type>
        <definition>MFPCInterp amrex::mf_pc_interp</definition>
        <argsstring></argsstring>
        <name>mf_pc_interp</name>
        <qualifiedname>amrex::mf_pc_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" line="10" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" bodystart="10" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.H" declline="123" declcolumn="31"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1ac4bf821ec9173cd447eb853deb9a015b" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1MFCellConsLinInterp" kindref="compound">MFCellConsLinInterp</ref></type>
        <definition>MFCellConsLinInterp amrex::mf_cell_cons_interp</definition>
        <argsstring>(false)</argsstring>
        <name>mf_cell_cons_interp</name>
        <qualifiedname>amrex::mf_cell_cons_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" line="11" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.H" bodystart="124" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.H" declline="124" declcolumn="31"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a111a2176d26d2d8f7b25edc036ef84fb" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1MFCellConsLinInterp" kindref="compound">MFCellConsLinInterp</ref></type>
        <definition>MFCellConsLinInterp amrex::mf_lincc_interp</definition>
        <argsstring>(true)</argsstring>
        <name>mf_lincc_interp</name>
        <qualifiedname>amrex::mf_lincc_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" line="12" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.H" bodystart="125" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.H" declline="125" declcolumn="31"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a72a8847518322c389f8af37d7b9b20e5" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1MFCellConsLinMinmaxLimitInterp" kindref="compound">MFCellConsLinMinmaxLimitInterp</ref></type>
        <definition>MFCellConsLinMinmaxLimitInterp amrex::mf_linear_slope_minmax_interp</definition>
        <argsstring></argsstring>
        <name>mf_linear_slope_minmax_interp</name>
        <qualifiedname>amrex::mf_linear_slope_minmax_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" line="13" column="32" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" bodystart="13" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.H" declline="126" declcolumn="42"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1ac264469b0f79dbe9e54d068825d6b10c" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1MFCellBilinear" kindref="compound">MFCellBilinear</ref></type>
        <definition>MFCellBilinear amrex::mf_cell_bilinear_interp</definition>
        <argsstring></argsstring>
        <name>mf_cell_bilinear_interp</name>
        <qualifiedname>amrex::mf_cell_bilinear_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" line="14" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" bodystart="14" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.H" declline="127" declcolumn="31"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a07c05999fda899bbfc802ac73e64e8a3" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1MFNodeBilinear" kindref="compound">MFNodeBilinear</ref></type>
        <definition>MFNodeBilinear amrex::mf_node_bilinear_interp</definition>
        <argsstring></argsstring>
        <name>mf_node_bilinear_interp</name>
        <qualifiedname>amrex::mf_node_bilinear_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" line="17" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.cpp" bodystart="17" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_MFInterpolater.H" declline="128" declcolumn="31"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a3b30dfb18fc4a2ff698adce0b7216359" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr char</type>
        <definition>constexpr char amrex::ResetDisplay[]</definition>
        <argsstring>[]</argsstring>
        <name>ResetDisplay</name>
        <qualifiedname>amrex::ResetDisplay</qualifiedname>
        <initializer>= &quot;\033[0m&quot;</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ANSIEscCode.H" line="8" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ANSIEscCode.H" bodystart="8" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1abac42537a3d9d5a2f6c6fac15f99f66c" prot="public" static="yes" mutable="no">
        <type>const char</type>
        <definition>const char amrex::sys_name[]</definition>
        <argsstring>[]</argsstring>
        <name>sys_name</name>
        <qualifiedname>amrex::sys_name</qualifiedname>
        <initializer>= &quot;IEEE&quot;</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FArrayBox.cpp" line="32" column="19" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FArrayBox.cpp" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1ad449c6a61a817b311238986b4ef19e38" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="namespaceamrex_1a98a85f350a96eb36272d756d5a9c9a05" kindref="member">gpuError_t</ref></type>
        <definition>constexpr gpuError_t amrex::gpuSuccess</definition>
        <argsstring></argsstring>
        <name>gpuSuccess</name>
        <qualifiedname>amrex::gpuSuccess</qualifiedname>
        <initializer>= cudaSuccess</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuError.H" line="34" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuError.H" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1ae5aa4a92b1c9940d028c38628ec7a866" prot="public" static="no" mutable="no">
        <type><ref refid="namespaceamrex_1abbea0a87a768d8f4e8112b9cd673b124" kindref="member">amrex::randState_t</ref> *</type>
        <definition>randState_t * amrex::gpu_rand_state</definition>
        <argsstring></argsstring>
        <name>gpu_rand_state</name>
        <qualifiedname>amrex::gpu_rand_state</qualifiedname>
        <initializer>= nullptr</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Random.cpp" line="23" column="24" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Random.cpp" bodystart="23" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" declline="62" declcolumn="24"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a45a0f32668f8318b51473908c068caa6" prot="public" static="no" constexpr="yes" mutable="no">
        <type>constexpr int</type>
        <definition>constexpr int amrex::SpaceDim</definition>
        <argsstring></argsstring>
        <name>SpaceDim</name>
        <qualifiedname>amrex::SpaceDim</qualifiedname>
        <initializer>= 3</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SPACE.H" line="51" column="19" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SPACE.H" bodystart="51" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1aa264b7308102fabb2a7356eea1800644" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class A</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool amrex::IsBaseFab_v</definition>
        <argsstring></argsstring>
        <name>IsBaseFab_v</name>
        <qualifiedname>amrex::IsBaseFab_v</qualifiedname>
        <initializer>= <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt;A&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="27" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a36e5941ad0614ee76ddb49b9bcc2c515" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class A</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool amrex::IsFabArray_v</definition>
        <argsstring></argsstring>
        <name>IsFabArray_v</name>
        <qualifiedname>amrex::IsFabArray_v</qualifiedname>
        <initializer>= <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt;A&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="38" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a4a4cee24cf2ff5e02dd18fbf39bc33ce" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class M</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool amrex::IsMultiFabLike_v</definition>
        <argsstring></argsstring>
        <name>IsMultiFabLike_v</name>
        <qualifiedname>amrex::IsMultiFabLike_v</qualifiedname>
        <initializer>= <ref refid="structamrex_1_1IsMultiFabLike" kindref="compound">IsMultiFabLike</ref>&lt;M&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="49" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="49" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a6c0ad9de6dc5e0ca9324f19210bd62b9" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool amrex::IsConvertible_v</definition>
        <argsstring></argsstring>
        <name>IsConvertible_v</name>
        <qualifiedname>amrex::IsConvertible_v</qualifiedname>
        <initializer>= <ref refid="structamrex_1_1IsConvertible" kindref="compound">IsConvertible</ref>&lt;T, Args...&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="276" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="276" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a2633fb41c81d41e25ded4da987274ed5" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool amrex::IsNarrowingConversion_v</definition>
        <argsstring></argsstring>
        <name>IsNarrowingConversion_v</name>
        <qualifiedname>amrex::IsNarrowingConversion_v</qualifiedname>
        <initializer>= <ref refid="structamrex_1_1IsNarrowingConversion" kindref="compound">IsNarrowingConversion</ref>&lt;From, To&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="290" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="290" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a5f567f08e64064aad355331c6cbe79ef" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool amrex::IsNonNarrowingConversion_v</definition>
        <argsstring></argsstring>
        <name>IsNonNarrowingConversion_v</name>
        <qualifiedname>amrex::IsNonNarrowingConversion_v</qualifiedname>
        <initializer>= !<ref refid="structamrex_1_1IsNarrowingConversion" kindref="compound">IsNarrowingConversion</ref>&lt;From, To&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" line="293" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeTraits.H" bodystart="293" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a2ab2963a7b15880c02fa58394f4b8d1f" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>constexpr std::array&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>, 3 &gt;</type>
        <definition>constexpr std::array&lt;IntVect,3&gt; amrex::E_ixtype</definition>
        <argsstring></argsstring>
        <name>E_ixtype</name>
        <qualifiedname>amrex::E_ixtype</qualifiedname>
        <initializer>{<ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>(0,1,1),<ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>(1,0,1),<ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>(1,1,0)}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_EdgeFluxRegister.cpp" line="7" column="29" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_EdgeFluxRegister.cpp" bodystart="7" bodyend="7"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a7e0f258a02602680779facdad15ec448" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
        <definition>constexpr amrex::Real amrex::eb_covered_val</definition>
        <argsstring></argsstring>
        <name>eb_covered_val</name>
        <qualifiedname>amrex::eb_covered_val</qualifiedname>
        <initializer>= <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>(1.e40)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="17" column="34" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" bodystart="17" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a9c0be24427378d764043ecb9428022b4" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1EBCellConservativeLinear" kindref="compound">EBCellConservativeLinear</ref></type>
        <definition>EBCellConservativeLinear amrex::eb_lincc_interp</definition>
        <argsstring></argsstring>
        <name>eb_lincc_interp</name>
        <qualifiedname>amrex::eb_lincc_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBInterpolater.cpp" line="9" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBInterpolater.cpp" bodystart="9" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBInterpolater.H" declline="31" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1ac9faae570d31666accb8ea6bb3405c28" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1EBCellConservativeLinear" kindref="compound">EBCellConservativeLinear</ref></type>
        <definition>EBCellConservativeLinear amrex::eb_cell_cons_interp</definition>
        <argsstring>(false)</argsstring>
        <name>eb_cell_cons_interp</name>
        <qualifiedname>amrex::eb_cell_cons_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBInterpolater.cpp" line="10" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBInterpolater.H" bodystart="32" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBInterpolater.H" declline="32" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a755c13c3c4f1ccdd18ecc58ee4e8ec06" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1EBMFCellConsLinInterp" kindref="compound">EBMFCellConsLinInterp</ref></type>
        <definition>EBMFCellConsLinInterp amrex::eb_mf_cell_cons_interp</definition>
        <argsstring>(false)</argsstring>
        <name>eb_mf_cell_cons_interp</name>
        <qualifiedname>amrex::eb_mf_cell_cons_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMFInterpolater.cpp" line="7" column="23" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMFInterpolater.H" bodystart="21" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMFInterpolater.H" declline="21" declcolumn="33"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1a1b9cc26c472f4ce4595c7125bd880652" prot="public" static="no" mutable="no">
        <type><ref refid="classamrex_1_1EBMFCellConsLinInterp" kindref="compound">EBMFCellConsLinInterp</ref></type>
        <definition>EBMFCellConsLinInterp amrex::eb_mf_lincc_interp</definition>
        <argsstring>(true)</argsstring>
        <name>eb_mf_lincc_interp</name>
        <qualifiedname>amrex::eb_mf_lincc_interp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMFInterpolater.cpp" line="8" column="23" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMFInterpolater.H" bodystart="22" bodyend="-1" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMFInterpolater.H" declline="22" declcolumn="33"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespaceamrex_1ae4eb9d3fef37595defb201fde203bae6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, AmrMesh const &amp;amr_mesh)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1AmrMesh" kindref="compound">AmrMesh</ref> const &amp;</type>
          <declname>amr_mesh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_AmrMesh.cpp" line="1237" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_AmrMesh.cpp" bodystart="1237" bodyend="1263" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_AmrMesh.H" declline="298" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9610a39b43057d1e9e78c4d5156965ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParticleToMesh</definition>
        <argsstring>(PC const &amp;pc, const Vector&lt; MultiFab * &gt; &amp;mf, int lev_min, int lev_max, F &amp;&amp;f, bool zero_out_input=true, bool vol_weight=true)</argsstring>
        <name>ParticleToMesh</name>
        <qualifiedname>amrex::ParticleToMesh</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>zero_out_input</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>vol_weight</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_AmrParticles.H" line="156" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_AmrParticles.H" bodystart="156" bodyend="254"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab1b1f90152c1c5636d634b475056389e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const ErrorList &amp;elst)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1ErrorList" kindref="compound">ErrorList</ref> &amp;</type>
          <declname>elst</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.cpp" line="199" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.cpp" bodystart="200" bodyend="213" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_ErrorList.H" declline="334" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a72195f024b69133f6704c2c3cce969f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::InterpCrseFineBndryEMfield</definition>
        <argsstring>(InterpEM_t interp_type, const Array&lt; MultiFab, 3 &gt; &amp;crse, Array&lt; MultiFab, 3 &gt; &amp;fine, const Geometry &amp;cgeom, const Geometry &amp;fgeom, int ref_ratio)</argsstring>
        <name>InterpCrseFineBndryEMfield</name>
        <qualifiedname>amrex::InterpCrseFineBndryEMfield</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a2f30e076962c1c148d279b63851d80df" kindref="member">InterpEM_t</ref></type>
          <declname>interp_type</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ref_ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.cpp" line="11" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.cpp" bodystart="11" bodyend="21" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="851" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab4f94130788e27fce5b4e56079ad002d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::InterpCrseFineBndryEMfield</definition>
        <argsstring>(InterpEM_t interp_type, const Array&lt; MultiFab const *, 3 &gt; &amp;crse, const Array&lt; MultiFab *, 3 &gt; &amp;fine, const Geometry &amp;cgeom, const Geometry &amp;fgeom, int ref_ratio)</argsstring>
        <name>InterpCrseFineBndryEMfield</name>
        <qualifiedname>amrex::InterpCrseFineBndryEMfield</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a2f30e076962c1c148d279b63851d80df" kindref="member">InterpEM_t</ref></type>
          <declname>interp_type</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const *, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ref_ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.cpp" line="23" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.cpp" bodystart="23" bodyend="137" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="857" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a93b8e270e0c8360ed35815598a5b7f46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::FillPatchInterp</definition>
        <argsstring>(MultiFab &amp;mf_fine_patch, int fcomp, MultiFab const &amp;mf_crse_patch, int ccomp, int ncomp, IntVect const &amp;ng, const Geometry &amp;cgeom, const Geometry &amp;fgeom, Box const &amp;dest_domain, const IntVect &amp;ratio, MFInterpolater *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp)</argsstring>
        <name>FillPatchInterp</name>
        <qualifiedname>amrex::FillPatchInterp</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf_fine_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fcomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const &amp;</type>
          <declname>mf_crse_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>dest_domain</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MFInterpolater" kindref="compound">MFInterpolater</ref> *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.cpp" line="140" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.cpp" bodystart="140" bodyend="150" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" declline="197" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a36b10976708081700c810d70417da8c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Interp</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ProperlyNested</definition>
        <argsstring>(const IntVect &amp;ratio, const IntVect &amp;blocking_factor, int ngrow, const IndexType &amp;boxType, Interp *mapper)</argsstring>
        <name>ProperlyNested</name>
        <qualifiedname>amrex::ProperlyNested</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>blocking_factor</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a7e095993c9b3f5a4c2abddd839d800e2" kindref="member">IndexType</ref> &amp;</type>
          <declname>boxType</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <briefdescription>
<para>Test if AMR grids are properly nested. </para>
        </briefdescription>
        <detaileddescription>
<para>If grids are not properly nested, FillPatch functions may fail.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Interpolater" kindref="compound">Interpolater</ref> type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>blocking_factor</parametername>
</parameternamelist>
<parameterdescription>
<para>blocking factor on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ngrow</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of fine <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>boxType</parametername>
</parameternamelist>
<parameterdescription>
<para>index type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>an interpolater object </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="35" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="35" bodyend="59" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="59" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3cf973090fa613c635340a08df7ecd38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchSingleLevel</definition>
        <argsstring>(MF &amp;mf, IntVect const &amp;nghost, Real time, const Vector&lt; MF * &gt; &amp;smf, const Vector&lt; Real &gt; &amp;stime, int scomp, int dcomp, int ncomp, const Geometry &amp;geom, BC &amp;physbcf, int bcfcomp)</argsstring>
        <name>FillPatchSingleLevel</name>
        <qualifiedname>amrex::FillPatchSingleLevel</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>smf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>stime</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>physbcf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcfcomp</declname>
        </param>
        <briefdescription>
<para>FillPatch with data from the current level. </para>
        </briefdescription>
        <detaileddescription>
<para>The destination MultiFab/FabArray is on the same AMR level as the source MultiFab/FabArray. Usually this can only be used on AMR level 0, because filling fine level MF usually requires coarse level data. If needed, interpolation in time is performed.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>smf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stime</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated smf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for this level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>physbcf</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcfcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for physbcf </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="75" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="75" bodyend="195" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="87" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a05934ee478017afcd9908667de64a79c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchSingleLevel</definition>
        <argsstring>(MF &amp;mf, Real time, const Vector&lt; MF * &gt; &amp;smf, const Vector&lt; Real &gt; &amp;stime, int scomp, int dcomp, int ncomp, const Geometry &amp;geom, BC &amp;physbcf, int bcfcomp)</argsstring>
        <name>FillPatchSingleLevel</name>
        <qualifiedname>amrex::FillPatchSingleLevel</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>smf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>stime</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>physbcf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcfcomp</declname>
        </param>
        <briefdescription>
<para>FillPatch with data from the current level. </para>
        </briefdescription>
        <detaileddescription>
<para>The destination MultiFab/FabArray is on the same AMR level as the source MultiFab/FabArray. Usually this can only be used on AMR level 0, because filling fine level MF usually requires coarse level data. If needed, interpolation in time is performed. All ghost cells of the destination MF are filled.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>smf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stime</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated smf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for this level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>physbcf</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcfcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for physbcf </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="63" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="63" bodyend="71" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="118" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5b5440802e0895fcba37e6b295116585" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchTwoLevels</definition>
        <argsstring>(MF &amp;mf, IntVect const &amp;nghost, Real time, const Vector&lt; MF * &gt; &amp;cmf, const Vector&lt; Real &gt; &amp;ct, const Vector&lt; MF * &gt; &amp;fmf, const Vector&lt; Real &gt; &amp;ft, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, BC &amp;cbc, int cbccomp, BC &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>FillPatchTwoLevels</name>
        <qualifiedname>amrex::FillPatchTwoLevels</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ct</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>FillPatch with data from the current level and the level below. </para>
        </briefdescription>
        <detaileddescription>
<para>First, we fill the destination MultiFab/FabArray with the current level data as much as possible. This may include interpolation in time. For the rest of the destination MF, we fill them with the coarse level data using interpolation in space (and in time if needed).</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ct</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated cmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated fmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="800" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="800" bodyend="822" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="166" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3f8f5f13146586dfaa0fb8d082132f12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchTwoLevels</definition>
        <argsstring>(MF &amp;mf, Real time, const Vector&lt; MF * &gt; &amp;cmf, const Vector&lt; Real &gt; &amp;ct, const Vector&lt; MF * &gt; &amp;fmf, const Vector&lt; Real &gt; &amp;ft, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, BC &amp;cbc, int cbccomp, BC &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>FillPatchTwoLevels</name>
        <qualifiedname>amrex::FillPatchTwoLevels</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ct</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>FillPatch with data from the current level and the level below. </para>
        </briefdescription>
        <detaileddescription>
<para>First, we fill the destination MultiFab/FabArray with the current level data as much as possible. This may include interpolation in time. For the rest of the destination MF, we fill them with the coarse level data using interpolation in space (and in time if needed). All ghost cells of the destination MF are filled.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ct</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated cmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated fmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="826" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="826" bodyend="849" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="220" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0c7ffe6f08d1495383e8b7a360f5067e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchTwoLevels</definition>
        <argsstring>(Array&lt; MF *, 3 &gt; const &amp;mf, IntVect const &amp;nghost, Real time, const Vector&lt; Array&lt; MF *, 3 &gt; &gt; &amp;cmf, const Vector&lt; Real &gt; &amp;ct, const Vector&lt; Array&lt; MF *, 3 &gt; &gt; &amp;fmf, const Vector&lt; Real &gt; &amp;ft, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, Array&lt; BC, 3 &gt; &amp;cbc, const Array&lt; int, 3 &gt; &amp;cbccomp, Array&lt; BC, 3 &gt; &amp;fbc, const Array&lt; int, 3 &gt; &amp;fbccomp, const IntVect &amp;ratio, Interp *mapper, const Array&lt; Vector&lt; BCRec &gt;, 3 &gt; &amp;bcs, const Array&lt; int, 3 &gt; &amp;bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>FillPatchTwoLevels</name>
        <qualifiedname>amrex::FillPatchTwoLevels</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ct</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; int, 3 &gt; &amp;</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; int, 3 &gt; &amp;</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt;, 3 &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; int, 3 &gt; &amp;</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>FillPatch for face variables with data from the current level and the level below. Sometimes, we need to fillpatch all AMREX_SPACEDIM face MultiFabs togother to satisfy certain constraint such as divergence preserving. </para>
        </briefdescription>
        <detaileddescription>
<para>First, we fill the destination MultiFab/FabArray&apos;s with the current level data as much as possible. This may include interpolation in time. For the rest of the destination MFs, we fill them with the coarse level data using interpolation in space (and in time if needed).</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ct</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated cmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated fmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="853" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="853" bodyend="876" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="278" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a390894d7b417899ef5b5ac5554e9ba01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchTwoLevels</definition>
        <argsstring>(Array&lt; MF *, 3 &gt; const &amp;mf, IntVect const &amp;nghost, Real time, const Vector&lt; Array&lt; MF *, 3 &gt; &gt; &amp;cmf, const Vector&lt; Real &gt; &amp;ct, const Vector&lt; Array&lt; MF *, 3 &gt; &gt; &amp;fmf, const Vector&lt; Real &gt; &amp;ft, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, Array&lt; BC, 3 &gt; &amp;cbc, int cbccomp, Array&lt; BC, 3 &gt; &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Array&lt; Vector&lt; BCRec &gt;, 3 &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>FillPatchTwoLevels</name>
        <qualifiedname>amrex::FillPatchTwoLevels</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ct</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt;, 3 &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>FillPatch for face variables with data from the current level and the level below. Sometimes, we need to fillpatch all AMREX_SPACEDIM face MultiFabs togother to satisfy certain constraint such as divergence preserving. </para>
        </briefdescription>
        <detaileddescription>
<para>First, we fill the destination MultiFab/FabArray&apos;s with the current level data as much as possible. This may include interpolation in time. For the rest of the destination MFs, we fill them with the coarse level data using interpolation in space (and in time if needed).</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ct</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated cmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated fmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="880" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="880" bodyend="907" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="336" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a594916b2bbff20fc573a8e94386cbfb2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchTwoLevels</definition>
        <argsstring>(Array&lt; MF *, 3 &gt; const &amp;mf, Real time, const Vector&lt; Array&lt; MF *, 3 &gt; &gt; &amp;cmf, const Vector&lt; Real &gt; &amp;ct, const Vector&lt; Array&lt; MF *, 3 &gt; &gt; &amp;fmf, const Vector&lt; Real &gt; &amp;ft, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, Array&lt; BC, 3 &gt; &amp;cbc, int cbccomp, Array&lt; BC, 3 &gt; &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Array&lt; Vector&lt; BCRec &gt;, 3 &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>FillPatchTwoLevels</name>
        <qualifiedname>amrex::FillPatchTwoLevels</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ct</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt;, 3 &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>FillPatch for face variables with data from the current level and the level below. Sometimes, we need to fillpatch all AMREX_SPACEDIM face MultiFabs togother to satisfy certain constraint such as divergence preserving. </para>
        </briefdescription>
        <detaileddescription>
<para>First, we fill the destination MultiFab/FabArray&apos;s with the current level data as much as possible. This may include interpolation in time. For the rest of the destination MFs, we fill them with the coarse level data using interpolation in space (and in time if needed). All ghost cells of the destination MFs are filled.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ct</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated cmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated fmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="911" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="911" bodyend="938" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="393" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0d9ba9d4b23e68594276b631199ce7e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
          </param>
          <param>
            <type>typename PostInterpHook</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchTwoLevels</definition>
        <argsstring>(MF &amp;mf, IntVect const &amp;nghost, Real time, const EB2::IndexSpace &amp;index_space, const Vector&lt; MF * &gt; &amp;cmf, const Vector&lt; Real &gt; &amp;ct, const Vector&lt; MF * &gt; &amp;fmf, const Vector&lt; Real &gt; &amp;ft, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, BC &amp;cbc, int cbccomp, BC &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp, const PostInterpHook &amp;post_interp)</argsstring>
        <name>FillPatchTwoLevels</name>
        <qualifiedname>amrex::FillPatchTwoLevels</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1EB2_1_1IndexSpace" kindref="compound">EB2::IndexSpace</ref> &amp;</type>
          <declname>index_space</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ct</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
        </param>
        <briefdescription>
<para>FillPatch with data from the current level and the level below. </para>
        </briefdescription>
        <detaileddescription>
<para>First, we fill the destination MultiFab/FabArray with the current level data as much as possible. This may include interpolation in time. For the rest of the destination MF, we fill them with the coarse level data using interpolation in space (and in time if needed).</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>index_space</parametername>
</parameternamelist>
<parameterdescription>
<para>EB IndexSpace </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ct</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated cmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated fmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="943" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="943" bodyend="961" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="448" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac62cac089968552ebdbfffed1803a64b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
          </param>
          <param>
            <type>typename PostInterpHook</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchTwoLevels</definition>
        <argsstring>(MF &amp;mf, Real time, const EB2::IndexSpace &amp;index_space, const Vector&lt; MF * &gt; &amp;cmf, const Vector&lt; Real &gt; &amp;ct, const Vector&lt; MF * &gt; &amp;fmf, const Vector&lt; Real &gt; &amp;ft, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, BC &amp;cbc, int cbccomp, BC &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp, const PostInterpHook &amp;post_interp)</argsstring>
        <name>FillPatchTwoLevels</name>
        <qualifiedname>amrex::FillPatchTwoLevels</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1EB2_1_1IndexSpace" kindref="compound">EB2::IndexSpace</ref> &amp;</type>
          <declname>index_space</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ct</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
        </param>
        <briefdescription>
<para>FillPatch with data from the current level and the level below. </para>
        </briefdescription>
        <detaileddescription>
<para>First, we fill the destination MultiFab/FabArray with the current level data as much as possible. This may include interpolation in time. For the rest of the destination MF, we fill them with the coarse level data using interpolation in space (and in time if needed). All ghost cells of the destination MF are filled.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>index_space</parametername>
</parameternamelist>
<parameterdescription>
<para>EB IndexSpace </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ct</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated cmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated fmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="965" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="965" bodyend="983" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="502" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6fa430e1648835f9dea38b7568d79506" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::InterpFromCoarseLevel</definition>
        <argsstring>(MF &amp;mf, Real time, const MF &amp;cmf, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, BC &amp;cbc, int cbccomp, BC &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>InterpFromCoarseLevel</name>
        <qualifiedname>amrex::InterpFromCoarseLevel</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const MF &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Fill with interpolation of coarse level data. </para>
        </briefdescription>
        <detaileddescription>
<para>All ghost cells of the destination MF are filled.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MF on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="988" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="988" bodyend="1008" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="551" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa081e015e8252796d1f7675189020446" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::InterpFromCoarseLevel</definition>
        <argsstring>(MF &amp;mf, IntVect const &amp;nghost, Real time, const MF &amp;cmf, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, BC &amp;cbc, int cbccomp, BC &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>InterpFromCoarseLevel</name>
        <qualifiedname>amrex::InterpFromCoarseLevel</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const MF &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Fill with interpolation of coarse level data. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MF on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="1030" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="1030" bodyend="1050" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="595" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac07ae2ebcb4a8b75ec50eb979a26ef9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::InterpFromCoarseLevel</definition>
        <argsstring>(MF &amp;mf, IntVect const &amp;nghost, Real time, const EB2::IndexSpace *index_space, const MF &amp;cmf, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, BC &amp;cbc, int cbccomp, BC &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>InterpFromCoarseLevel</name>
        <qualifiedname>amrex::InterpFromCoarseLevel</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1EB2_1_1IndexSpace" kindref="compound">EB2::IndexSpace</ref> *</type>
          <declname>index_space</declname>
        </param>
        <param>
          <type>const MF &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type>BC &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Fill with interpolation of coarse level data. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>index_space</parametername>
</parameternamelist>
<parameterdescription>
<para>EB IndexSpace </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MF on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="1054" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="1054" bodyend="1146" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="640" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4416974d946e9527aa91936144873a51" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::InterpFromCoarseLevel</definition>
        <argsstring>(Array&lt; MF *, 3 &gt; const &amp;mf, Real time, const Array&lt; MF *, 3 &gt; &amp;cmf, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, Array&lt; BC, 3 &gt; &amp;cbc, int cbccomp, Array&lt; BC, 3 &gt; &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Array&lt; Vector&lt; BCRec &gt;, 3 &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>InterpFromCoarseLevel</name>
        <qualifiedname>amrex::InterpFromCoarseLevel</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt;, 3 &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Fill face variables with data from the coarse level. Sometimes, we need to fillpatch all AMREX_SPACEDIM face MultiFabs together to satisfy certain constraint such as divergence preserving. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="1012" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="1012" bodyend="1026" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="686" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af3c3186e1ed40653258d9ce5b6a6645d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
          <param>
            <type>typename PreInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
          <param>
            <type>typename PostInterpHook</type>
            <defval>NullInterpHook&lt;typename MF::FABType::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::InterpFromCoarseLevel</definition>
        <argsstring>(Array&lt; MF *, 3 &gt; const &amp;mf, IntVect const &amp;nghost, Real time, const Array&lt; MF *, 3 &gt; &amp;cmf, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, Array&lt; BC, 3 &gt; &amp;cbc, int cbccomp, Array&lt; BC, 3 &gt; &amp;fbc, int fbccomp, const IntVect &amp;ratio, Interp *mapper, const Array&lt; Vector&lt; BCRec &gt;, 3 &gt; &amp;bcs, int bcscomp, const PreInterpHook &amp;pre_interp={}, const PostInterpHook &amp;post_interp={})</argsstring>
        <name>InterpFromCoarseLevel</name>
        <qualifiedname>amrex::InterpFromCoarseLevel</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>cbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cbccomp</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; BC, 3 &gt; &amp;</type>
          <declname>fbc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fbccomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt;, 3 &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type>const PreInterpHook &amp;</type>
          <declname>pre_interp</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>const PostInterpHook &amp;</type>
          <declname>post_interp</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Fill face variables with data from the coarse level. Sometimes, we need to fillpatch all AMREX_SPACEDIM face MultiFabs togother to satisfy certain constraint such as divergence preserving. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PreInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PostInterpHook</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for cbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbc</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for physical boundaries on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fbccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for fbc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pre_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>pre-interpolation hook </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>post_interp</parametername>
</parameternamelist>
<parameterdescription>
<para>post-interpolation hook </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="1150" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="1150" bodyend="1296" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="732" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a501c1ca3e717ceda6598c632d9af6768" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::InterpFromCoarseLevel</definition>
        <argsstring>(MF &amp;mf, IntVect const &amp;nghost, IntVect const &amp;nghost_outside_domain, const MF &amp;cmf, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp)</argsstring>
        <name>InterpFromCoarseLevel</name>
        <qualifiedname>amrex::InterpFromCoarseLevel</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost_outside_domain</declname>
        </param>
        <param>
          <type>const MF &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <briefdescription>
<para>Fill with interpolation of coarse level data. </para>
        </briefdescription>
        <detaileddescription>
<para>It&apos;s the CALLER&apos;s responsibility to make sure all ghost cells of the coarse MF needed for interpolation are filled already before calling this function. It&apos;s assumed that the fine level <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> mf&apos;s <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is coarsenable by the refinement ratio. There is no support for EB.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf inside domain needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost_outside_domain</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf outside domain needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MF on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundar types for each component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="1300" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="1300" bodyend="1311" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="771" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aee597ed9a498322591bb42a475f66ddb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchSingleLevel</definition>
        <argsstring>(MF &amp;mf, IntVect const &amp;nghost, Real time, const Vector&lt; MF * &gt; &amp;smf, IntVect const &amp;snghost, const Vector&lt; Real &gt; &amp;stime, int scomp, int dcomp, int ncomp, const Geometry &amp;geom)</argsstring>
        <name>FillPatchSingleLevel</name>
        <qualifiedname>amrex::FillPatchSingleLevel</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>smf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>snghost</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>stime</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
<para>FillPatch with data from the current level. </para>
        </briefdescription>
        <detaileddescription>
<para>In this version of FillPatchSingleLevel, it&apos;s the CALLER&apos;s responsibility to make sure that smf has <computeroutput>snghost</computeroutput> ghost cells already filled before calling this function. The destination MultiFab/FabArray is on the same AMR level as the source MultiFab/FabArray. If needed, interpolation in time is performed.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>smf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>snghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells in smf with valid data </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stime</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated smf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for this level </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="1315" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="1315" bodyend="1323" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="802" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7bf1330df5e763beff79913372ef9e7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchTwoLevels</definition>
        <argsstring>(MF &amp;mf, IntVect const &amp;nghost, IntVect const &amp;nghost_outside_domain, Real time, const Vector&lt; MF * &gt; &amp;cmf, const Vector&lt; Real &gt; &amp;ct, const Vector&lt; MF * &gt; &amp;fmf, const Vector&lt; Real &gt; &amp;ft, int scomp, int dcomp, int ncomp, const Geometry &amp;cgeom, const Geometry &amp;fgeom, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp)</argsstring>
        <name>FillPatchTwoLevels</name>
        <qualifiedname>amrex::FillPatchTwoLevels</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost_outside_domain</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ct</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>ft</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <briefdescription>
<para>FillPatch with data from the current level and the level below. </para>
        </briefdescription>
        <detaileddescription>
<para>In this version of FillPatchTwoLevels, it&apos;s the CALLER&apos;s responsibility to make sure all ghost cells of the coarse MF needed for interpolation are filled already before calling this function. It&apos;s assumed that the fine level <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> mf&apos;s <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is coarsenable by the refinement ratio. There is no support for EB.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf inside domain needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost_outside_domain</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf outside domain needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ct</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated cmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs on the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ft</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated fmf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the coarse level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fgeom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> for the fine level </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcs</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcscomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="1327" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="1327" bodyend="1342" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="839" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a32e7df23157daf632a48f41ebd9c8ace" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename BC</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchNLevels</definition>
        <argsstring>(MF &amp;mf, int level, const IntVect &amp;nghost, Real time, const Vector&lt; Vector&lt; MF * &gt; &gt; &amp;smf, const Vector&lt; Vector&lt; Real &gt; &gt; &amp;st, int scomp, int dcomp, int ncomp, const Vector&lt; Geometry &gt; &amp;geom, Vector&lt; BC &gt; &amp;bc, int bccomp, const Vector&lt; IntVect &gt; &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcr, int bcrcomp)</argsstring>
        <name>FillPatchNLevels</name>
        <qualifiedname>amrex::FillPatchNLevels</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &gt; &amp;</type>
          <declname>smf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &gt; &amp;</type>
          <declname>st</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; BC &gt; &amp;</type>
          <declname>bc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bccomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcrcomp</declname>
        </param>
        <briefdescription>
<para>FillPatch with data from AMR levels. </para>
        </briefdescription>
        <detaileddescription>
<para>First, we try to fill the destination MultiFab/FabArray with this level&apos;s data if it&apos;s available. For the unfilled region, we try to fill with the coarse level below if it&apos;s available. Even coarser levels will be used if necessary till all regions are filled. This function is more expensive than FillPatchTwoLevels. So if one knows FillPatchTwoLevels can do the job because grids are properly nested, this function should be avoided.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BC</parametername>
</parameternamelist>
<parameterdescription>
<para>functor for filling physical boundaries </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Interp</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>AMR level associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells of mf needed to be filled </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>time</parametername>
</parameternamelist>
<parameterdescription>
<para>time associated with mf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>smf</parametername>
</parameternamelist>
<parameterdescription>
<para>source MFs. The outer <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref> is for AMR levels, whereas the inner <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref> is for data at various times. It is not an error if the level for the destination MF is finer than data in smf (i.e., <computeroutput>level &gt;= smf.size()</computeroutput>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>st</parametername>
</parameternamelist>
<parameterdescription>
<para>times associated smf </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the source MFs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of the destination MF </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geom</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> objects for AMR levels. The size must be big enough such that <computeroutput>level &lt; geom.size()</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bc</parametername>
</parameternamelist>
<parameterdescription>
<para>functors for physical boundaries on AMR levels. The size must be big enough such that <computeroutput>level &lt; bc.size()</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bc </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio for AMR levels. The size must be big enough such that <computeroutput>level &lt; bc.size()-1</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mapper</parametername>
</parameternamelist>
<parameterdescription>
<para>spatial interpolater </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcr</parametername>
</parameternamelist>
<parameterdescription>
<para>boundary types for each component. We need this because some interpolaters need it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bcrcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component for bcr </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="1346" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="1346" bodyend="1519" declfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil.H" declline="904" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afa9a7f1a8a6c3759671645a9295d6326" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &amp;&amp;!std::is_same_v&lt; Interp, <ref refid="classamrex_1_1MFInterpolater" kindref="compound">MFInterpolater</ref> &gt; &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &amp;&amp;!std::is_same_v&lt; Interp, MFInterpolater &gt; &gt; amrex::FillPatchInterp</definition>
        <argsstring>(MF &amp;mf_fine_patch, int fcomp, MF const &amp;mf_crse_patch, int ccomp, int ncomp, IntVect const &amp;ng, const Geometry &amp;cgeom, const Geometry &amp;fgeom, Box const &amp;dest_domain, const IntVect &amp;ratio, Interp *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp)</argsstring>
        <name>FillPatchInterp</name>
        <qualifiedname>amrex::FillPatchInterp</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf_fine_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fcomp</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>mf_crse_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>dest_domain</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>Interp *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="204" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="204" bodyend="231"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1bb7a2fc324d4f235ab27027e12d1b8c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillPatchInterp</definition>
        <argsstring>(MF &amp;mf_fine_patch, int fcomp, MF const &amp;mf_crse_patch, int ccomp, int ncomp, IntVect const &amp;ng, const Geometry &amp;cgeom, const Geometry &amp;fgeom, Box const &amp;dest_domain, const IntVect &amp;ratio, InterpBase *mapper, const Vector&lt; BCRec &gt; &amp;bcs, int bcscomp)</argsstring>
        <name>FillPatchInterp</name>
        <qualifiedname>amrex::FillPatchInterp</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>mf_fine_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fcomp</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>mf_crse_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>dest_domain</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1InterpBase" kindref="compound">InterpBase</ref> *</type>
          <declname>mapper</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="235" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="235" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a846207ec88f79f3019dc051899e10e3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename iMF</type>
          </param>
          <param>
            <type>typename Interp</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &amp;&amp;!std::is_same_v&lt; Interp, <ref refid="classamrex_1_1MFInterpolater" kindref="compound">MFInterpolater</ref> &gt; &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &amp;&amp;!std::is_same_v&lt; Interp, MFInterpolater &gt; &gt; amrex::InterpFace</definition>
        <argsstring>(Interp *interp, MF const &amp;mf_crse_patch, int crse_comp, MF &amp;mf_refined_patch, int fine_comp, int ncomp, const IntVect &amp;ratio, const iMF &amp;solve_mask, const Geometry &amp;crse_geom, const Geometry &amp;fine_geom, int bcscomp, RunOn gpu_or_cpu, const Vector&lt; BCRec &gt; &amp;bcs)</argsstring>
        <name>InterpFace</name>
        <qualifiedname>amrex::InterpFace</qualifiedname>
        <param>
          <type>Interp *</type>
          <declname>interp</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>mf_crse_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>crse_comp</declname>
        </param>
        <param>
          <type>MF &amp;</type>
          <declname>mf_refined_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fine_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>const iMF &amp;</type>
          <declname>solve_mask</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>crse_geom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fine_geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcscomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a33bef6ea796972dbf046ba79277795d2" kindref="member">RunOn</ref></type>
          <declname>gpu_or_cpu</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="255" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="255" bodyend="277"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3e5469c515ce2b8c5907105be4c9d6a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename iMF</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::InterpFace</definition>
        <argsstring>(InterpBase *interp, MF const &amp;mf_crse_patch, int crse_comp, MF &amp;mf_refined_patch, int fine_comp, int ncomp, const IntVect &amp;ratio, const iMF &amp;solve_mask, const Geometry &amp;crse_geom, const Geometry &amp;fine_geom, int bccomp, RunOn gpu_or_cpu, const Vector&lt; BCRec &gt; &amp;bcs)</argsstring>
        <name>InterpFace</name>
        <qualifiedname>amrex::InterpFace</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1InterpBase" kindref="compound">InterpBase</ref> *</type>
          <declname>interp</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>mf_crse_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>crse_comp</declname>
        </param>
        <param>
          <type>MF &amp;</type>
          <declname>mf_refined_patch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fine_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>const iMF &amp;</type>
          <declname>solve_mask</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>crse_geom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fine_geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bccomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a33bef6ea796972dbf046ba79277795d2" kindref="member">RunOn</ref></type>
          <declname>gpu_or_cpu</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" line="281" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/AmrCore/AMReX_FillPatchUtil_I.H" bodystart="281" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae23d62d1c91ace8d10a35f15db80e780" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
        <definition>FPExcept amrex::getFPExcept</definition>
        <argsstring>()</argsstring>
        <name>getFPExcept</name>
        <qualifiedname>amrex::getFPExcept</qualifiedname>
        <briefdescription>
<para>Return currently enabled FP exceptions. Linux only. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" line="995" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="995" bodyend="1005" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="353" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a78c3e0b7066802f4a1777e4384f004ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
        <definition>FPExcept amrex::setFPExcept</definition>
        <argsstring>(FPExcept excepts)</argsstring>
        <name>setFPExcept</name>
        <qualifiedname>amrex::setFPExcept</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
          <declname>excepts</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set FP exception traps. Linux only. This enables set flags and DISABLES unset flags. This can be used to restore previous settings. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" line="1007" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="1007" bodyend="1022" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="357" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aeb028d29f68c1aea92c12903a8bfa262" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
        <definition>FPExcept amrex::disableFPExcept</definition>
        <argsstring>(FPExcept excepts)</argsstring>
        <name>disableFPExcept</name>
        <qualifiedname>amrex::disableFPExcept</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
          <declname>excepts</declname>
        </param>
        <briefdescription>
<para>Disable FP exceptions. Linux Only. </para>
        </briefdescription>
        <detaileddescription>
<para>This function disables given exception traps and keeps the status of the others. The example below disables FPE invalid and divide-by-zero, and later restores the previous settings.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>prev_excepts<sp/>=<sp/><ref refid="namespaceamrex_1aeb028d29f68c1aea92c12903a8bfa262" kindref="member">disableFPExcept</ref>(<ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2cafedb2d84cafe20862cb4399751a8a7e3" kindref="member">FPExcept::invalid</ref><sp/>|<sp/><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2cad02c4c4cde7ae76252540d116a40f23a" kindref="member">FPExcept::zero</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>....</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a78c3e0b7066802f4a1777e4384f004ac" kindref="member">setFPExcept</ref>(prev_excepts);<sp/></highlight><highlight class="comment">//<sp/>restore<sp/>previous<sp/>settings</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" line="1024" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="1024" bodyend="1037" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="372" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aebfde21396d2ff792d29469193f4853e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
        <definition>FPExcept amrex::enableFPExcept</definition>
        <argsstring>(FPExcept excepts)</argsstring>
        <name>enableFPExcept</name>
        <qualifiedname>amrex::enableFPExcept</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
          <declname>excepts</declname>
        </param>
        <briefdescription>
<para>Enable FP exceptions. Linux Only. </para>
        </briefdescription>
        <detaileddescription>
<para>This function enables given exception traps and keeps the status of the others. The example below enables all FPE traps, and later restores the previous settings.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>prev_excepts<sp/>=<sp/><ref refid="namespaceamrex_1aebfde21396d2ff792d29469193f4853e" kindref="member">enableFPExcept</ref>(<ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2caa181a603769c1f98ad927e7367c7aa51" kindref="member">FPExcept::all</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>....</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a78c3e0b7066802f4a1777e4384f004ac" kindref="member">setFPExcept</ref>(prev_excepts);<sp/></highlight><highlight class="comment">//<sp/>restore<sp/>previous<sp/>settings</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" line="1039" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="1039" bodyend="1052" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="387" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afadc6162983c674e4597ea37fa732645" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Init_minimal</definition>
        <argsstring>(MPI_Comm mpi_comm)</argsstring>
        <name>Init_minimal</name>
        <qualifiedname>amrex::Init_minimal</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref></type>
          <declname>mpi_comm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" line="1054" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="1054" bodyend="1062" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="111" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5f0a2d36e3539b0feab77cb7670d5053" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Finalize_minimal</definition>
        <argsstring>()</argsstring>
        <name>Finalize_minimal</name>
        <qualifiedname>amrex::Finalize_minimal</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" line="1064" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="1064" bodyend="1073" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="124" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad4158723bb78d3d5f19e396a20c0ce2d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::Version</definition>
        <argsstring>()</argsstring>
        <name>Version</name>
        <qualifiedname>amrex::Version</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>the <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> &quot;git describe&quot; version </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Version.cpp" line="9" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Version.cpp" bodystart="9" bodyend="16" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="75" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a50b9b83c886549ba070ec27eb45df025" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> *</type>
        <definition>amrex::AMReX * amrex::Initialize</definition>
        <argsstring>(MPI_Comm mpi_comm, std::ostream &amp;a_osout=std::cout, std::ostream &amp;a_oserr=std::cerr, ErrorHandler a_errhandler=nullptr, int a_device_id=-1)</argsstring>
        <name>Initialize</name>
        <qualifiedname>amrex::Initialize</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref></type>
          <declname>mpi_comm</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>a_osout</declname>
          <defval>std::cout</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>a_oserr</declname>
          <defval>std::cerr</defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1af6f45c130cacf67455811e9b4829f432" kindref="member">ErrorHandler</ref></type>
          <declname>a_errhandler</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type>int</type>
          <declname>a_device_id</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="78" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="332" bodyend="340" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="78" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aff8713b6b61da69030f4b925d062220d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> *</type>
        <definition>amrex::AMReX * amrex::Initialize</definition>
        <argsstring>(int &amp;argc, char **&amp;argv, const std::function&lt; void()&gt; &amp;func_parm_parse, std::ostream &amp;a_osout=std::cout, std::ostream &amp;a_oserr=std::cerr, ErrorHandler a_errhandler=nullptr, int a_device_id=-1)</argsstring>
        <name>Initialize</name>
        <qualifiedname>amrex::Initialize</qualifiedname>
        <param>
          <type>int &amp;</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **&amp;</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>const std::function&lt; void()&gt; &amp;</type>
          <declname>func_parm_parse</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>a_osout</declname>
          <defval>std::cout</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>a_oserr</declname>
          <defval>std::cerr</defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1af6f45c130cacf67455811e9b4829f432" kindref="member">ErrorHandler</ref></type>
          <declname>a_errhandler</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type>int</type>
          <declname>a_device_id</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="85" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="343" bodyend="350" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="85" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae7c1b924c46e9f20d1286b2ab2cb6f89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> *</type>
        <definition>amrex::AMReX * amrex::Initialize</definition>
        <argsstring>(int &amp;argc, char **&amp;argv, bool build_parm_parse=true, MPI_Comm mpi_comm=MPI_COMM_WORLD, const std::function&lt; void()&gt; &amp;func_parm_parse={}, std::ostream &amp;a_osout=std::cout, std::ostream &amp;a_oserr=std::cerr, ErrorHandler a_errhandler=nullptr, int a_device_id=-1)</argsstring>
        <name>Initialize</name>
        <qualifiedname>amrex::Initialize</qualifiedname>
        <param>
          <type>int &amp;</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **&amp;</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>build_parm_parse</declname>
          <defval>true</defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref></type>
          <declname>mpi_comm</declname>
          <defval><ref refid="namespaceamrex_1_1mpidatatypes_1a329d3319d614b002a09db3eb845571c1" kindref="member">MPI_COMM_WORLD</ref></defval>
        </param>
        <param>
          <type>const std::function&lt; void()&gt; &amp;</type>
          <declname>func_parm_parse</declname>
          <defval>{}</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>a_osout</declname>
          <defval>std::cout</defval>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>a_oserr</declname>
          <defval>std::cerr</defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1af6f45c130cacf67455811e9b4829f432" kindref="member">ErrorHandler</ref></type>
          <declname>a_errhandler</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type>int</type>
          <declname>a_device_id</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="93" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="353" bodyend="777" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="93" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afdedd4a55eb147e0e27194b9e06f68e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::Initialized</definition>
        <argsstring>()</argsstring>
        <name>Initialized</name>
        <qualifiedname>amrex::Initialized</qualifiedname>
        <briefdescription>
<para>Returns true if there are any currently-active and initialized <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> instances (i.e. one for which <ref refid="namespaceamrex_1a50b9b83c886549ba070ec27eb45df025" kindref="member">amrex::Initialize</ref> has been called, and <ref refid="namespaceamrex_1a8117ae9942e01445ea7fe62d2f190c64" kindref="member">amrex::Finalize</ref> has not). Otherwise false. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="118" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="780" bodyend="783" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="118" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8117ae9942e01445ea7fe62d2f190c64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Finalize</definition>
        <argsstring>(AMReX *pamrex)</argsstring>
        <name>Finalize</name>
        <qualifiedname>amrex::Finalize</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> *</type>
          <declname>pamrex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="120" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="792" bodyend="922" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="120" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a58b341e8a1b6a668812e8801b917a9de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Finalize</definition>
        <argsstring>()</argsstring>
        <name>Finalize</name>
        <qualifiedname>amrex::Finalize</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="121" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="786" bodyend="789" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="121" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad321a3965621a748d4c08e80c42b7af3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ExecOnFinalize</definition>
        <argsstring>(std::function&lt; void()&gt;)</argsstring>
        <name>ExecOnFinalize</name>
        <qualifiedname>amrex::ExecOnFinalize</qualifiedname>
        <param>
          <type>std::function&lt; void()&gt;</type>
          <defname>f</defname>
        </param>
        <briefdescription>
<para>We maintain a stack of functions that need to be called in <ref refid="namespaceamrex_1a58b341e8a1b6a668812e8801b917a9de" kindref="member">Finalize()</ref>. The functions are called in LIFO order. The idea here is to allow classes to clean up any &quot;global&quot; state that they maintain when we&apos;re exiting from <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="132" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="320" bodyend="323" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="132" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3087256f5c6ac4e3c89eb62111603d44" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ExecOnInitialize</definition>
        <argsstring>(std::function&lt; void()&gt;)</argsstring>
        <name>ExecOnInitialize</name>
        <qualifiedname>amrex::ExecOnInitialize</qualifiedname>
        <param>
          <type>std::function&lt; void()&gt;</type>
          <defname>f</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="133" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="326" bodyend="329" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="133" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0a525af3444a2814c6dbda9e71a965a5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::ignore_unused</definition>
        <argsstring>(const Ts &amp;...)</argsstring>
        <name>ignore_unused</name>
        <qualifiedname>amrex::ignore_unused</qualifiedname>
        <param>
          <type>const Ts &amp;</type>
          <declname>...</declname>
        </param>
        <briefdescription>
<para>This shuts up the compiler about unused variables. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="138" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="138" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aaa5d048f7bf7386b6976b10001a5f8b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Error</definition>
        <argsstring>(const std::string &amp;msg)</argsstring>
        <name>Error</name>
        <qualifiedname>amrex::Error</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1Print" kindref="compound">Print</ref> out message to cerr and exit via <ref refid="namespaceamrex_1ad26f2328bf66aa9678347a6055a25431" kindref="member">amrex::Abort()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="141" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="224" bodyend="227" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="141" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a620a62df5f47fd577e2628f850a447fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Error_host</definition>
        <argsstring>(const char *type, const char *msg)</argsstring>
        <name>Error_host</name>
        <qualifiedname>amrex::Error_host</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>type</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="143" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="242" bodyend="261" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="143" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a65ba5f9f63ed8993a48065da650d0eb8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Error</definition>
        <argsstring>(const char *msg=nullptr)</argsstring>
        <name>Error</name>
        <qualifiedname>amrex::Error</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>msg</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="146" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="146" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad1cc69bc2c0172148e82713abb30d2dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Warning</definition>
        <argsstring>(const std::string &amp;msg)</argsstring>
        <name>Warning</name>
        <qualifiedname>amrex::Warning</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1Print" kindref="compound">Print</ref> out warning message to cerr. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="159" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="236" bodyend="239" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="159" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac1e74d5d4c035c4f129a0cbb28077cf9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Warning_host</definition>
        <argsstring>(const char *msg)</argsstring>
        <name>Warning_host</name>
        <qualifiedname>amrex::Warning_host</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="161" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="264" bodyend="269" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="161" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab5327610ee94e063a3eb1339d7c12c58" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Warning</definition>
        <argsstring>(const char *msg)</argsstring>
        <name>Warning</name>
        <qualifiedname>amrex::Warning</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="164" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="164" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad26f2328bf66aa9678347a6055a25431" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Abort</definition>
        <argsstring>(const std::string &amp;msg)</argsstring>
        <name>Abort</name>
        <qualifiedname>amrex::Abort</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
<para><ref refid="classamrex_1_1Print" kindref="compound">Print</ref> out message to cerr and exit via abort(). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="174" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="230" bodyend="233" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="174" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9c29e5709280bec2ec21793f2761baf0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Abort</definition>
        <argsstring>(const char *msg=nullptr)</argsstring>
        <name>Abort</name>
        <qualifiedname>amrex::Abort</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>msg</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="177" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="177" bodyend="187"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af528c13b73eddf73d652b15ada1b9b1d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Assert_host</definition>
        <argsstring>(const char *EX, const char *file, int line, const char *msg, std::size_t msg_size=0)</argsstring>
        <name>Assert_host</name>
        <qualifiedname>amrex::Assert_host</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>EX</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>file</declname>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>msg</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>msg_size</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Prints assertion failed messages to cerr and exits via abort(). Intended for use by the <ref refid="AMReX__BLassert_8H_1a53ebc8b227de416f458800faa44c619e" kindref="member">BL_ASSERT()</ref> macro in &lt;<ref refid="AMReX__BLassert_8H" kindref="compound">AMReX_BLassert.H</ref>&gt;. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="195" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="272" bodyend="311" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="195" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a02fd700ccb02993f5c052928dff4e4ca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Assert</definition>
        <argsstring>(const char *EX, const char *file, int line)</argsstring>
        <name>Assert</name>
        <qualifiedname>amrex::Assert</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>EX</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>file</declname>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="199" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="199" bodyend="210"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad11e1e9056b5f7d1a9bba059aff7257e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Assert</definition>
        <argsstring>(const char *EX, const char *file, int line, const char *msg)</argsstring>
        <name>Assert</name>
        <qualifiedname>amrex::Assert</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>EX</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>file</declname>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="213" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="213" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae655d96541d183e84c3857655b7c25ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Assert</definition>
        <argsstring>(const char *EX, const char *file, int line, const std::string &amp;msg)</argsstring>
        <name>Assert</name>
        <qualifiedname>amrex::Assert</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>EX</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>file</declname>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>msg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="227" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="227" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0c0dc9355722e150b88c6fc71422288e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::write_to_stderr_without_buffering</definition>
        <argsstring>(const char *str)</argsstring>
        <name>write_to_stderr_without_buffering</name>
        <qualifiedname>amrex::write_to_stderr_without_buffering</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>This is used by <ref refid="namespaceamrex_1aaa5d048f7bf7386b6976b10001a5f8b4" kindref="member">amrex::Error()</ref>, <ref refid="namespaceamrex_1ad26f2328bf66aa9678347a6055a25431" kindref="member">amrex::Abort()</ref>, and <ref refid="namespaceamrex_1a02fd700ccb02993f5c052928dff4e4ca" kindref="member">amrex::Assert()</ref> to ensure that when writing the message to stderr, that no additional heap-based memory is allocated. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="236" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="188" bodyend="206" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="236" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a448749e34552187d2fa9254841970a6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::SetErrorHandler</definition>
        <argsstring>(ErrorHandler f)</argsstring>
        <name>SetErrorHandler</name>
        <qualifiedname>amrex::SetErrorHandler</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1af6f45c130cacf67455811e9b4829f432" kindref="member">ErrorHandler</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="238" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="177" bodyend="179" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="238" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1add2f0f36ce80f2f3934e3a8ec2a966df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::OutStream</definition>
        <argsstring>()</argsstring>
        <name>OutStream</name>
        <qualifiedname>amrex::OutStream</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="240" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="925" bodyend="928" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="240" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1e213ab52cdac41e691ab49370b30a34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::ErrorStream</definition>
        <argsstring>()</argsstring>
        <name>ErrorStream</name>
        <qualifiedname>amrex::ErrorStream</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="241" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="931" bodyend="934" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="241" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acafd26c0f64d958aed9ee56043c4f10e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::Verbose</definition>
        <argsstring>() noexcept</argsstring>
        <name>Verbose</name>
        <qualifiedname>amrex::Verbose</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="243" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="169" bodyend="169" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="243" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a125dcbb8afa7e676566242972a5b7757" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::SetVerbose</definition>
        <argsstring>(int v) noexcept</argsstring>
        <name>SetVerbose</name>
        <qualifiedname>amrex::SetVerbose</qualifiedname>
        <param>
          <type>int</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="244" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="171" bodyend="171" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="244" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a48ee24ac226396b92932d8d533d68af1" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::InitSNaN</definition>
        <argsstring>() noexcept</argsstring>
        <name>InitSNaN</name>
        <qualifiedname>amrex::InitSNaN</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="246" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="173" bodyend="173" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="246" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac250c5ca9b8aaa82a1fc020e6855ae07" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::SetInitSNaN</definition>
        <argsstring>(bool v) noexcept</argsstring>
        <name>SetInitSNaN</name>
        <qualifiedname>amrex::SetInitSNaN</qualifiedname>
        <param>
          <type>bool</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="247" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="175" bodyend="175" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="247" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0b2451baea738a8717530466c13f37fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::get_command</definition>
        <argsstring>()</argsstring>
        <name>get_command</name>
        <qualifiedname>amrex::get_command</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="250" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="937" bodyend="940" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="250" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0f3d8f755663a93f3953f7cda5590cac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::command_argument_count</definition>
        <argsstring>()</argsstring>
        <name>command_argument_count</name>
        <qualifiedname>amrex::command_argument_count</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="253" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="943" bodyend="946" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="253" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a566544464dedd2d70fe9969fc79658cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::get_command_argument</definition>
        <argsstring>(int number)</argsstring>
        <name>get_command_argument</name>
        <qualifiedname>amrex::get_command_argument</qualifiedname>
        <param>
          <type>int</type>
          <declname>number</declname>
        </param>
        <briefdescription>
<para>Get command line arguments. The executable name is the zero-th argument. Return empty string if there are not that many arguments. std::string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="260" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.cpp" bodystart="949" bodyend="956" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" declline="260" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9d0fa7afb6bbeb5e81b5570445599fbf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::GccPlacater</definition>
        <argsstring>()</argsstring>
        <name>GccPlacater</name>
        <qualifiedname>amrex::GccPlacater</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="263" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="263" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a60b385a670733e5570818f7007307e1c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::any</definition>
        <argsstring>(FPExcept a)</argsstring>
        <name>any</name>
        <qualifiedname>amrex::any</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="338" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="338" bodyend="338"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a61941cdb68b6ca2b6bd0ccef3831019b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
        <definition>FPExcept amrex::operator|</definition>
        <argsstring>(FPExcept a, FPExcept b)</argsstring>
        <name>operator|</name>
        <qualifiedname>amrex::operator|</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="340" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="340" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acaadf207d66c9ffa15b672effdca6eab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
        <definition>FPExcept amrex::operator&amp;</definition>
        <argsstring>(FPExcept a, FPExcept b)</argsstring>
        <name>operator&amp;</name>
        <qualifiedname>amrex::operator&amp;</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a242c1fdf859dbcbdecd2794373ea0d2c" kindref="member">FPExcept</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" line="346" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX.H" bodystart="346" bodyend="350"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a66e2eab6a08dc06e8892a05efdc832c7" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr const T &amp;</type>
        <definition>__host__ __device__ constexpr const T &amp; amrex::min</definition>
        <argsstring>(const T &amp;a, const T &amp;b) noexcept</argsstring>
        <name>min</name>
        <qualifiedname>amrex::min</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="21" column="32" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="21" bodyend="24"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9526defdf8a172dfef964620c6530d03" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr const T &amp;</type>
        <definition>__host__ __device__ constexpr const T &amp; amrex::min</definition>
        <argsstring>(const T &amp;a, const T &amp;b, const Ts &amp;... c) noexcept</argsstring>
        <name>min</name>
        <qualifiedname>amrex::min</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const Ts &amp;...</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="28" column="32" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="28" bodyend="31"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9d99cb1523b9f336dad742f6a15bdf59" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr const T &amp;</type>
        <definition>__host__ __device__ constexpr const T &amp; amrex::max</definition>
        <argsstring>(const T &amp;a, const T &amp;b) noexcept</argsstring>
        <name>max</name>
        <qualifiedname>amrex::max</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="35" column="32" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="35" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aefa062243bd4a4215308cd1b27aea98c" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr const T &amp;</type>
        <definition>__host__ __device__ constexpr const T &amp; amrex::max</definition>
        <argsstring>(const T &amp;a, const T &amp;b, const Ts &amp;... c) noexcept</argsstring>
        <name>max</name>
        <qualifiedname>amrex::max</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const Ts &amp;...</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="42" column="32" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="42" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af4ef71de20b680abfb05fddbe1e4ace7" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr T</type>
        <definition>__host__ __device__ constexpr T amrex::elemwiseMin</definition>
        <argsstring>(T const &amp;a, T const &amp;b) noexcept</argsstring>
        <name>elemwiseMin</name>
        <qualifiedname>amrex::elemwiseMin</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="49" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="49" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8055ba6e4c232b9dcfa2a759ef4b7787" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr T</type>
        <definition>__host__ __device__ constexpr T amrex::elemwiseMin</definition>
        <argsstring>(const T &amp;a, const T &amp;b, const Ts &amp;... c) noexcept</argsstring>
        <name>elemwiseMin</name>
        <qualifiedname>amrex::elemwiseMin</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const Ts &amp;...</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="55" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="55" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a55d850a6aec956259d9fbc1ef06e9722" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr T</type>
        <definition>__host__ __device__ constexpr T amrex::elemwiseMax</definition>
        <argsstring>(T const &amp;a, T const &amp;b) noexcept</argsstring>
        <name>elemwiseMax</name>
        <qualifiedname>amrex::elemwiseMax</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="62" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="62" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae38a1a3fcd8702295c3f64d87cd056b8" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr T</type>
        <definition>__host__ __device__ constexpr T amrex::elemwiseMax</definition>
        <argsstring>(const T &amp;a, const T &amp;b, const Ts &amp;... c) noexcept</argsstring>
        <name>elemwiseMax</name>
        <qualifiedname>amrex::elemwiseMax</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const Ts &amp;...</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="68" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="68" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1c182abe7695240cd35e1ba3d4477758" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Swap</definition>
        <argsstring>(T &amp;t1, T &amp;t2) noexcept</argsstring>
        <name>Swap</name>
        <qualifiedname>amrex::Swap</qualifiedname>
        <param>
          <type>T &amp;</type>
          <declname>t1</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>t2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="75" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="75" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a61fd7da0bbaba8c15a54fab7356ef1db" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr const T &amp;</type>
        <definition>__host__ __device__ constexpr const T &amp; amrex::Clamp</definition>
        <argsstring>(const T &amp;v, const T &amp;lo, const T &amp;hi)</argsstring>
        <name>Clamp</name>
        <qualifiedname>amrex::Clamp</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>lo</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>hi</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="84" column="23" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="84" bodyend="87"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8defcf36ddf219cae1fed871e05e78e3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt;, bool &gt;</type>
        <definition>__host__ __device__ std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt;, bool &gt; amrex::almostEqual</definition>
        <argsstring>(T x, T y, int ulp=2)</argsstring>
        <name>almostEqual</name>
        <qualifiedname>amrex::almostEqual</qualifiedname>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <param>
          <type>T</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ulp</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="93" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="93" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a00bdafca20ac708320d704d4da6976f0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt;, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ T</type>
        <definition>__host__ __device__ T amrex::bisect</definition>
        <argsstring>(T lo, T hi, F f, T tol=1e-12, int max_iter=100)</argsstring>
        <name>bisect</name>
        <qualifiedname>amrex::bisect</qualifiedname>
        <param>
          <type>T</type>
          <declname>lo</declname>
        </param>
        <param>
          <type>T</type>
          <declname>hi</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type>T</type>
          <declname>tol</declname>
          <defval>1e-12</defval>
        </param>
        <param>
          <type>int</type>
          <declname>max_iter</declname>
          <defval>100</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="105" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="105" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7d59f8eb44002bb99f5b72dc715f9e96" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; I &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ I</type>
        <definition>__host__ __device__ I amrex::bisect</definition>
        <argsstring>(T const *d, I lo, I hi, T const &amp;v)</argsstring>
        <name>bisect</name>
        <qualifiedname>amrex::bisect</qualifiedname>
        <param>
          <type>T const *</type>
          <declname>d</declname>
        </param>
        <param>
          <type>I</type>
          <declname>lo</declname>
        </param>
        <param>
          <type>I</type>
          <declname>hi</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="146" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="146" bodyend="158"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0a1ab0a65a603d33befa6ab7ab2f6ee1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ItType</type>
          </param>
          <param>
            <type>typename ValType</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ ItType</type>
        <definition>__host__ __device__ ItType amrex::upper_bound</definition>
        <argsstring>(ItType first, ItType last, const ValType &amp;val)</argsstring>
        <name>upper_bound</name>
        <qualifiedname>amrex::upper_bound</qualifiedname>
        <param>
          <type>ItType</type>
          <declname>first</declname>
        </param>
        <param>
          <type>ItType</type>
          <declname>last</declname>
        </param>
        <param>
          <type>const ValType &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="162" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="162" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6d70f9830e9b3e4debf25ae90e125f14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ItType</type>
          </param>
          <param>
            <type>typename ValType</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ ItType</type>
        <definition>__host__ __device__ ItType amrex::lower_bound</definition>
        <argsstring>(ItType first, ItType last, const ValType &amp;val)</argsstring>
        <name>lower_bound</name>
        <qualifiedname>amrex::lower_bound</qualifiedname>
        <param>
          <type>ItType</type>
          <declname>first</declname>
        </param>
        <param>
          <type>ItType</type>
          <declname>last</declname>
        </param>
        <param>
          <type>const ValType &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="187" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="187" bodyend="210"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae14af77635298b20192e1a355acf43b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ItType</type>
          </param>
          <param>
            <type>typename ValType</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_floating_point_v&lt; typename std::iterator_traits&lt; ItType &gt;::value_type &gt; &amp;&amp;std::is_floating_point_v&lt; ValType &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::linspace</definition>
        <argsstring>(ItType first, const ItType &amp;last, const ValType &amp;start, const ValType &amp;stop)</argsstring>
        <name>linspace</name>
        <qualifiedname>amrex::linspace</qualifiedname>
        <param>
          <type>ItType</type>
          <declname>first</declname>
        </param>
        <param>
          <type>const ItType &amp;</type>
          <declname>last</declname>
        </param>
        <param>
          <type>const ValType &amp;</type>
          <declname>start</declname>
        </param>
        <param>
          <type>const ValType &amp;</type>
          <declname>stop</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="218" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="218" bodyend="228"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac4094518716f4e3a78ead5bb32b682b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ItType</type>
          </param>
          <param>
            <type>typename ValType</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_floating_point_v&lt; typename std::iterator_traits&lt; ItType &gt;::value_type &gt; &amp;&amp;std::is_floating_point_v&lt; ValType &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::logspace</definition>
        <argsstring>(ItType first, const ItType &amp;last, const ValType &amp;start, const ValType &amp;stop, const ValType &amp;base)</argsstring>
        <name>logspace</name>
        <qualifiedname>amrex::logspace</qualifiedname>
        <param>
          <type>ItType</type>
          <declname>first</declname>
        </param>
        <param>
          <type>const ItType &amp;</type>
          <declname>last</declname>
        </param>
        <param>
          <type>const ValType &amp;</type>
          <declname>start</declname>
        </param>
        <param>
          <type>const ValType &amp;</type>
          <declname>stop</declname>
        </param>
        <param>
          <type>const ValType &amp;</type>
          <declname>base</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="236" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="236" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aeb40d9124d428dcc8daf5f69933d3908" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; std::decay_t&lt; T &gt;, std::uint8_t &gt;||std::is_same_v&lt; std::decay_t&lt; T &gt;, std::uint16_t &gt;||std::is_same_v&lt; std::decay_t&lt; T &gt;, std::uint32_t &gt;||std::is_same_v&lt; std::decay_t&lt; T &gt;, std::uint64_t &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ int</type>
        <definition>__host__ __device__ int amrex::clz</definition>
        <argsstring>(T x) noexcept</argsstring>
        <name>clz</name>
        <qualifiedname>amrex::clz</qualifiedname>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" line="358" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" bodystart="358" bodyend="366" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Algorithm.H" declline="289" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae3d1414946b992f39ca41f135f12a0d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Arena" kindref="compound">Arena</ref> *</type>
        <definition>Arena * amrex::The_Arena</definition>
        <argsstring>()</argsstring>
        <name>The_Arena</name>
        <qualifiedname>amrex::The_Arena</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" line="783" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" bodystart="783" bodyend="790" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" declline="44" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad371ec91e94c5131b6002127a1008157" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Arena" kindref="compound">Arena</ref> *</type>
        <definition>Arena * amrex::The_Async_Arena</definition>
        <argsstring>()</argsstring>
        <name>The_Async_Arena</name>
        <qualifiedname>amrex::The_Async_Arena</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" line="793" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" bodystart="793" bodyend="800" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" declline="45" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a97a60825e6e7886b3502c2f4ed1eb417" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Arena" kindref="compound">Arena</ref> *</type>
        <definition>Arena * amrex::The_Device_Arena</definition>
        <argsstring>()</argsstring>
        <name>The_Device_Arena</name>
        <qualifiedname>amrex::The_Device_Arena</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" line="803" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" bodystart="803" bodyend="810" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" declline="46" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a76cc74eb7c42bf4d111ac5cae5db8420" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Arena" kindref="compound">Arena</ref> *</type>
        <definition>Arena * amrex::The_Managed_Arena</definition>
        <argsstring>()</argsstring>
        <name>The_Managed_Arena</name>
        <qualifiedname>amrex::The_Managed_Arena</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" line="813" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" bodystart="813" bodyend="820" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" declline="47" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aba0258410952c3ccfe405a462ef2d887" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Arena" kindref="compound">Arena</ref> *</type>
        <definition>Arena * amrex::The_Pinned_Arena</definition>
        <argsstring>()</argsstring>
        <name>The_Pinned_Arena</name>
        <qualifiedname>amrex::The_Pinned_Arena</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" line="823" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" bodystart="823" bodyend="830" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" declline="48" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adcb4e473f4a6058ae8abd15c75bde706" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Arena" kindref="compound">Arena</ref> *</type>
        <definition>Arena * amrex::The_Cpu_Arena</definition>
        <argsstring>()</argsstring>
        <name>The_Cpu_Arena</name>
        <qualifiedname>amrex::The_Cpu_Arena</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" line="833" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" bodystart="833" bodyend="840" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" declline="50" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a867372a2ed191bd458e5e487ae3e6fa1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Arena" kindref="compound">Arena</ref> *</type>
        <definition>Arena * amrex::The_Comms_Arena</definition>
        <argsstring>()</argsstring>
        <name>The_Comms_Arena</name>
        <qualifiedname>amrex::The_Comms_Arena</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" line="843" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.cpp" bodystart="843" bodyend="850" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" declline="49" declcolumn="7"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad7bef6630afa8a2109d2a242cc2d7591" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t amrex::aligned_size</definition>
        <argsstring>(std::size_t align_requirement, std::size_t size) noexcept</argsstring>
        <name>aligned_size</name>
        <qualifiedname>amrex::aligned_size</qualifiedname>
        <param>
          <type>std::size_t</type>
          <declname>align_requirement</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Given a minimum required size of size bytes, this returns the next largest arena size that will align to align_requirement bytes. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" line="30" column="20" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" bodystart="30" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a73309828f34cc814833092699bdbc241" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::is_aligned</definition>
        <argsstring>(const void *p, std::size_t alignment) noexcept</argsstring>
        <name>is_aligned</name>
        <qualifiedname>amrex::is_aligned</qualifiedname>
        <param>
          <type>const void *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>alignment</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" line="35" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Arena.H" bodystart="35" bodyend="40"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6fd91e3438328994318629db66d67eec" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename T::FABType</defval>
          </param>
        </templateparamlist>
        <type>std::array&lt; T *, 3 &gt;</type>
        <definition>std::array&lt; T *, 3 &gt; amrex::GetArrOfPtrs</definition>
        <argsstring>(std::array&lt; T, 3 &gt; &amp;a) noexcept</argsstring>
        <name>GetArrOfPtrs</name>
        <qualifiedname>amrex::GetArrOfPtrs</qualifiedname>
        <param>
          <type>std::array&lt; T, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" line="1004" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" bodystart="1004" bodyend="1007"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af3ee66042454b6246d2e887a5710435d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::array&lt; T *, 3 &gt;</type>
        <definition>std::array&lt; T *, 3 &gt; amrex::GetArrOfPtrs</definition>
        <argsstring>(const std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &amp;a) noexcept</argsstring>
        <name>GetArrOfPtrs</name>
        <qualifiedname>amrex::GetArrOfPtrs</qualifiedname>
        <param>
          <type>const std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" line="1010" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" bodystart="1010" bodyend="1013"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a11874f0ad8ce6fca0dc5764a2ad64df1" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::array&lt; T const *, 3 &gt;</type>
        <definition>std::array&lt; T const  *, 3 &gt; amrex::GetArrOfConstPtrs</definition>
        <argsstring>(const std::array&lt; T, 3 &gt; &amp;a) noexcept</argsstring>
        <name>GetArrOfConstPtrs</name>
        <qualifiedname>amrex::GetArrOfConstPtrs</qualifiedname>
        <param>
          <type>const std::array&lt; T, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" line="1016" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" bodystart="1016" bodyend="1019"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9f2beefbc321474791906031b2466227" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::array&lt; T const *, 3 &gt;</type>
        <definition>std::array&lt; T const  *, 3 &gt; amrex::GetArrOfConstPtrs</definition>
        <argsstring>(const std::array&lt; T *, 3 &gt; &amp;a) noexcept</argsstring>
        <name>GetArrOfConstPtrs</name>
        <qualifiedname>amrex::GetArrOfConstPtrs</qualifiedname>
        <param>
          <type>const std::array&lt; T *, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" line="1022" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" bodystart="1022" bodyend="1025"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a32bb77f8057351a9182c03ea9ec6cda4" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::array&lt; T const *, 3 &gt;</type>
        <definition>std::array&lt; T const  *, 3 &gt; amrex::GetArrOfConstPtrs</definition>
        <argsstring>(const std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &amp;a) noexcept</argsstring>
        <name>GetArrOfConstPtrs</name>
        <qualifiedname>amrex::GetArrOfConstPtrs</qualifiedname>
        <param>
          <type>const std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" line="1028" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" bodystart="1028" bodyend="1031"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2fb02d7c62025643663f5a9f154a6547" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref></type>
        <definition>XDim3 amrex::makeXDim3</definition>
        <argsstring>(const Array&lt; Real, 3 &gt; &amp;a) noexcept</argsstring>
        <name>makeXDim3</name>
        <qualifiedname>amrex::makeXDim3</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref>, 3 &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" line="1037" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array.H" bodystart="1037" bodyend="1046"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4eb610e50ec9d0311a2a0b0531484ecc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type></type>
        <definition>amrex::ArrayND</definition>
        <argsstring>(T *, BoxND&lt; N &gt; const &amp;) -&gt; ArrayND&lt; T, N, false &gt;</argsstring>
        <name>ArrayND</name>
        <qualifiedname>amrex::ArrayND</qualifiedname>
        <param>
          <type>T *</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; N &gt; const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="757" column="5" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" declline="757" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab343fd634872754a3158b329def6e0d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type></type>
        <definition>amrex::ArrayND</definition>
        <argsstring>(T *, BoxND&lt; N &gt; const &amp;, int) -&gt; ArrayND&lt; T, N+1, true &gt;</argsstring>
        <name>ArrayND</name>
        <qualifiedname>amrex::ArrayND</qualifiedname>
        <param>
          <type>T *</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; N &gt; const &amp;</type>
        </param>
        <param>
          <type>int</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="762" column="5" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" declline="762" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acf1b278ff6bd0c975123f7ec21411a34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type></type>
        <definition>amrex::ArrayND</definition>
        <argsstring>(T *, IntVectND&lt; N &gt; const &amp;, IntVectND&lt; N &gt; const &amp;) -&gt; ArrayND&lt; T, N, false &gt;</argsstring>
        <name>ArrayND</name>
        <qualifiedname>amrex::ArrayND</qualifiedname>
        <param>
          <type>T *</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; N &gt; const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; N &gt; const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="766" column="5" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" declline="766" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af20f42ed2d48cfb0865f73b0c3e01103" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type></type>
        <definition>amrex::ArrayND</definition>
        <argsstring>(T *, IntVectND&lt; N &gt; const &amp;, IntVectND&lt; N &gt; const &amp;, int) -&gt; ArrayND&lt; T, N+1, true &gt;</argsstring>
        <name>ArrayND</name>
        <qualifiedname>amrex::ArrayND</qualifiedname>
        <param>
          <type>T *</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; N &gt; const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; N &gt; const &amp;</type>
        </param>
        <param>
          <type>int</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="770" column="5" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" declline="770" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a69dab39f98b607ded324831b726e424f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>amrex::ArrayND</definition>
        <argsstring>(T *, Dim3 const &amp;, Dim3 const &amp;, int) -&gt; ArrayND&lt; T, 4, true &gt;</argsstring>
        <name>ArrayND</name>
        <qualifiedname>amrex::ArrayND</qualifiedname>
        <param>
          <type>T *</type>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> const &amp;</type>
        </param>
        <param>
          <type>int</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="774" column="5" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" declline="774" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afad6a65d8f99b00c14e8de32e2806fd7" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::lbound</definition>
        <argsstring>(Array4&lt; T &gt; const &amp;a) noexcept</argsstring>
        <name>lbound</name>
        <qualifiedname>amrex::lbound</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; T &gt; const &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="781" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" bodystart="781" bodyend="784"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a00ddc55986bb8cc48ba98491e5d5ba52" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::ubound</definition>
        <argsstring>(Array4&lt; T &gt; const &amp;a) noexcept</argsstring>
        <name>ubound</name>
        <qualifiedname>amrex::ubound</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; T &gt; const &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="788" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" bodystart="788" bodyend="791"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3078c8f88bd6a4f625b7057c7370f7cc" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::length</definition>
        <argsstring>(Array4&lt; T &gt; const &amp;a) noexcept</argsstring>
        <name>length</name>
        <qualifiedname>amrex::length</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; T &gt; const &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="795" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" bodystart="795" bodyend="798"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a41c0202f94cace534ac4555aff7c841d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>C</declname>
            <defname>C</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const ArrayND&lt; T, N, C &gt; &amp;a)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1ArrayND" kindref="compound">ArrayND</ref>&lt; T, N, <ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a0d61f8370cad1d412f80b84d143e1257" kindref="member">C</ref> &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="801" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" bodystart="801" bodyend="804"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad1efaa3873e5b9015cfd7b4ede4ba1f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structamrex_1_1PolymorphicArray4" kindref="compound">PolymorphicArray4</ref>&lt; T &gt;</type>
        <definition>PolymorphicArray4&lt; T &gt; amrex::makePolymorphic</definition>
        <argsstring>(Array4&lt; T &gt; const &amp;a)</argsstring>
        <name>makePolymorphic</name>
        <qualifiedname>amrex::makePolymorphic</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; T &gt; const &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" line="849" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Array4.H" bodystart="849" bodyend="852"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a652bd22fb8cfcdfeaa4ac62e81a41fe6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::BaseFab_Initialize</definition>
        <argsstring>()</argsstring>
        <name>BaseFab_Initialize</name>
        <qualifiedname>amrex::BaseFab_Initialize</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" line="30" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" bodystart="30" bodyend="56" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" declline="67" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a67b24cef9df62e8cced041445b239e86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::BaseFab_Finalize</definition>
        <argsstring>()</argsstring>
        <name>BaseFab_Finalize</name>
        <qualifiedname>amrex::BaseFab_Finalize</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" line="59" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" bodystart="59" bodyend="62" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" declline="68" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a587a3cb57cff4b7fa72c7c1d4d98900b" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::TotalBytesAllocatedInFabs</definition>
        <argsstring>() noexcept</argsstring>
        <name>TotalBytesAllocatedInFabs</name>
        <qualifiedname>amrex::TotalBytesAllocatedInFabs</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" line="66" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" bodystart="66" bodyend="80" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" declline="60" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a95a2c5251b0bc8cc9f28f6384738404a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::TotalBytesAllocatedInFabsHWM</definition>
        <argsstring>() noexcept</argsstring>
        <name>TotalBytesAllocatedInFabsHWM</name>
        <qualifiedname>amrex::TotalBytesAllocatedInFabsHWM</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" line="83" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" bodystart="83" bodyend="97" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" declline="61" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa9ed510cedd140658efd18542d9479c7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::TotalCellsAllocatedInFabs</definition>
        <argsstring>() noexcept</argsstring>
        <name>TotalCellsAllocatedInFabs</name>
        <qualifiedname>amrex::TotalCellsAllocatedInFabs</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" line="100" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" bodystart="100" bodyend="114" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" declline="62" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa85143ea71ce835e3a64ce8551b726b4" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::TotalCellsAllocatedInFabsHWM</definition>
        <argsstring>() noexcept</argsstring>
        <name>TotalCellsAllocatedInFabsHWM</name>
        <qualifiedname>amrex::TotalCellsAllocatedInFabsHWM</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" line="117" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" bodystart="117" bodyend="131" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" declline="63" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a765c5cc6e670eb707740d51c99e7b35e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ResetTotalBytesAllocatedInFabsHWM</definition>
        <argsstring>() noexcept</argsstring>
        <name>ResetTotalBytesAllocatedInFabsHWM</name>
        <qualifiedname>amrex::ResetTotalBytesAllocatedInFabsHWM</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" line="134" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" bodystart="134" bodyend="143" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" declline="64" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae096acad3cf4e038809c53d73c0c57c8" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::update_fab_stats</definition>
        <argsstring>(Long n, Long s, size_t szt) noexcept</argsstring>
        <name>update_fab_stats</name>
        <qualifiedname>amrex::update_fab_stats</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>s</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>szt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" line="146" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.cpp" bodystart="146" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a610006830e72a750eb65c44c5a540695" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::update_fab_stats</definition>
        <argsstring>(Long n, Long s, std::size_t szt) noexcept</argsstring>
        <name>update_fab_stats</name>
        <qualifiedname>amrex::update_fab_stats</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>s</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>szt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" line="65" column="6" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" declline="65" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a210f2e40437f79c38535ce7cf847642a" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ Array4&lt; T &gt; amrex::makeArray4</definition>
        <argsstring>(T *p, Box const &amp;bx, int ncomp) noexcept</argsstring>
        <name>makeArray4</name>
        <qualifiedname>amrex::makeArray4</qualifiedname>
        <param>
          <type>T *</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" line="91" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" bodystart="91" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a37e7fca457f1fa445077469fa8110443" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt; amrex::placementNew</definition>
        <argsstring>(T *const, Long)</argsstring>
        <name>placementNew</name>
        <qualifiedname>amrex::placementNew</qualifiedname>
        <param>
          <type>T * const</type>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" line="98" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" bodystart="98" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1f7795a2449ec3d82382fe16b9721850" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_trivially_default_constructible_v&lt; T &gt; &amp;&amp;!std::is_arithmetic_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_trivially_default_constructible_v&lt; T &gt; &amp;&amp;!std::is_arithmetic_v&lt; T &gt; &gt; amrex::placementNew</definition>
        <argsstring>(T *const ptr, Long n)</argsstring>
        <name>placementNew</name>
        <qualifiedname>amrex::placementNew</qualifiedname>
        <param>
          <type>T *const</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" line="104" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" bodystart="104" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aab359a0dda88a4d04ed3b85ad1f34635" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!std::is_trivially_default_constructible_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt;!std::is_trivially_default_constructible_v&lt; T &gt; &gt; amrex::placementNew</definition>
        <argsstring>(T *const ptr, Long n)</argsstring>
        <name>placementNew</name>
        <qualifiedname>amrex::placementNew</qualifiedname>
        <param>
          <type>T *const</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" line="113" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" bodystart="113" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abfcd362c43fc0a141e3d38b64e7cd8a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_trivially_destructible_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_trivially_destructible_v&lt; T &gt; &gt; amrex::placementDelete</definition>
        <argsstring>(T *const, Long)</argsstring>
        <name>placementDelete</name>
        <qualifiedname>amrex::placementDelete</qualifiedname>
        <param>
          <type>T * const</type>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" line="123" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" bodystart="123" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acc27e73c011e49ac271d3dcdd03d901e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!std::is_trivially_destructible_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt;!std::is_trivially_destructible_v&lt; T &gt; &gt; amrex::placementDelete</definition>
        <argsstring>(T *const ptr, Long n)</argsstring>
        <name>placementDelete</name>
        <qualifiedname>amrex::placementDelete</qualifiedname>
        <param>
          <type>T *const</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" line="128" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFab.H" bodystart="128" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a238562144a9a4a23191bdb450d4b5c5b" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Tto</type>
          </param>
          <param>
            <type>class Tfrom</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::cast</definition>
        <argsstring>(BaseFab&lt; Tto &gt; &amp;tofab, BaseFab&lt; Tfrom &gt; const &amp;fromfab, Box const &amp;bx, SrcComp scomp, DestComp dcomp, NumComps ncomp) noexcept</argsstring>
        <name>cast</name>
        <qualifiedname>amrex::cast</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; Tto &gt; &amp;</type>
          <declname>tofab</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; Tfrom &gt; const &amp;</type>
          <declname>fromfab</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1SrcComp" kindref="compound">SrcComp</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1DestComp" kindref="compound">DestComp</ref></type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NumComps" kindref="compound">NumComps</ref></type>
          <declname>ncomp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFabUtility.H" line="13" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFabUtility.H" bodystart="13" bodyend="22"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7b3c5a372f37d8bb9aa21a76a5129a95" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename STRUCT</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;(sizeof(STRUCT)&lt;=36 *8) &amp;&amp;std::is_trivially_copyable_v&lt; STRUCT &gt; &amp;&amp;std::is_trivially_destructible_v&lt; STRUCT &gt;, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::fill</definition>
        <argsstring>(BaseFab&lt; STRUCT &gt; &amp;aos_fab, F const &amp;f)</argsstring>
        <name>fill</name>
        <qualifiedname>amrex::fill</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; STRUCT &gt; &amp;</type>
          <declname>aos_fab</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFabUtility.H" line="29" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFabUtility.H" bodystart="29" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a145b9fc071ef1dcce318e0652c226e02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::transposeCtoF</definition>
        <argsstring>(T const *pi, T *po, int nx, int ny, int nz)</argsstring>
        <name>transposeCtoF</name>
        <qualifiedname>amrex::transposeCtoF</qualifiedname>
        <param>
          <type>T const *</type>
          <declname>pi</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>po</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ny</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nz</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Transpose 3D array (nx,ny,nz) from row-major (i.e. C order) to column-major (Fortran order). The input&apos;s unit stride direction is z, whereas the output&apos;s unit stride direction is x. Note that for GPU builds, the kernel runs on the current GPU stream asynchronously with respect to the host. If synchronization is needed, it&apos;s up to the user to call <computeroutput><ref refid="namespaceamrex_1_1Gpu_1a67a618504ee5fb94bd65a5d393e344b4" kindref="member">amrex::Gpu::streamSynchronize()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFabUtility.H" line="105" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFabUtility.H" bodystart="105" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a66180cb7652c231d66901a5ff7dcb804" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::transposeCtoF</definition>
        <argsstring>(T const *pi, T *po, int nx, int ny)</argsstring>
        <name>transposeCtoF</name>
        <qualifiedname>amrex::transposeCtoF</qualifiedname>
        <param>
          <type>T const *</type>
          <declname>pi</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>po</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ny</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Transpose 2D array (nx,ny) from row-major (i.e. C order) to column-major (Fortran order). The input&apos;s unit stride direction is y, whereas the output&apos;s unit stride direction is x. Note that for GPU builds, the kernel runs on the current GPU stream asynchronously with respect to the host. If synchronization is needed, it&apos;s up to the user to call <computeroutput><ref refid="namespaceamrex_1_1Gpu_1a67a618504ee5fb94bd65a5d393e344b4" kindref="member">amrex::Gpu::streamSynchronize()</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFabUtility.H" line="257" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BaseFabUtility.H" bodystart="257" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac58ae562e33ec29796418c84ad3d07dc" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::setBC</definition>
        <argsstring>(const Box &amp;bx, const Box &amp;domain, int src_comp, int dest_comp, int ncomp, const Vector&lt; BCRec &gt; &amp;bc_dom, Vector&lt; BCRec &gt; &amp;bcr) noexcept</argsstring>
        <name>setBC</name>
        <qualifiedname>amrex::setBC</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type>int</type>
          <declname>src_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dest_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bc_dom</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bcr</declname>
        </param>
        <briefdescription>
<para>Function for setting array of BCs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCRec.cpp" line="8" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCRec.cpp" bodystart="8" bodyend="32" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCRec.H" declline="170" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6200dfaa632683c58a430e2d23b8d516" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const BCRec &amp;b)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCRec.cpp" line="34" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCRec.cpp" bodystart="35" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a60c51b53218578b8560c262e7a48a08c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::setBC</definition>
        <argsstring>(const Box &amp;bx, const Box &amp;domain, const BCRec &amp;bc_dom, BCRec &amp;bcr) noexcept</argsstring>
        <name>setBC</name>
        <qualifiedname>amrex::setBC</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &amp;</type>
          <declname>bc_dom</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &amp;</type>
          <declname>bcr</declname>
        </param>
        <briefdescription>
<para>Function for setting a BC. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCRec.H" line="153" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCRec.H" bodystart="153" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0b7407c69f5df5cb424eccddb336331b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::FillDomainBoundary</definition>
        <argsstring>(MultiFab &amp;phi, const Geometry &amp;geom, const Vector&lt; BCRec &gt; &amp;bc)</argsstring>
        <name>FillDomainBoundary</name>
        <qualifiedname>amrex::FillDomainBoundary</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>phi</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>bc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCUtil.cpp" line="36" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCUtil.cpp" bodystart="36" bodyend="56" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BCUtil.H" declline="18" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6f6fae4428a3e15f113ba80d2523a634" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::AMREX_FORT_NAME</definition>
        <argsstring>(BL_PROFFORTFUNCSTART_CPP, bl_proffortfuncstart_cpp)(const int[]</argsstring>
        <name>AMREX_FORT_NAME</name>
        <qualifiedname>amrex::AMREX_FORT_NAME</qualifiedname>
        <param>
          <type>BL_PROFFORTFUNCSTART_CPP</type>
        </param>
        <param>
          <type>bl_proffortfuncstart_cpp</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BLProfiler.cpp" line="1662" column="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad433171e426d58e2414c5394bfe0303c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::AllGatherBoxes</definition>
        <argsstring>(Vector&lt; Box &gt; &amp;bxs, int n_extra_reserve)</argsstring>
        <name>AllGatherBoxes</name>
        <qualifiedname>amrex::AllGatherBoxes</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &gt; &amp;</type>
          <declname>bxs</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n_extra_reserve</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.cpp" line="124" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.cpp" bodystart="124" bodyend="199" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" declline="1264" declcolumn="6"/>
      </memberdef>
      <member refid="group__amrex__index__space_1gac0f0db5587c264e8397139733225a229" kind="function"><name>grow</name></member>
      <member refid="group__amrex__index__space_1ga8b684a24eac8fbfe3f7c2f3f8c098562" kind="function"><name>grow</name></member>
      <member refid="group__amrex__index__space_1ga86cadfdb86c9a1dd0966cf2b9eb8721f" kind="function"><name>grow</name></member>
      <member refid="group__amrex__index__space_1gaeed4c890f5bc317598e165d61b85ab5e" kind="function"><name>grow</name></member>
      <memberdef kind="function" id="namespaceamrex_1a9fcd46e832a59e17d0be031ff2da83fe" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::growLo</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int idir, int n_cell) noexcept</argsstring>
        <name>growLo</name>
        <qualifiedname>amrex::growLo</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>idir</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n_cell</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1354" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1354" bodyend="1359"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af1c94c12b8dd4d6b08ff5f4a7a8ed9fa" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::growLo</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, Direction d, int n_cell) noexcept</argsstring>
        <name>growLo</name>
        <qualifiedname>amrex::growLo</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69" kindref="member">Direction</ref></type>
          <declname>d</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n_cell</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1365" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1365" bodyend="1368"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae5c2ef8f1acebfe9c10a0c80a3413da6" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::growHi</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int idir, int n_cell) noexcept</argsstring>
        <name>growHi</name>
        <qualifiedname>amrex::growHi</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>idir</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n_cell</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1374" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1374" bodyend="1379"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a67ce753c7346099f4ef7e53bd297b731" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::growHi</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, Direction d, int n_cell) noexcept</argsstring>
        <name>growHi</name>
        <qualifiedname>amrex::growHi</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69" kindref="member">Direction</ref></type>
          <declname>d</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n_cell</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1385" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1385" bodyend="1388"/>
      </memberdef>
      <member refid="group__amrex__index__space_1ga5af1ac4b7471ba90a59e111dd0dd2b22" kind="function"><name>coarsen</name></member>
      <member refid="group__amrex__index__space_1gaafcf63c353b1bed97e75246c2cb87e89" kind="function"><name>coarsen</name></member>
      <member refid="group__amrex__index__space_1gae102526cec1dc978897cc1d9a4ebae65" kind="function"><name>refine</name></member>
      <member refid="group__amrex__index__space_1ga5d58ae22b8078bd222ee7a526475a4fc" kind="function"><name>refine</name></member>
      <memberdef kind="function" id="namespaceamrex_1a76fbe1062cee2e63648f5a448ea82ea4" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::shift</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int dir, int nzones) noexcept</argsstring>
        <name>shift</name>
        <qualifiedname>amrex::shift</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nzones</declname>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> with indices shifted by nzones in dir direction. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1495" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1495" bodyend="1500"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aabd22daa513510c618b42eb03d7d4abd" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::shift</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, const IntVectND&lt; dim &gt; &amp;nzones) noexcept</argsstring>
        <name>shift</name>
        <qualifiedname>amrex::shift</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>nzones</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1506" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1506" bodyend="1511"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a28508323d997598b646624d29783b445" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::surroundingNodes</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int dir) noexcept</argsstring>
        <name>surroundingNodes</name>
        <qualifiedname>amrex::surroundingNodes</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> with NODE based coordinates in direction dir that encloses <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> b. NOTE: equivalent to b.convert(dir,NODE) NOTE: error if b.type(dir) == NODE. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1522" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1522" bodyend="1527"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a44efa4a57671e547bdd13a149aeb35c7" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::surroundingNodes</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, Direction d) noexcept</argsstring>
        <name>surroundingNodes</name>
        <qualifiedname>amrex::surroundingNodes</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69" kindref="member">Direction</ref></type>
          <declname>d</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1533" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1533" bodyend="1536"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0bbcf66e5c0a013ded77fa8dbb3a91e5" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::surroundingNodes</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b) noexcept</argsstring>
        <name>surroundingNodes</name>
        <qualifiedname>amrex::surroundingNodes</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> with NODE based coordinates in all directions that encloses <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1546" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1546" bodyend="1551"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0b3cd8bfa7c301f5ebd96c126737a0ef" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::convert</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, const IntVectND&lt; dim &gt; &amp;typ) noexcept</argsstring>
        <name>convert</name>
        <qualifiedname>amrex::convert</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>typ</declname>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> with different type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1558" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1558" bodyend="1563"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a673d85342b2f336a13105aa3e58f65b4" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::convert</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, const IndexTypeND&lt; dim &gt; &amp;typ) noexcept</argsstring>
        <name>convert</name>
        <qualifiedname>amrex::convert</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dim &gt; &amp;</type>
          <declname>typ</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1569" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1569" bodyend="1574"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8875ec5ccdb05826b3187182d55f118f" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::enclosedCells</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int dir) noexcept</argsstring>
        <name>enclosedCells</name>
        <qualifiedname>amrex::enclosedCells</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> with CELL based coordinates in direction dir that is enclosed by b. NOTE: equivalent to b.convert(dir,CELL) NOTE: error if b.type(dir) == CELL. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1586" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1586" bodyend="1591"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aef94be77c2b858faef7ed9e697c56c65" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::enclosedCells</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, Direction d) noexcept</argsstring>
        <name>enclosedCells</name>
        <qualifiedname>amrex::enclosedCells</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69" kindref="member">Direction</ref></type>
          <declname>d</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1597" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1597" bodyend="1600"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aea287687d1cf516a806a364f1aa9720d" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::enclosedCells</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b) noexcept</argsstring>
        <name>enclosedCells</name>
        <qualifiedname>amrex::enclosedCells</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> with CELL based coordinates in all directions that is enclosed by b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1610" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1610" bodyend="1615"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a47bfcd64af31cb8d262e1505e41d0450" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::bdryLo</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int dir, int len=1) noexcept</argsstring>
        <name>bdryLo</name>
        <qualifiedname>amrex::bdryLo</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>int</type>
          <declname>len</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Return the edge-centered <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> (in direction dir) defining the low side of <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1625" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1625" bodyend="1638"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae41a3ef13a63737b46765a7fec52fe39" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::bdryHi</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int dir, int len=1) noexcept</argsstring>
        <name>bdryHi</name>
        <qualifiedname>amrex::bdryHi</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>int</type>
          <declname>len</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Return the edge-centered <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> (in direction dir) defining the high side of <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1648" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1648" bodyend="1662"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9889c3e5147768e9b0e014a85d8fe5cd" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::bdryNode</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, Orientation face, int len=1) noexcept</argsstring>
        <name>bdryNode</name>
        <qualifiedname>amrex::bdryNode</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Orientation" kindref="compound">Orientation</ref></type>
          <declname>face</declname>
        </param>
        <param>
          <type>int</type>
          <declname>len</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Similar to bdryLo and bdryHi except that it operates on the given face of box b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1672" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1672" bodyend="1696"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a27c2456b05ba70f78ec1a55df80e2a2c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::adjCellLo</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int dir, int len=1) noexcept</argsstring>
        <name>adjCellLo</name>
        <qualifiedname>amrex::adjCellLo</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>int</type>
          <declname>len</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Return the cell centered <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> of length len adjacent to b on the low end along the coordinate direction dir. The return <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> is identical to b in the other directions. The return <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> and b have an empty intersection. NOTE: len &gt;= 1 NOTE: <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> retval = b.adjCellLo(b,dir,len) is equivalent to the following set of operations: <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> retval(b); retval.convert(dir,BoxND::CELL); retval.setrange(dir,retval.smallEnd(dir)-len,len);. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1714" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1714" bodyend="1728"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a01fe448de58a61fa00feaef8162055c8" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::adjCellHi</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, int dir, int len=1) noexcept</argsstring>
        <name>adjCellHi</name>
        <qualifiedname>amrex::adjCellHi</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>int</type>
          <declname>len</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Similar to adjCellLo but builds an adjacent <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> on the high end. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1735" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1735" bodyend="1750"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a689a69681821630d9a11f838e8b2bea2" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::adjCell</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b, Orientation face, int len=1) noexcept</argsstring>
        <name>adjCell</name>
        <qualifiedname>amrex::adjCell</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Orientation" kindref="compound">Orientation</ref></type>
          <declname>face</declname>
        </param>
        <param>
          <type>int</type>
          <declname>len</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Similar to adjCellLo and adjCellHi; operates on given face. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1757" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1757" bodyend="1782"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4e810a13db8b0987a2d1829c8be89296" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::minBox</definition>
        <argsstring>(const BoxND&lt; dim &gt; &amp;b1, const BoxND&lt; dim &gt; &amp;b2) noexcept</argsstring>
        <name>minBox</name>
        <qualifiedname>amrex::minBox</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
<para>Modify <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> to that of the minimum <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> containing both the original <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> and the argument. Both BoxNDes must have identical type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1793" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1793" bodyend="1798"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2b847393707eec5d41bb277203431089" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const BoxND&lt; dim &gt; &amp;bx)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>bx</declname>
        </param>
        <briefdescription>
<para>Write an ASCII representation to the ostream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1817" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1817" bodyend="1821"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adb7fdc4e49a1cc9001bbee2b985c56f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, BoxND&lt; dim &gt; &amp;bx)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; &amp;</type>
          <declname>bx</declname>
        </param>
        <briefdescription>
<para>Read from istream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1825" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1825" bodyend="1832"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a96262cf818d11ac4fbe83c2537be0f7c" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>d</declname>
            <defname>d</defname>
          </param>
          <param>
            <type>int...</type>
            <declname>dims</declname>
            <defname>dims</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; detail::get_sum&lt; d, dims... &gt;()&gt;</type>
        <definition>__host__ __device__ constexpr BoxND&lt; detail::get_sum&lt; d, dims... &gt;()&gt; amrex::BoxCat</definition>
        <argsstring>(const BoxND&lt; d &gt; &amp;bx, const BoxND&lt; dims &gt; &amp;...boxes) noexcept</argsstring>
        <name>BoxCat</name>
        <qualifiedname>amrex::BoxCat</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; d &gt; &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dims &gt; &amp;...</type>
          <declname>boxes</declname>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> obtained by concatenating the input BoxNDs. The dimension of the return value equals the sum of the dimensions of the inputted BoxNDs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1842" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1842" bodyend="1847"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afa05f68db47f50d3184089867e849678" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>d</declname>
            <defname>d</defname>
          </param>
          <param>
            <type>int...</type>
            <declname>dims</declname>
            <defname>dims</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; d &gt;, <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dims &gt;... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; BoxND&lt; d &gt;, BoxND&lt; dims &gt;... &gt; amrex::BoxSplit</definition>
        <argsstring>(const BoxND&lt; detail::get_sum&lt; d, dims... &gt;()&gt; &amp;bx) noexcept</argsstring>
        <name>BoxSplit</name>
        <qualifiedname>amrex::BoxSplit</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; detail::get_sum&lt; d, dims... &gt;()&gt; &amp;</type>
          <declname>bx</declname>
        </param>
        <briefdescription>
<para>Return a tuple of BoxNDs obtained by splitting the input <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> according to the dimensions specified by the template arguments. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1857" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1857" bodyend="1862"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7937e30c57cd590ef09a9b13a5764175" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr BoxND&lt; new_dim &gt; amrex::BoxShrink</definition>
        <argsstring>(const BoxND&lt; old_dim &gt; &amp;bx) noexcept</argsstring>
        <name>BoxShrink</name>
        <qualifiedname>amrex::BoxShrink</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>bx</declname>
        </param>
        <briefdescription>
<para>Return a new <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> of dimension new_dim and assigns the first new_dim dimension of this <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> to it. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1872" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1872" bodyend="1874"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acd0207594dab5726379edcd1397ce595" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr BoxND&lt; new_dim &gt; amrex::BoxExpand</definition>
        <argsstring>(const BoxND&lt; old_dim &gt; &amp;bx) noexcept</argsstring>
        <name>BoxExpand</name>
        <qualifiedname>amrex::BoxExpand</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>bx</declname>
        </param>
        <briefdescription>
<para>Return a new <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> of size new_dim and assigns all values of this <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> to it and (small=0, big=0, typ=CELL) to the remaining elements. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1885" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1885" bodyend="1887"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a63f4219b3f3f3b188db1f0a36ac53ef9" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr BoxND&lt; new_dim &gt; amrex::BoxResize</definition>
        <argsstring>(const BoxND&lt; old_dim &gt; &amp;bx) noexcept</argsstring>
        <name>BoxResize</name>
        <qualifiedname>amrex::BoxResize</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>bx</declname>
        </param>
        <briefdescription>
<para>Return a new <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref> of size new_dim by either shrinking or expanding this <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1897" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1897" bodyend="1899"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a40424ba2cf6e3c4e7f26ee81e83cc2cb" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::lbound_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>lbound_iv</name>
        <qualifiedname>amrex::lbound_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1905" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1905" bodyend="1908"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa0b5ecef36390cfee654d209a6023589" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::ubound_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>ubound_iv</name>
        <qualifiedname>amrex::ubound_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1914" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1914" bodyend="1917"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6f0d0bcf60c6a23dd7a821c20bdacc79" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::begin_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>begin_iv</name>
        <qualifiedname>amrex::begin_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1923" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1923" bodyend="1926"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a38575670b98a018e1d4b3ecde5307160" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::end_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>end_iv</name>
        <qualifiedname>amrex::end_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1932" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1932" bodyend="1935"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8ba999ed1340d4d82439b69a49c563ee" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::length_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>length_iv</name>
        <qualifiedname>amrex::length_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1941" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1941" bodyend="1944"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afee525661a6373f418787183c2493c5a" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::max_lbound_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, BoxND&lt; dim &gt; const &amp;b2) noexcept</argsstring>
        <name>max_lbound_iv</name>
        <qualifiedname>amrex::max_lbound_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1951" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1951" bodyend="1954"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac534afcd4340b20e8703dafa3b63cebe" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::max_lbound_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, IntVectND&lt; dim &gt; const &amp;lo) noexcept</argsstring>
        <name>max_lbound_iv</name>
        <qualifiedname>amrex::max_lbound_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; const &amp;</type>
          <declname>lo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1960" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1960" bodyend="1963"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4d0dce579a1d83ac7da68ea4ddae27c9" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::min_ubound_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, BoxND&lt; dim &gt; const &amp;b2) noexcept</argsstring>
        <name>min_ubound_iv</name>
        <qualifiedname>amrex::min_ubound_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1970" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1970" bodyend="1973"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8046f8024f332009a66ce57c4616681e" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::min_ubound_iv</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, IntVectND&lt; dim &gt; const &amp;hi) noexcept</argsstring>
        <name>min_ubound_iv</name>
        <qualifiedname>amrex::min_ubound_iv</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; const &amp;</type>
          <declname>hi</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1979" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1979" bodyend="1982"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a89b60912e8c589a5ae3e6c4f6f12a8e1" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::lbound</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>lbound</name>
        <qualifiedname>amrex::lbound</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1988" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1988" bodyend="1991"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5b84b133a84c933c954653b851b34fc4" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::ubound</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>ubound</name>
        <qualifiedname>amrex::ubound</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="1997" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="1997" bodyend="2000"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6a67d23bf90db71610ec5144cbae8f7c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::begin</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>begin</name>
        <qualifiedname>amrex::begin</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2006" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2006" bodyend="2009"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae25fd282035e5bd6ae581c49f7bd0111" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::end</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>end</name>
        <qualifiedname>amrex::end</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2015" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2015" bodyend="2018"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae1199696bd607d4da2511121f469d09c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::length</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box) noexcept</argsstring>
        <name>length</name>
        <qualifiedname>amrex::length</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2024" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2024" bodyend="2027"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad9121d8329aef803ae370e500e348c88" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::max_lbound</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, BoxND&lt; dim &gt; const &amp;b2) noexcept</argsstring>
        <name>max_lbound</name>
        <qualifiedname>amrex::max_lbound</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2034" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2034" bodyend="2037"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a43a9607d775204fa19d7e20c5ead5ab7" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::max_lbound</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, Dim3 const &amp;lo) noexcept</argsstring>
        <name>max_lbound</name>
        <qualifiedname>amrex::max_lbound</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> const &amp;</type>
          <declname>lo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2043" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2043" bodyend="2046"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8d181a324af23360d7aad9fcee711971" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::min_ubound</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, BoxND&lt; dim &gt; const &amp;b2) noexcept</argsstring>
        <name>min_ubound</name>
        <qualifiedname>amrex::min_ubound</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2053" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2053" bodyend="2056"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8b7db16a3d5236f47f76c531fdc75244" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::min_ubound</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, Dim3 const &amp;hi) noexcept</argsstring>
        <name>min_ubound</name>
        <qualifiedname>amrex::min_ubound</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> const &amp;</type>
          <declname>hi</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2062" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2062" bodyend="2065"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af33973994600415fe6caffbde704244e" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>BoxND&lt; dim &gt; amrex::getIndexBounds</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1) noexcept</argsstring>
        <name>getIndexBounds</name>
        <qualifiedname>amrex::getIndexBounds</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2074" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2074" bodyend="2077"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a66c9caace0bad67ed71f420e82899696" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>BoxND&lt; dim &gt; amrex::getIndexBounds</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b1, BoxND&lt; dim &gt; const &amp;b2) noexcept</argsstring>
        <name>getIndexBounds</name>
        <qualifiedname>amrex::getIndexBounds</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2082" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2082" bodyend="2088"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6db3936d56e7e29df87cc7d59bdc0768" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::getIndexBounds</definition>
        <argsstring>(T const &amp;b1, T const &amp;b2, Ts const &amp;... b3) noexcept</argsstring>
        <name>getIndexBounds</name>
        <qualifiedname>amrex::getIndexBounds</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>b1</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>b2</declname>
        </param>
        <param>
          <type>Ts const &amp;...</type>
          <declname>b3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2093" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2093" bodyend="2096"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad0dfb3671177716f07a0a3b6501d29ab" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::getCell</definition>
        <argsstring>(BoxND&lt; dim &gt; const *boxes, int nboxes, Long icell) noexcept</argsstring>
        <name>getCell</name>
        <qualifiedname>amrex::getCell</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const *</type>
          <declname>boxes</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nboxes</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>icell</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2103" column="11" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2103" bodyend="2117"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a16870720c21d5db7fb7ba7d922ec1275" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::makeSlab</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b, int direction, int slab_index) noexcept</argsstring>
        <name>makeSlab</name>
        <qualifiedname>amrex::makeSlab</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>direction</declname>
        </param>
        <param>
          <type>int</type>
          <declname>slab_index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2123" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2123" bodyend="2128"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a517d51846bba6df79106505faa2b5ac3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::makeSingleCellBox</definition>
        <argsstring>(int i, int j, int k, IndexTypeND&lt; dim &gt; typ=IndexTypeND&lt; dim &gt;::TheCellType())</argsstring>
        <name>makeSingleCellBox</name>
        <qualifiedname>amrex::makeSingleCellBox</qualifiedname>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>j</declname>
        </param>
        <param>
          <type>int</type>
          <declname>k</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dim &gt;</type>
          <declname>typ</declname>
          <defval><ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dim &gt;::TheCellType()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2134" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2134" bodyend="2139"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a308a7efd7f5accc611f61283a11fa158" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ BoxND&lt; dim &gt; amrex::makeSingleCellBox</definition>
        <argsstring>(IntVectND&lt; dim &gt; const &amp;vect, IndexTypeND&lt; dim &gt; typ=IndexTypeND&lt; dim &gt;::TheCellType())</argsstring>
        <name>makeSingleCellBox</name>
        <qualifiedname>amrex::makeSingleCellBox</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; const &amp;</type>
          <declname>vect</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dim &gt;</type>
          <declname>typ</declname>
          <defval><ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dim &gt;::TheCellType()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" line="2145" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Box.H" bodystart="2145" bodyend="2148"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ada7c77f7ac84c643ea21113e4ff5f2d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const BoxArray &amp;ba)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <briefdescription>
<para>Write a <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> to an ostream in ASCII format. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1673" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1674" bodyend="1697" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="897" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af4b25f1a81ffa836ed7356d6da7e814e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::boxComplement</definition>
        <argsstring>(const Box &amp;b1in, const Box &amp;b2)</argsstring>
        <name>boxComplement</name>
        <qualifiedname>amrex::boxComplement</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b1in</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
<para>Make a <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> from the the complement of b2 in b1in. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1700" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1700" bodyend="1704" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="23" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8c00ae57393c9f6665f88b80e3cdfb2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::complementIn</definition>
        <argsstring>(const Box &amp;b, const BoxArray &amp;ba)</argsstring>
        <name>complementIn</name>
        <qualifiedname>amrex::complementIn</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <briefdescription>
<para>Make a <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> from the complement of <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> ba in Box b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1707" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1707" bodyend="1711" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="26" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a31f38031bc51519297d88d3234115277" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::intersect</definition>
        <argsstring>(const BoxArray &amp;ba, const Box &amp;b, int ng=0)</argsstring>
        <name>intersect</name>
        <qualifiedname>amrex::intersect</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ng</declname>
        </param>
        <briefdescription>
<para>Make a <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> from the intersection of Box b and <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>(+ghostcells). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1714" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1714" bodyend="1737" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="29" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2fa5535ba8d983023e1a6bd61c9a4880" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::intersect</definition>
        <argsstring>(const BoxArray &amp;ba, const Box &amp;b, const IntVect &amp;ng)</argsstring>
        <name>intersect</name>
        <qualifiedname>amrex::intersect</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ng</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1740" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1740" bodyend="1763" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="31" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a172c409fe49ab498d9910cc19b732346" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::intersect</definition>
        <argsstring>(const BoxArray &amp;lhs, const BoxArray &amp;rhs)</argsstring>
        <name>intersect</name>
        <qualifiedname>amrex::intersect</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Make a <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> from the intersection of two BoxArrays. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1766" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1766" bodyend="1776" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="34" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4f75454b7ddd1be750318c754c3b1ae3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::intersect</definition>
        <argsstring>(const BoxArray &amp;ba, const BoxList &amp;bl)</argsstring>
        <name>intersect</name>
        <qualifiedname>amrex::intersect</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>bl</declname>
        </param>
        <briefdescription>
<para>Make a <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> from the intersection of <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> and <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1779" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1779" bodyend="1788" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="37" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af37f380f72af598af4865070235664c2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::convert</definition>
        <argsstring>(const BoxArray &amp;ba, IndexType typ)</argsstring>
        <name>convert</name>
        <qualifiedname>amrex::convert</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a7e095993c9b3f5a4c2abddd839d800e2" kindref="member">IndexType</ref></type>
          <declname>typ</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1791" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1791" bodyend="1796" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="39" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a911442fbfdd591235baf90cac01d9856" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::convert</definition>
        <argsstring>(const BoxArray &amp;ba, const IntVect &amp;typ)</argsstring>
        <name>convert</name>
        <qualifiedname>amrex::convert</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>typ</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1799" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1799" bodyend="1804" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="40" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a22ce5ec6a27aa7bce43ca708cec77023" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::coarsen</definition>
        <argsstring>(const BoxArray &amp;ba, int ratio)</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1807" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1807" bodyend="1812" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="42" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a255709aafea190412cf8a963f450ebc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::coarsen</definition>
        <argsstring>(const BoxArray &amp;ba, const IntVect &amp;ratio)</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1815" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1815" bodyend="1820" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="43" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae4c03c73102c83c74769b7773fb82483" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::refine</definition>
        <argsstring>(const BoxArray &amp;ba, int ratio)</argsstring>
        <name>refine</name>
        <qualifiedname>amrex::refine</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1823" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1823" bodyend="1828" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="45" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a85187c36418a08cc244643e6fc869f4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::refine</definition>
        <argsstring>(const BoxArray &amp;ba, const IntVect &amp;ratio)</argsstring>
        <name>refine</name>
        <qualifiedname>amrex::refine</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1831" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1831" bodyend="1836" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="46" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a719e505b04b336141e1a9a6ab52ecbcd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::GetBndryCells</definition>
        <argsstring>(const BoxArray &amp;ba, int ngrow)</argsstring>
        <name>GetBndryCells</name>
        <qualifiedname>amrex::GetBndryCells</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
        </param>
        <briefdescription>
<para>Find the ghost cells of a given <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1839" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1839" bodyend="1893" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="49" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae634c8846124c00149fa2a0ad45f4ec4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readBoxArray</definition>
        <argsstring>(BoxArray &amp;ba, std::istream &amp;s, bool b=false)</argsstring>
        <name>readBoxArray</name>
        <qualifiedname>amrex::readBoxArray</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>bReadSpecial</declname>
        </param>
        <briefdescription>
<para>Read a <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> from a stream. If b is true, read in a special way. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1897" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1897" bodyend="1925" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="52" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a89eb9459b4109c4f9a9b3225abae29f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::match</definition>
        <argsstring>(const BoxArray &amp;x, const BoxArray &amp;y)</argsstring>
        <name>match</name>
        <qualifiedname>amrex::match</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>Note that two BoxArrays that match are not necessarily equal. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1927" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1927" bodyend="1938" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="55" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a86a6591ebde4320c6b7a835c701f1830" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref></type>
        <definition>BoxArray amrex::decompose</definition>
        <argsstring>(Box const  &amp;domain, int nboxes, Array&lt; bool, 3 &gt; const  &amp;decomp={ true, true, true }, bool no_overlap=false)</argsstring>
        <name>decompose</name>
        <qualifiedname>amrex::decompose</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nboxes</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; bool, 3 &gt; const &amp;</type>
          <declname>decomp</declname>
          <defval>{ true, true, true }</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>no_overlap</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Decompose domain box into <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> has nboxes Boxes, unless the the domain is too small. We aim to decompose the domain into subdomains that are as cubic as possible, even if this results in Boxes with odd numbers of cells. Thus, this function is generally not suited for applications with multiple AMR levels or for multigrid solvers.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>domain</parametername>
</parameternamelist>
<parameterdescription>
<para>Domain Box </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nboxes</parametername>
</parameternamelist>
<parameterdescription>
<para>the target number of Boxes </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>decomp</parametername>
</parameternamelist>
<parameterdescription>
<para>controls whether domain decomposition should be done in that direction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>no_overlap</parametername>
</parameternamelist>
<parameterdescription>
<para>optional argument specifying whether nodal boxes can overlap </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="1940" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="1940" bodyend="2120" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="72" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae7f2c81407f110284eec40dface36cbe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const BoxArray::RefID &amp;id)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1BoxArray_1_1RefID" kindref="compound">BoxArray::RefID</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" line="2122" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.cpp" bodystart="2123" bodyend="2127" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxArray.H" declline="899" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3fb0e9220f2aa85a365f7ec254f2e3d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::intersect</definition>
        <argsstring>(BoxDomain &amp;dest, const BoxDomain &amp;fin, const Box &amp;b)</argsstring>
        <name>intersect</name>
        <qualifiedname>amrex::intersect</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>fin</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Compute the intersection of <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> fin with Box b and place the result into <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> dest. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" line="19" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" bodystart="19" bodyend="25" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.H" declline="39" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af32b91948787281bd9c0c691f3f355dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::refine</definition>
        <argsstring>(BoxDomain &amp;dest, const BoxDomain &amp;fin, int ratio)</argsstring>
        <name>refine</name>
        <qualifiedname>amrex::refine</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>fin</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
<para>Refine all Boxes in the domain by the refinement ratio and return the result in dest. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" line="36" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" bodystart="36" bodyend="42" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.H" declline="31" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a15969b1b7e5e1431ce9aea3b513ec98a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::accrete</definition>
        <argsstring>(BoxDomain &amp;dest, const BoxDomain &amp;fin, int sz=1)</argsstring>
        <name>accrete</name>
        <qualifiedname>amrex::accrete</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>fin</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sz</declname>
        </param>
        <briefdescription>
<para>Grow each Box in <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> fin by size sz and place the result into <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> dest. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" line="45" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" bodystart="45" bodyend="51" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.H" declline="47" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa7fdcd82c18fdf6c33f4194da8e7da46" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::coarsen</definition>
        <argsstring>(BoxDomain &amp;dest, const BoxDomain &amp;fin, int ratio)</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>fin</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
<para>Coarsen all Boxes in the domain by the refinement ratio. The result is placed into a new <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" line="54" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" bodystart="54" bodyend="60" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.H" declline="25" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a417fa2fe3545ffe81b848760bbe1bcd9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref></type>
        <definition>BoxDomain amrex::complementIn</definition>
        <argsstring>(const Box &amp;b, const BoxDomain &amp;bl)</argsstring>
        <name>complementIn</name>
        <qualifiedname>amrex::complementIn</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>bl</declname>
        </param>
        <briefdescription>
<para>Returns the complement of <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> bl in Box b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" line="73" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" bodystart="73" bodyend="79" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.H" declline="19" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a227c6302f26efd6a5c8fef40c77906f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const BoxDomain &amp;bd)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> &amp;</type>
          <declname>bd</declname>
        </param>
        <briefdescription>
<para>Output a <ref refid="classamrex_1_1BoxDomain" kindref="compound">BoxDomain</ref> to an ostream is ASCII format. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" line="229" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.cpp" bodystart="230" bodyend="238" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxDomain.H" declline="53" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afe22e052a797bf296858f9330273112d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::intersect</definition>
        <argsstring>(const BoxList &amp;bl, const Box &amp;b)</argsstring>
        <name>intersect</name>
        <qualifiedname>amrex::intersect</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>bl</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Returns a <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> defining the intersection of bl with b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="102" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="102" bodyend="108" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="34" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afe1aa5a62080b50fbc4c3646ddbc6c8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::refine</definition>
        <argsstring>(const BoxList &amp;bl, int ratio)</argsstring>
        <name>refine</name>
        <qualifiedname>amrex::refine</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>bl</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> in which each Box is refined by the given ratio. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="111" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="111" bodyend="116" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="28" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2def914169be100afac8106fd618b6f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::coarsen</definition>
        <argsstring>(const BoxList &amp;bl, int ratio)</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>bl</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> in which each Box is coarsened by the given ratio. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="119" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="119" bodyend="124" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="31" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac662c42f6780a1a61523d3bb4fa5fba1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::accrete</definition>
        <argsstring>(const BoxList &amp;bl, int sz)</argsstring>
        <name>accrete</name>
        <qualifiedname>amrex::accrete</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>bl</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sz</declname>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> in which each Box is grown by the given size. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="127" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="127" bodyend="132" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="37" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af71361ab9190f8aeb8f70488669095c2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::removeOverlap</definition>
        <argsstring>(const BoxList &amp;bl)</argsstring>
        <name>removeOverlap</name>
        <qualifiedname>amrex::removeOverlap</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>bl</declname>
        </param>
        <briefdescription>
<para>Return <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> which covers the same area but has no overlapping boxes. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="135" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="135" bodyend="140" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="40" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a07499fc06f1137386e318ccccca0b5bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::complementIn</definition>
        <argsstring>(const Box &amp;b, const BoxList &amp;bl)</argsstring>
        <name>complementIn</name>
        <qualifiedname>amrex::complementIn</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>bl</declname>
        </param>
        <briefdescription>
<para>Returns a <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> defining the complement of <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> bl in Box b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="298" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="298" bodyend="304" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="20" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7cb1edb123daa9e2146ae0db8e2ed910" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref></type>
        <definition>BoxList amrex::boxDiff</definition>
        <argsstring>(const Box &amp;b1in, const Box &amp;b2)</argsstring>
        <name>boxDiff</name>
        <qualifiedname>amrex::boxDiff</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b1in</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
<para>Returns <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> defining the compliment of b2 in b1in. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="599" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="599" bodyend="605" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="23" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a23d225d20bb2631874de8edff71dbc88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::boxDiff</definition>
        <argsstring>(BoxList &amp;bl_diff, const Box &amp;b1in, const Box &amp;b2)</argsstring>
        <name>boxDiff</name>
        <qualifiedname>amrex::boxDiff</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>bl_diff</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b1in</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>b2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="608" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="608" bodyend="651" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="25" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a68a5f9135797f74f352eb1c3d966ab1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const BoxList &amp;blist)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> &amp;</type>
          <declname>blist</declname>
        </param>
        <briefdescription>
<para>Output a <ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> to an ostream in ASCII format. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" line="877" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.cpp" bodystart="878" bodyend="893" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_BoxList.H" declline="44" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a14dfe2fb4a9b97fd0c118883449462e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const CArena &amp;arena)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1CArena" kindref="compound">CArena</ref> &amp;</type>
          <declname>arena</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CArena.cpp" line="547" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CArena.cpp" bodystart="547" bodyend="584"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7873051e5cef8f5a0bea83511df89da8" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>auto</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>auto</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr void</type>
        <definition>__host__ __device__ constexpr void amrex::constexpr_for</definition>
        <argsstring>(F const &amp;f)</argsstring>
        <name>constexpr_for</name>
        <qualifiedname>amrex::constexpr_for</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ConstexprFor.H" line="28" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ConstexprFor.H" bodystart="28" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad4bc5ce2974b01ab366426d7cfeb6e9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const CoordSys &amp;c)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1CoordSys" kindref="compound">CoordSys</ref> &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CoordSys.cpp" line="445" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CoordSys.cpp" bodystart="446" bodyend="458"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae456f45b3ef6a3559e803eb2465950be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, CoordSys &amp;c)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1CoordSys" kindref="compound">CoordSys</ref> &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CoordSys.cpp" line="466" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CoordSys.cpp" bodystart="466" bodyend="491"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a38a7ba8943c52193488c28b3b6a94822" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class L</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Fs</declname>
            <defname>Fs</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>CTOs</declname>
            <defname>CTOs</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::AnyCTO</definition>
        <argsstring>(TypeList&lt; CTOs... &gt; list_of_compile_time_options, std::array&lt; int, sizeof...(CTOs)&gt; const &amp;runtime_options, L &amp;&amp;l, Fs &amp;&amp;...cto_functs)</argsstring>
        <name>AnyCTO</name>
        <qualifiedname>amrex::AnyCTO</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; CTOs... &gt;</type>
          <declname>list_of_compile_time_options</declname>
        </param>
        <param>
          <type>std::array&lt; int, sizeof...(CTOs)&gt; const &amp;</type>
          <declname>runtime_options</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>l</declname>
        </param>
        <param>
          <type>Fs &amp;&amp;...</type>
          <declname>cto_functs</declname>
        </param>
        <briefdescription>
<para>Compile time optimization of kernels with run time options. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a generalized version of ParallelFor with CTOs that can support any function that takes in one lambda to launch a GPU kernel such as ParallelFor, ParallelForRNG, launch, etc. It uses fold expression to generate kernel launches for all combinations of the run time options. The kernel function can use constexpr if to discard unused code blocks for better run time performance. In the example below, the code will be expanded into 4*2=8 normal ParallelForRNGs for all combinations of the run time parameters. <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>A_runtime_option<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>B_runtime_option<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>A_options<sp/>:<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{<sp/>A0,<sp/>A1,<sp/>A2,<sp/>A3<sp/>};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>B_options<sp/>:<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{<sp/>B0,<sp/>B1<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a38a7ba8943c52193488c28b3b6a94822" kindref="member">AnyCTO</ref>(TypeList&lt;CompileTimeOptions&lt;A0,A1,A2,A3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CompileTimeOptions&lt;B0,B1&gt;&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{A_runtime_option,<sp/>B_runtime_option},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[&amp;](</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cto_func){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceamrex_1ae3514c3f8c4b2a78c2ddc9b49d8cca6c" kindref="member">ParallelForRNG</ref>(N,<sp/>cto_func);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>RandomEngine&amp;<sp/>engine,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>A_control,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>B_control)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>!=<sp/>A3<sp/>&amp;&amp;<sp/>B_control.value<sp/>==<sp/>B1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nthreads_per_block<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nblocks<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a38a7ba8943c52193488c28b3b6a94822" kindref="member">AnyCTO</ref>(TypeList&lt;CompileTimeOptions&lt;A0,A1,A2,A3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CompileTimeOptions&lt;B0,B1&gt;&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{A_runtime_option,<sp/>B_runtime_option},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[&amp;](</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cto_func){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>launch&lt;nthreads_per_block&gt;(nblocks,<sp/><ref refid="namespaceamrex_1_1Gpu_1ae1a0966ad8daf3a49564123b8dbdb3fa" kindref="member">Gpu::gpuStream</ref>(),<sp/>cto_func);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>A_control,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>B_control){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting> The static member function cto_func.GetOptions() can be used to obtain the runtime_options passed into AnyCTO, but at compile time. This enables some advanced use cases, such as changing the number of threads per block or the dimensionality of ParallelFor at runtime. For the second example -&gt; decltype(void(intvect.size())) is necessary to disambiguate IntVectND&lt;1&gt; and int for the first argument of the kernel function. <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nthreads_per_block<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a38a7ba8943c52193488c28b3b6a94822" kindref="member">AnyCTO</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt;<ref refid="structamrex_1_1CompileTimeOptions" kindref="compound">CompileTimeOptions&lt;128,256,512,1024&gt;</ref>&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{nthreads_per_block},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[&amp;](</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cto_func){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>std::array&lt;int,<sp/>1&gt;<sp/>ctos<sp/>=<sp/>cto_func.GetOptions();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c_nthreads_per_block<sp/>=<sp/>ctos[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ParallelFor&lt;c_nthreads_per_block&gt;(N,<sp/>cto_func);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">BoxND&lt;6&gt;<sp/>box6D<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dims_needed<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a38a7ba8943c52193488c28b3b6a94822" kindref="member">AnyCTO</ref>(TypeList&lt;CompileTimeOptions&lt;1,2,3,4,5,6&gt;&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{dims_needed},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[&amp;](</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>cto_func){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>std::array&lt;int,<sp/>1&gt;<sp/>ctos<sp/>=<sp/>cto_func.GetOptions();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c_dims_needed<sp/>=<sp/>ctos[0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>box<sp/>=<sp/>BoxShrink&lt;c_dims_needed&gt;(box6D);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceamrex_1a1f15630874d45aeb722ca649e6c4c3a9" kindref="member">ParallelFor</ref>(box,<sp/>cto_func);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>intvect,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">)<sp/>-&gt;<sp/></highlight><highlight class="keyword">decltype</highlight><highlight class="normal">(void(intvect.size()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>Note that due to a limitation of CUDA&apos;s extended device lambda, the constexpr if block cannot be the one that captures a variable first. If nvcc complains about it, you will have to manually capture it outside constexpr if. Alternatively, the constexpr if can be replaced with a regular if. Compilers can still perform the same optimizations since the condition is known at compile time. The data type for the parameters is int.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>list_of_compile_time_options</parametername>
</parameternamelist>
<parameterdescription>
<para>list of all possible values of the parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>runtime_options</parametername>
</parameternamelist>
<parameterdescription>
<para>the run time parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>l</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object containing a CPU function that launches the provided GPU kernel. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cto_functs</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object containing the GPU kernel with optimizations. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" line="181" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" bodystart="181" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1f15630874d45aeb722ca649e6c4c3a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>CTOs</declname>
            <defname>CTOs</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; amrex::ParallelFor</definition>
        <argsstring>(TypeList&lt; CTOs... &gt; ctos, std::array&lt; int, sizeof...(CTOs)&gt; const &amp;runtime_options, T N, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; CTOs... &gt;</type>
          <declname>ctos</declname>
        </param>
        <param>
          <type>std::array&lt; int, sizeof...(CTOs)&gt; const &amp;</type>
          <declname>runtime_options</declname>
        </param>
        <param>
          <type>T</type>
          <declname>N</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" line="193" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" bodystart="193" bodyend="203"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a97a94af0fa091bf7fe84c64000abbfb9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>CTOs</declname>
            <defname>CTOs</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(TypeList&lt; CTOs... &gt; ctos, std::array&lt; int, sizeof...(CTOs)&gt; const &amp;runtime_options, BoxND&lt; dim &gt; const &amp;box, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; CTOs... &gt;</type>
          <declname>ctos</declname>
        </param>
        <param>
          <type>std::array&lt; int, sizeof...(CTOs)&gt; const &amp;</type>
          <declname>runtime_options</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" line="206" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" bodystart="206" bodyend="216"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0701946897169892c662a898e6523224" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>CTOs</declname>
            <defname>CTOs</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; amrex::ParallelFor</definition>
        <argsstring>(TypeList&lt; CTOs... &gt; ctos, std::array&lt; int, sizeof...(CTOs)&gt; const &amp;runtime_options, BoxND&lt; dim &gt; const &amp;box, T ncomp, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; CTOs... &gt;</type>
          <declname>ctos</declname>
        </param>
        <param>
          <type>std::array&lt; int, sizeof...(CTOs)&gt; const &amp;</type>
          <declname>runtime_options</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" line="220" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" bodystart="220" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a202fe419e606d52e38bfa0a2ff5348d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>CTOs</declname>
            <defname>CTOs</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; amrex::ParallelFor</definition>
        <argsstring>(TypeList&lt; CTOs... &gt; ctos, std::array&lt; int, sizeof...(CTOs)&gt; const &amp;option, T N, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; CTOs... &gt;</type>
          <declname>ctos</declname>
        </param>
        <param>
          <type>std::array&lt; int, sizeof...(CTOs)&gt; const &amp;</type>
          <declname>option</declname>
        </param>
        <param>
          <type>T</type>
          <declname>N</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor with compile time optimization of kernels with run time options. </para>
        </briefdescription>
        <detaileddescription>
<para>It uses fold expression to generate kernel launches for all combinations of the run time options. The kernel function can use constexpr if to discard unused code blocks for better run time performance. In the example below, the code will be expanded into 4*2=8 normal ParallelFors for all combinations of the run time parameters. <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>A_runtime_option<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>B_runtime_option<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>A_options<sp/>:<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{<sp/>A0,<sp/>A1,<sp/>A2,<sp/>A3};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>B_options<sp/>:<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{<sp/>B0,<sp/>B1<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a1f15630874d45aeb722ca649e6c4c3a9" kindref="member">ParallelFor</ref>(TypeList&lt;CompileTimeOptions&lt;A0,A1,A2,A3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CompileTimeOptions&lt;B0,B1&gt;&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{A_runtime_option,<sp/>B_runtime_option},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>N,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>A_control,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>B_control)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>!=<sp/>A3<sp/>&amp;&amp;<sp/>B_control.value<sp/>==<sp/>B1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting> Note that due to a limitation of CUDA&apos;s extended device lambda, the constexpr if block cannot be the one that captures a variable first. If nvcc complains about it, you will have to manually capture it outside constexpr if. The data type for the parameters is int.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctos</parametername>
</parameternamelist>
<parameterdescription>
<para>list of all possible values of the parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>option</parametername>
</parameternamelist>
<parameterdescription>
<para>the run time parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>an integer specifying the 1D for loop&apos;s range. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object taking an integer and working on that iteration. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" line="278" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" bodystart="278" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aba7383cd8901b18ae39e85e5817cb9e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>CTOs</declname>
            <defname>CTOs</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(TypeList&lt; CTOs... &gt; ctos, std::array&lt; int, sizeof...(CTOs)&gt; const &amp;option, BoxND&lt; dim &gt; const &amp;box, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; CTOs... &gt;</type>
          <declname>ctos</declname>
        </param>
        <param>
          <type>std::array&lt; int, sizeof...(CTOs)&gt; const &amp;</type>
          <declname>option</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor with compile time optimization of kernels with run time options. </para>
        </briefdescription>
        <detaileddescription>
<para>It uses fold expression to generate kernel launches for all combinations of the run time options. The kernel function can use constexpr if to discard unused code blocks for better run time performance. In the example below, the code will be expanded into 4*2=8 normal ParallelFors for all combinations of the run time parameters. <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>A_runtime_option<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>B_runtime_option<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>A_options<sp/>:<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{<sp/>A0,<sp/>A1,<sp/>A2,<sp/>A3};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>B_options<sp/>:<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{<sp/>B0,<sp/>B1<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a1f15630874d45aeb722ca649e6c4c3a9" kindref="member">ParallelFor</ref>(TypeList&lt;CompileTimeOptions&lt;A0,A1,A2,A3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CompileTimeOptions&lt;B0,B1&gt;&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{A_runtime_option,<sp/>B_runtime_option},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>box,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>A_control,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>B_control)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>!=<sp/>A3<sp/>&amp;&amp;<sp/>B_control.value<sp/>==<sp/>B1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting> Note that due to a limitation of CUDA&apos;s extended device lambda, the constexpr if block cannot be the one that captures a variable first. If nvcc complains about it, you will have to manually capture it outside constexpr if. The data type for the parameters is int.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctos</parametername>
</parameternamelist>
<parameterdescription>
<para>list of all possible values of the parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>option</parametername>
</parameternamelist>
<parameterdescription>
<para>the run time parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>box</parametername>
</parameternamelist>
<parameterdescription>
<para>a Box specifying the 3D for loop&apos;s range. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object taking three integers and working on the given cell. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" line="331" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" bodystart="331" bodyend="336"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a28129b3b643f84b1b81e80d220281ca3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>CTOs</declname>
            <defname>CTOs</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; amrex::ParallelFor</definition>
        <argsstring>(TypeList&lt; CTOs... &gt; ctos, std::array&lt; int, sizeof...(CTOs)&gt; const &amp;option, BoxND&lt; dim &gt; const &amp;box, T ncomp, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; CTOs... &gt;</type>
          <declname>ctos</declname>
        </param>
        <param>
          <type>std::array&lt; int, sizeof...(CTOs)&gt; const &amp;</type>
          <declname>option</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor with compile time optimization of kernels with run time options. </para>
        </briefdescription>
        <detaileddescription>
<para>It uses fold expression to generate kernel launches for all combinations of the run time options. The kernel function can use constexpr if to discard unused code blocks for better run time performance. In the example below, the code will be expanded into 4*2=8 normal ParallelFors for all combinations of the run time parameters. <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>A_runtime_option<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>B_runtime_option<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>A_options<sp/>:<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{<sp/>A0,<sp/>A1,<sp/>A2,<sp/>A3};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>B_options<sp/>:<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{<sp/>B0,<sp/>B1<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a1f15630874d45aeb722ca649e6c4c3a9" kindref="member">ParallelFor</ref>(TypeList&lt;CompileTimeOptions&lt;A0,A1,A2,A3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CompileTimeOptions&lt;B0,B1&gt;&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{A_runtime_option,<sp/>B_runtime_option},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>box,<sp/>ncomp,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>A_control,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>B_control)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>==<sp/>A2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(A_control.value<sp/>!=<sp/>A3<sp/>&amp;&amp;<sp/>B_control.value<sp/>==<sp/>B1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting> Note that due to a limitation of CUDA&apos;s extended device lambda, the constexpr if block cannot be the one that captures a variable first. If nvcc complains about it, you will have to manually capture it outside constexpr if. The data type for the parameters is int.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctos</parametername>
</parameternamelist>
<parameterdescription>
<para>list of all possible values of the parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>option</parametername>
</parameternamelist>
<parameterdescription>
<para>the run time parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>box</parametername>
</parameternamelist>
<parameterdescription>
<para>a Box specifying the iteration in 3D space. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>an integer specifying the range for iteration over components. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object taking three integers and working on the given cell. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" line="386" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_CTOParallelForImpl.H" bodystart="386" bodyend="391"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae6ff944334fa82f4315eb44b3dd08dae" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::demangle</definition>
        <argsstring>(const char *name)</argsstring>
        <name>demangle</name>
        <qualifiedname>amrex::demangle</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Demangle C++ name. </para>
        </briefdescription>
        <detaileddescription>
<para>Demange C++ name if possible. For example <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classamrex_1_1BoxND" kindref="compound">amrex::Box</ref><sp/>box;</highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/><ref refid="namespaceamrex_1ae6ff944334fa82f4315eb44b3dd08dae" kindref="member">amrex::demangle</ref>(</highlight><highlight class="keyword">typeid</highlight><highlight class="normal">(box).name());</highlight></codeline>
</programlisting> Demangling turns &quot;N5amrex3BoxE&quot; into &quot;amrex::Box&quot;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Demangle.H" line="25" column="20" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Demangle.H" bodystart="25" bodyend="39"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4ccbd682515522788d7de1c6ac8bb257" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        <definition>__host__ __device__ Real amrex::dot_product</definition>
        <argsstring>(XDim3 const &amp;a, XDim3 const &amp;b)</argsstring>
        <name>dot_product</name>
        <qualifiedname>amrex::dot_product</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref> const &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref> const &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" line="16" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" bodystart="16" bodyend="19"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aca9ce24409159c017d8ac8e050b2f19c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ <ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref></type>
        <definition>__host__ __device__ XDim3 amrex::cross_product</definition>
        <argsstring>(XDim3 const &amp;a, XDim3 const &amp;b)</argsstring>
        <name>cross_product</name>
        <qualifiedname>amrex::cross_product</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref> const &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref> const &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" line="22" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" bodystart="22" bodyend="25"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aeda7f41b14dd61e8cf4572dc94ec85b1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ <ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref></type>
        <definition>__host__ __device__ XDim3 amrex::operator+</definition>
        <argsstring>(XDim3 const &amp;a, XDim3 const &amp;b)</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref> const &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref> const &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" line="28" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" bodystart="28" bodyend="31"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae84b486770ebde6c2c1d35937793289a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ <ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref></type>
        <definition>__host__ __device__ XDim3 amrex::operator-</definition>
        <argsstring>(XDim3 const &amp;a, XDim3 const &amp;b)</argsstring>
        <name>operator-</name>
        <qualifiedname>amrex::operator-</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref> const &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1XDim3" kindref="compound">XDim3</ref> const &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" line="34" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" bodystart="34" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8b89bc9bdbe34a4a1feb5581ca374104" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, Dim3 &gt;||std::is_same_v&lt; T, XDim3 &gt; &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const T &amp;d)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>d</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" line="42" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Dim3.H" bodystart="42" bodyend="46"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6e9865ac3868b0b19a46f021f2db2421" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const DistributionMapping &amp;pmap)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &amp;</type>
          <declname>pmap</declname>
        </param>
        <briefdescription>
<para>Our output operator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.cpp" line="1945" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.cpp" bodystart="1946" bodyend="1963" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.H" declline="391" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2a1640fc2ba97306ea4b3546daa1e6b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const DistributionMapping::RefID &amp;id)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1DistributionMapping_1_1RefID" kindref="compound">DistributionMapping::RefID</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.cpp" line="1965" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.cpp" bodystart="1966" bodyend="1970" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.H" declline="393" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aca8ca3ed7e01a5c954d6c70cae7b94a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref></type>
        <definition>DistributionMapping amrex::MakeSimilarDM</definition>
        <argsstring>(const BoxArray &amp;ba, const MultiFab &amp;mf, const IntVect &amp;ng)</argsstring>
        <name>MakeSimilarDM</name>
        <qualifiedname>amrex::MakeSimilarDM</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ng</declname>
        </param>
        <briefdescription>
<para>Function that creates a <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &quot;similar&quot; to that of a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>&quot;Similar&quot; means that, if a box in &quot;ba&quot; intersects with any of the boxes in the <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> associated with &quot;mf&quot;, taking &quot;ngrow&quot; ghost cells into account, then that box will be assigned to the proc owning the one it has the maximum amount of overlap with.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ba</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> we want to generate a <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mf</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> we want said <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> to be similar to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ng</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of grow cells to use when computing intersection / overlap </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The computed <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.cpp" line="2007" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.cpp" bodystart="2007" bodyend="2012" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.H" declline="408" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adc0569d3487d998596b2a11392bddaca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref></type>
        <definition>DistributionMapping amrex::MakeSimilarDM</definition>
        <argsstring>(const BoxArray &amp;ba, const BoxArray &amp;src_ba, const DistributionMapping &amp;src_dm, const IntVect &amp;ng)</argsstring>
        <name>MakeSimilarDM</name>
        <qualifiedname>amrex::MakeSimilarDM</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>src_ba</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &amp;</type>
          <declname>src_dm</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ng</declname>
        </param>
        <briefdescription>
<para>Function that creates a <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &quot;similar&quot; to that of a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>&quot;Similar&quot; means that, if a box in &quot;ba&quot; intersects with any of the boxes in the <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> associated with &quot;mf&quot;, taking &quot;ngrow&quot; ghost cells into account, then that box will be assigned to the proc owning the one it has the maximum amount of overlap with.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ba</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> we want to generate a <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src_ba</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> associated with the src <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src_dm</parametername>
</parameternamelist>
<parameterdescription>
<para>The input <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> we want the output to be similar to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ng</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of grow cells to use when computing intersection / overlap </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The computed <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.cpp" line="2014" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.cpp" bodystart="2014" bodyend="2046" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_DistributionMapping.H" declline="424" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a88ecea52b7921b731f070226526fa55a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::pair&lt; std::string, T &gt; &gt; const &amp;</type>
        <definition>std::vector&lt; std::pair&lt; std::string, T &gt; &gt; const  &amp; amrex::getEnumNameValuePairs</definition>
        <argsstring>()</argsstring>
        <name>getEnumNameValuePairs</name>
        <qualifiedname>amrex::getEnumNameValuePairs</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" line="67" column="23" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" bodystart="67" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7d635bdb718c30952079c43671149a5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::getEnum</definition>
        <argsstring>(std::string_view const &amp;s)</argsstring>
        <name>getEnum</name>
        <qualifiedname>amrex::getEnum</qualifiedname>
        <param>
          <type>std::string_view const &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a string to an enum value</para>
<para>Example: <programlisting filename=".C"><codeline><highlight class="normal"><sp/>++</highlight></codeline>
<codeline><highlight class="normal"><ref refid="AMReX__Enum_8H_1a19559ed6a3d4281344b600b10c6a31f2" kindref="member">AMREX_ENUM</ref>(Model,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>linear,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nonlinear</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>model_str<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;nonlinear&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">Model<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>model<sp/>=<sp/>amrex::getEnum&lt;Model&gt;(model_str);</highlight></codeline>
<codeline><highlight class="normal">assert(model<sp/>==<sp/>Model::nonlinear);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" line="89" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" bodystart="89" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab3ae8b43aca87a0f9b7c66250c04a316" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::getEnumCaseInsensitive</definition>
        <argsstring>(std::string_view const &amp;s)</argsstring>
        <name>getEnumCaseInsensitive</name>
        <qualifiedname>amrex::getEnumCaseInsensitive</qualifiedname>
        <param>
          <type>std::string_view const &amp;</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a string case insensitive to an enum value</para>
<para><ref refid="structamrex_1_1Same" kindref="compound">Same</ref> as getEnum&lt;T&gt;, but case insensitive match to enum value.</para>
<para>Example: <programlisting filename=".C"><codeline><highlight class="normal"><sp/>++</highlight></codeline>
<codeline><highlight class="normal"><ref refid="AMReX__Enum_8H_1a19559ed6a3d4281344b600b10c6a31f2" kindref="member">AMREX_ENUM</ref>(Model,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>linear,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nonlinear</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>model_str<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;NonLinear&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">Model<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>model<sp/>=<sp/>amrex::getEnumCaseInsensitive&lt;Model&gt;(model_str);</highlight></codeline>
<codeline><highlight class="normal">assert(model<sp/>==<sp/>Model::nonlinear);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" line="123" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" bodystart="123" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2690baa171c059a8cb8e7131989be2e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string amrex::getEnumNameString</definition>
        <argsstring>(T const &amp;v)</argsstring>
        <name>getEnumNameString</name>
        <qualifiedname>amrex::getEnumNameString</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get a string from an enum value</para>
<para>Example: <programlisting filename=".C"><codeline><highlight class="normal"><sp/>++</highlight></codeline>
<codeline><highlight class="normal"><ref refid="AMReX__Enum_8H_1a19559ed6a3d4281344b600b10c6a31f2" kindref="member">AMREX_ENUM</ref>(Model,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>linear,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nonlinear</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">Model<sp/>model<sp/>=<sp/>Model::linear;</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>model_str<sp/>=<sp/><ref refid="namespaceamrex_1a2690baa171c059a8cb8e7131989be2e6" kindref="member">amrex::getEnumNameString</ref>(model);</highlight></codeline>
<codeline><highlight class="normal">assert(model_str<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;linear&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" line="156" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" bodystart="156" bodyend="172"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad291f7c70d02dbbb3cc58228d4d7f4e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; amrex::getEnumNameStrings</definition>
        <argsstring>()</argsstring>
        <name>getEnumNameStrings</name>
        <qualifiedname>amrex::getEnumNameStrings</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" line="176" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" bodystart="176" bodyend="187"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a045ff5fa344cfaa38699087003062fcb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string amrex::getEnumClassName</definition>
        <argsstring>()</argsstring>
        <name>getEnumClassName</name>
        <qualifiedname>amrex::getEnumClassName</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" line="191" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" bodystart="191" bodyend="194"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af11e27e33248402e16a37489677647d3" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ET</type>
            <defval><ref refid="AMReX__Enum_8H_1a9f2a1a484d1e714fda55c741bf6b7ec9" kindref="member">amrex_enum_traits</ref>&lt;T&gt;</defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; ET::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto amrex::toUnderlying</definition>
        <argsstring>(T v) noexcept</argsstring>
        <name>toUnderlying</name>
        <qualifiedname>amrex::toUnderlying</qualifiedname>
        <param>
          <type>T</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the underlying (u)int of an enum value</para>
<para>Useful when building bitmasks. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" line="202" column="20" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Enum.H" bodystart="202" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a68d95d50ed271feafbd28018aa0e8d96" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!IsBaseFab&lt; T &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::nBytesOwned</definition>
        <argsstring>(T const &amp;) noexcept</argsstring>
        <name>nBytesOwned</name>
        <qualifiedname>amrex::nBytesOwned</qualifiedname>
        <param>
          <type>T const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" line="58" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" bodystart="58" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a064d90077e1d86d6ba81b5b546bb7438" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::nBytesOwned</definition>
        <argsstring>(BaseFab&lt; T &gt; const &amp;fab) noexcept</argsstring>
        <name>nBytesOwned</name>
        <qualifiedname>amrex::nBytesOwned</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; T &gt; const &amp;</type>
          <declname>fab</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" line="61" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" bodystart="61" bodyend="61"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a449d5cd7d3d778be0440141f9272d6bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DFAB</type>
          </param>
          <param>
            <type>class SFAB</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::conjunction_v&lt; IsBaseFab&lt; DFAB &gt;, IsBaseFab&lt; SFAB &gt;, std::is_convertible&lt; typename SFAB::value_type, typename DFAB::value_type &gt; &gt;, int &gt;</type>
            <declname>BAR</declname>
            <defname>BAR</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Copy</definition>
        <argsstring>(FabArray&lt; DFAB &gt; &amp;dst, FabArray&lt; SFAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, int nghost)</argsstring>
        <name>Copy</name>
        <qualifiedname>amrex::Copy</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; DFAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; SFAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" line="180" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" bodystart="180" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a094833951f442db9516e0741bd50f6aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DFAB</type>
          </param>
          <param>
            <type>class SFAB</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::conjunction_v&lt; IsBaseFab&lt; DFAB &gt;, IsBaseFab&lt; SFAB &gt;, std::is_convertible&lt; typename SFAB::value_type, typename DFAB::value_type &gt; &gt;, int &gt;</type>
            <declname>BAR</declname>
            <defname>BAR</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Copy</definition>
        <argsstring>(FabArray&lt; DFAB &gt; &amp;dst, FabArray&lt; SFAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, const IntVect &amp;nghost)</argsstring>
        <name>Copy</name>
        <qualifiedname>amrex::Copy</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; DFAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; SFAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" line="191" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" bodystart="191" bodyend="236"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab72e53672887ede3d7ddc5f65002700e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Add</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, int nghost)</argsstring>
        <name>Add</name>
        <qualifiedname>amrex::Add</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" line="241" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" bodystart="241" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae53cc004fbab26533ec33294445a4d5c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Add</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, const IntVect &amp;nghost)</argsstring>
        <name>Add</name>
        <qualifiedname>amrex::Add</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" line="249" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArray.H" bodystart="249" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a049702dd862399b25a2acf1c140bf4bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const FabArrayBase::BDKey &amp;id)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1BDKey" kindref="compound">FabArrayBase::BDKey</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" line="2621" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" bodystart="2622" bodyend="2626" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.H" declline="789" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0cef8b304e3c55a8d985c2a8907da9e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::nComp</definition>
        <argsstring>(FabArrayBase const &amp;fa)</argsstring>
        <name>nComp</name>
        <qualifiedname>amrex::nComp</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArrayBase" kindref="compound">FabArrayBase</ref> const &amp;</type>
          <declname>fa</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" line="2854" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" bodystart="2854" bodyend="2857" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.H" declline="780" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a28fbc0acd8368951bb043d23d5c0727e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
        <definition>IntVect amrex::nGrowVect</definition>
        <argsstring>(FabArrayBase const &amp;fa)</argsstring>
        <name>nGrowVect</name>
        <qualifiedname>amrex::nGrowVect</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArrayBase" kindref="compound">FabArrayBase</ref> const &amp;</type>
          <declname>fa</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" line="2859" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" bodystart="2859" bodyend="2862" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.H" declline="781" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af69fc0af80dbc4a91b1532451e9533c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> const &amp;</type>
        <definition>BoxArray const  &amp; amrex::boxArray</definition>
        <argsstring>(FabArrayBase const &amp;fa)</argsstring>
        <name>boxArray</name>
        <qualifiedname>amrex::boxArray</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArrayBase" kindref="compound">FabArrayBase</ref> const &amp;</type>
          <declname>fa</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" line="2864" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" bodystart="2864" bodyend="2867" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.H" declline="782" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a21a1acd7c1fc44aa5ce27ab461aded41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> const &amp;</type>
        <definition>DistributionMapping const  &amp; amrex::DistributionMap</definition>
        <argsstring>(FabArrayBase const &amp;fa)</argsstring>
        <name>DistributionMap</name>
        <qualifiedname>amrex::DistributionMap</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArrayBase" kindref="compound">FabArrayBase</ref> const &amp;</type>
          <declname>fa</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" line="2869" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.cpp" bodystart="2869" bodyend="2872" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayBase.H" declline="783" declcolumn="28"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3af1dbed7575d3877b5b64882a384f12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillBoundary</definition>
        <argsstring>(Vector&lt; MF * &gt; const &amp;mf, Vector&lt; int &gt; const &amp;scomp, Vector&lt; int &gt; const &amp;ncomp, Vector&lt; IntVect &gt; const &amp;nghost, Vector&lt; Periodicity &gt; const &amp;period, Vector&lt; int &gt; const &amp;cross={})</argsstring>
        <name>FillBoundary</name>
        <qualifiedname>amrex::FillBoundary</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; const &amp;</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; const &amp;</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> &gt; const &amp;</type>
          <declname>period</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; const &amp;</type>
          <declname>cross</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayCommI.H" line="1050" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayCommI.H" bodystart="1050" bodyend="1300"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a777e5fc03f6c6077f7b4535312a517e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::FillBoundary</definition>
        <argsstring>(Vector&lt; MF * &gt; const &amp;mf, const Periodicity &amp;a_period=Periodicity::NonPeriodic())</argsstring>
        <name>FillBoundary</name>
        <qualifiedname>amrex::FillBoundary</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> &amp;</type>
          <declname>a_period</declname>
          <defval><ref refid="classamrex_1_1Periodicity_1a194e779bf59d1700830a35cecb5271a5" kindref="member">Periodicity::NonPeriodic</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayCommI.H" line="1304" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayCommI.H" bodystart="1304" bodyend="1317"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::ReduceSum</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="16" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="16" bodyend="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5e32d93cb04b6557dcf30553793aeb92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::ReduceSum</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="132" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="132" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4252562789c375cc55a545cd278cf212" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceSum</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="153" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="153" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a580c267bdc2ecf41ead1889d77b287c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceSum</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="211" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="211" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a41a3ccdb479b7b99b07b29315b85d602" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class FAB3</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceSum</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, FabArray&lt; FAB3 &gt; const &amp;fa3, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB3 &gt; const &amp;</type>
          <declname>fa3</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="234" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="234" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a643762b10ddb6c66e880320c6df34809" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class FAB3</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceSum</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, FabArray&lt; FAB3 &gt; const &amp;fa3, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB3 &gt; const &amp;</type>
          <declname>fa3</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="294" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="294" bodyend="302"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::ReduceMin</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="317" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="317" bodyend="320"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0b14cf8ae0f4d40d865377df85ff8301" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::ReduceMin</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="370" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="370" bodyend="377"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab427586186a5143d74279bb26107044a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceMin</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="391" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="391" bodyend="394"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7385647d73fd0e4b29617d87309f3c78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceMin</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="449" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="449" bodyend="457"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adbeb820864e599e86ce8f5f30773beac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class FAB3</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceMin</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, FabArray&lt; FAB3 &gt; const &amp;fa3, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB3 &gt; const &amp;</type>
          <declname>fa3</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="472" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="472" bodyend="476"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a98b8b6dfe17e7e9225a567793e47f606" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class FAB3</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceMin</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, FabArray&lt; FAB3 &gt; const &amp;fa3, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB3 &gt; const &amp;</type>
          <declname>fa3</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="532" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="532" bodyend="540"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::ReduceMax</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="555" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="555" bodyend="558"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aced90eccf9c8aa5de4fa7fddacbab125" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::ReduceMax</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="609" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="609" bodyend="616"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac8df373fd6d52b64c70d0e2c218f7b56" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceMax</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="630" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="630" bodyend="633"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0f27335e5238a53e12af0ad6dc8e04a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceMax</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="688" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="688" bodyend="696"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a07315aba6826805030c5f6fd847fc370" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class FAB3</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceMax</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, FabArray&lt; FAB3 &gt; const &amp;fa3, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB3 &gt; const &amp;</type>
          <declname>fa3</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="711" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="711" bodyend="715"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a210e45f0c136c51a835032cc34cfb0a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class FAB3</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>FAB1::value_type</type>
        <definition>FAB1::value_type amrex::ReduceMax</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, FabArray&lt; FAB3 &gt; const &amp;fa3, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB3 &gt; const &amp;</type>
          <declname>fa3</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="771" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="771" bodyend="779"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalAnd</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalAnd</name>
        <qualifiedname>amrex::ReduceLogicalAnd</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="794" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="794" bodyend="797"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1add25d5d5612fe7f7e697f9eff76568ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalAnd</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalAnd</name>
        <qualifiedname>amrex::ReduceLogicalAnd</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="847" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="847" bodyend="854"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aff9cc4b21a84dbb1def69e24fa575064" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalAnd</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalAnd</name>
        <qualifiedname>amrex::ReduceLogicalAnd</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="868" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="868" bodyend="872"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab19f7ad2a54b1e324d431adfe05978aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalAnd</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalAnd</name>
        <qualifiedname>amrex::ReduceLogicalAnd</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="926" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="926" bodyend="934"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalOr</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalOr</name>
        <qualifiedname>amrex::ReduceLogicalOr</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="949" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="949" bodyend="952"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afbf67596dd1ba6faf566beabcbab7776" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalOr</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalOr</name>
        <qualifiedname>amrex::ReduceLogicalOr</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1002" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1002" bodyend="1009"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aeddb35f2f67fa5f607d190b5d5306c9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalOr</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, int nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalOr</name>
        <qualifiedname>amrex::ReduceLogicalOr</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1023" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1023" bodyend="1027"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a93ead4b7e5a5b99b0a88040076d7fd21" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB1</type>
          </param>
          <param>
            <type>class FAB2</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB1&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalOr</definition>
        <argsstring>(FabArray&lt; FAB1 &gt; const &amp;fa1, FabArray&lt; FAB2 &gt; const &amp;fa2, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalOr</name>
        <qualifiedname>amrex::ReduceLogicalOr</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB1 &gt; const &amp;</type>
          <declname>fa1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB2 &gt; const &amp;</type>
          <declname>fa2</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1081" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1081" bodyend="1089"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a376ff66b5e6a76d195cace00df41d05e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::printCell</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;mf, const IntVect &amp;cell, int comp=-1, const IntVect &amp;ng=IntVect::TheZeroVector())</argsstring>
        <name>printCell</name>
        <qualifiedname>amrex::printCell</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>cell</declname>
        </param>
        <param>
          <type>int</type>
          <declname>comp</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ng</declname>
          <defval><ref refid="classamrex_1_1IntVectND_1ab2506f9097ba1cf1c59e8f8fe933ed83" kindref="member">IntVect::TheZeroVector</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1103" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1103" bodyend="1151"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a80257465148c89cb198291204f6d881e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Swap</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; &amp;src, int srccomp, int dstcomp, int numcomp, int nghost)</argsstring>
        <name>Swap</name>
        <qualifiedname>amrex::Swap</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1156" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1156" bodyend="1159"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a778756c697ef8ef4f05ae4fe4f26ba3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Swap</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; &amp;src, int srccomp, int dstcomp, int numcomp, const IntVect &amp;nghost)</argsstring>
        <name>Swap</name>
        <qualifiedname>amrex::Swap</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1164" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1164" bodyend="1218"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a54b8b46deca518b441b849bbd1ceda02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Subtract</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, int nghost)</argsstring>
        <name>Subtract</name>
        <qualifiedname>amrex::Subtract</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1223" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1223" bodyend="1226"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afeebec2f58b85bfde5b88b30810cd82d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Subtract</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, const IntVect &amp;nghost)</argsstring>
        <name>Subtract</name>
        <qualifiedname>amrex::Subtract</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1231" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1231" bodyend="1265"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aec148f53c2d7fcc3b00c9e91999d4058" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Multiply</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, int nghost)</argsstring>
        <name>Multiply</name>
        <qualifiedname>amrex::Multiply</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1271" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1271" bodyend="1274"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a71808e748d2cf6ea301231f278269b70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Multiply</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, const IntVect &amp;nghost)</argsstring>
        <name>Multiply</name>
        <qualifiedname>amrex::Multiply</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1279" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1279" bodyend="1313"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa9f3bb9afb6e1fdfc272654ee6923492" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Divide</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, int nghost)</argsstring>
        <name>Divide</name>
        <qualifiedname>amrex::Divide</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1319" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1319" bodyend="1322"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a98b5b165f2a8926b40da786a678ed7af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Divide</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int srccomp, int dstcomp, int numcomp, const IntVect &amp;nghost)</argsstring>
        <name>Divide</name>
        <qualifiedname>amrex::Divide</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dstcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1327" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1327" bodyend="1361"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3f0f44b09d21b49d00d3d1b12e9e2489" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Abs</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;fa, int icomp, int numcomp, int nghost)</argsstring>
        <name>Abs</name>
        <qualifiedname>amrex::Abs</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1366" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1366" bodyend="1369"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a76eee97924f5b2d883d161eb976b2cad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Abs</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;fa, int icomp, int numcomp, const IntVect &amp;nghost)</argsstring>
        <name>Abs</name>
        <qualifiedname>amrex::Abs</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1374" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1374" bodyend="1406"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab02b05e2eb3282f8df33e5cbc655b2a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::prefetchToHost</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, const bool synchronous=true)</argsstring>
        <name>prefetchToHost</name>
        <qualifiedname>amrex::prefetchToHost</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>synchronous</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1410" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1410" bodyend="1421"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4db8bcd1f50c790aba6b81860143cc96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::prefetchToDevice</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, const bool synchronous=true)</argsstring>
        <name>prefetchToDevice</name>
        <qualifiedname>amrex::prefetchToDevice</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>synchronous</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1425" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1425" bodyend="1436"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5821b989454c54f92dd1f2312e95b5b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class IFAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value                                                               &amp;&amp; IsBaseFab&lt;IFAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::OverrideSync</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;fa, FabArray&lt; IFAB &gt; const &amp;msk, const Periodicity &amp;period)</argsstring>
        <name>OverrideSync</name>
        <qualifiedname>amrex::OverrideSync</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; IFAB &gt; const &amp;</type>
          <declname>msk</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> &amp;</type>
          <declname>period</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1442" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1442" bodyend="1448"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af6d31b25633d781cd8fe931951889e6c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class IFAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value                                                               &amp;&amp; IsBaseFab&lt;IFAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::OverrideSync_nowait</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;fa, FabArray&lt; IFAB &gt; const &amp;msk, const Periodicity &amp;period)</argsstring>
        <name>OverrideSync_nowait</name>
        <qualifiedname>amrex::OverrideSync_nowait</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; IFAB &gt; const &amp;</type>
          <declname>msk</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> &amp;</type>
          <declname>period</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1454" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1454" bodyend="1497"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad81d4975698feb7461d8ad18c21c7951" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class bar</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::OverrideSync_finish</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;fa)</argsstring>
        <name>OverrideSync_finish</name>
        <qualifiedname>amrex::OverrideSync_finish</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1501" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1501" bodyend="1511"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a998c5815369d23cd73eea1b09f43a966" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::dtoh_memcpy</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int scomp, int dcomp, int ncomp)</argsstring>
        <name>dtoh_memcpy</name>
        <qualifiedname>amrex::dtoh_memcpy</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1515" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1515" bodyend="1529"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8531953b8fba66482d81cad6c5dc3e73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::dtoh_memcpy</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src)</argsstring>
        <name>dtoh_memcpy</name>
        <qualifiedname>amrex::dtoh_memcpy</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1533" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1533" bodyend="1536"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae243b10c65516ed7dfeaf9aed7e75aa3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::htod_memcpy</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src, int scomp, int dcomp, int ncomp)</argsstring>
        <name>htod_memcpy</name>
        <qualifiedname>amrex::htod_memcpy</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1540" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1540" bodyend="1554"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa9df7c449e875ece24add0d826c4f133" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::htod_memcpy</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dst, FabArray&lt; FAB &gt; const &amp;src)</argsstring>
        <name>htod_memcpy</name>
        <qualifiedname>amrex::htod_memcpy</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1558" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1558" bodyend="1561"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af1fe8dd7d2e436cf2e4e696b9b5ae006" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
        <definition>IntVect amrex::indexFromValue</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;mf, int comp, IntVect const &amp;nghost, typename FAB::value_type value)</argsstring>
        <name>indexFromValue</name>
        <qualifiedname>amrex::indexFromValue</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>comp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>typename FAB::value_type</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1565" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1565" bodyend="1658"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad99f216d6d06fb8bc99e3597173b7ef7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsBaseFab&lt; FAB &gt;::value, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::Dot</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;x, int xcomp, FabArray&lt; FAB &gt; const &amp;y, int ycomp, int ncomp, IntVect const &amp;nghost, bool local=false)</argsstring>
        <name>Dot</name>
        <qualifiedname>amrex::Dot</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>xcomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ycomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Compute dot products of two FabArrays. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>first <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>second <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ycomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of y </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>local</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, MPI communication is skipped. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1673" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1673" bodyend="1722"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab581fa08157574f4cb1f82702f5714f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsBaseFab&lt; FAB &gt;::value, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::Dot</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;x, int xcomp, int ncomp, IntVect const &amp;nghost, bool local=false)</argsstring>
        <name>Dot</name>
        <qualifiedname>amrex::Dot</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>xcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Compute dot product of <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> with itself. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>local</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, MPI communication is skipped. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1735" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1735" bodyend="1780"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4c9419f3bb631469eb846977ada50eb2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename IFAB</type>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsBaseFab&lt; FAB &gt;::value &amp;&amp;IsBaseFab&lt; IFAB &gt;::value, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::Dot</definition>
        <argsstring>(FabArray&lt; IFAB &gt; const &amp;mask, FabArray&lt; FAB &gt; const &amp;x, int xcomp, FabArray&lt; FAB &gt; const &amp;y, int ycomp, int ncomp, IntVect const &amp;nghost, bool local=false)</argsstring>
        <name>Dot</name>
        <qualifiedname>amrex::Dot</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; IFAB &gt; const &amp;</type>
          <declname>mask</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>xcomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ycomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Compute dot product of two FabArrays in region that mask is true. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>first <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>second <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ycomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of y </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>local</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, MPI communication is skipped. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1797" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1797" bodyend="1854"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3bc1446ffd74cc1d52a10b3b4f968892" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename IFAB</type>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsBaseFab&lt; FAB &gt;::value &amp;&amp;IsBaseFab&lt; IFAB &gt;::value, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>FAB::value_type</type>
        <definition>FAB::value_type amrex::Dot</definition>
        <argsstring>(FabArray&lt; IFAB &gt; const &amp;mask, FabArray&lt; FAB &gt; const &amp;x, int xcomp, int ncomp, IntVect const &amp;nghost, bool local=false)</argsstring>
        <name>Dot</name>
        <qualifiedname>amrex::Dot</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; IFAB &gt; const &amp;</type>
          <declname>mask</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>xcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Compute dot product of <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> with itself in region that mask is true. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>mask </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component of x </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>local</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, MPI communication is skipped. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1869" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1869" bodyend="1923"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae26f96532b61a1b39722a6125552c74c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::setVal</definition>
        <argsstring>(MF &amp;dst, typename MF::value_type val)</argsstring>
        <name>setVal</name>
        <qualifiedname>amrex::setVal</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>dst = val </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1927" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1927" bodyend="1930"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9e2396222f45dde47fc1cbf4fb45f162" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::setBndry</definition>
        <argsstring>(MF &amp;dst, typename MF::value_type val, int scomp, int ncomp)</argsstring>
        <name>setBndry</name>
        <qualifiedname>amrex::setBndry</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>val</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <briefdescription>
<para>dst = val in ghost cells. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1934" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1934" bodyend="1937"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab022cfcd5d3aa8db8abebe9fd6982f88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Scale</definition>
        <argsstring>(MF &amp;dst, typename MF::value_type val, int scomp, int ncomp, int nghost)</argsstring>
        <name>Scale</name>
        <qualifiedname>amrex::Scale</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>val</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst *= val </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1941" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1941" bodyend="1944"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3659f85fe1cf3635a62a6d417f9978bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DMF</type>
          </param>
          <param>
            <type>class SMF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; DMF &gt; &amp;&amp;IsMultiFabLike_v&lt; SMF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LocalCopy</definition>
        <argsstring>(DMF &amp;dst, SMF const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>LocalCopy</name>
        <qualifiedname>amrex::LocalCopy</qualifiedname>
        <param>
          <type>DMF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>SMF const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst = src </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1950" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1950" bodyend="1954"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3f948e8f69355439c8e408405d24eb05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LocalAdd</definition>
        <argsstring>(MF &amp;dst, MF const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>LocalAdd</name>
        <qualifiedname>amrex::LocalAdd</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst += src </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1958" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1958" bodyend="1962"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a22f88c7717e00b4c2a7fa3f01baa5668" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Saxpy</definition>
        <argsstring>(MF &amp;dst, typename MF::value_type a, MF const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>Saxpy</name>
        <qualifiedname>amrex::Saxpy</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst += a * src </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1966" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1966" bodyend="1970"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aafbeb2d5f8af6c2d371818a5b8b8b10e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Xpay</definition>
        <argsstring>(MF &amp;dst, typename MF::value_type a, MF const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>Xpay</name>
        <qualifiedname>amrex::Xpay</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst = src + a * dst </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1974" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1974" bodyend="1978"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa24df3cb31fc7cf3e804f5d8f50721f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Saxpy_Xpay</definition>
        <argsstring>(MF &amp;dst, typename MF::value_type a_saxpy, MF const &amp;src_saxpy, typename MF::value_type a_xpay, MF const &amp;src_xpay, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>Saxpy_Xpay</name>
        <qualifiedname>amrex::Saxpy_Xpay</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a_saxpy</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src_saxpy</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a_xpay</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src_xpay</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst += a_saxpy * src_saxpy followed by dst = src_xpay + a_xpay * dst </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1982" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1982" bodyend="1987"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6555c8be832a6712d826abce4e1026e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Saxpy_Saxpy</definition>
        <argsstring>(MF &amp;dst1, typename MF::value_type a1, MF const &amp;src1, MF &amp;dst2, typename MF::value_type a2, MF const &amp;src2, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>Saxpy_Saxpy</name>
        <qualifiedname>amrex::Saxpy_Saxpy</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst1</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a1</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src1</declname>
        </param>
        <param>
          <type>MF &amp;</type>
          <declname>dst2</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a2</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src2</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst1 += a1 * src1 followed by dst2 += a2 * src2 </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="1991" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="1991" bodyend="1996"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a72789b048ec506e1706ddb7adbedee91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Saypy_Saxpy</definition>
        <argsstring>(MF &amp;dst1, typename MF::value_type a1, MF &amp;dst2, typename MF::value_type a2, MF const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>Saypy_Saxpy</name>
        <qualifiedname>amrex::Saypy_Saxpy</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst1</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a1</declname>
        </param>
        <param>
          <type>MF &amp;</type>
          <declname>dst2</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a2</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst1 += a1 * dst2 followed by dst2 += a2 * src </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2000" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2000" bodyend="2005"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a932a04b3088166f5be65d24d2de33213" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LinComb</definition>
        <argsstring>(MF &amp;dst, typename MF::value_type a, MF const &amp;src_a, int acomp, typename MF::value_type b, MF const &amp;src_b, int bcomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>LinComb</name>
        <qualifiedname>amrex::LinComb</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src_a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>acomp</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>b</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src_b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst = a*src_a + b*src_b </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2009" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2009" bodyend="2015"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adadc145305be656128ae5ce4406166a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelCopy</definition>
        <argsstring>(MF &amp;dst, MF const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;ng_src=IntVect(0), IntVect const &amp;ng_dst=IntVect(0), Periodicity const &amp;period=Periodicity::NonPeriodic())</argsstring>
        <name>ParallelCopy</name>
        <qualifiedname>amrex::ParallelCopy</qualifiedname>
        <param>
          <type>MF &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng_src</declname>
          <defval><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>(0)</defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng_dst</declname>
          <defval><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>(0)</defval>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
          <defval><ref refid="classamrex_1_1Periodicity_1a194e779bf59d1700830a35cecb5271a5" kindref="member">Periodicity::NonPeriodic</ref>()</defval>
        </param>
        <briefdescription>
<para>dst = src w/ MPI communication </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2019" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2019" bodyend="2025"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a02870cc0ddaa25fae3bd252bb65da3a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>MF::value_type</type>
        <definition>MF::value_type amrex::norminf</definition>
        <argsstring>(MF const &amp;mf, int scomp, int ncomp, IntVect const &amp;nghost, bool local=false)</argsstring>
        <name>norminf</name>
        <qualifiedname>amrex::norminf</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2029" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2029" bodyend="2033"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a218ff989e44a5c9d38b430f9fd2de4cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::setVal</definition>
        <argsstring>(Array&lt; MF, N &gt; &amp;dst, typename MF::value_type val)</argsstring>
        <name>setVal</name>
        <qualifiedname>amrex::setVal</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>dst = val </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2037" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2037" bodyend="2042"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a380fc7ccd2dfefbe1d03434086a21555" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::setBndry</definition>
        <argsstring>(Array&lt; MF, N &gt; &amp;dst, typename MF::value_type val, int scomp, int ncomp)</argsstring>
        <name>setBndry</name>
        <qualifiedname>amrex::setBndry</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>val</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <briefdescription>
<para>dst = val in ghost cells. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2046" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2046" bodyend="2051"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a92f80b3d77660ad64c4a4fc8862708b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Scale</definition>
        <argsstring>(Array&lt; MF, N &gt; &amp;dst, typename MF::value_type val, int scomp, int ncomp, int nghost)</argsstring>
        <name>Scale</name>
        <qualifiedname>amrex::Scale</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>val</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst *= val </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2055" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2055" bodyend="2061"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aafcaf9751e46f39c2698dadad34f0c71" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class DMF</type>
          </param>
          <param>
            <type>class SMF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; DMF &gt; &amp;&amp;IsMultiFabLike_v&lt; SMF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LocalCopy</definition>
        <argsstring>(Array&lt; DMF, N &gt; &amp;dst, Array&lt; SMF, N &gt; const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>LocalCopy</name>
        <qualifiedname>amrex::LocalCopy</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; DMF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; SMF, N &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst = src </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2067" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2067" bodyend="2073"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a213a47a1b802fdf7a0a7bb562f3959f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LocalAdd</definition>
        <argsstring>(Array&lt; MF, N &gt; &amp;dst, Array&lt; MF, N &gt; const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>LocalAdd</name>
        <qualifiedname>amrex::LocalAdd</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst += src </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2077" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2077" bodyend="2083"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab62706b1ead6a26e124cc6c7359ab109" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Saxpy</definition>
        <argsstring>(Array&lt; MF, N &gt; &amp;dst, typename MF::value_type a, Array&lt; MF, N &gt; const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>Saxpy</name>
        <qualifiedname>amrex::Saxpy</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst += a * src </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2087" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2087" bodyend="2094"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a25babe95b2334561dc4664fd9ff1fd20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Xpay</definition>
        <argsstring>(Array&lt; MF, N &gt; &amp;dst, typename MF::value_type a, Array&lt; MF, N &gt; const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>Xpay</name>
        <qualifiedname>amrex::Xpay</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst = src + a * dst </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2098" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2098" bodyend="2105"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af278d1e4cb4398d1743bca45138fa9a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LinComb</definition>
        <argsstring>(Array&lt; MF, N &gt; &amp;dst, typename MF::value_type a, Array&lt; MF, N &gt; const &amp;src_a, int acomp, typename MF::value_type b, Array&lt; MF, N &gt; const &amp;src_b, int bcomp, int dcomp, int ncomp, IntVect const &amp;nghost)</argsstring>
        <name>LinComb</name>
        <qualifiedname>amrex::LinComb</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>src_a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>acomp</declname>
        </param>
        <param>
          <type>typename MF::value_type</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>src_b</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <briefdescription>
<para>dst = a*src_a + b*src_b </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2109" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2109" bodyend="2117"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4b5b2920e4c1f13544630db42af9eaca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelCopy</definition>
        <argsstring>(Array&lt; MF, N &gt; &amp;dst, Array&lt; MF, N &gt; const &amp;src, int scomp, int dcomp, int ncomp, IntVect const &amp;ng_src=IntVect(0), IntVect const &amp;ng_dst=IntVect(0), Periodicity const &amp;period=Periodicity::NonPeriodic())</argsstring>
        <name>ParallelCopy</name>
        <qualifiedname>amrex::ParallelCopy</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng_src</declname>
          <defval><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>(0)</defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng_dst</declname>
          <defval><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>(0)</defval>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
          <defval><ref refid="classamrex_1_1Periodicity_1a194e779bf59d1700830a35cecb5271a5" kindref="member">Periodicity::NonPeriodic</ref>()</defval>
        </param>
        <briefdescription>
<para>dst = src w/ MPI communication </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2121" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2121" bodyend="2130"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0298f67b516f80f783d08d796763d0bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>MF::value_type</type>
        <definition>MF::value_type amrex::norminf</definition>
        <argsstring>(Array&lt; MF, N &gt; const &amp;mf, int scomp, int ncomp, IntVect const &amp;nghost, bool local=false)</argsstring>
        <name>norminf</name>
        <qualifiedname>amrex::norminf</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2134" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2134" bodyend="2146"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a27531cc00ae88701b82d827296ac6496" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt; &amp;&amp;(N &gt; 0), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::nComp</definition>
        <argsstring>(Array&lt; MF, N &gt; const &amp;mf)</argsstring>
        <name>nComp</name>
        <qualifiedname>amrex::nComp</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2150" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2150" bodyend="2153"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a35376063ac1a1e47b47f61e5c0b169e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt; &amp;&amp;(N &gt; 0), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
        <definition>IntVect amrex::nGrowVect</definition>
        <argsstring>(Array&lt; MF, N &gt; const &amp;mf)</argsstring>
        <name>nGrowVect</name>
        <qualifiedname>amrex::nGrowVect</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2157" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2157" bodyend="2160"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a734203d56d84066cf0ac227feb40e0a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt; &amp;&amp;(N &gt; 0), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> const &amp;</type>
        <definition>BoxArray const  &amp; amrex::boxArray</definition>
        <argsstring>(Array&lt; MF, N &gt; const &amp;mf)</argsstring>
        <name>boxArray</name>
        <qualifiedname>amrex::boxArray</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2165" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2165" bodyend="2168"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adf8dd364320055dc090911f79bd0e51e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; MF &gt; &amp;&amp;(N &gt; 0), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> const &amp;</type>
        <definition>DistributionMapping const  &amp; amrex::DistributionMap</definition>
        <argsstring>(Array&lt; MF, N &gt; const &amp;mf)</argsstring>
        <name>DistributionMap</name>
        <qualifiedname>amrex::DistributionMap</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF, N &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2173" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2173" bodyend="2176"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5b03cad3144b45df7691ca553e1f507c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; <ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; int &gt; &gt;</type>
        <definition>FabArray&lt; BaseFab&lt; int &gt; &gt; amrex::OverlapMask</definition>
        <argsstring>(FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, Periodicity const &amp;period)</argsstring>
        <name>OverlapMask</name>
        <qualifiedname>amrex::OverlapMask</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" line="2187" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabArrayUtility.H" bodystart="2187" bodyend="2246"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac185c39750011cc24fb8c1a0b872a34d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const IntDescriptor &amp;id)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write out an <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> to an ostream in ASCII. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.cpp" line="49" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.cpp" bodystart="50" bodyend="63" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.H" declline="67" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0ed9b6ea967b3a6cebc43973e1440e06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, IntDescriptor &amp;id)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read in an <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> from an istream. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.cpp" line="66" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.cpp" bodystart="66" bodyend="89" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.H" declline="71" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a571e81ef7e9fdb96f23e2691c59e1b0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const RealDescriptor &amp;rd)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealDescriptor" kindref="compound">amrex::RealDescriptor</ref> &amp;</type>
          <declname>rd</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write out an <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> to an ostream in ASCII. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.cpp" line="881" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.cpp" bodystart="882" bodyend="895" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.H" declline="254" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a543f68ea96151adca9c24601b7f472e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, RealDescriptor &amp;rd)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1RealDescriptor" kindref="compound">amrex::RealDescriptor</ref> &amp;</type>
          <declname>rd</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read in a <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> from an istream. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.cpp" line="898" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.cpp" bodystart="898" bodyend="920" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FabConv.H" declline="258" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a644864c6cc33620e712d8de0cb6b6a6c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const FArrayBox &amp;f)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FArrayBox" kindref="compound">FArrayBox</ref> &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FArrayBox.cpp" line="975" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FArrayBox.cpp" bodystart="976" bodyend="992"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad8642429f22cbe2a6bcbb34fd4444669" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, FArrayBox &amp;f)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FArrayBox" kindref="compound">FArrayBox</ref> &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FArrayBox.cpp" line="995" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FArrayBox.cpp" bodystart="995" bodyend="1012"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a30ee6a24a0b0fd18d710278879681aed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::fab_filcc</definition>
        <argsstring>(Box const &amp;bx, Array4&lt; Real &gt; const &amp;qn, int ncomp, Box const &amp;domain, Real const *, Real const *, BCRec const *bcn)</argsstring>
        <name>fab_filcc</name>
        <qualifiedname>amrex::fab_filcc</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>qn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const *</type>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const *</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> const *</type>
          <declname>bcn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FilCC_C.cpp" line="5" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FilCC_C.cpp" bodystart="5" bodyend="778"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3440f6cdd23e00f1fa05a2cf05e8a482" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::fab_filfc</definition>
        <argsstring>(Box const &amp;bx, Array4&lt; Real &gt; const &amp;qn, int ncomp, Box const &amp;domain, Real const *, Real const *, BCRec const *bcn)</argsstring>
        <name>fab_filfc</name>
        <qualifiedname>amrex::fab_filfc</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>qn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const *</type>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const *</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> const *</type>
          <declname>bcn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FilFC_C.cpp" line="5" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FilFC_C.cpp" bodystart="5" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7584537c492af5e1cad3da079a51c324" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::fab_filnd</definition>
        <argsstring>(Box const &amp;bx, Array4&lt; Real &gt; const &amp;qn, int ncomp, Box const &amp;domain, Real const *, Real const *, BCRec const *bcn)</argsstring>
        <name>fab_filnd</name>
        <qualifiedname>amrex::fab_filnd</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>qn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const *</type>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const *</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> const *</type>
          <declname>bcn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_FilND_C.cpp" line="5" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_FilND_C.cpp" bodystart="5" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad287398c706f3a1775e0954b73e5c779" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;, const Geometry &amp;)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Nice ASCII output. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.cpp" line="17" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.cpp" bodystart="18" bodyend="22" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" declline="471" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5086c850dfa16df677225c8c1139e466" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;, Geometry &amp;)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>g</declname>
        </param>
        <briefdescription>
<para>Nice ASCII input. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.cpp" line="25" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.cpp" bodystart="25" bodyend="43" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" declline="473" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adbc2cc619f36c517e2d0c6cbc5a40068" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref></type>
        <definition>Geometry amrex::coarsen</definition>
        <argsstring>(Geometry const &amp;fine, IntVect const &amp;rr)</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>rr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" line="477" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" bodystart="477" bodyend="481"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abf0376e5e15137aa9ec711295e7bf6bf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref></type>
        <definition>Geometry amrex::coarsen</definition>
        <argsstring>(Geometry const &amp;fine, int rr)</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>int</type>
          <declname>rr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" line="485" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" bodystart="485" bodyend="485"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad0f0f651612f7b14e3c2768e69aaeb92" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref></type>
        <definition>Geometry amrex::refine</definition>
        <argsstring>(Geometry const &amp;crse, IntVect const &amp;rr)</argsstring>
        <name>refine</name>
        <qualifiedname>amrex::refine</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>rr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" line="489" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" bodystart="489" bodyend="493"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a54d77694c8efe15e13ae6e08ba5e9fae" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref></type>
        <definition>Geometry amrex::refine</definition>
        <argsstring>(Geometry const &amp;crse, int rr)</argsstring>
        <name>refine</name>
        <qualifiedname>amrex::refine</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>rr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" line="497" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" bodystart="497" bodyend="497"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa5b2bd23abee24f752611a40efe3046c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
        <definition>const Geometry &amp; amrex::DefaultGeometry</definition>
        <argsstring>()</argsstring>
        <name>DefaultGeometry</name>
        <qualifiedname>amrex::DefaultGeometry</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" line="501" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Geometry.H" bodystart="501" bodyend="503"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa92fe9cc159271081f5d93db53a531f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename A1</type>
          </param>
          <param>
            <type>typename A2</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsArenaAllocator&lt; A1 &gt;::value &amp;&amp;IsArenaAllocator&lt; A2 &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::operator==</definition>
        <argsstring>(A1 const &amp;a1, A2 const &amp;a2)</argsstring>
        <name>operator==</name>
        <qualifiedname>amrex::operator==</qualifiedname>
        <param>
          <type>A1 const &amp;</type>
          <declname>a1</declname>
        </param>
        <param>
          <type>A2 const &amp;</type>
          <declname>a2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuAllocators.H" line="202" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuAllocators.H" bodystart="202" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8e766038223d0266729aaf683f0b45be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename A1</type>
          </param>
          <param>
            <type>typename A2</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsArenaAllocator&lt; A1 &gt;::value &amp;&amp;IsArenaAllocator&lt; A2 &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::operator!=</definition>
        <argsstring>(A1 const &amp;a1, A2 const &amp;a2)</argsstring>
        <name>operator!=</name>
        <qualifiedname>amrex::operator!=</qualifiedname>
        <param>
          <type>A1 const &amp;</type>
          <declname>a1</declname>
        </param>
        <param>
          <type>A2 const &amp;</type>
          <declname>a2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuAllocators.H" line="210" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuAllocators.H" bodystart="210" bodyend="213"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1fbb153d0895a40b78bf9a7499f1f9f6" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ T</type>
        <definition>__host__ __device__ T amrex::norm</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_z) noexcept</argsstring>
        <name>norm</name>
        <qualifiedname>amrex::norm</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_z</declname>
        </param>
        <briefdescription>
<para>Return the norm (magnitude squared) of a complex number. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="349" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="349" bodyend="354" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" declline="16" declcolumn="3"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a78c867a478e87e0f94ae5e208e1bb44a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const GpuComplex&lt; U &gt; &amp;c)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; U &gt; &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="159" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="159" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a28a2ff57157afc3f66e22ff8a4b9035f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator+</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x)</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <briefdescription>
<para>Identity operation on a complex number. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="171" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="171" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a395bc94e5c67a40f8ac625d2716c14c8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator-</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x)</argsstring>
        <name>operator-</name>
        <qualifiedname>amrex::operator-</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <briefdescription>
<para>Negate a complex number. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="178" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="178" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a044134c1b60ebab90a63407725bd290e" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator-</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x, const GpuComplex&lt; T &gt; &amp;a_y) noexcept</argsstring>
        <name>operator-</name>
        <qualifiedname>amrex::operator-</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Subtract two complex numbers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="185" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="185" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a85a8c75418fcb0bba110f44058141da2" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator-</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x, const T &amp;a_y) noexcept</argsstring>
        <name>operator-</name>
        <qualifiedname>amrex::operator-</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Subtract a real number from a complex one. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="197" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="197" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a19900fb7670e54c43a0b967b7566c4e4" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator-</definition>
        <argsstring>(const T &amp;a_x, const GpuComplex&lt; T &gt; &amp;a_y) noexcept</argsstring>
        <name>operator-</name>
        <qualifiedname>amrex::operator-</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Subtract a complex number from a real one. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="209" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="209" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad72333dfba49493b0b3c1aa6f939ac86" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator+</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x, const GpuComplex&lt; T &gt; &amp;a_y) noexcept</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Add two complex numbers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="221" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="221" bodyend="226"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aefc7b3fa6fb08e1dfbb079a33ef3bdbc" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator+</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x, const T &amp;a_y) noexcept</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Add a real number to a complex one. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="233" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="233" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a663f0f1927ddba5fd510d9e60d4a1fb8" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator+</definition>
        <argsstring>(const T &amp;a_x, const GpuComplex&lt; T &gt; &amp;a_y) noexcept</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Add a complex number to a real one. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="245" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="245" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5a2b77e6f7f970fc23e0278a544aa4ef" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator*</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x, const GpuComplex&lt; U &gt; &amp;a_y) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>amrex::operator*</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; U &gt; &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Multiply two complex numbers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="257" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="257" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a771f75d7822ad994d80e5611781a3094" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator*</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x, const U &amp;a_y) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>amrex::operator*</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Multiply a complex number by a real one. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="269" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="269" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3c00f4ed6b90c536678ba3adf8bdb63b" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator*</definition>
        <argsstring>(const T &amp;a_x, const GpuComplex&lt; T &gt; &amp;a_y) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>amrex::operator*</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Multiply a real number by a complex one. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="281" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="281" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa1edd9f39dda27f28b422072e76c7dd5" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator/</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x, const GpuComplex&lt; T &gt; &amp;a_y) noexcept</argsstring>
        <name>operator/</name>
        <qualifiedname>amrex::operator/</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Divide a complex number by another one. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="293" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="293" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a57e2d42898bcd035b9a90dea4d7e8f31" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator/</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_x, const T &amp;a_y) noexcept</argsstring>
        <name>operator/</name>
        <qualifiedname>amrex::operator/</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Divide a complex number by a real. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="305" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="305" bodyend="310"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab5ab6183e97426abd9a14bffada2f688" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::operator/</definition>
        <argsstring>(const T &amp;a_x, const GpuComplex&lt; T &gt; &amp;a_y) noexcept</argsstring>
        <name>operator/</name>
        <qualifiedname>amrex::operator/</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a_x</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Divide a real number by a complex one. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="317" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="317" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5ef1a6d573444d25fd390b1662ccf148" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::polar</definition>
        <argsstring>(const T &amp;a_r, const T &amp;a_theta) noexcept</argsstring>
        <name>polar</name>
        <qualifiedname>amrex::polar</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>a_r</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a_theta</declname>
        </param>
        <briefdescription>
<para>Return a complex number given its polar representation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="329" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="329" bodyend="332"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aae8cf126d10650f57ee30d33f675b77c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::exp</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_z) noexcept</argsstring>
        <name>exp</name>
        <qualifiedname>amrex::exp</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_z</declname>
        </param>
        <briefdescription>
<para>Complex expotential function. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="339" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="339" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9f75dcaea40fb24f23f6540e51976ec8" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ T</type>
        <definition>__host__ __device__ T amrex::abs</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_z) noexcept</argsstring>
        <name>abs</name>
        <qualifiedname>amrex::abs</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_z</declname>
        </param>
        <briefdescription>
<para>Return the absolute value of a complex number. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="361" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="361" bodyend="371"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae2a8c9aa84efc7a7f4b407f16a3bfcac" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::sqrt</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_z) noexcept</argsstring>
        <name>sqrt</name>
        <qualifiedname>amrex::sqrt</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_z</declname>
        </param>
        <briefdescription>
<para>Return the square root of a complex number. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="378" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="378" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1d4a9589e4112856cf8735a07e02dc05" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ T</type>
        <definition>__host__ __device__ T amrex::arg</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_z) noexcept</argsstring>
        <name>arg</name>
        <qualifiedname>amrex::arg</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_z</declname>
        </param>
        <briefdescription>
<para>Return the angle of a complex number&apos;s polar representation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="403" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="403" bodyend="406"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7e727d6241c95fa0514893568385c279" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::log</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_z) noexcept</argsstring>
        <name>log</name>
        <qualifiedname>amrex::log</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_z</declname>
        </param>
        <briefdescription>
<para>Complex natural logarithm function. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="413" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="413" bodyend="416"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2a686d717dfc09897ddca32c75e06300" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::pow</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_z, const T &amp;a_y) noexcept</argsstring>
        <name>pow</name>
        <qualifiedname>amrex::pow</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_z</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>a_y</declname>
        </param>
        <briefdescription>
<para>Raise a complex number to a (real) power. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="423" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="423" bodyend="431"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a38960cb7300a045879a48b756f3be0ed" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt;</type>
        <definition>__host__ __device__ GpuComplex&lt; T &gt; amrex::pow</definition>
        <argsstring>(const GpuComplex&lt; T &gt; &amp;a_z, int a_n) noexcept</argsstring>
        <name>pow</name>
        <qualifiedname>amrex::pow</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuComplex" kindref="compound">GpuComplex</ref>&lt; T &gt; &amp;</type>
          <declname>a_z</declname>
        </param>
        <param>
          <type>int</type>
          <declname>a_n</declname>
        </param>
        <briefdescription>
<para>Raise a complex number to an integer power. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" line="460" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuComplex.H" bodystart="460" bodyend="465"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9350dac44e563ea3d35902cf36cf4b00" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a98a85f350a96eb36272d756d5a9c9a05" kindref="member">gpuError_t</ref></type>
        <definition>gpuError_t amrex::gpuGetLastError</definition>
        <argsstring>()</argsstring>
        <name>gpuGetLastError</name>
        <qualifiedname>amrex::gpuGetLastError</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuError.H" line="37" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuError.H" bodystart="37" bodyend="39"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a79b913ab583aa109660a3d6b829d95d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char * amrex::gpuGetErrorString</definition>
        <argsstring>(gpuError_t error)</argsstring>
        <name>gpuGetErrorString</name>
        <qualifiedname>amrex::gpuGetErrorString</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a98a85f350a96eb36272d756d5a9c9a05" kindref="member">gpuError_t</ref></type>
          <declname>error</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuError.H" line="42" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuError.H" bodystart="42" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aed052bd73e2ad4d248708e710c534633" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class L</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Lambdas</declname>
            <defname>Lambdas</defname>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void amrex::launch_global</definition>
        <argsstring>(L f0, Lambdas... fs)</argsstring>
        <name>launch_global</name>
        <qualifiedname>amrex::launch_global</qualifiedname>
        <param>
          <type>L</type>
          <declname>f0</declname>
        </param>
        <param>
          <type>Lambdas...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunch.H" line="55" column="23" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunch.H" bodystart="55" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a006c22eb1e141a0784faa415c00a49c4" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch_host</definition>
        <argsstring>(L &amp;&amp;f0) noexcept</argsstring>
        <name>launch_host</name>
        <qualifiedname>amrex::launch_host</qualifiedname>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f0</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunch.H" line="72" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunch.H" bodystart="72" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a12c011a8bc6459b1c2a8f691b2554972" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class L</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Lambdas</declname>
            <defname>Lambdas</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch_host</definition>
        <argsstring>(L &amp;&amp;f0, Lambdas &amp;&amp;... fs) noexcept</argsstring>
        <name>launch_host</name>
        <qualifiedname>amrex::launch_host</qualifiedname>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f0</declname>
        </param>
        <param>
          <type>Lambdas &amp;&amp;...</type>
          <declname>fs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunch.H" line="75" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunch.H" bodystart="75" bodyend="78"/>
      </memberdef>
      <member refid="group__amrex__execution_1ga04c5802123f70da48b28edc03aaa7a00" kind="function"><name>ParallelForOMP</name></member>
      <member refid="group__amrex__execution_1ga3aae358bff466d224feb83e88581f818" kind="function"><name>ParallelForOMP</name></member>
      <member refid="group__amrex__execution_1gaf0cfb9300117e9ffda0bd23a9768aebd" kind="function"><name>ParallelForOMP</name></member>
      <memberdef kind="function" id="namespaceamrex_1a685ae8eab582f895ce964b6a99030ef2" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch</definition>
        <argsstring>(T const &amp;n, L &amp;&amp;f) noexcept</argsstring>
        <name>launch</name>
        <qualifiedname>amrex::launch</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="140" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="140" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a30469a18e5c88bd166595ac713cabe22" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch</definition>
        <argsstring>(T const &amp;n, L &amp;&amp;f) noexcept</argsstring>
        <name>launch</name>
        <qualifiedname>amrex::launch</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="146" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="146" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adb038d495d77c299406ea33380d0f548" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::For</definition>
        <argsstring>(T n, L const &amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="154" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="154" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a22c6c19b7533ed5219ce1853d5aa625d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(T n, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="162" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="162" bodyend="166"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a58f6305adbac638674782f274ce8bb80" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="169" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="169" bodyend="172"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7cea287f0304e88558d9ca04a4c36ed8" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="175" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="175" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af60d0d1ff2d8e4b50ece6b220764f064" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::ParallelFor</definition>
        <argsstring>(T n, L const &amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="183" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="183" bodyend="189"/>
      </memberdef>
      <member refid="group__amrex__execution_1ga072608d6bf753001563975d5a8fe4fbd" kind="function"><name>ParallelFor</name></member>
      <memberdef kind="function" id="namespaceamrex_1a7329f7a3e903d5a9abcd5f8603def1a1" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>WIDTH</declname>
            <defname>WIDTH</defname>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;N&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::ParallelForSIMD</definition>
        <argsstring>(N n, L const &amp;f) noexcept</argsstring>
        <name>ParallelForSIMD</name>
        <qualifiedname>amrex::ParallelForSIMD</qualifiedname>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>ParallelFor with a SIMD Width (in elements)</para>
<para>SIMD load/Write-back operations need to be performed before/after calling this.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>WIDTH</parametername>
</parameternamelist>
<parameterdescription>
<para>SIMD width in elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>index type (integer) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>L</parametername>
</parameternamelist>
<parameterdescription>
<para>function/functor to call per SIMD set of elements </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="208" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="208" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3402f6ed86316371198e6c2ff17ac5ac" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="224" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="224" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afc6cc810bf41a81eface49f9cc852316" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="230" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="230" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0d978e5f393e8e667b075e736636f1c4" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L const &amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="270" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="270" bodyend="276"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad35f3db1603e73e8e8d7f652bb6865eb" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="279" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="279" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9a81d8c924a27f9fb7decf2d2ac1dcd8" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="286" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="286" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad6b4af72f2df44517e9b6162fbe028d2" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="292" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="292" bodyend="296"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a66c7166d0d13ddd9eae467278ebea3d1" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::ParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L const &amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="335" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="335" bodyend="341"/>
      </memberdef>
      <member refid="group__amrex__execution_1ga48c30f3939e6a0577acf93eca7ee74e8" kind="function"><name>ParallelFor</name></member>
      <memberdef kind="function" id="namespaceamrex_1ab1293861fa35f7217666cb145467f09f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="351" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="351" bodyend="354"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab9f2354c8582cd76f586127d34330e3c" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="357" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="357" bodyend="361"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac265b5bf7b7f3dca04c343c198b4d6ae" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L const &amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="397" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="397" bodyend="405"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a82a13be7442ff8f47fe56b3fdd1665c2" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="408" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="408" bodyend="412"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a251ca4b51f175328b286fdfd7171c15f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="415" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="415" bodyend="418"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a04fbb0e48ef14f89ace92b1cc058e043" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="421" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="421" bodyend="425"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa21e723d12168fdcb9ac99c7f71ee05d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::ParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L const &amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="464" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="464" bodyend="472"/>
      </memberdef>
      <member refid="group__amrex__execution_1gaeb25c11f900fd632e0fbf0bfceb1e941" kind="function"><name>ParallelFor</name></member>
      <memberdef kind="function" id="namespaceamrex_1ace191cd2e5d99b138f7bf17c0162351a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="482" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="482" bodyend="485"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa6b5e74f73b2fc7b3174fa45e9d79e5d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="488" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="488" bodyend="492"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a833a3a896f9a27574e313b57e01ebd85" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="495" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="495" bodyend="499"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7dff05ac5b5c424d1af38a8410e3f155" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="502" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="502" bodyend="507"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7fc8e0d09589aa2e8933caa1677ea10a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="510" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="510" bodyend="513"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abd78b57fec2c2043ec2bdef7116aa775" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="516" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="516" bodyend="520"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aac7c7bd1c17c60efcd9caba171127c04" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="523" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="523" bodyend="528"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5b952ccbc50bc9049506897ea8050373" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="531" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="531" bodyend="537"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2c17fa7ab4b55cbcb121d819843bef73" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="540" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="540" bodyend="543"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac6fd71501b0c33f59a45f24fb45bdc3e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="546" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="546" bodyend="550"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1ea98821ea183c55bd8a7ecca588e971" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="555" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="555" bodyend="560"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adbfb44e1a05afe7fbdae500ab3797481" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="565" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="565" bodyend="571"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa9c28f856b384e7639fbb34427123b7d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="576" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="576" bodyend="581"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a097659acd9d92785f8e0a1aff4c06ee5" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="586" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="586" bodyend="592"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aeee7a2a1b52aa2d57763ab36928ceec4" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="598" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="598" bodyend="605"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3de6383b95f0e709a16c8aa212a530a0" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="611" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="611" bodyend="619"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad457e5329315312926c0113d9f3d626d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="625" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="625" bodyend="633"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2f8ea56d6a1b9ab6ae591e7a11d0edfa" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="639" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="639" bodyend="648"/>
      </memberdef>
      <member refid="group__amrex__execution_1ga4285c8b85f60e60e3a39da94f10244d3" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga65be6ab5286c866d56e425a66cb14620" kind="function"><name>ParallelFor</name></member>
      <memberdef kind="function" id="namespaceamrex_1ad4d0a1a75e2f23d9ac1ab9fc6d1b1941" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="666" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="666" bodyend="669"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a973070d38bb44c6d77839d06bdd95b61" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="672" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="672" bodyend="676"/>
      </memberdef>
      <member refid="group__amrex__execution_1ga345d853c34161b740da9bfed2cf9980b" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1gad586d7b2eed6de95b9e92d9cf69c762c" kind="function"><name>ParallelFor</name></member>
      <memberdef kind="function" id="namespaceamrex_1a2085f4123d08ffc2a370f76a5f15a8ad" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="696" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="696" bodyend="699"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a48ddb79d8398fdbbd3e1c41cbc7ef207" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="702" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="702" bodyend="706"/>
      </memberdef>
      <member refid="group__amrex__execution_1ga45b9da75fb97b1e7917f940d42061d55" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga76aa378c8e16e19e82db9b3b0d660bfe" kind="function"><name>ParallelFor</name></member>
      <memberdef kind="function" id="namespaceamrex_1af0d555cdb1a9c3d5e48a5db38af5b6b8" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="732" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="732" bodyend="738"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0583f5f82579c44211cb38d6bd8e9742" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="743" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="743" bodyend="750"/>
      </memberdef>
      <member refid="group__amrex__execution_1ga99029a09e703f51860ddab84f8e1c490" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga7569e8a1b6793f4203adfbe3c32e90e5" kind="function"><name>ParallelFor</name></member>
      <memberdef kind="function" id="namespaceamrex_1aab66312a8b6b1917316863fdb67ca868" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="783" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="783" bodyend="791"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aea15a461fa55040196c830e84ecba7fb" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="797" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="797" bodyend="806"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8fbd6b37b492537aed607bfd14595409" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="809" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="809" bodyend="812"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a404044a9b269d7f9672d46b81c41584b" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="815" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="815" bodyend="819"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5f7177073e56ccdb161d727c3b355c86" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="822" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="822" bodyend="825"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab4270fccceeedebb34cd792b94c0328e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="828" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="828" bodyend="832"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a40f6f2af18bb504d5435ff204e0e0b09" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="835" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="835" bodyend="838"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af8cec6ecebfff309e9064f7b8d70928a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="841" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="841" bodyend="845"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3763c5b1f0bd54bd4811e503351f2377" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="848" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="848" bodyend="851"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7011860ac4d3b9662c2e213cf74c2c7a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="854" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="854" bodyend="858"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a78a12c2221bfea8298c5ad4aa060ed28" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="861" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="861" bodyend="865"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af90c18c90c9f3e9391ee30ce7a721944" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="868" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="868" bodyend="873"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3a030f294fac0688f0a029c43b79b68b" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="878" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="878" bodyend="882"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a007b0bae48db5de4faf67eee59ad6fa4" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="887" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="887" bodyend="892"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8b56d06bc25e8334cf9af48c442e906d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="898" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="898" bodyend="905"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad57d36e469431aff623f22b3dcebb502" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="911" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="911" bodyend="919"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7272329c4c5b06cda2ee47e4ee3f46e2" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="922" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="922" bodyend="925"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a52a015c2685e72eedbec426e5c759e38" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="928" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="928" bodyend="932"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3189a2b23e96e8168b832bf046f9ffcc" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="935" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="935" bodyend="938"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a310f80bb86e77de79b992eb3a5611060" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="941" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="941" bodyend="945"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad7f374c1219aa3622e64b4be6dfb02b5" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="948" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="948" bodyend="951"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a545d5fef2095d5f3fddea69dba151840" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="954" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="954" bodyend="958"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4bf53c73af6a835b3ccde8b962e7d3f6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="961" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="961" bodyend="964"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af4b9f892d7cd16b475416f18ff672640" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="967" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="967" bodyend="971"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3506b815d7bc6b3c3a06bf8a51152bf0" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="974" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="974" bodyend="978"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a80d05bc95164f89ff3bef69567dd8bda" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="981" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="981" bodyend="986"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a64c77616437c6705f7880c08e0032062" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="991" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="991" bodyend="995"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af6fbad8fd43a238a5e51ef4037c9b3f3" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1000" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1000" bodyend="1005"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a88f467b530e8ca7c172eb7a1edee4642" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1011" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1011" bodyend="1018"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a805938fae1e017c24d596bc5c95406df" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1024" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1024" bodyend="1032"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aaa43ade38dff5d2e3eea8085d5c2e99e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1035" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1035" bodyend="1038"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0fce6fe39c46eb7d8cfce96b5cd18675" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1041" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1041" bodyend="1045"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a98cc7310a7b756ded68f0d3b81e2c4c2" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1048" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1048" bodyend="1051"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7a9cfe9817ad71f341d5d3d80e3f0d59" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1054" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1054" bodyend="1058"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4ad7270aa3fe2e3247c76b4b70e0eea5" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1061" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1061" bodyend="1064"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae03b20a613037d3fdd4421d95ebbd98e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1067" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1067" bodyend="1071"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a75ed59606fb6aabb3e07828d1e4931bb" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1074" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1074" bodyend="1077"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a01095cb6a015bfd16cca1c163987890e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1080" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1080" bodyend="1084"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a98d800b1df2cb51d14698a774c042149" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1087" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1087" bodyend="1092"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1b58de92252e75ce90ced33d8e4aefba" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1095" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1095" bodyend="1101"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9ab943c1c98941cd33ad27e2f7cf993a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1106" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1106" bodyend="1111"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4269ee16d264a32b677830fb53747255" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1116" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1116" bodyend="1122"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4d64ccb2db1999b9ccb64ea88de96d43" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1128" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1128" bodyend="1136"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a50e9cb160a110200ce5b3e2a32f8a4bc" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1142" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1142" bodyend="1151"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aad398246e65a7d7102beb5169e03a04d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1154" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1154" bodyend="1157"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3100c920743097917f3a6a9ab4b90436" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1160" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1160" bodyend="1164"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa7987e46b80fa56902831dbe79888564" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1167" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1167" bodyend="1170"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4c3d7656b89863a89eb34a8cf265edd6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1173" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1173" bodyend="1177"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa542e73ac4ffe59f5a44c65aec316ac6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1180" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1180" bodyend="1183"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abd2a3580ff1d0be31736e0ae542495bb" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1186" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1186" bodyend="1190"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6b53227a97323409b958730f49ebb17b" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1193" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1193" bodyend="1196"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7761bb2e4a79916f5a00f4ac50d86beb" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1199" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1199" bodyend="1203"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a874d24acab9e84aa6b01a562b658cf9e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1206" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1206" bodyend="1211"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aca863bd6a848c4968b89d3e011986744" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1214" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1214" bodyend="1220"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af335937a7c7f6e30fb69365120d56062" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1225" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1225" bodyend="1230"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa712034e4c1839d2f237b545bffed04f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1235" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1235" bodyend="1241"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9c27a235f3c50e77f60a837f9bffb7a7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1247" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1247" bodyend="1255"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aaa27170808a043a0bdb895b594df8fef" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::HostDeviceFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceFor</name>
        <qualifiedname>amrex::HostDeviceFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <defname>info</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1261" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1261" bodyend="1270"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae3514c3f8c4b2a78c2ddc9b49d8cca6c" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::ParallelForRNG</definition>
        <argsstring>(T n, L const &amp;f) noexcept</argsstring>
        <name>ParallelForRNG</name>
        <qualifiedname>amrex::ParallelForRNG</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1274" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1274" bodyend="1279"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a63990001fd080e6f727c689437f5668e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::ParallelForRNG</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L const &amp;f) noexcept</argsstring>
        <name>ParallelForRNG</name>
        <qualifiedname>amrex::ParallelForRNG</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1341" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1341" bodyend="1347"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a521bdccaadc0600f798cb1ffbb083e86" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a959c30675fdc4974adca486be8de3c6e" kindref="member">AMREX_ATTRIBUTE_FLATTEN_FOR</ref> void</type>
        <definition>AMREX_ATTRIBUTE_FLATTEN_FOR void amrex::ParallelForRNG</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L const &amp;f) noexcept</argsstring>
        <name>ParallelForRNG</name>
        <qualifiedname>amrex::ParallelForRNG</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1351" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1351" bodyend="1359"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa785b3b07c24c864604e8de72a0bb919" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::single_task</definition>
        <argsstring>(L &amp;&amp;f) noexcept</argsstring>
        <name>single_task</name>
        <qualifiedname>amrex::single_task</qualifiedname>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" line="1362" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsC.H" bodystart="1362" bodyend="1365"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a806c4106b25aa520cedc66fcbb10fff7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::single_task</definition>
        <argsstring>(gpuStream_t stream, L const &amp;f) noexcept</argsstring>
        <name>single_task</name>
        <qualifiedname>amrex::single_task</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a3e08759747455ff96c8f68e8673c2b19" kindref="member">gpuStream_t</ref></type>
          <declname>stream</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="712" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="712" bodyend="716"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a71da9a7033d01c042d0ad270a71f6618" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch</definition>
        <argsstring>(int nblocks, std::size_t shared_mem_bytes, gpuStream_t stream, L const &amp;f) noexcept</argsstring>
        <name>launch</name>
        <qualifiedname>amrex::launch</qualifiedname>
        <param>
          <type>int</type>
          <declname>nblocks</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>shared_mem_bytes</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a3e08759747455ff96c8f68e8673c2b19" kindref="member">gpuStream_t</ref></type>
          <declname>stream</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="719" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="719" bodyend="724"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acf9e876d759a1c4b3984ab2373d670bc" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch</definition>
        <argsstring>(int nblocks, gpuStream_t stream, L const &amp;f) noexcept</argsstring>
        <name>launch</name>
        <qualifiedname>amrex::launch</qualifiedname>
        <param>
          <type>int</type>
          <declname>nblocks</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a3e08759747455ff96c8f68e8673c2b19" kindref="member">gpuStream_t</ref></type>
          <declname>stream</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="727" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="727" bodyend="731"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aff64e983a02f98455e7319fb031838e7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch</definition>
        <argsstring>(int nblocks, int nthreads_per_block, std::size_t shared_mem_bytes, gpuStream_t stream, L const &amp;f) noexcept</argsstring>
        <name>launch</name>
        <qualifiedname>amrex::launch</qualifiedname>
        <param>
          <type>int</type>
          <declname>nblocks</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nthreads_per_block</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>shared_mem_bytes</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a3e08759747455ff96c8f68e8673c2b19" kindref="member">gpuStream_t</ref></type>
          <declname>stream</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="734" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="734" bodyend="739"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a93bf7d62b3ca318333e7e1d4a6d5d5c1" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch</definition>
        <argsstring>(int nblocks, int nthreads_per_block, gpuStream_t stream, L &amp;&amp;f) noexcept</argsstring>
        <name>launch</name>
        <qualifiedname>amrex::launch</qualifiedname>
        <param>
          <type>int</type>
          <declname>nblocks</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nthreads_per_block</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a3e08759747455ff96c8f68e8673c2b19" kindref="member">gpuStream_t</ref></type>
          <declname>stream</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="742" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="742" bodyend="745"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afd77498e51f5d032621b6f6ec7213bec" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; T &gt;, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch</definition>
        <argsstring>(T const &amp;n, L const &amp;f) noexcept</argsstring>
        <name>launch</name>
        <qualifiedname>amrex::launch</qualifiedname>
        <param>
          <type>T const &amp;</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="748" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="748" bodyend="766"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6ea04e28cfba5279ba6a079ace618cb6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::launch</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L const &amp;f) noexcept</argsstring>
        <name>launch</name>
        <qualifiedname>amrex::launch</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="769" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="769" bodyend="787"/>
      </memberdef>
      <member refid="group__amrex__execution_1ga7a4f23cc16489ffdc9bbde645e72fce9" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1gac687b01ac371abacd573e07248573c96" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga7f4c17203131669131e08c31388a132f" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1gad9476499ddef9f1ecbcb1b8716df4c14" kind="function"><name>ParallelForRNG</name></member>
      <member refid="group__amrex__execution_1ga5af25315f4422ff8092cd79af21f186b" kind="function"><name>ParallelForRNG</name></member>
      <member refid="group__amrex__execution_1gac5c300849a3bbe31f22e6b94e25113ef" kind="function"><name>ParallelForRNG</name></member>
      <member refid="group__amrex__execution_1ga2999ea165bfa82788ef9b729391e5223" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga785daad8d78a29b6a452555cc874072c" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga4cdc8c22b8a396026cb159ecb54778a3" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga64441e4f8352310ca63b7ca1772a3365" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga5213be0d4e9269a26c30628042ba96ec" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga2d48bfbb8ec6d1cda3e8936caf51d791" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga1a35b6c7aa3b27a1b45e38424982a2be" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga8e207b794feb8ec5a45c9bdeecfe6e7e" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga64a88b871bda19b096d4d875e441e93d" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga4d63f819b9792e308d9f45e82379fa63" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1gaedc2c324b6f7f21927374bef21968d55" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1gaff9b2ebd167a621c7784769618bda4c6" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga028e20eac95c13e9663226246e72f7bf" kind="function"><name>ParallelFor</name></member>
      <member refid="group__amrex__execution_1ga1338030001b43e68961d1da354429df8" kind="function"><name>ParallelFor</name></member>
      <memberdef kind="function" id="namespaceamrex_1a254b157995b540641c02a74d2ad65ebe" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(T n, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1486" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1486" bodyend="1489"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2c997958875b66c29beaa428de3d8660" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1498" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1498" bodyend="1501"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6114d3cd545d0e7c47bf8969d106d2a0" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::For</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>For</name>
        <qualifiedname>amrex::For</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1510" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1510" bodyend="1513"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afe4a0c7334c5645ea096268be7c02cac" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1595" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1595" bodyend="1607"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6ff78293c26f556e49cb2617db103b8d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1611" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1611" bodyend="1623"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a98069b4e17ae1c2c818145c292fa0254" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1627" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1627" bodyend="1630"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4ae34081fda24b2cf5d0aa78349afbea" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(T n, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1634" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1634" bodyend="1637"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a69e2de59c96d3cf9eaad82b4730a36da" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1641" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1641" bodyend="1652"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af8eb3088fc8749979507110bb06c25a1" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1656" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1656" bodyend="1667"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a64b99b15036070b9dd0548a0c6919ed5" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1671" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1671" bodyend="1682"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a28c88997d470d8ed973906becc88a622" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box, T ncomp, L &amp;&amp;f) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>T</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>L &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1686" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1686" bodyend="1697"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ade93eacfa76c740408457b3bcde4d684" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L1 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L2 &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L1 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L2 &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1701" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1701" bodyend="1714"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2c84b166a656a8bab8fb14d44470a64c" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L1 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L2 &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L1 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L2 &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, L1 &amp;&amp;f1, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1718" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1718" bodyend="1731"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7a3fe6ac483c6d1a2d6e9354455c2486" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L1 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L2 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L3 &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L1 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L2 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L3 &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box1, BoxND&lt; dim &gt; const &amp;box2, BoxND&lt; dim &gt; const &amp;box3, L1 &amp;&amp;f1, L2 &amp;&amp;f2, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1735" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1735" bodyend="1751"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0305ab595660448732cc59222ce073b3" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L1 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L2 &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L1 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L2 &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1757" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1757" bodyend="1771"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad6c62e40899705633e61244835f5005d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L1 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L2 &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L1 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L2 &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1777" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1777" bodyend="1791"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a27a9a2f62879db516a5357ce9bc25568" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L1 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L2 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L3 &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L1 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L2 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L3 &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1798" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1798" bodyend="1817"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a86a8f5618b206e6ca19a6a4db65f07f7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename T3</type>
          </param>
          <param>
            <type>typename L1</type>
          </param>
          <param>
            <type>typename L2</type>
          </param>
          <param>
            <type>typename L3</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>typename M1</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T1&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M2</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T2&gt;&gt;</defval>
          </param>
          <param>
            <type>typename M3</type>
            <defval>std::enable_if_t&lt;std::is_integral_v&lt;T3&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L1 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L2 &gt;::value &amp;&amp;<ref refid="structamrex_1_1MaybeHostDeviceRunnable" kindref="compound">MaybeHostDeviceRunnable</ref>&lt; L3 &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; MaybeHostDeviceRunnable&lt; L1 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L2 &gt;::value &amp;&amp;MaybeHostDeviceRunnable&lt; L3 &gt;::value &gt; amrex::HostDeviceParallelFor</definition>
        <argsstring>(Gpu::KernelInfo const &amp;info, BoxND&lt; dim &gt; const &amp;box1, T1 ncomp1, L1 &amp;&amp;f1, BoxND&lt; dim &gt; const &amp;box2, T2 ncomp2, L2 &amp;&amp;f2, BoxND&lt; dim &gt; const &amp;box3, T3 ncomp3, L3 &amp;&amp;f3) noexcept</argsstring>
        <name>HostDeviceParallelFor</name>
        <qualifiedname>amrex::HostDeviceParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Gpu_1_1KernelInfo" kindref="compound">Gpu::KernelInfo</ref> const &amp;</type>
          <declname>info</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>T1</type>
          <declname>ncomp1</declname>
        </param>
        <param>
          <type>L1 &amp;&amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type>T2</type>
          <declname>ncomp2</declname>
        </param>
        <param>
          <type>L2 &amp;&amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>box3</declname>
        </param>
        <param>
          <type>T3</type>
          <declname>ncomp3</declname>
        </param>
        <param>
          <type>L3 &amp;&amp;</type>
          <declname>f3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" line="1824" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchFunctsG.H" bodystart="1824" bodyend="1843"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4618ec35f024d34727a26fcc02d29586" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class L</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void amrex::launch_global</definition>
        <argsstring>(L f0)</argsstring>
        <name>launch_global</name>
        <qualifiedname>amrex::launch_global</qualifiedname>
        <param>
          <type>L</type>
          <declname>f0</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchGlobal.H" line="17" column="23" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchGlobal.H" bodystart="17" bodyend="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5f2a43464c5982c02b444e309249b01e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>amrex_launch_bounds_max_threads</declname>
            <defname>amrex_launch_bounds_max_threads</defname>
          </param>
          <param>
            <type>class L</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>amrex::__launch_bounds__</definition>
        <argsstring>(amrex_launch_bounds_max_threads) __global__ void launch_global(L f0)</argsstring>
        <name>__launch_bounds__</name>
        <qualifiedname>amrex::__launch_bounds__</qualifiedname>
        <param>
          <type>amrex_launch_bounds_max_threads</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchGlobal.H" line="20" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchGlobal.H" bodystart="20" bodyend="21"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abe4874bdbfd8de9c99ec3a485bae4d63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>amrex_launch_bounds_max_threads</declname>
            <defname>amrex_launch_bounds_max_threads</defname>
          </param>
          <param>
            <type>int</type>
            <declname>min_blocks</declname>
            <defname>min_blocks</defname>
          </param>
          <param>
            <type>class L</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>amrex::__launch_bounds__</definition>
        <argsstring>(amrex_launch_bounds_max_threads, min_blocks) __global__ void launch_global(L f0)</argsstring>
        <name>__launch_bounds__</name>
        <qualifiedname>amrex::__launch_bounds__</qualifiedname>
        <param>
          <type>amrex_launch_bounds_max_threads</type>
        </param>
        <param>
          <type>min_blocks</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchGlobal.H" line="24" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuLaunchGlobal.H" bodystart="24" bodyend="25"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a923303ed68b75a5a2e65f20876e25a7a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; T &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::isEmpty</definition>
        <argsstring>(T n) noexcept</argsstring>
        <name>isEmpty</name>
        <qualifiedname>amrex::isEmpty</qualifiedname>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuRange.H" line="14" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuRange.H" bodystart="14" bodyend="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a51f04b8fcaeac895eca50474ca046336" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::isEmpty</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;b) noexcept</argsstring>
        <name>isEmpty</name>
        <qualifiedname>amrex::isEmpty</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuRange.H" line="17" column="15" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuRange.H" bodystart="17" bodyend="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9757af2bf86a9ecbb80561b51d6b5323" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const dim3 &amp;d)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const dim3 &amp;</type>
          <declname>d</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuUtility.cpp" line="12" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuUtility.cpp" bodystart="13" bodyend="17" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_GpuUtility.H" declline="232" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a63e28af3672b72154d156eac5f51ce06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref> &gt;</type>
        <definition>std::unique_ptr&lt; iMultiFab &gt; amrex::OwnerMask</definition>
        <argsstring>(FabArrayBase const &amp;mf, const Periodicity &amp;period, const IntVect &amp;ngrow)</argsstring>
        <name>OwnerMask</name>
        <qualifiedname>amrex::OwnerMask</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArrayBase" kindref="compound">FabArrayBase</ref> const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> &amp;</type>
          <declname>period</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ngrow</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_iMultiFab.cpp" line="699" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_iMultiFab.cpp" bodystart="699" bodyend="773" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_iMultiFab.H" declline="590" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a54072ee00026bf45073bfff260086372" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__</type>
        <definition>__host__ __device__ amrex::IndexTypeND</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;) -&gt; IndexTypeND&lt; dim &gt;</argsstring>
        <name>IndexTypeND</name>
        <qualifiedname>amrex::IndexTypeND</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="248" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" declline="248" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af4438d90f43d1418099be8a5aab845e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsConvertible_v&lt; IndexType::CellIndex, Args... &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__</type>
        <definition>__host__ __device__ amrex::IndexTypeND</definition>
        <argsstring>(IndexType::CellIndex, Args...) -&gt; IndexTypeND&lt; sizeof...(Args)+1 &gt;</argsstring>
        <name>IndexTypeND</name>
        <qualifiedname>amrex::IndexTypeND</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1CellIndexEnum_1aceb83f25ce499aa265f5326d75e1a0a3" kindref="member">IndexType::CellIndex</ref></type>
        </param>
        <param>
          <type>Args...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="256" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" declline="256" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3b51533853a4febbb158730cf9b956d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const IndexTypeND&lt; dim &gt; &amp;it)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dim &gt; &amp;</type>
          <declname>it</declname>
        </param>
        <briefdescription>
<para>Write an <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref> to an ostream in ASCII. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="281" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" bodystart="281" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af4403352ed0655573e15f4001fd317e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, IndexTypeND&lt; dim &gt; &amp;it)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dim &gt; &amp;</type>
          <declname>it</declname>
        </param>
        <briefdescription>
<para>Read an <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref> from an istream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="286" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" bodystart="286" bodyend="288"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a895d1d84ca0dbb824119fbee8fed197e" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>d</declname>
            <defname>d</defname>
          </param>
          <param>
            <type>int...</type>
            <declname>dims</declname>
            <defname>dims</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; detail::get_sum&lt; d, dims... &gt;()&gt;</type>
        <definition>__host__ __device__ constexpr IndexTypeND&lt; detail::get_sum&lt; d, dims... &gt;()&gt; amrex::IndexTypeCat</definition>
        <argsstring>(const IndexTypeND&lt; d &gt; &amp;v, const IndexTypeND&lt; dims &gt; &amp;...vects) noexcept</argsstring>
        <name>IndexTypeCat</name>
        <qualifiedname>amrex::IndexTypeCat</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; d &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dims &gt; &amp;...</type>
          <declname>vects</declname>
        </param>
        <briefdescription>
<para>Returns a <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref> obtained by concatenating the input IndexTypeNDs. The dimension of the return value equals the sum of the dimensions of the inputted IndexTypeNDs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="297" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" bodystart="297" bodyend="308"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afb1dea21793b6825cd7cd695d5f24b8a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>d</declname>
            <defname>d</defname>
          </param>
          <param>
            <type>int...</type>
            <declname>dims</declname>
            <defname>dims</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; d &gt;, <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; dims &gt;... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; IndexTypeND&lt; d &gt;, IndexTypeND&lt; dims &gt;... &gt; amrex::IndexTypeSplit</definition>
        <argsstring>(const IndexTypeND&lt; detail::get_sum&lt; d, dims... &gt;()&gt; &amp;v) noexcept</argsstring>
        <name>IndexTypeSplit</name>
        <qualifiedname>amrex::IndexTypeSplit</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; detail::get_sum&lt; d, dims... &gt;()&gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Returns a tuple of <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref> obtained by splitting the input <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref> according to the dimensions specified by the template arguments. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="317" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" bodystart="317" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8d94fa400e77102b63844772b0b09dff" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr IndexTypeND&lt; new_dim &gt; amrex::IndexTypeShrink</definition>
        <argsstring>(const IndexTypeND&lt; old_dim &gt; &amp;v) noexcept</argsstring>
        <name>IndexTypeShrink</name>
        <qualifiedname>amrex::IndexTypeShrink</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref> of size new_dim and assigns the first new_dim values of v to it. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="331" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" bodystart="331" bodyend="333"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa596f632581599bae26556499f2c4212" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr IndexTypeND&lt; new_dim &gt; amrex::IndexTypeExpand</definition>
        <argsstring>(const IndexTypeND&lt; old_dim &gt; &amp;v, IndexType::CellIndex fill_extra=IndexType::CellIndex::CELL) noexcept</argsstring>
        <name>IndexTypeExpand</name>
        <qualifiedname>amrex::IndexTypeExpand</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1CellIndexEnum_1aceb83f25ce499aa265f5326d75e1a0a3" kindref="member">IndexType::CellIndex</ref></type>
          <declname>fill_extra</declname>
          <defval><ref refid="structamrex_1_1CellIndexEnum_1aceb83f25ce499aa265f5326d75e1a0a3a1f9d32418f4279a931e3f65f092f9439" kindref="member">IndexType::CellIndex::CELL</ref></defval>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref> of size new_dim and assigns all values of iv to it andfill_extra to the remaining elements. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="342" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" bodystart="342" bodyend="345"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9931a2376bb5efef0ccd55bc07fde9b4" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr IndexTypeND&lt; new_dim &gt; amrex::IndexTypeResize</definition>
        <argsstring>(const IndexTypeND&lt; old_dim &gt; &amp;v, IndexType::CellIndex fill_extra=IndexType::CellIndex::CELL) noexcept</argsstring>
        <name>IndexTypeResize</name>
        <qualifiedname>amrex::IndexTypeResize</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1CellIndexEnum_1aceb83f25ce499aa265f5326d75e1a0a3" kindref="member">IndexType::CellIndex</ref></type>
          <declname>fill_extra</declname>
          <defval><ref refid="structamrex_1_1CellIndexEnum_1aceb83f25ce499aa265f5326d75e1a0a3a1f9d32418f4279a931e3f65f092f9439" kindref="member">IndexType::CellIndex::CELL</ref></defval>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1IndexTypeND" kindref="compound">IndexTypeND</ref> of size new_dim by either shrinking or expanding iv. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" line="354" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IndexType.H" bodystart="354" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac25dfba1079e742467f752e4ee21450f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::int16_t</type>
        <definition>std::int16_t amrex::swapBytes</definition>
        <argsstring>(std::int16_t val)</argsstring>
        <name>swapBytes</name>
        <qualifiedname>amrex::swapBytes</qualifiedname>
        <param>
          <type>std::int16_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" line="5" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" bodystart="5" bodyend="8" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" declline="14" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a591f0270c546f1ece0504803e064d8d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::int32_t</type>
        <definition>std::int32_t amrex::swapBytes</definition>
        <argsstring>(std::int32_t val)</argsstring>
        <name>swapBytes</name>
        <qualifiedname>amrex::swapBytes</qualifiedname>
        <param>
          <type>std::int32_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" line="10" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" bodystart="10" bodyend="14" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" declline="15" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aafe4e1214f81026ac1c1704afef4ad79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::int64_t</type>
        <definition>std::int64_t amrex::swapBytes</definition>
        <argsstring>(std::int64_t val)</argsstring>
        <name>swapBytes</name>
        <qualifiedname>amrex::swapBytes</qualifiedname>
        <param>
          <type>std::int64_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" line="16" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" bodystart="16" bodyend="21" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" declline="16" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad65cae2ff531a4079a272c48094ce223" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint16_t</type>
        <definition>std::uint16_t amrex::swapBytes</definition>
        <argsstring>(std::uint16_t val)</argsstring>
        <name>swapBytes</name>
        <qualifiedname>amrex::swapBytes</qualifiedname>
        <param>
          <type>std::uint16_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" line="23" column="15" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" bodystart="23" bodyend="26" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" declline="18" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afe5aa643ac55845309ffb09b6cd6bc6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t amrex::swapBytes</definition>
        <argsstring>(std::uint32_t val)</argsstring>
        <name>swapBytes</name>
        <qualifiedname>amrex::swapBytes</qualifiedname>
        <param>
          <type>std::uint32_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" line="28" column="15" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" bodystart="28" bodyend="32" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" declline="19" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa67c20a40ddd4aeebbbb36e32af4b546" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint64_t</type>
        <definition>std::uint64_t amrex::swapBytes</definition>
        <argsstring>(std::uint64_t val)</argsstring>
        <name>swapBytes</name>
        <qualifiedname>amrex::swapBytes</qualifiedname>
        <param>
          <type>std::uint64_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" line="34" column="15" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.cpp" bodystart="34" bodyend="39" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" declline="20" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0718da697f64bda3be2152538b70d4c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename To</type>
          </param>
          <param>
            <type>typename From</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::writeIntData</definition>
        <argsstring>(const From *data, std::size_t size, std::ostream &amp;os, const amrex::IntDescriptor &amp;id)</argsstring>
        <name>writeIntData</name>
        <qualifiedname>amrex::writeIntData</qualifiedname>
        <param>
          <type>const From *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntDescriptor" kindref="compound">amrex::IntDescriptor</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" line="23" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" bodystart="23" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af8ec915a2cffc7c342e1f15e52cbd697" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename To</type>
          </param>
          <param>
            <type>typename From</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::readIntData</definition>
        <argsstring>(To *data, std::size_t size, std::istream &amp;is, const amrex::IntDescriptor &amp;id)</argsstring>
        <name>readIntData</name>
        <qualifiedname>amrex::readIntData</qualifiedname>
        <param>
          <type>To *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntDescriptor" kindref="compound">amrex::IntDescriptor</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" line="36" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntConv.H" bodystart="36" bodyend="46"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a230af13573521ea69547e437b8c1f1db" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>__host__ __device__ int</type>
        <definition>__host__ __device__ int amrex::coarsen</definition>
        <argsstring>(int i, int ratio) noexcept</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="27" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="27" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab9479d7642672db1aaf6d34cb6a65e33" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>ratio</declname>
            <defname>ratio</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ int</type>
        <definition>__host__ __device__ int amrex::coarsen</definition>
        <argsstring>(int i) noexcept</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="39" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="39" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aaeeea648b7f5cf801244e5ffab6d5f3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__</type>
        <definition>__host__ __device__ amrex::IntVectND</definition>
        <argsstring>(const Array&lt; int, dim &gt; &amp;) -&gt; IntVectND&lt; dim &gt;</argsstring>
        <name>IntVectND</name>
        <qualifiedname>amrex::IntVectND</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; int, dim &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="807" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" declline="807" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa5ae8aa8fc1fd67b6408ed96676716e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsConvertible_v&lt; int, Args... &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__</type>
        <definition>__host__ __device__ amrex::IntVectND</definition>
        <argsstring>(int, int, Args...) -&gt; IntVectND&lt; sizeof...(Args)+2 &gt;</argsstring>
        <name>IntVectND</name>
        <qualifiedname>amrex::IntVectND</qualifiedname>
        <param>
          <type>int</type>
        </param>
        <param>
          <type>int</type>
        </param>
        <param>
          <type>Args...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="815" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" declline="815" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1098118446dc0e0042c77818350a0dae" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::operator+</definition>
        <argsstring>(int s, const IntVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type>int</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Returns p + s. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="902" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="902" bodyend="909"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abb59abe745cb448d1499e6e1dfdf3185" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ __host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ __host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::operator-</definition>
        <argsstring>(int s, const IntVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator-</name>
        <qualifiedname>amrex::operator-</qualifiedname>
        <param>
          <type>int</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Returns -p + s. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="916" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="916" bodyend="923"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a43dc59f20de8bb6858d08ceca3b68b28" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::operator*</definition>
        <argsstring>(int s, const IntVectND&lt; dim &gt; &amp;p) noexcept</argsstring>
        <name>operator*</name>
        <qualifiedname>amrex::operator*</qualifiedname>
        <param>
          <type>int</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Returns p * s. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="929" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="929" bodyend="936"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a149badb6dde33a7b076f140f8210fab1" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::min</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;p1, const IntVectND&lt; dim &gt; &amp;p2) noexcept</argsstring>
        <name>min</name>
        <qualifiedname>amrex::min</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Returns the <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> that is the component-wise minimum of two argument IntVectNDs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="946" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="946" bodyend="951"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad40fe232c4ebcce4fba985cea71de3dd" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::elemwiseMin</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;p1, const IntVectND&lt; dim &gt; &amp;p2) noexcept</argsstring>
        <name>elemwiseMin</name>
        <qualifiedname>amrex::elemwiseMin</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="957" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="957" bodyend="962"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad23927f648f12aad6d0818c8c7736006" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::max</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;p1, const IntVectND&lt; dim &gt; &amp;p2) noexcept</argsstring>
        <name>max</name>
        <qualifiedname>amrex::max</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Returns the <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> that is the component-wise maximum of two argument IntVectNDs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="972" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="972" bodyend="977"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1ef8642cbd619d5470c9b9da56e51e97" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::elemwiseMax</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;p1, const IntVectND&lt; dim &gt; &amp;p2) noexcept</argsstring>
        <name>elemwiseMax</name>
        <qualifiedname>amrex::elemwiseMax</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="983" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="983" bodyend="988"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a506b6a0767866bff4edba8f0bbfd2b0f" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::BASISV</definition>
        <argsstring>(int dir) noexcept</argsstring>
        <name>BASISV</name>
        <qualifiedname>amrex::BASISV</qualifiedname>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <briefdescription>
<para>Returns a basis vector in the given coordinate direction; eg. <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND&lt;3&gt;</ref> BASISV&lt;3&gt;(1) == (0,1,0). Note that the coordinate directions are zero based. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="999" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="999" bodyend="1005"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9b213248c90c51d8f42566c96a74b1f0" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::scale</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;p, int s) noexcept</argsstring>
        <name>scale</name>
        <qualifiedname>amrex::scale</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>int</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Returns a <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> obtained by multiplying each of the components of this <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> by s. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1015" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1015" bodyend="1018"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7f8f98abe3e9d3104e21cd4971c18997" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::reflect</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;a, int ref_ix, int idir) noexcept</argsstring>
        <name>reflect</name>
        <qualifiedname>amrex::reflect</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ref_ix</declname>
        </param>
        <param>
          <type>int</type>
          <declname>idir</declname>
        </param>
        <briefdescription>
<para>Returns an <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> that is the reflection of input in the plane which passes through ref_ix and normal to the coordinate direction idir. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1029" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1029" bodyend="1032"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5c36b39e4d7e584989c5c6667c8bcd2e" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; dim &gt; amrex::diagShift</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;p, int s) noexcept</argsstring>
        <name>diagShift</name>
        <qualifiedname>amrex::diagShift</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>int</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Returns <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> obtained by adding s to each of the components of this <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1042" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1042" bodyend="1045"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af2723b915f123a3f32cd897cf833bf69" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::coarsen</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;p, int s) noexcept</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>int</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Returns an <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> that is the component-wise integer projection of p by s. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1055" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1055" bodyend="1061"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a17a6d2c86ceb1c67c5d2c5cbb307341e" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ IntVectND&lt; dim &gt; amrex::coarsen</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;p1, const IntVectND&lt; dim &gt; &amp;p2) noexcept</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
<para>Returns an <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> which is the component-wise integer projection of <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> p1 by <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> p2. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1071" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1071" bodyend="1076"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0d79b36f095870cacae9730cf240d28f" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ constexpr Dim3 amrex::refine</definition>
        <argsstring>(Dim3 const &amp;coarse, IntVectND&lt; dim &gt; const &amp;ratio) noexcept</argsstring>
        <name>refine</name>
        <qualifiedname>amrex::refine</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> const &amp;</type>
          <declname>coarse</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; const &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1080" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1080" bodyend="1089"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae9367398c2b10ca46766342351728ac0" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(1&lt;=dim &amp;&amp;dim&lt;=3), int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
        <definition>__host__ __device__ Dim3 amrex::coarsen</definition>
        <argsstring>(Dim3 const &amp;fine, IntVectND&lt; dim &gt; const &amp;ratio) noexcept</argsstring>
        <name>coarsen</name>
        <qualifiedname>amrex::coarsen</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> const &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; const &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1093" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1093" bodyend="1108"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a93f94e93b8b32f5e0f786a5d0be7418e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const IntVectND&lt; dim &gt; &amp;iv)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>iv</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1149" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1150" bodyend="1153"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac35ce8aa632498c466dcc90c268ebb13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, IntVectND&lt; dim &gt; &amp;iv)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>iv</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1157" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1157" bodyend="1160"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adc21609c555583eb7c24d38d85a6d3c4" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>d</declname>
            <defname>d</defname>
          </param>
          <param>
            <type>int...</type>
            <declname>dims</declname>
            <defname>dims</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; detail::get_sum&lt; d, dims... &gt;()&gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; detail::get_sum&lt; d, dims... &gt;()&gt; amrex::IntVectCat</definition>
        <argsstring>(const IntVectND&lt; d &gt; &amp;v, const IntVectND&lt; dims &gt; &amp;...vects) noexcept</argsstring>
        <name>IntVectCat</name>
        <qualifiedname>amrex::IntVectCat</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; d &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dims &gt; &amp;...</type>
          <declname>vects</declname>
        </param>
        <briefdescription>
<para>Returns a <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> obtained by concatenating the input IntVectNDs. The dimension of the return value equals the sum of the dimensions of the inputted IntVectNDs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1170" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1170" bodyend="1176"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a494828299bc3b1e07fa5852d12de5925" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>d</declname>
            <defname>d</defname>
          </param>
          <param>
            <type>int...</type>
            <declname>dims</declname>
            <defname>dims</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; d &gt;, <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dims &gt;... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; IntVectND&lt; d &gt;, IntVectND&lt; dims &gt;... &gt; amrex::IntVectSplit</definition>
        <argsstring>(const IntVectND&lt; detail::get_sum&lt; d, dims... &gt;()&gt; &amp;v) noexcept</argsstring>
        <name>IntVectSplit</name>
        <qualifiedname>amrex::IntVectSplit</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; detail::get_sum&lt; d, dims... &gt;()&gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Returns a tuple of <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> obtained by splitting the input <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> according to the dimensions specified by the template arguments. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1186" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1186" bodyend="1191"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a85d919ad9804340ca9b4acbf5a052cf7" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; new_dim &gt; amrex::IntVectShrink</definition>
        <argsstring>(const IntVectND&lt; old_dim &gt; &amp;iv) noexcept</argsstring>
        <name>IntVectShrink</name>
        <qualifiedname>amrex::IntVectShrink</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>iv</declname>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> of size new_dim and assigns the first new_dim values of iv to it. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1201" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1201" bodyend="1203"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad11327890dbdec6a7fedcbe55d55cd7f" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; new_dim &gt; amrex::IntVectExpand</definition>
        <argsstring>(const IntVectND&lt; old_dim &gt; &amp;iv, int fill_extra=0) noexcept</argsstring>
        <name>IntVectExpand</name>
        <qualifiedname>amrex::IntVectExpand</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>iv</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fill_extra</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> of size new_dim and assigns all values of iv to it andfill_extra to the remaining elements. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1213" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1213" bodyend="1215"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0edf35c2784129c0bb4c6bf86ad18e19" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>new_dim</declname>
            <defname>new_dim</defname>
          </param>
          <param>
            <type>int</type>
            <declname>old_dim</declname>
            <defname>old_dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; new_dim &gt;</type>
        <definition>__host__ __device__ constexpr IntVectND&lt; new_dim &gt; amrex::IntVectResize</definition>
        <argsstring>(const IntVectND&lt; old_dim &gt; &amp;iv, int fill_extra=0) noexcept</argsstring>
        <name>IntVectResize</name>
        <qualifiedname>amrex::IntVectResize</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; old_dim &gt; &amp;</type>
          <declname>iv</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fill_extra</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Returns a new <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref> of size new_dim by either shrinking or expanding iv. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" line="1225" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_IntVect.H" bodystart="1225" bodyend="1227"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad42469e811612a4430f6b9c4620dfd50" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Loop</definition>
        <argsstring>(Dim3 lo, Dim3 hi, F const &amp;f) noexcept</argsstring>
        <name>Loop</name>
        <qualifiedname>amrex::Loop</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>lo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>hi</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="127" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="127" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9bb96820229bfa287b370b85f38ec6ca" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Loop</definition>
        <argsstring>(Dim3 lo, Dim3 hi, int ncomp, F const &amp;f) noexcept</argsstring>
        <name>Loop</name>
        <qualifiedname>amrex::Loop</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>lo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>hi</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="139" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="139" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af75f7f92a46da88ba3d755902df89413" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::LoopConcurrent</definition>
        <argsstring>(Dim3 lo, Dim3 hi, F const &amp;f) noexcept</argsstring>
        <name>LoopConcurrent</name>
        <qualifiedname>amrex::LoopConcurrent</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>lo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>hi</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="152" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="152" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad55d4965d44b4ea712b1189b7cdfb2b7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::LoopConcurrent</definition>
        <argsstring>(Dim3 lo, Dim3 hi, int ncomp, F const &amp;f) noexcept</argsstring>
        <name>LoopConcurrent</name>
        <qualifiedname>amrex::LoopConcurrent</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>lo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>hi</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="165" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="165" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4a02f7226119892491321e3fd4e7f27d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Loop</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;bx, F const &amp;f) noexcept</argsstring>
        <name>Loop</name>
        <qualifiedname>amrex::Loop</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="211" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="211" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a87bfcd3210c91023841436ccca3df665" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::Loop</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;bx, int ncomp, F const &amp;f) noexcept</argsstring>
        <name>Loop</name>
        <qualifiedname>amrex::Loop</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="254" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="254" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7add8298f306acee39d8b1fab71b4de0" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::LoopConcurrent</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;bx, F const &amp;f) noexcept</argsstring>
        <name>LoopConcurrent</name>
        <qualifiedname>amrex::LoopConcurrent</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="302" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="302" bodyend="308"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4a30444ba4155f7004eee87cffdebc36" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::LoopConcurrent</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;bx, int ncomp, F const &amp;f) noexcept</argsstring>
        <name>LoopConcurrent</name>
        <qualifiedname>amrex::LoopConcurrent</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="348" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="348" bodyend="356"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adcfb36df4559fd8ffb462f4b4b4cebaa" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LoopOnCpu</definition>
        <argsstring>(Dim3 lo, Dim3 hi, F const &amp;f) noexcept</argsstring>
        <name>LoopOnCpu</name>
        <qualifiedname>amrex::LoopOnCpu</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>lo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>hi</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="365" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="365" bodyend="372"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a14489e7106b23f6c8c3d3f8db5a17f4a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LoopOnCpu</definition>
        <argsstring>(Dim3 lo, Dim3 hi, int ncomp, F const &amp;f) noexcept</argsstring>
        <name>LoopOnCpu</name>
        <qualifiedname>amrex::LoopOnCpu</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>lo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>hi</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="376" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="376" bodyend="384"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac8ac637100c5c3e84d9c8c9e6747a695" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LoopConcurrentOnCpu</definition>
        <argsstring>(Dim3 lo, Dim3 hi, F const &amp;f) noexcept</argsstring>
        <name>LoopConcurrentOnCpu</name>
        <qualifiedname>amrex::LoopConcurrentOnCpu</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>lo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>hi</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="388" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="388" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a712980daa0c85db5883f9cce15874f72" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LoopConcurrentOnCpu</definition>
        <argsstring>(Dim3 lo, Dim3 hi, int ncomp, F const &amp;f) noexcept</argsstring>
        <name>LoopConcurrentOnCpu</name>
        <qualifiedname>amrex::LoopConcurrentOnCpu</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>lo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref></type>
          <declname>hi</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="400" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="400" bodyend="409"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af31604d9cfd3c8f8f0ccec50c860160f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LoopOnCpu</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;bx, F const &amp;f) noexcept</argsstring>
        <name>LoopOnCpu</name>
        <qualifiedname>amrex::LoopOnCpu</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="445" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="445" bodyend="451"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a00212f2e0dbec9d013abdc5fe3ed7e47" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LoopOnCpu</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;bx, int ncomp, F const &amp;f) noexcept</argsstring>
        <name>LoopOnCpu</name>
        <qualifiedname>amrex::LoopOnCpu</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="487" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="487" bodyend="495"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a838b39448fc6d3c6f71b6bd3a47f9647" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LoopConcurrentOnCpu</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;bx, F const &amp;f) noexcept</argsstring>
        <name>LoopConcurrentOnCpu</name>
        <qualifiedname>amrex::LoopConcurrentOnCpu</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="534" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="534" bodyend="540"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af16a3e0dd038be87a0271bd36cf914aa" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LoopConcurrentOnCpu</definition>
        <argsstring>(BoxND&lt; dim &gt; const &amp;bx, int ncomp, F const &amp;f) noexcept</argsstring>
        <name>LoopConcurrentOnCpu</name>
        <qualifiedname>amrex::LoopConcurrentOnCpu</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1BoxND" kindref="compound">BoxND</ref>&lt; dim &gt; const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" line="579" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Loop.H" bodystart="579" bodyend="587"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad622d627e1fea988d361c48316ad9275" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>RunOn</type>
            <declname>run_on</declname>
            <defname>run_on</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; T, double &gt;||std::is_same_v&lt; T, float &gt;, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::fill_snan</definition>
        <argsstring>(T *p, std::size_t nelems)</argsstring>
        <name>fill_snan</name>
        <qualifiedname>amrex::fill_snan</qualifiedname>
        <param>
          <type>T *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>nelems</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MemPool.H" line="24" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MemPool.H" bodystart="24" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a93c128f8c475b4b0e631531c753f201b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const MemProfiler::Bytes &amp;bytes)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const MemProfiler::Bytes &amp;</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MemProfiler.cpp" line="330" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MemProfiler.cpp" bodystart="331" bodyend="358"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a27cafa2b50e6b371f2be90a544837e9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const MemProfiler::Builds &amp;builds)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const MemProfiler::Builds &amp;</type>
          <declname>builds</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MemProfiler.cpp" line="360" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MemProfiler.cpp" bodystart="361" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4b0d01afec5218e25096773af48821bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::InterpAddBox</definition>
        <argsstring>(MultiFabCopyDescriptor &amp;fabCopyDesc, BoxList *returnUnfilledBoxes, Vector&lt; FillBoxId &gt; &amp;returnedFillBoxIds, const Box &amp;subbox, MultiFabId faid1, MultiFabId faid2, Real t1, Real t2, Real t, int src_comp, int dest_comp, int num_comp, bool extrap)</argsstring>
        <name>InterpAddBox</name>
        <qualifiedname>amrex::InterpAddBox</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFabCopyDescriptor" kindref="compound">MultiFabCopyDescriptor</ref> &amp;</type>
          <declname>fabCopyDesc</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BoxList" kindref="compound">BoxList</ref> *</type>
          <declname>returnUnfilledBoxes</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1FillBoxId" kindref="compound">FillBoxId</ref> &gt; &amp;</type>
          <declname>returnedFillBoxIds</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>subbox</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a55427a27e71c45e7066414b0accf4a9b" kindref="member">MultiFabId</ref></type>
          <declname>faid1</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a55427a27e71c45e7066414b0accf4a9b" kindref="member">MultiFabId</ref></type>
          <declname>faid2</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>t1</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>t2</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>t</declname>
        </param>
        <param>
          <type>int</type>
          <declname>src_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dest_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_comp</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>extrap</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFCopyDescriptor.cpp" line="7" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFCopyDescriptor.cpp" bodystart="7" bodyend="68" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFCopyDescriptor.H" declline="15" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aabdb646a3159210a31ec8dc806eaf7bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::InterpFillFab</definition>
        <argsstring>(MultiFabCopyDescriptor &amp;fabCopyDesc, const Vector&lt; FillBoxId &gt; &amp;fillBoxIds, MultiFabId faid1, MultiFabId faid2, FArrayBox &amp;dest, Real t1, Real t2, Real t, int src_comp, int dest_comp, int num_comp, bool extrap)</argsstring>
        <name>InterpFillFab</name>
        <qualifiedname>amrex::InterpFillFab</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFabCopyDescriptor" kindref="compound">MultiFabCopyDescriptor</ref> &amp;</type>
          <declname>fabCopyDesc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1FillBoxId" kindref="compound">FillBoxId</ref> &gt; &amp;</type>
          <declname>fillBoxIds</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a55427a27e71c45e7066414b0accf4a9b" kindref="member">MultiFabId</ref></type>
          <declname>faid1</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a55427a27e71c45e7066414b0accf4a9b" kindref="member">MultiFabId</ref></type>
          <declname>faid2</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FArrayBox" kindref="compound">FArrayBox</ref> &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>t1</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>t2</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>t</declname>
        </param>
        <param>
          <type>int</type>
          <declname>src_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dest_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_comp</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>extrap</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFCopyDescriptor.cpp" line="71" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFCopyDescriptor.cpp" bodystart="71" bodyend="120" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFCopyDescriptor.H" declline="29" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab482b500359e03b77389d42f968c46fe" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::TilingIfNotGPU</definition>
        <argsstring>() noexcept</argsstring>
        <name>TilingIfNotGPU</name>
        <qualifiedname>amrex::TilingIfNotGPU</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFIter.H" line="12" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFIter.H" bodystart="12" bodyend="12"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6a1aa0c151c5fe560ebb86c99194bfc3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::isMFIterSafe</definition>
        <argsstring>(const FabArrayBase &amp;x, const FabArrayBase &amp;y)</argsstring>
        <name>isMFIterSafe</name>
        <qualifiedname>amrex::isMFIterSafe</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArrayBase" kindref="compound">FabArrayBase</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArrayBase" kindref="compound">FabArrayBase</ref> &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Is it safe to have these two MultiFabs in the same MFiter? True means safe; false means maybe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFIter.H" line="249" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFIter.H" bodystart="249" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abbb7e279aea120a5e6417d5d5d781e29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid region. If built for CPU, tiling will be enabled. For GPU builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="43" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="43" bodyend="46"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5011a6d8a6fc910c96a68d2c47a06c6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid region. If built for CPU, tiling will be enabled. For GPU builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MT</parametername>
</parameternamelist>
<parameterdescription>
<para>max threads in GPU blocks (Only relevant for GPU builds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="66" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="66" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9fa297c8a404a5036e4bdfb094ba4101" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. For GPU builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="93" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="93" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af4c68d55b60c90660bc72dbd96565dab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. For GPU builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MT</parametername>
</parameternamelist>
<parameterdescription>
<para>max threads in GPU blocks (Only relevant for GPU builds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="117" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="117" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af83780124b3d6b5056803b5668eaea34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, int ncomp, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. For GPU builds, this function is NON-BLOCKING on the host. Conceptually, this is a 5D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int,int), where the first argument is the local box index, the following three are spatial indices for x, y, and z-directions, and the last is for component. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="145" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="145" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9e58812d17a8ba9b02d34015c51b7455" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, int ncomp, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 5D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MT</parametername>
</parameternamelist>
<parameterdescription>
<para>max threads in GPU blocks (Only relevant for GPU builds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int,int), where the first argument is the local box index, the following three are spatial indices for x, y, and z-directions, and the last is for component. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="170" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="170" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5a5602c3d8afc03692d2c2f7eb948f8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, TileSize const &amp;ts, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid region. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="198" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="198" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab037a4e94e30075d4e4270a4c6f7a98d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, TileSize const &amp;ts, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid region. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MT</parametername>
</parameternamelist>
<parameterdescription>
<para>max threads in GPU blocks (Only relevant for GPU builds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="223" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="223" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a203b662b0a7359b07cdf5e4d6ab8e2f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, TileSize const &amp;ts, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="252" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="252" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac5d1a8d1096813c2f4ed0e9060738705" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, TileSize const &amp;ts, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MT</parametername>
</parameternamelist>
<parameterdescription>
<para>max threads in GPU blocks (Only relevant for GPU builds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="278" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="278" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a670f31d991c0223fb621d536bd0555b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, int ncomp, TileSize const &amp;ts, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 5D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int,int), where the first argument is the local box index, the following three are spatial indices for x, y, and z-directions, and the last is for component. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="308" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="308" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a523b5454dae8ba85b63b6ff2c73ff33f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, int ncomp, TileSize const &amp;ts, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 5D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MT</parametername>
</parameternamelist>
<parameterdescription>
<para>max threads in GPU blocks (Only relevant for GPU builds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int,int), where the first argument is the local box index, the following three are spatial indices for x, y, and z-directions, and the last is for component. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="335" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="335" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4404292f25338b758846da16b827c8d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, TileSize const &amp;ts, DynamicTiling dt, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1DynamicTiling" kindref="compound">DynamicTiling</ref></type>
          <declname>dt</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For GPU builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dt</parametername>
</parameternamelist>
<parameterdescription>
<para>controls dynamic tiling for the cpu build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="365" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="365" bodyend="368"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad8e641460523d265f2ec4fee3f4a7b29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, int ncomp, TileSize const &amp;ts, DynamicTiling dt, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1DynamicTiling" kindref="compound">DynamicTiling</ref></type>
          <declname>dt</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 5D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dt</parametername>
</parameternamelist>
<parameterdescription>
<para>controls dynamic tiling for the cpu build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int,int), where the first argument is the local box index, the following three are spatial indices for x, y, and z-directions, and the last is for component. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="392" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="392" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5b298195f628be2414d35666eb97ffe0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, TileSize const &amp;ts, DynamicTiling dt, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1DynamicTiling" kindref="compound">DynamicTiling</ref></type>
          <declname>dt</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For GPU builds, this function is NON-BLOCKING on the host. Conceptually, this is a 4D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MT</parametername>
</parameternamelist>
<parameterdescription>
<para>max threads in GPU blocks (Only relevant for GPU builds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dt</parametername>
</parameternamelist>
<parameterdescription>
<para>controls dynamic tiling for the cpu build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int), where the first argument is the local box index, and the following three are spatial indices for x, y, and z-directions. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="420" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="420" bodyend="428"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab63725315e543b85cff569c6f2450748" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>MT</declname>
            <defname>MT</defname>
          </param>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsFabArray" kindref="compound">IsFabArray</ref>&lt; MF &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value &gt; amrex::ParallelFor</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;ng, int ncomp, TileSize const &amp;ts, DynamicTiling dt, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TileSize" kindref="compound">TileSize</ref> const &amp;</type>
          <declname>ts</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1DynamicTiling" kindref="compound">DynamicTiling</ref></type>
          <declname>dt</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>ParallelFor for MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This version launches a kernel to work on the valid and ghost regions. If built for CPU, tiling will be enabled. However, one could specify a huge tile size to effectively disable tiling. For gpu builds, this function is NON-BLOCKING on the host. Conceptually, this is a 5D loop.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>MT</parametername>
</parameternamelist>
<parameterdescription>
<para>max threads in GPU blocks (Only relevant for GPU builds) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>MF</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable type like lambda</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>the MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ng</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells around the valid region </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ts</parametername>
</parameternamelist>
<parameterdescription>
<para>tile size, ignored by GPU build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dt</parametername>
</parameternamelist>
<parameterdescription>
<para>controls dynamic tiling for the cpu build </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object void(int,int,int,int,int), where the first argument is the local box index, the following three are spatial indices for x, y, and z-directions, and the last is for component. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" line="453" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MFParallelFor.H" bodystart="453" bodyend="461"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad60aac176908ba51373d63ca49bef063" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::GccPlacaterMF</definition>
        <argsstring>()</argsstring>
        <name>GccPlacaterMF</name>
        <qualifiedname>amrex::GccPlacaterMF</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFab.H" line="761" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFab.H" bodystart="761" bodyend="772"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad64dcd62b16d9022d914f067d30d7918" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_node_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;cc, int dcomp, const MultiFab &amp;nd, int scomp, int ncomp, int ngrow=0)</argsstring>
        <name>average_node_to_cellcenter</name>
        <qualifiedname>amrex::average_node_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>nd</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
        </param>
        <briefdescription>
<para>Average nodal-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="62" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="62" bodyend="67" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="18" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abd1e0355143aa3a18b40c80ede637485" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_node_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;cc, int dcomp, const MultiFab &amp;nd, int scomp, int ncomp, IntVect const &amp;ng_vect)</argsstring>
        <name>average_node_to_cellcenter</name>
        <qualifiedname>amrex::average_node_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>nd</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng_vect</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="69" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="69" bodyend="102" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="21" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae993b889bb9c1feed61788d148fd4920" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_edge_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;cc, int dcomp, const Vector&lt; const MultiFab * &gt; &amp;edge, int ngrow=0)</argsstring>
        <name>average_edge_to_cellcenter</name>
        <qualifiedname>amrex::average_edge_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>edge</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Average edge-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This fills in <computeroutput>ngrow</computeroutput> ghost cells in the cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. Both cell-centered and edge-centered MultiFabs need to have <computeroutput>ngrow</computeroutput> ghost values. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="104" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="104" bodyend="109" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="31" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac078218ce178e4333a3541e8ecb00e74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_edge_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;cc, int dcomp, const Vector&lt; const MultiFab * &gt; &amp;edge, IntVect const &amp;ng_vect)</argsstring>
        <name>average_edge_to_cellcenter</name>
        <qualifiedname>amrex::average_edge_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>edge</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng_vect</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="111" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="111" bodyend="153" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="34" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a327f65de28d16b8f3aae1023aa8c4dfe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_face_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;cc, int dcomp, const Vector&lt; const MultiFab * &gt; &amp;fc, IntVect const &amp;ng_vect)</argsstring>
        <name>average_face_to_cellcenter</name>
        <qualifiedname>amrex::average_face_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>fc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng_vect</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="155" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="155" bodyend="161" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="47" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a95f27241ad83b39ffc015be064f382e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_face_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;cc, int dcomp, const Vector&lt; const MultiFab * &gt; &amp;fc, int ngrow=0)</argsstring>
        <name>average_face_to_cellcenter</name>
        <qualifiedname>amrex::average_face_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>fc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Average face-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This fills in <computeroutput>ngrow</computeroutput> ghost cells in the cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. Both cell-centered and face-centered MultiFabs need to have <computeroutput>ngrow</computeroutput> ghost values. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="163" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="163" bodyend="169" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="44" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abdb4a7a5967743f8bce82ac78128963d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_face_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;cc, const Vector&lt; const MultiFab * &gt; &amp;fc, const Geometry &amp;geom)</argsstring>
        <name>average_face_to_cellcenter</name>
        <qualifiedname>amrex::average_face_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>fc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
<para>Average face-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with geometric weighting. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="171" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="171" bodyend="178" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="65" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab0622186af47d75f832f79787dd2b633" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_face_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;cc, const Array&lt; const MultiFab *, 3 &gt; &amp;fc, const Geometry &amp;geom)</argsstring>
        <name>average_face_to_cellcenter</name>
        <qualifiedname>amrex::average_face_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>fc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
<para>Average face-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with geometric weighting. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="180" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="180" bodyend="238" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="69" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab843405531b26d824c1133128452afcb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_cellcenter_to_face</definition>
        <argsstring>(const Vector&lt; MultiFab * &gt; &amp;fc, const MultiFab &amp;cc, const Geometry &amp;geom, int ncomp=1, bool use_harmonic_averaging=false)</argsstring>
        <name>average_cellcenter_to_face</name>
        <qualifiedname>amrex::average_cellcenter_to_face</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>fc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_harmonic_averaging</declname>
        </param>
        <briefdescription>
<para>Average cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto face-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with geometric weighting. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="240" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="240" bodyend="245" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="73" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aea81c928bb538cca38ff80bd4ad00659" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_cellcenter_to_face</definition>
        <argsstring>(const Array&lt; MultiFab *, 3 &gt; &amp;fc, const MultiFab &amp;cc, const Geometry &amp;geom, int ncomp=1, bool use_harmonic_averaging=false)</argsstring>
        <name>average_cellcenter_to_face</name>
        <qualifiedname>amrex::average_cellcenter_to_face</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>fc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_harmonic_averaging</declname>
        </param>
        <briefdescription>
<para>Average cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto face-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with geometric weighting. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="248" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="248" bodyend="332" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="79" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a21e594569f8a9ba321155a5ecd7ce4ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_down</definition>
        <argsstring>(const MultiFab &amp;S_fine, MultiFab &amp;S_crse, const Geometry &amp;fgeom, const Geometry &amp;cgeom, int scomp, int ncomp, int rr)</argsstring>
        <name>average_down</name>
        <qualifiedname>amrex::average_down</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_crse</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>rr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="336" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="336" bodyend="341" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="161" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a62368c6c303e36dc51ded56d7881920e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_down</definition>
        <argsstring>(const MultiFab &amp;S_fine, MultiFab &amp;S_crse, const Geometry &amp;fgeom, const Geometry &amp;cgeom, int scomp, int ncomp, const IntVect &amp;ratio)</argsstring>
        <name>average_down</name>
        <qualifiedname>amrex::average_down</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_crse</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
<para>Volume weighed average of fine <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto coarse <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Both MultiFabs are assumed to be cell-centered. This routine DOES NOT assume that the crse <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is a coarsened version of the fine <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="343" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="343" bodyend="413" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="158" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab67331acff75bf2840f409750b1ada66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::sum_fine_to_coarse</definition>
        <argsstring>(const MultiFab &amp;S_fine, MultiFab &amp;S_crse, int scomp, int ncomp, const IntVect &amp;ratio, const Geometry &amp;cgeom, const Geometry &amp;)</argsstring>
        <name>sum_fine_to_coarse</name>
        <qualifiedname>amrex::sum_fine_to_coarse</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_Fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>cgeom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>fgeom</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a coarsened version of the data contained in the S_fine <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> to S_crse, including ghost cells. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="415" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="415" bodyend="465" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="177" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a84e55e433b2972354d98a0684f7f1394" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_down_edges</definition>
        <argsstring>(const Vector&lt; const MultiFab * &gt; &amp;fine, const Vector&lt; MultiFab * &gt; &amp;crse, const IntVect &amp;ratio, int ngcrse=0)</argsstring>
        <name>average_down_edges</name>
        <qualifiedname>amrex::average_down_edges</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
        </param>
        <briefdescription>
<para>Average fine edge-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto crse edge-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Average fine edge-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto crse edge-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. This routine does NOT assume that the crse <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is a coarsened version of the fine <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="469" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="469" bodyend="476" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="130" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a576184719e242874a9b13733bbb9ade9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_down_edges</definition>
        <argsstring>(const Array&lt; const MultiFab *, 3 &gt; &amp;fine, const Array&lt; MultiFab *, 3 &gt; &amp;crse, const IntVect &amp;ratio, int ngcrse)</argsstring>
        <name>average_down_edges</name>
        <qualifiedname>amrex::average_down_edges</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="478" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="478" bodyend="486" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="134" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab744a797b85135257add34a49c96c734" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::average_down_edges</definition>
        <argsstring>(const MultiFab &amp;fine, MultiFab &amp;crse, const IntVect &amp;ratio, int ngcrse)</argsstring>
        <name>average_down_edges</name>
        <qualifiedname>amrex::average_down_edges</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This version does average down for one direction. It uses the IndexType of MultiFabs to determine the direction. It is expected that one direction is cell-centered and the rest are nodal. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="488" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="488" bodyend="544" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="141" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aac09e7e5e074f207deb9fae3b4e9148f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::print_state</definition>
        <argsstring>(const MultiFab &amp;mf, const IntVect &amp;cell, int n=-1, const IntVect &amp;ng=IntVect::TheZeroVector())</argsstring>
        <name>print_state</name>
        <qualifiedname>amrex::print_state</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>cell</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ng</declname>
        </param>
        <briefdescription>
<para>Output state data for a single zone. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="546" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="546" bodyend="549" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="183" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a78ee47545ca66e809f4f680e7513cbd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeFabs</definition>
        <argsstring>(const MultiFab &amp;mf, const std::string &amp;name)</argsstring>
        <name>writeFabs</name>
        <qualifiedname>amrex::writeFabs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Write each fab individually. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="551" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="551" bodyend="554" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="187" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa9f903b417da5fb1d02ea65d0bbf8934" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeFabs</definition>
        <argsstring>(const MultiFab &amp;mf, int comp, int ncomp, const std::string &amp;name)</argsstring>
        <name>writeFabs</name>
        <qualifiedname>amrex::writeFabs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="556" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="556" bodyend="562" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="188" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6ca286511a003d2770dba9c37ab53c94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref></type>
        <definition>MultiFab amrex::ToMultiFab</definition>
        <argsstring>(const iMultiFab &amp;imf)</argsstring>
        <name>ToMultiFab</name>
        <qualifiedname>amrex::ToMultiFab</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref> &amp;</type>
          <declname>imf</declname>
        </param>
        <briefdescription>
<para>Convert <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref> to <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="564" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="564" bodyend="567" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="255" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae062fb7f904c1f39327797d8c3fea414" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; <ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; <ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> &gt; &gt;</type>
        <definition>FabArray&lt; BaseFab&lt; Long &gt; &gt; amrex::ToLongMultiFab</definition>
        <argsstring>(const iMultiFab &amp;imf)</argsstring>
        <name>ToLongMultiFab</name>
        <qualifiedname>amrex::ToLongMultiFab</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref> &amp;</type>
          <declname>imf</declname>
        </param>
        <briefdescription>
<para>Convert <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref> to Long. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="569" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="569" bodyend="572" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="257" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2984686d3572b38439702c00c3ed66d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>std::unique_ptr&lt; MultiFab &gt; amrex::get_slice_data</definition>
        <argsstring>(int dir, Real coord, const MultiFab &amp;cc, const Geometry &amp;geom, int start_comp, int ncomp, bool interpolate, RealBox const &amp;bnd_rbx)</argsstring>
        <name>get_slice_data</name>
        <qualifiedname>amrex::get_slice_data</qualifiedname>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>coord</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>interpolate</declname>
          <defval>false</defval>
        </param>
        <param>
          <type><ref refid="classamrex_1_1RealBox" kindref="compound">RealBox</ref> const &amp;</type>
          <declname>bnd_rbx</declname>
          <defval><ref refid="classamrex_1_1RealBox" kindref="compound">RealBox</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Extract a slice from the given cell-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> at coordinate &quot;coord&quot; along direction &quot;dir&quot;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="574" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="574" bodyend="627" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="192" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af97d55742a96cb9e934e06c45ec22f03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref></type>
        <definition>iMultiFab amrex::makeFineMask</definition>
        <argsstring>(const BoxArray &amp;cba, const DistributionMapping &amp;cdm, const BoxArray &amp;fba, const IntVect &amp;ratio, int crse_value, int fine_value)</argsstring>
        <name>makeFineMask</name>
        <qualifiedname>amrex::makeFineMask</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>cba</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &amp;</type>
          <declname>cdm</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>fba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>crse_value</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fine_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="629" column="15" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="629" bodyend="635" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="223" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a549567bbb4fc6d2e53d5a0c03fe62a81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::makeFineMask_doit</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mask, const BoxArray &amp;fba, const IntVect &amp;ratio, Periodicity const &amp;period, typename FAB::value_type crse_value, typename FAB::value_type fine_value)</argsstring>
        <name>makeFineMask_doit</name>
        <qualifiedname>amrex::makeFineMask_doit</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>fba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
        </param>
        <param>
          <type>typename FAB::value_type</type>
          <declname>crse_value</declname>
        </param>
        <param>
          <type>typename FAB::value_type</type>
          <declname>fine_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="638" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="638" bodyend="693"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abe90237191ad363f7f9dd34c2ac0ebcb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref></type>
        <definition>iMultiFab amrex::makeFineMask</definition>
        <argsstring>(const BoxArray &amp;cba, const DistributionMapping &amp;cdm, const IntVect &amp;cnghost, const BoxArray &amp;fba, const IntVect &amp;ratio, Periodicity const &amp;period, int crse_value, int fine_value)</argsstring>
        <name>makeFineMask</name>
        <qualifiedname>amrex::makeFineMask</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>cba</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &amp;</type>
          <declname>cdm</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>cnghost</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>fba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
        </param>
        <param>
          <type>int</type>
          <declname>crse_value</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fine_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="695" column="15" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="695" bodyend="702" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="229" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac54193c21e9f609ad488d3cb074dfeef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref></type>
        <definition>MultiFab amrex::makeFineMask</definition>
        <argsstring>(const BoxArray &amp;cba, const DistributionMapping &amp;cdm, const BoxArray &amp;fba, const IntVect &amp;ratio, Real crse_value, Real fine_value)</argsstring>
        <name>makeFineMask</name>
        <qualifiedname>amrex::makeFineMask</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>cba</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &amp;</type>
          <declname>cdm</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>fba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>crse_value</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>fine_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="704" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="704" bodyend="711" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="242" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7fc308401815849dd974430e863d5abb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::computeDivergence</definition>
        <argsstring>(MultiFab &amp;divu, const Array&lt; MultiFab const  *, 3 &gt; &amp;umac, const Geometry &amp;geom)</argsstring>
        <name>computeDivergence</name>
        <qualifiedname>amrex::computeDivergence</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>divu</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const *, 3 &gt; &amp;</type>
          <declname>umac</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
<para>Computes divergence of face-data stored in the umac <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="713" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="713" bodyend="763" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="247" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae5460d77e09dfc8d0e41e7a2e7babd77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::computeGradient</definition>
        <argsstring>(MultiFab &amp;grad, const Array&lt; MultiFab const  *, 3 &gt; &amp;umac, const Geometry &amp;geom)</argsstring>
        <name>computeGradient</name>
        <qualifiedname>amrex::computeGradient</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>grad</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const *, 3 &gt; &amp;</type>
          <declname>umac</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
<para>Computes gradient of face-data stored in the umac <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="765" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="765" bodyend="812" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="251" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a48b0e0bc9bd17bdcba18aa237718737f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref></type>
        <definition>MultiFab amrex::periodicShift</definition>
        <argsstring>(MultiFab const  &amp;mf, IntVect const  &amp;offset, Periodicity const  &amp;period)</argsstring>
        <name>periodicShift</name>
        <qualifiedname>amrex::periodicShift</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>offset</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
        </param>
        <briefdescription>
<para>Periodic shift <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="814" column="14" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="814" bodyend="835" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="260" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a882a700cf7fab66ee3ce8de37de3ef73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__amrex__linear__containers_1ga337aceb06d1f93486e6593ff058c0a93" kindref="member">Gpu::HostVector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt;</type>
        <definition>Gpu::HostVector&lt; Real &gt; amrex::sumToLine</definition>
        <argsstring>(MultiFab const  &amp;mf, int icomp, int ncomp, Box const  &amp;domain, int direction, bool local=false)</argsstring>
        <name>sumToLine</name>
        <qualifiedname>amrex::sumToLine</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type>int</type>
          <declname>direction</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Sum <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> data to line. </para>
        </briefdescription>
        <detaileddescription>
<para>Return a HostVector that contains the sum of the given <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> data in the plane with the given normal direction. The size of the vector is domain.length(direction) x ncomp. The vector is actually a 2D array, where the element for component icomp at spatial index k is at [icomp+ncomp*k].</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> data for summing </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>icomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain</parametername>
</parameternamelist>
<parameterdescription>
<para>the domain </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>direction</parametername>
</parameternamelist>
<parameterdescription>
<para>the direction of the line </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>local</parametername>
</parameternamelist>
<parameterdescription>
<para>If false, reduce across MPI processes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="838" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="838" bodyend="978" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="474" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5daadefeacaedc115d9a284241da21cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        <definition>Real amrex::volumeWeightedSum</definition>
        <argsstring>(Vector&lt; MultiFab const  * &gt; const  &amp;mf, int icomp, Vector&lt; Geometry &gt; const  &amp;geom, Vector&lt; IntVect &gt; const  &amp;ratio, bool local=false)</argsstring>
        <name>volumeWeightedSum</name>
        <qualifiedname>amrex::volumeWeightedSum</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const * &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; const &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; const &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Volume weighted sum for a vector of MultiFabs. </para>
        </briefdescription>
        <detaileddescription>
<para>Return a volume weighted sum of MultiFabs of AMR data. The sum is perform on a single component of the data. If the MultiFabs are built with EB Factories, the cut cell volume fraction will be included in the weight. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="980" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="980" bodyend="1132" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="484" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adde5cec8cf83a5e5970cf61cd12e6bb7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::FourthOrderInterpFromFineToCoarse</definition>
        <argsstring>(MultiFab &amp;cmf, int scomp, int ncomp, MultiFab const  &amp;fmf, IntVect const  &amp;ratio)</argsstring>
        <name>FourthOrderInterpFromFineToCoarse</name>
        <qualifiedname>amrex::FourthOrderInterpFromFineToCoarse</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
<para>Fourth-order interpolation from fine to coarse level. </para>
        </briefdescription>
        <detaileddescription>
<para>This is for high-order &quot;average-down&quot; of finite-difference data. If ghost cell data are used, it&apos;s the caller&apos;s responsibility to fill the ghost cells before calling this function.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cmf</parametername>
</parameternamelist>
<parameterdescription>
<para>coarse data </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fmf</parametername>
</parameternamelist>
<parameterdescription>
<para>fine data </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ratio</parametername>
</parameternamelist>
<parameterdescription>
<para>refinement ratio. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="1134" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="1134" bodyend="1219" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="502" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a10bd6ff61966130ea99ab9faa410da13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::FillRandom</definition>
        <argsstring>(MultiFab &amp;mf, int scomp, int ncomp)</argsstring>
        <name>FillRandom</name>
        <qualifiedname>amrex::FillRandom</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <briefdescription>
<para>Fill <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with random numbers from uniform distribution. </para>
        </briefdescription>
        <detaileddescription>
<para>The uniform distribution range is [0.0, 1.0) for CPU and SYCL, it&apos;s (0,1] for CUDA and HIP. All cells including ghost cells are filled.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of component </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="1221" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="1221" bodyend="1232" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="516" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0b5cc6671c574fc82057046c73789ee5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::FillRandomNormal</definition>
        <argsstring>(MultiFab &amp;mf, int scomp, int ncomp, Real mean, Real stddev)</argsstring>
        <name>FillRandomNormal</name>
        <qualifiedname>amrex::FillRandomNormal</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>mean</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>stddev</declname>
        </param>
        <briefdescription>
<para>Fill <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with random numbers from normal distribution. </para>
        </briefdescription>
        <detaileddescription>
<para>All cells including ghost cells are filled.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of component </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mean</parametername>
</parameternamelist>
<parameterdescription>
<para>mean of normal distribution </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stddev</parametername>
</parameternamelist>
<parameterdescription>
<para>standard deviation of normal distribution </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="1234" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="1234" bodyend="1245" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="529" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a39248910c4503df29ff96fc63539021d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &gt;</type>
        <definition>Vector&lt; MultiFab &gt; amrex::convexify</definition>
        <argsstring>(Vector&lt; MultiFab const  * &gt; const  &amp;mf, Vector&lt; IntVect &gt; const  &amp;refinement_ratio)</argsstring>
        <name>convexify</name>
        <qualifiedname>amrex::convexify</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const * &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; const &amp;</type>
          <declname>refinement_ratio</declname>
        </param>
        <briefdescription>
<para>Convexify AMR data. </para>
        </briefdescription>
        <detaileddescription>
<para>This function &quot;convexifies&quot; the AMR data by removing cells that are covered by fine levels from coarse level MultiFabs. This could be useful for visualization. The returned MultiFabs on coarse levels have different BoxArrays from the original BoxArrays. For the finest level, the data is simply copied to the returned object. The returned MultiFabs have no ghost cells. For nodal data, the nodes on the coarse/fine interface exist on both levels. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" line="1247" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.cpp" bodystart="1247" bodyend="1298" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="542" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3de41052b3ad490e6eb1064c89de713d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename CMF</type>
          </param>
          <param>
            <type>typename FMF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray_v&lt; CMF &gt; &amp;&amp;IsFabArray_v&lt; FMF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_face_to_cellcenter</definition>
        <argsstring>(CMF &amp;cc, int dcomp, const Array&lt; const FMF *, 3 &gt; &amp;fc, int ngrow=0)</argsstring>
        <name>average_face_to_cellcenter</name>
        <qualifiedname>amrex::average_face_to_cellcenter</qualifiedname>
        <param>
          <type>CMF &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const FMF *, 3 &gt; &amp;</type>
          <declname>fc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Average face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> onto cell-centered <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="915" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="915" bodyend="921" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="54" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a82b0c66526be566ac3f5eddf99132d30" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename CMF</type>
          </param>
          <param>
            <type>typename FMF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray_v&lt; CMF &gt; &amp;&amp;IsFabArray_v&lt; FMF &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_face_to_cellcenter</definition>
        <argsstring>(CMF &amp;cc, int dcomp, const Array&lt; const FMF *, 3 &gt; &amp;fc, IntVect const &amp;ng_vect)</argsstring>
        <name>average_face_to_cellcenter</name>
        <qualifiedname>amrex::average_face_to_cellcenter</qualifiedname>
        <param>
          <type>CMF &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const FMF *, 3 &gt; &amp;</type>
          <declname>fc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>ng_vect</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="925" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="925" bodyend="986" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="60" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a444e92d4213a53739768571a4bb72ce3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down_faces</definition>
        <argsstring>(const Vector&lt; const MF * &gt; &amp;fine, const Vector&lt; MF * &gt; &amp;crse, const IntVect &amp;ratio, int ngcrse=0)</argsstring>
        <name>average_down_faces</name>
        <qualifiedname>amrex::average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const MF * &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Average fine face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> onto crse face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="989" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="989" bodyend="999" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="87" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac0212832fb955bf32b6ce4cb2779c930" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down_faces</definition>
        <argsstring>(const Vector&lt; const MF * &gt; &amp;fine, const Vector&lt; MF * &gt; &amp;crse, int ratio, int ngcrse=0)</argsstring>
        <name>average_down_faces</name>
        <qualifiedname>amrex::average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const MF * &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; MF * &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Average fine face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> onto crse face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1002" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1002" bodyend="1006" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="93" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa01edd4c1c30efba5ead298c69ee50e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down_faces</definition>
        <argsstring>(const Array&lt; const MF *, 3 &gt; &amp;fine, const Array&lt; MF *, 3 &gt; &amp;crse, const IntVect &amp;ratio, int ngcrse=0)</argsstring>
        <name>average_down_faces</name>
        <qualifiedname>amrex::average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const MF *, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Average fine face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> onto crse face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1017" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1017" bodyend="1024" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="99" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa48f03bb74a4dcc191c43c6ebe665a87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down_faces</definition>
        <argsstring>(const Array&lt; const MF *, 3 &gt; &amp;fine, const Array&lt; MF *, 3 &gt; &amp;crse, int ratio, int ngcrse=0)</argsstring>
        <name>average_down_faces</name>
        <qualifiedname>amrex::average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const MF *, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>Average fine face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> onto crse face-based <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1009" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1009" bodyend="1014" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="105" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1bc63dedd63a3c820e4527fd4d6cac6c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down_faces</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;fine, FabArray&lt; FAB &gt; &amp;crse, const IntVect &amp;ratio, int ngcrse=0)</argsstring>
        <name>average_down_faces</name>
        <qualifiedname>amrex::average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>This version does average down for one face direction. </para>
        </briefdescription>
        <detaileddescription>
<para>It uses the IndexType of MultiFabs to determine the direction. It is expected that one direction is nodal and the rest are cell-centered. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1027" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1027" bodyend="1084" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="116" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a35ffe89d251a21a4edd668813793b753" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down_faces</definition>
        <argsstring>(const Array&lt; const MF *, 3 &gt; &amp;fine, const Array&lt; MF *, 3 &gt; &amp;crse, const IntVect &amp;ratio, const Geometry &amp;crse_geom)</argsstring>
        <name>average_down_faces</name>
        <qualifiedname>amrex::average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const MF *, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; MF *, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>crse_geom</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1087" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1087" bodyend="1094" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="121" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8d23f273421b89ddf32a809cba7bdaef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down_faces</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;fine, FabArray&lt; FAB &gt; &amp;crse, const IntVect &amp;ratio, const Geometry &amp;crse_geom)</argsstring>
        <name>average_down_faces</name>
        <qualifiedname>amrex::average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>crse_geom</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1097" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1097" bodyend="1104" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="126" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aff7bc26e4e82b323802d4b6d546101fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down_nodal</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;S_fine, FabArray&lt; FAB &gt; &amp;S_crse, const IntVect &amp;ratio, int ngcrse=0, bool mfiter_is_definitely_safe=false)</argsstring>
        <name>average_down_nodal</name>
        <qualifiedname>amrex::average_down_nodal</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>S_fine</declname>
          <defname>fine</defname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>S_crse</declname>
          <defname>crse</defname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>mfiter_is_definitely_safe</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Average fine node-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto crse node-centered <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Average fine node-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto crse node-based <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. This routine assumes that the crse <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is a coarsened version of the fine <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="606" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="606" bodyend="640" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="146" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5eed60d257307d60b712f3d5ffd7cf49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;S_fine, FabArray&lt; FAB &gt; &amp;S_crse, int scomp, int ncomp, const IntVect &amp;ratio)</argsstring>
        <name>average_down</name>
        <qualifiedname>amrex::average_down</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>S_fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>S_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Average <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> onto crse <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> without volume weighting. This routine DOES NOT assume that the crse <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is a coarsened version of the fine <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>. Work for both cell-centered and nodal MultiFabs. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="654" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="654" bodyend="777" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="169" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2b8d8a68104aadc30564aeb092961205" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::average_down</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;S_fine, FabArray&lt; FAB &gt; &amp;S_crse, int scomp, int ncomp, int rr)</argsstring>
        <name>average_down</name>
        <qualifiedname>amrex::average_down</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>S_fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>S_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>rr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="648" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="648" bodyend="651" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="172" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2a50a85d7bbd84f5b4116132d9dc5815" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; typename MF::value_type &gt;</type>
        <definition>Vector&lt; typename MF::value_type &gt; amrex::get_cell_data</definition>
        <argsstring>(MF const &amp;mf, IntVect const &amp;cell)</argsstring>
        <name>get_cell_data</name>
        <qualifiedname>amrex::get_cell_data</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>cell</declname>
        </param>
        <briefdescription>
<para>Get data in a cell of MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This returns a <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref> containing the data in a given cell, if it&apos;s available on a process. The returned <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref> is empty if a process does not have the given cell. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1107" column="8" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1107" bodyend="1135" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="206" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae3df2c0dc2d4234f59ca14f507231e4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MF</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; MF &gt;::value, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>MF</type>
        <definition>MF amrex::get_line_data</definition>
        <argsstring>(MF const &amp;mf, int dir, IntVect const &amp;cell, Box const &amp;bnd_bx=Box())</argsstring>
        <name>get_line_data</name>
        <qualifiedname>amrex::get_line_data</qualifiedname>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>cell</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bnd_bx</declname>
          <defval><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref>()</defval>
        </param>
        <briefdescription>
<para>Get data in a line of MultiFab/FabArray. </para>
        </briefdescription>
        <detaileddescription>
<para>This returns a MultiFab/FabArray containing the data in a line specified by a direction and a cell. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1138" column="4" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1138" bodyend="1197" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="215" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a60886a6799fb7ae612bf30d74a493a26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref></type>
        <definition>iMultiFab amrex::makeFineMask</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;cmf, const BoxArray &amp;fba, const IntVect &amp;ratio, int crse_value=0, int fine_value=1)</argsstring>
        <name>makeFineMask</name>
        <qualifiedname>amrex::makeFineMask</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>fba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>crse_value</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>int</type>
          <declname>fine_value</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return an <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref> that has the same <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> and <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> as the coarse <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> cmf. Cells covered by the coarsened fine grids are set to fine_value, whereas other cells are set to crse_value. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="550" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="550" bodyend="555" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="221" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a78142d53611f8627f6d68afd0779ef54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref></type>
        <definition>iMultiFab amrex::makeFineMask</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;cmf, const BoxArray &amp;fba, const IntVect &amp;ratio, Periodicity const &amp;period, int crse_value, int fine_value)</argsstring>
        <name>makeFineMask</name>
        <qualifiedname>amrex::makeFineMask</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>fba</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
        </param>
        <param>
          <type>int</type>
          <declname>crse_value</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fine_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="559" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="559" bodyend="564" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="227" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a478148eaeebd74ddc7956806c55fa2cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref></type>
        <definition>iMultiFab amrex::makeFineMask</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;cmf, const FabArray&lt; FAB &gt; &amp;fmf, const IntVect &amp;cnghost, const IntVect &amp;ratio, Periodicity const &amp;period, int crse_value, int fine_value)</argsstring>
        <name>makeFineMask</name>
        <qualifiedname>amrex::makeFineMask</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>cnghost</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
        </param>
        <param>
          <type>int</type>
          <declname>crse_value</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fine_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="568" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="568" bodyend="581" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="233" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af559f21584872566541db61cbacf7470" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref></type>
        <definition>iMultiFab amrex::makeFineMask</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;cmf, const FabArray&lt; FAB &gt; &amp;fmf, const IntVect &amp;cnghost, const IntVect &amp;ratio, Periodicity const &amp;period, int crse_value, int fine_value, LayoutData&lt; int &gt; &amp;has_cf)</argsstring>
        <name>makeFineMask</name>
        <qualifiedname>amrex::makeFineMask</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>cmf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>cnghost</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Periodicity" kindref="compound">Periodicity</ref> const &amp;</type>
          <declname>period</declname>
        </param>
        <param>
          <type>int</type>
          <declname>crse_value</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fine_value</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1LayoutData" kindref="compound">LayoutData</ref>&lt; int &gt; &amp;</type>
          <declname>has_cf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="585" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="585" bodyend="601" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="237" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a24aa5b51c299dd1337df192681f47e0e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::cast</definition>
        <argsstring>(U const &amp;mf_in)</argsstring>
        <name>cast</name>
        <qualifiedname>amrex::cast</qualifiedname>
        <param>
          <type>U const &amp;</type>
          <declname>mf_in</declname>
        </param>
        <briefdescription>
<para>example: auto mf = amrex::cast&lt;MultiFab&gt;(imf); </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="265" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="265" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a364dfb9be3b959cfdb2509f4680ecd6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsBaseFab&lt; FAB &gt;::value, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>&lt; T &gt;</type>
        <definition>BaseFab&lt; T &gt; amrex::ReduceToPlane</definition>
        <argsstring>(int direction, Box const &amp;domain, FabArray&lt; FAB &gt; const &amp;mf, F const &amp;f)</argsstring>
        <name>ReduceToPlane</name>
        <qualifiedname>amrex::ReduceToPlane</qualifiedname>
        <param>
          <type>int</type>
          <declname>direction</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para><ref refid="namespaceamrex_1_1Reduce" kindref="compound">Reduce</ref> FabArray/MultiFab data to a plane Fab. </para>
        </briefdescription>
        <detaileddescription>
<para>This function takes a FabArray/MultiFab and reduces its data to a plane. The return data are stored in a <ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref> with only one cell in the normal direction of the plane. The index range of the <ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref> in the other directions is the same as the provided domain Box. If data do not exist along a certain line, the value is set to the minimum, maximum and zero, for reduce max, min and sum, respectively. The reduction is local and the user may need to do MPI communication afterwards if needed.</para>
<para>In the example code below, the sum along each line at (i,j) in the z-direction is computed and stored at (i,j,0) of the returned <ref refid="classamrex_1_1BaseFab" kindref="compound">BaseFab</ref>. <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dir<sp/>=<sp/>2;<sp/></highlight><highlight class="comment">//<sp/>z-direction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>domain_box<sp/>=<sp/>geom.Domain();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma<sp/>=<sp/>mf.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rr<sp/>=<sp/>ReduceToPlane&lt;ReduceOpSum,Real&gt;(dir,<sp/>domain_box,<sp/>mf,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_no,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ma[box_no](i,j,k);<sp/></highlight><highlight class="comment">//<sp/>data<sp/>at<sp/>(i,j,k)<sp/>of<sp/>Box<sp/>box_no</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting></para>
<para>Below is another example. This finds the maximum value in the x-direction and stores the maximum value and the i-index. An MPI reduce is then called to further reduce the data to the root process 0. <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>dir<sp/>=<sp/>0;<sp/></highlight><highlight class="comment">//<sp/>x-direction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>domain_box<sp/>=<sp/>geom.Domain().surroundingNodes();<sp/></highlight><highlight class="comment">//<sp/>nodal<sp/>data</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma<sp/>=<sp/>mf.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rr<sp/>=<sp/>ReduceToPlane&lt;ReduceOpMax,KeyValuePair&lt;Real,int&gt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(dir,<sp/>domain_box,<sp/>mf,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_no,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="structamrex_1_1ValLocPair" kindref="compound">KeyValuePair&lt;Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{ma[box_no](i,j,k),<sp/>i};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__amrex__mpi_1ga6c3ee948e758158f19ccce52a7865c92" kindref="member">ParallelReduce::Max</ref>(rr.dataPtr(),<sp/>rr.size(),<sp/>root,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespaceamrex_1_1ParallelDescriptor_1a0f53686fc6a6b7dca69c230fd1336e44" kindref="member">ParallelDescriptor::Communicator</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Process<sp/>root<sp/>now<sp/>has<sp/>the<sp/>final<sp/>results.</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>reduce operator (e.g., <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref> and <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>data type of reduction result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>FabArray/MultiFab type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>direction</parametername>
</parameternamelist>
<parameterdescription>
<para>normal direction of the plane (e.g., 0, 1 and 2) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain</parametername>
</parameternamelist>
<parameterdescription>
<para>domain Box </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>a FabArray/MultiFab object specifying the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning T. It takes four ints, where the first int is the local box index and the others are spatial indices for x, y, and z-directions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (BaseFab&lt;T&gt;) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1293" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1293" bodyend="1319" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="352" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a40c2c0500c3c5f5b536616ca66a968da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename FA</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; FA &gt;, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>FA</type>
        <definition>FA amrex::ReduceToPlaneMF</definition>
        <argsstring>(int direction, Box const &amp;domain, FA const &amp;mf, F const &amp;f)</argsstring>
        <name>ReduceToPlaneMF</name>
        <qualifiedname>amrex::ReduceToPlaneMF</qualifiedname>
        <param>
          <type>int</type>
          <declname>direction</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type>FA const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para><ref refid="namespaceamrex_1_1Reduce" kindref="compound">Reduce</ref> FabArray/MultiFab data to plane <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function takes a FabArray/MultiFab and reduce its data to a plane. The first template parameter specifies the reduction operation. Currently only <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref> is supported. The return data is a <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> whose <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is based on the input <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> with each box shrunk to just one cell in the the specified direction and its index set to zero. Its <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> is the same as the input <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. Note that the returned FA may contain duplicated Boxes. It contains global reduction results that have been MPI reduced. This behavior is different from that of ReduceToPlane that returns local reduction results.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma<sp/>=<sp/>mf.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mf2<sp/>=<sp/>ReduceToPlaneMF&lt;ReduceOpSum&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(2,<sp/>domain,<sp/>mf,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>b,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ma[b](i,j,k);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>nz<sp/>=<sp/>domain.length(2);<sp/></highlight><highlight class="comment">//<sp/>number<sp/>of<sp/>cells<sp/>in<sp/>z-direction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma2<sp/>=<sp/>mf2.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1a1f15630874d45aeb722ca649e6c4c3a9" kindref="member">ParallelFor</ref>(mf,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>b,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ma[b](i,j,k)<sp/>-=<sp/>ma2[b](i,j,0)<sp/>/<sp/>nz;<sp/></highlight><highlight class="comment">//<sp/>(i,j,0)<sp/>is<sp/>used<sp/>to<sp/>access<sp/>ma2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>If<sp/>sync<sp/>is<sp/>needed,<sp/>call<sp/>Gpu::streamSynchronize()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>mf<sp/>now<sp/>contains<sp/>data<sp/>with<sp/>z-direction<sp/>line<sp/>average<sp/>subtracted</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>reduce operator (Must be ReduceSum for now.) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FA</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>direction</parametername>
</parameternamelist>
<parameterdescription>
<para>normal direction of the plane (e.g., 0, 1 and 2) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain</parametername>
</parameternamelist>
<parameterdescription>
<para>domain Box </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>a FabArray/MultiFab object specifying the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning data fore reduction. It takes four ints, where the first int is the local box index and the others are spatial indices for x, y, and z-directions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (FA) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1367" column="4" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1367" bodyend="1372" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="405" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a372b4c6fd8af2bdf17bb3d790e03f64d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename FA</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsMultiFabLike_v&lt; FA &gt;, int &gt;</type>
            <declname>FOO</declname>
            <defname>FOO</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>std::pair&lt; FA, FA &gt;</type>
        <definition>std::pair&lt; FA, FA &gt; amrex::ReduceToPlaneMF2</definition>
        <argsstring>(int direction, Box const &amp;domain, FA const &amp;mf, F const &amp;f)</argsstring>
        <name>ReduceToPlaneMF2</name>
        <qualifiedname>amrex::ReduceToPlaneMF2</qualifiedname>
        <param>
          <type>int</type>
          <declname>direction</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <param>
          <type>FA const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para><ref refid="namespaceamrex_1_1Reduce" kindref="compound">Reduce</ref> FabArray/MultiFab data to plane <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function takes a FabArray/MultiFab and reduce its data to a plane. The first template parameter specifies the reduction operation. Currently only <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref> is supported. The return data are a pair of FabArrays. The first FA&apos;s <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is based on the input <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> with each box shrunk to just one cell in the the specified direction and its index set to zero. Its <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> is the same as the input <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. The second FA&apos;s <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> is a new 2D <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> with only one cell in the specified direction. The first FA may contain duplicated Boxes, whereas the second one is unique. The local reduction results are stored in the first FA, whereas the global results (including MPI communication) are in the second FA. Below is and an example.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma<sp/>=<sp/>mf.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[mf2,<sp/>mf2_unique]<sp/>=<sp/>ReduceToPlaneMF2&lt;ReduceOpSum&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(2,<sp/>domain,<sp/>mf,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>b,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ma[b](i,j,k);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>mf2:<sp/>box<sp/>local<sp/>reduction<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>mf2_unique:<sp/>global<sp/>reduction<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>phi<sp/>=<sp/>poisson_solver(mf2_unique);<sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>2D<sp/>Poisson<sp/>solve</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mf2.ParallelCopy(phi);<sp/></highlight><highlight class="comment">//<sp/>Each<sp/>Fab<sp/>in<sp/>mf2<sp/>has<sp/>the<sp/>2D<sp/>Poisson<sp/>solver<sp/>result</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>reduce operator (Must be ReduceSum for now.) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FA</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>direction</parametername>
</parameternamelist>
<parameterdescription>
<para>normal direction of the plane (e.g., 0, 1 and 2) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain</parametername>
</parameternamelist>
<parameterdescription>
<para>domain Box </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>a FabArray/MultiFab object specifying the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning data fore reduction. It takes four ints, where the first int is the local box index and the others are spatial indices for x, y, and z-directions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (std::pair&lt;FA,FA&gt;) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="1382" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="1382" bodyend="1415" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" declline="457" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7ef9aec0b2f67456f1467c71e043025c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        <definition>Real amrex::NormHelper</definition>
        <argsstring>(const MultiFab &amp;x, int xcomp, const MultiFab &amp;y, int ycomp, F const &amp;f, int numcomp, IntVect nghost, bool local)</argsstring>
        <name>NormHelper</name>
        <qualifiedname>amrex::NormHelper</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>xcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ycomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
        </param>
        <briefdescription>
<para>Returns part of a norm based on two MultiFabs. </para>
        </briefdescription>
        <detaileddescription>
<para>The MultiFabs MUST have the same underlying <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>. The function f is applied elementwise as f(<ref refid="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69a9dd4e461268c8034f5c8564e155c67a6" kindref="member">x(i,j,k,n)</ref>,<ref refid="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69a415290769594460e2e485922904f345d" kindref="member">y(i,j,k,n)</ref>) inside the summation (subject to a valid mask entry pf(<ref refid="AMReX__InterpFaceRegister_8cpp_1a5b2221de12a27f0d22ceec3ecf3fc430" kindref="member">mask(i,j,k,n)</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="792" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="792" bodyend="840"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6758d6b184b1615ea5e4434762e944c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MMF</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        <definition>Real amrex::NormHelper</definition>
        <argsstring>(const MMF &amp;mask, const MultiFab &amp;x, int xcomp, const MultiFab &amp;y, int ycomp, Pred const &amp;pf, F const &amp;f, int numcomp, IntVect nghost, bool local)</argsstring>
        <name>NormHelper</name>
        <qualifiedname>amrex::NormHelper</qualifiedname>
        <param>
          <type>const MMF &amp;</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>xcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ycomp</declname>
        </param>
        <param>
          <type>Pred const &amp;</type>
          <declname>pf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
        </param>
        <briefdescription>
<para>Returns part of a norm based on three MultiFabs. </para>
        </briefdescription>
        <detaileddescription>
<para>The MultiFabs MUST have the same underlying <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref>. The Predicate pf is used to test the mask The function f is applied elementwise as f(<ref refid="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69a9dd4e461268c8034f5c8564e155c67a6" kindref="member">x(i,j,k,n)</ref>,<ref refid="namespaceamrex_1a8de829410ed15dbc56e4dafc9bc6ea69a415290769594460e2e485922904f345d" kindref="member">y(i,j,k,n)</ref>) inside the summation (subject to a valid mask entry pf(<ref refid="AMReX__InterpFaceRegister_8cpp_1a5b2221de12a27f0d22ceec3ecf3fc430" kindref="member">mask(i,j,k,n)</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" line="852" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_MultiFabUtil.H" bodystart="852" bodyend="911"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae675dc0a879b2652b42833f5999ee6b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::numUniquePhysicalCores</definition>
        <argsstring>()</argsstring>
        <name>numUniquePhysicalCores</name>
        <qualifiedname>amrex::numUniquePhysicalCores</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>... </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_OpenMP.cpp" line="29" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_OpenMP.cpp" bodystart="29" bodyend="132" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_OpenMP.H" declline="47" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac38f92b345723f71defea15e208ee644" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Orientation &amp;o)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Orientation" kindref="compound">Orientation</ref> &amp;</type>
          <declname>o</declname>
        </param>
        <briefdescription>
<para>Write to an ostream in ASCII format. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Orientation.cpp" line="9" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Orientation.cpp" bodystart="10" bodyend="18" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Orientation.H" declline="130" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a55b6061edd95e18d4e44f26cbdb18f00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, Orientation &amp;o)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Orientation" kindref="compound">Orientation</ref> &amp;</type>
          <declname>o</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Orientation.cpp" line="26" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Orientation.cpp" bodystart="26" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a323ccd5565111870ca88d165b6f9f60b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ops</declname>
            <defname>Ops</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ReduceData" kindref="compound">ReduceData</ref>&lt; Ts... &gt;::Type</type>
        <definition>ReduceData&lt; Ts... &gt;::Type amrex::ParReduce</definition>
        <argsstring>(TypeList&lt; Ops... &gt; operation_list, TypeList&lt; Ts... &gt; type_list, FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ParReduce</name>
        <qualifiedname>amrex::ParReduce</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ops... &gt;</type>
          <declname>operation_list</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ts... &gt;</type>
          <declname>type_list</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Parallel reduce for MultiFab/FabArray. The reduce result is local and it&apos;s the user&apos;s responsibility if MPI communication is needed. </para>
        </briefdescription>
        <detaileddescription>
<para>This performs reduction over a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>&apos;s valid and specified ghost regions. For example, the code below computes the minimum of the first <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> and the maximum of the second <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. <programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma1<sp/>=<sp/>mf1.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma2<sp/>=<sp/>mf2.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple&lt;Real,Real&gt;</ref><sp/>mm<sp/>=<sp/><ref refid="namespaceamrex_1a323ccd5565111870ca88d165b6f9f60b" kindref="member">ParReduce</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList&lt;ReduceOpMin,ReduceOpMax&gt;</ref>{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TypeList&lt;Real,Real&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mf1,<sp/>mf1.nGrowVect(),</highlight></codeline>
<codeline><highlight class="normal">[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_no,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-&gt;<sp/>GpuTuple&lt;Real,Real&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{<sp/>ma1[box_no](i,j,k),<sp/>ma2[box_no](i,j,k)<sp/>};</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Ops...</parametername>
</parameternamelist>
<parameterdescription>
<para>reduce operators (e.g., <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref>, <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref>, <ref refid="structamrex_1_1ReduceOpLogicalAnd" kindref="compound">ReduceOpLogicalAnd</ref>, and <ref refid="structamrex_1_1ReduceOpLogicalOr" kindref="compound">ReduceOpLogicalOr</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Ts...</parametername>
</parameternamelist>
<parameterdescription>
<para>data types (e.g., Real, int, etc.) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operation_list</parametername>
</parameternamelist>
<parameterdescription>
<para>list of reduce operators </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type_list</parametername>
</parameternamelist>
<parameterdescription>
<para>list of data types </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fa</parametername>
</parameternamelist>
<parameterdescription>
<para>a MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells included in the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning GpuTuple&lt;Ts...&gt;. It takes four ints, where the first int is the local box index and the others are spatial indices for x, y, and z-directions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (GpuTuple&lt;Ts...&gt;) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" line="48" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" bodystart="48" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abfa262ba247496c6cd85e2e9ae110fbd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::ParReduce</definition>
        <argsstring>(TypeList&lt; Op &gt; operation_list, TypeList&lt; T &gt; type_list, FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, F &amp;&amp;f)</argsstring>
        <name>ParReduce</name>
        <qualifiedname>amrex::ParReduce</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Op &gt;</type>
          <declname>operation_list</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; T &gt;</type>
          <declname>type_list</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Parallel reduce for MultiFab/FabArray. The reduce result is local and it&apos;s the user&apos;s responsibility if MPI communication is needed. </para>
        </briefdescription>
        <detaileddescription>
<para>This performs reduction over a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>&apos;s valid and specified ghost regions. For example, the code below computes the sum of the processed data in a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. <programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma<sp/>=<sp/>mf.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref><sp/>ektot<sp/>=<sp/><ref refid="namespaceamrex_1a323ccd5565111870ca88d165b6f9f60b" kindref="member">ParReduce</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList&lt;ReduceOpSum&gt;</ref>{},<sp/>TypeList&lt;Real&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mf,<sp/><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref>(0),</highlight></codeline>
<codeline><highlight class="normal">[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_no,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-&gt;<sp/>GpuTuple&lt;Real&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rho<sp/>=<sp/>ma[box_no](i,j,k,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/>ma[box_no](i,j,k,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>my<sp/>=<sp/>ma[box_no](i,j,k,2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mz<sp/>=<sp/>ma[box_no](i,j,k,3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ek<sp/>=<sp/>(mx*mx+my*my+mz*mz)/(2.*rho);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{<sp/>ek<sp/>};</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="namespaceamrex_1_1Reduce" kindref="compound">Reduce</ref> operator (e.g., <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref>, <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref>, <ref refid="structamrex_1_1ReduceOpLogicalAnd" kindref="compound">ReduceOpLogicalAnd</ref>, and <ref refid="structamrex_1_1ReduceOpLogicalOr" kindref="compound">ReduceOpLogicalOr</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>data type (e.g., Real, int, etc.) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operation_list</parametername>
</parameternamelist>
<parameterdescription>
<para>a reduce operator stored in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type_list</parametername>
</parameternamelist>
<parameterdescription>
<para>a data type stored in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fa</parametername>
</parameternamelist>
<parameterdescription>
<para>a MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells included in the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning GpuTuple&lt;T&gt;. It takes four ints, where the first int is the local box index and the others are spatial indices for x, y, and z-directions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (T) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" line="99" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" bodystart="99" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab2e804fa99d8bb4542f17716b52d2779" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ops</declname>
            <defname>Ops</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ReduceData" kindref="compound">ReduceData</ref>&lt; Ts... &gt;::Type</type>
        <definition>ReduceData&lt; Ts... &gt;::Type amrex::ParReduce</definition>
        <argsstring>(TypeList&lt; Ops... &gt; operation_list, TypeList&lt; Ts... &gt; type_list, FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, int ncomp, F &amp;&amp;f)</argsstring>
        <name>ParReduce</name>
        <qualifiedname>amrex::ParReduce</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ops... &gt;</type>
          <declname>operation_list</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ts... &gt;</type>
          <declname>type_list</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Parallel reduce for MultiFab/FabArray. The reduce result is local and it&apos;s the user&apos;s responsibility if MPI communication is needed. </para>
        </briefdescription>
        <detaileddescription>
<para>This performs reduction over a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>&apos;s valid and specified ghost regions and components. For example, the code below computes the minimum of the first <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> and the maximum of the second <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. <programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma1<sp/>=<sp/>mf1.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma2<sp/>=<sp/>mf2.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple&lt;Real,Real&gt;</ref><sp/>mm<sp/>=<sp/><ref refid="namespaceamrex_1a323ccd5565111870ca88d165b6f9f60b" kindref="member">ParReduce</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList&lt;ReduceOpMin,ReduceOpMax&gt;</ref>{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TypeList&lt;Real,Real&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mf1,<sp/>mf1.nGrowVect(),<sp/>mf1.nComp(),</highlight></codeline>
<codeline><highlight class="normal">[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_no,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-&gt;<sp/>GpuTuple&lt;Real,Real&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{<sp/>ma1[box_no](i,j,k,n),<sp/>ma2[box_no](i,j,k,n)<sp/>};</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Ops...</parametername>
</parameternamelist>
<parameterdescription>
<para>reduce operators (e.g., <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref>, <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref>, <ref refid="structamrex_1_1ReduceOpLogicalAnd" kindref="compound">ReduceOpLogicalAnd</ref>, and <ref refid="structamrex_1_1ReduceOpLogicalOr" kindref="compound">ReduceOpLogicalOr</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Ts...</parametername>
</parameternamelist>
<parameterdescription>
<para>data types (e.g., Real, int, etc.) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operation_list</parametername>
</parameternamelist>
<parameterdescription>
<para>list of reduce operators </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type_list</parametername>
</parameternamelist>
<parameterdescription>
<para>list of data types </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fa</parametername>
</parameternamelist>
<parameterdescription>
<para>a MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells included in the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of components in the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning GpuTuple&lt;Ts...&gt;. It takes five ints, where the first int is the local box index, the next three are spatial indices for x, y, and z-directions, and the last is for component.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (GpuTuple&lt;Ts...&gt;) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" line="151" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" bodystart="151" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3ce1e3d392107eb3cdaaf9b1dcaee3f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::ParReduce</definition>
        <argsstring>(TypeList&lt; Op &gt; operation_list, TypeList&lt; T &gt; type_list, FabArray&lt; FAB &gt; const &amp;fa, IntVect const &amp;nghost, int ncomp, F &amp;&amp;f)</argsstring>
        <name>ParReduce</name>
        <qualifiedname>amrex::ParReduce</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Op &gt;</type>
          <declname>operation_list</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; T &gt;</type>
          <declname>type_list</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Parallel reduce for MultiFab/FabArray. The reduce result is local and it&apos;s the user&apos;s responsibility if MPI communication is needed. </para>
        </briefdescription>
        <detaileddescription>
<para>This performs reduction over a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>&apos;s valid and specified ghost regions. For example, the code below computes the sum of the data in a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. <programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma<sp/>=<sp/>mf.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref><sp/>ektot<sp/>=<sp/><ref refid="namespaceamrex_1a323ccd5565111870ca88d165b6f9f60b" kindref="member">ParReduce</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList&lt;ReduceOpSum&gt;</ref>{},<sp/>TypeList&lt;Real&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mf,<sp/>mf.nGrowVect(),<sp/>mf.nComp(),</highlight></codeline>
<codeline><highlight class="normal">[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_no,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-&gt;<sp/>GpuTuple&lt;Real&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{<sp/>ma[box_no](i,j,k,n)<sp/>};</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="namespaceamrex_1_1Reduce" kindref="compound">Reduce</ref> operator (e.g., <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref>, <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref>, <ref refid="structamrex_1_1ReduceOpLogicalAnd" kindref="compound">ReduceOpLogicalAnd</ref>, and <ref refid="structamrex_1_1ReduceOpLogicalOr" kindref="compound">ReduceOpLogicalOr</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>data type (e.g., Real, int, etc.) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operation_list</parametername>
</parameternamelist>
<parameterdescription>
<para>a reduce operator stored in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type_list</parametername>
</parameternamelist>
<parameterdescription>
<para>a data type stored in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fa</parametername>
</parameternamelist>
<parameterdescription>
<para>a MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of ghost cells included in the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of components in the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning GpuTuple&lt;T&gt;. It takes four ints, where the first int is the local box index and the others are spatial indices for x, y, and z-directions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (T) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" line="198" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" bodystart="198" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af536110e09c19c7bf52c0ac725d83019" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ops</declname>
            <defname>Ops</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1ReduceData" kindref="compound">ReduceData</ref>&lt; Ts... &gt;::Type</type>
        <definition>ReduceData&lt; Ts... &gt;::Type amrex::ParReduce</definition>
        <argsstring>(TypeList&lt; Ops... &gt; operation_list, TypeList&lt; Ts... &gt; type_list, FabArray&lt; FAB &gt; const &amp;fa, F &amp;&amp;f)</argsstring>
        <name>ParReduce</name>
        <qualifiedname>amrex::ParReduce</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ops... &gt;</type>
          <declname>operation_list</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ts... &gt;</type>
          <declname>type_list</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Parallel reduce for MultiFab/FabArray. The reduce result is local and it&apos;s the user&apos;s responsibility if MPI communication is needed. </para>
        </briefdescription>
        <detaileddescription>
<para>This performs reduction over a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>&apos;s valid region. For example, the code below computes the minimum of the first <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> and the maximum of the second <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. <programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma1<sp/>=<sp/>mf1.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma2<sp/>=<sp/>mf2.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple&lt;Real,Real&gt;</ref><sp/>mm<sp/>=<sp/><ref refid="namespaceamrex_1a323ccd5565111870ca88d165b6f9f60b" kindref="member">ParReduce</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList&lt;ReduceOpMin,ReduceOpMax&gt;</ref>{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TypeList&lt;Real,Real&gt;{},<sp/>mf1,</highlight></codeline>
<codeline><highlight class="normal">[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_no,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-&gt;<sp/>GpuTuple&lt;Real,Real&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{<sp/>ma1[box_no](i,j,k),<sp/>ma2[box_no](i,j,k)<sp/>};</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Ops...</parametername>
</parameternamelist>
<parameterdescription>
<para>reduce operators (e.g., <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref>, <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref>, <ref refid="structamrex_1_1ReduceOpLogicalAnd" kindref="compound">ReduceOpLogicalAnd</ref>, and <ref refid="structamrex_1_1ReduceOpLogicalOr" kindref="compound">ReduceOpLogicalOr</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Ts...</parametername>
</parameternamelist>
<parameterdescription>
<para>data types (e.g., Real, int, etc.) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operation_list</parametername>
</parameternamelist>
<parameterdescription>
<para>list of reduce operators </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type_list</parametername>
</parameternamelist>
<parameterdescription>
<para>list of data types </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fa</parametername>
</parameternamelist>
<parameterdescription>
<para>a MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning GpuTuple&lt;Ts...&gt;. It takes four ints, where the first int is the local box index and the others are spatial indices for x, y, and z-directions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (GpuTuple&lt;Ts...&gt;) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" line="246" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" bodystart="246" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad8ec82d3270be95cb3ee77860a6a46db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename foo</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::ParReduce</definition>
        <argsstring>(TypeList&lt; Op &gt; operation_list, TypeList&lt; T &gt; type_list, FabArray&lt; FAB &gt; const &amp;fa, F &amp;&amp;f)</argsstring>
        <name>ParReduce</name>
        <qualifiedname>amrex::ParReduce</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Op &gt;</type>
          <declname>operation_list</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; T &gt;</type>
          <declname>type_list</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; const &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Parallel reduce for MultiFab/FabArray. The reduce result is local and it&apos;s the user&apos;s responsibility if MPI communication is needed. </para>
        </briefdescription>
        <detaileddescription>
<para>This performs reduction over a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>&apos;s valid region. For example, the code below computes the sum of the processed data in a <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. <programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ma<sp/>=<sp/>mf.const_arrays();</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref><sp/>ektot<sp/>=<sp/><ref refid="namespaceamrex_1a323ccd5565111870ca88d165b6f9f60b" kindref="member">ParReduce</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList&lt;ReduceOpSum&gt;</ref>{},<sp/>TypeList&lt;Real&gt;{},<sp/>mf,</highlight></codeline>
<codeline><highlight class="normal">[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>box_no,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>-&gt;<sp/>GpuTuple&lt;Real&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rho<sp/>=<sp/>ma[box_no](i,j,k,0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/>ma[box_no](i,j,k,1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>my<sp/>=<sp/>ma[box_no](i,j,k,2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mz<sp/>=<sp/>ma[box_no](i,j,k,3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>ek<sp/>=<sp/>(mx*mx+my*my+mz*mz)/(2.*rho);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{<sp/>ek<sp/>};</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="namespaceamrex_1_1Reduce" kindref="compound">Reduce</ref> operator (e.g., <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref>, <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref>, <ref refid="structamrex_1_1ReduceOpLogicalAnd" kindref="compound">ReduceOpLogicalAnd</ref>, and <ref refid="structamrex_1_1ReduceOpLogicalOr" kindref="compound">ReduceOpLogicalOr</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>data type (e.g., Real, int, etc.) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type like a lambda function</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>operation_list</parametername>
</parameternamelist>
<parameterdescription>
<para>a reduce operator stored in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type_list</parametername>
</parameternamelist>
<parameterdescription>
<para>a data type stored in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fa</parametername>
</parameternamelist>
<parameterdescription>
<para>a MultiFab/FabArray object used to specify the iteration space </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object returning GpuTuple&lt;T&gt;. It takes four ints, where the first int is the local box index and the others are spatial indices for x, y, and z-directions.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>reduction result (T) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" line="291" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_ParReduce.H" bodystart="291" bodyend="295"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a45701cae6632ec65a5eebdecc587c780" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::pout</definition>
        <argsstring>()</argsstring>
        <name>pout</name>
        <qualifiedname>amrex::pout</qualifiedname>
        <briefdescription>
<para>the stream that all output except error msgs should use </para>
        </briefdescription>
        <detaileddescription>
<para>Use this in place of std::cout for program output.</para>
<para>In serial this is the standard output, in parallel it is a different file on each proc (see <ref refid="namespaceamrex_1a76884405b2dc4cd3167652aa79be5606" kindref="member">setPoutBaseName()</ref>).</para>
<para>Can be used to replace std::cout. In serial this just returns std::cout. In parallel, this creates a separate file for each proc called &lt;basename&gt;.n where n is the procID and &lt;basename&gt; defaults to &quot;pout&quot; but can be set by calling <ref refid="namespaceamrex_1a76884405b2dc4cd3167652aa79be5606" kindref="member">setPoutBaseName()</ref>. Output is then directed to these files. This keeps the output from different processors from getting all jumbled up. If you want fewer files, you can use <ref refid="classamrex_1_1ParmParse" kindref="compound">ParmParse</ref> parameter amrex.pout_int=nproc and it will only output every nproc processors pout.n files (where nnproc == 0). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.cpp" line="116" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.cpp" bodystart="116" bodyend="151" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.H" declline="23" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a76884405b2dc4cd3167652aa79be5606" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::setPoutBaseName</definition>
        <argsstring>(const std::string &amp;a_Name)</argsstring>
        <name>setPoutBaseName</name>
        <qualifiedname>amrex::setPoutBaseName</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>a_Name</declname>
        </param>
        <briefdescription>
<para>Set the base name for the parallel output files used by <ref refid="namespaceamrex_1a45701cae6632ec65a5eebdecc587c780" kindref="member">pout()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Changes the base part of the filename for <ref refid="namespaceamrex_1a45701cae6632ec65a5eebdecc587c780" kindref="member">pout()</ref> files.</para>
<para>If the file has already been used and this is a different name, close the current file and open a new one.</para>
<para>When in parallel, changes the base name of the <ref refid="namespaceamrex_1a45701cae6632ec65a5eebdecc587c780" kindref="member">pout()</ref> files. If <ref refid="namespaceamrex_1a45701cae6632ec65a5eebdecc587c780" kindref="member">pout()</ref> has already been called, it closes the current output file and opens a new one (unless the name is the same, in which case it does nothing). In serial, ignores the argument and does nothing. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.cpp" line="162" column="8" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.cpp" bodystart="162" bodyend="174" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.H" declline="33" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0b6b28892d1b7c4a6845bcf08ba7a461" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const std::string &amp;</type>
        <definition>const std::string &amp; amrex::poutFileName</definition>
        <argsstring>()</argsstring>
        <name>poutFileName</name>
        <qualifiedname>amrex::poutFileName</qualifiedname>
        <briefdescription>
<para>return the current filename as used by <ref refid="namespaceamrex_1a45701cae6632ec65a5eebdecc587c780" kindref="member">pout()</ref> </para>
        </briefdescription>
        <detaileddescription>
<para>Accesses the filename for the local <ref refid="namespaceamrex_1a45701cae6632ec65a5eebdecc587c780" kindref="member">pout()</ref> file.</para>
<para>in serial, just return the string &quot;cout&quot;; abort if MPI is not initialized.</para>
<para>Returns the name used for the local <ref refid="namespaceamrex_1a45701cae6632ec65a5eebdecc587c780" kindref="member">pout()</ref> file. In parallel this is &quot;\&lt;pout_basename\&gt;.\&lt;procID\&gt;&quot;, where &lt;pout_basename&gt; defaults to &quot;pout&quot; and can be modified by calling <ref refid="namespaceamrex_1a76884405b2dc4cd3167652aa79be5606" kindref="member">setPoutBaseName()</ref>, and &lt;procID&gt; is the local proc number. In serial, this always returns the string &quot;cout&quot;. It is an error (exit code 111) to call this in parallel before MPI_Initialize(). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.cpp" line="184" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.cpp" bodystart="184" bodyend="220" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_parstream.H" declline="44" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3b8c7b9108d9ccbc108689fb9b8b2a7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::Partition</definition>
        <argsstring>(T *data, int beg, int end, F &amp;&amp;f)</argsstring>
        <name>Partition</name>
        <qualifiedname>amrex::Partition</qualifiedname>
        <param>
          <type>T *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>int</type>
          <declname>end</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A GPU-capable partition function for contiguous data. </para>
        </briefdescription>
        <detaileddescription>
<para>After calling this, all the items for which the predicate is true will be before the items for which the predicate is false in the input array.</para>
<para>This version is not stable, if you want that behavior use <ref refid="namespaceamrex_1a57310fe9971a6396f436f596efa45226" kindref="member">amrex::StablePartition</ref> instead.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the data to be partitioned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the predicate function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the data to be partitioned </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which to start </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which to stop (exclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function that returns 1 or 0 for each input</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns the index of the first element for which f is 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" line="82" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" bodystart="82" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1214d3602cac3f99cebc60c951dbb938" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::Partition</definition>
        <argsstring>(T *data, int n, F &amp;&amp;f)</argsstring>
        <name>Partition</name>
        <qualifiedname>amrex::Partition</qualifiedname>
        <param>
          <type>T *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A GPU-capable partition function for contiguous data. </para>
        </briefdescription>
        <detaileddescription>
<para>After calling this, all the items for which the predicate is true will be before the items for which the predicate is false in the input array.</para>
<para>This version is not stable, if you want that behavior use <ref refid="namespaceamrex_1a57310fe9971a6396f436f596efa45226" kindref="member">amrex::StablePartition</ref> instead.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the data to be partitioned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the predicate function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the data to be partitioned </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of elements in the array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function that returns 1 or 0 for each input</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns the index of the first element for which f is 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" line="111" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" bodystart="111" bodyend="114"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae3a47d7e7e8f7a66ddf15cdd606dbb8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::Partition</definition>
        <argsstring>(Gpu::DeviceVector&lt; T &gt; &amp;v, F &amp;&amp;f)</argsstring>
        <name>Partition</name>
        <qualifiedname>amrex::Partition</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1ga99e1f048890efc1c275606cb9bdc41c7" kindref="member">Gpu::DeviceVector</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A GPU-capable partition function for contiguous data. </para>
        </briefdescription>
        <detaileddescription>
<para>After calling this, all the items for which the predicate is true will be before the items for which the predicate is false in the input array.</para>
<para>This version is not stable, if you want that behavior use <ref refid="namespaceamrex_1a57310fe9971a6396f436f596efa45226" kindref="member">amrex::StablePartition</ref> instead.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the data to be partitioned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the predicate function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="group__amrex__linear__containers_1ga99e1f048890efc1c275606cb9bdc41c7" kindref="member">Gpu::DeviceVector</ref> with the data to be partitioned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function that returns 1 or 0 for each input</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns the index of the first element for which f is 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" line="135" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" bodystart="135" bodyend="142"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a57310fe9971a6396f436f596efa45226" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::StablePartition</definition>
        <argsstring>(T *data, int beg, int end, F &amp;&amp;f)</argsstring>
        <name>StablePartition</name>
        <qualifiedname>amrex::StablePartition</qualifiedname>
        <param>
          <type>T *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>int</type>
          <declname>end</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A GPU-capable partition function for contiguous data. </para>
        </briefdescription>
        <detaileddescription>
<para>After calling this, all the items for which the predicate is true will be before the items for which the predicate is false in the input array.</para>
<para>This version is stable, meaning that, within each side of the resulting array, order is maintained - if element i was before element j in the input, then it will also be before j in the output. If you don&apos;t care about this property, use <ref refid="namespaceamrex_1a3b8c7b9108d9ccbc108689fb9b8b2a7e" kindref="member">amrex::Partition</ref> instead.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the data to be partitioned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the predicate function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the data to be partitioned </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which to start </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>index at which to stop (exclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function that returns 1 or 0 for each input</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns the index of the first element for which f is 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" line="167" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" bodystart="167" bodyend="173"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab4fdc897c184681028ce35c12fead8c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::StablePartition</definition>
        <argsstring>(T *data, int n, F &amp;&amp;f)</argsstring>
        <name>StablePartition</name>
        <qualifiedname>amrex::StablePartition</qualifiedname>
        <param>
          <type>T *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A GPU-capable partition function for contiguous data. </para>
        </briefdescription>
        <detaileddescription>
<para>After calling this, all the items for which the predicate is true will be before the items for which the predicate is false in the input array.</para>
<para>This version is stable, meaning that, within each side of the resulting array, order is maintained - if element i was before element j in the input, then it will also be before j in the output. If you don&apos;t care about this property, use <ref refid="namespaceamrex_1a3b8c7b9108d9ccbc108689fb9b8b2a7e" kindref="member">amrex::Partition</ref> instead.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the data to be partitioned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the predicate function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the data to be partitioned </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of elements in the array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function that returns 1 or 0 for each input</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns the index of the first element for which f is 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" line="197" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" bodystart="197" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a52a83682c1d3c6b56f1fba2bbaaed439" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::StablePartition</definition>
        <argsstring>(Gpu::DeviceVector&lt; T &gt; &amp;v, F &amp;&amp;f)</argsstring>
        <name>StablePartition</name>
        <qualifiedname>amrex::StablePartition</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1ga99e1f048890efc1c275606cb9bdc41c7" kindref="member">Gpu::DeviceVector</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A GPU-capable partition function for contiguous data. </para>
        </briefdescription>
        <detaileddescription>
<para>After calling this, all the items for which the predicate is true will be before the items for which the predicate is false in the input array.</para>
<para>This version is stable, meaning that, within each side of the resulting array, order is maintained - if element i was before element j in the input, then it will also be before j in the output. If you don&apos;t care about this property, use <ref refid="namespaceamrex_1a3b8c7b9108d9ccbc108689fb9b8b2a7e" kindref="member">amrex::Partition</ref> instead.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the data to be partitioned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the predicate function.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="group__amrex__linear__containers_1ga99e1f048890efc1c275606cb9bdc41c7" kindref="member">Gpu::DeviceVector</ref> with the data to be partitioned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function that returns 1 or 0 for each input</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns the index of the first element for which f is 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" line="223" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Partition.H" bodystart="223" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6e1c541c50331b9a3c005b80b4503f85" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::LevelPath</definition>
        <argsstring>(int level, const std::string &amp;levelPrefix=&quot;Level_&quot;)</argsstring>
        <name>LevelPath</name>
        <qualifiedname>amrex::LevelPath</qualifiedname>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <briefdescription>
<para>return the name of the level directory, e.g., Level_5 </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="18" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="18" bodyend="21" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="22" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab4ba0c733501dc74a5d254dac0bfc47d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::MultiFabHeaderPath</definition>
        <argsstring>(int level, const std::string &amp;levelPrefix=&quot;Level_&quot;, const std::string &amp;mfPrefix=&quot;Cell&quot;)</argsstring>
        <name>MultiFabHeaderPath</name>
        <qualifiedname>amrex::MultiFabHeaderPath</qualifiedname>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <briefdescription>
<para>return the path of the multifab to write to the header, e.g., Level_5/Cell </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="23" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="23" bodyend="28" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="25" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a438b71d250fb65fd385716c745be94ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::LevelFullPath</definition>
        <argsstring>(int level, const std::string &amp;plotfilename, const std::string &amp;levelPrefix=&quot;Level_&quot;)</argsstring>
        <name>LevelFullPath</name>
        <qualifiedname>amrex::LevelFullPath</qualifiedname>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <briefdescription>
<para>return the full path of the level directory, e.g., plt00005/Level_5 </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="30" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="30" bodyend="40" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="30" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a81e8d2ba5c7abaf7b2ca9bd2f43d5fb1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::MultiFabFileFullPrefix</definition>
        <argsstring>(int level, const std::string &amp;plotfilename, const std::string &amp;levelPrefix=&quot;Level_&quot;, const std::string &amp;mfPrefix=&quot;Cell&quot;)</argsstring>
        <name>MultiFabFileFullPrefix</name>
        <qualifiedname>amrex::MultiFabFileFullPrefix</qualifiedname>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <briefdescription>
<para>return the full path multifab prefix, e.g., plt00005/Level_5/Cell </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="42" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="42" bodyend="53" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="35" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa099c9a81b678f94bc075120f85f0df2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::PreBuildDirectorHierarchy</definition>
        <argsstring>(const std::string &amp;dirName, const std::string &amp;subDirPrefix, int nSubDirs, bool callBarrier)</argsstring>
        <name>PreBuildDirectorHierarchy</name>
        <qualifiedname>amrex::PreBuildDirectorHierarchy</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>dirName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>subDirPrefix</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nSubDirs</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>callBarrier</declname>
        </param>
        <briefdescription>
<para>prebuild a hierarchy of directories dirName is built first. if dirName exists, it is renamed. then build dirName/subDirPrefix_0 .. dirName/subDirPrefix_nSubDirs-1 if callBarrier is true, call <ref refid="group__amrex__mpi_1ga732a4be5017987f2d6edc0fcd2329301" kindref="member">ParallelDescriptor::Barrier()</ref> after all directories are built <ref refid="group__amrex__mpi_1gac7fb3467af4aabf15e61cb9c27e916d9" kindref="member">ParallelDescriptor::IOProcessor()</ref> creates the directories </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>&amp;dirName</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>&amp;subDirPrefix</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nSubDirs</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callBarrier</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="57" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="57" bodyend="70" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="54" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aeaa559cd77a4c889c84b144f59a6e35c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteGenericPlotfileHeader</definition>
        <argsstring>(std::ostream &amp;HeaderFile, int nlevels, const Vector&lt; BoxArray &gt; &amp;bArray, const Vector&lt; std::string &gt; &amp;varnames, const Vector&lt; Geometry &gt; &amp;geom, Real time, const Vector&lt; int &gt; &amp;level_steps, const Vector&lt; IntVect &gt; &amp;ref_ratio, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix)</argsstring>
        <name>WriteGenericPlotfileHeader</name>
        <qualifiedname>amrex::WriteGenericPlotfileHeader</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>HeaderFile</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nlevels</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &gt; &amp;</type>
          <declname>bArray</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>level_steps</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref_ratio</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
          <defval>&quot;HyperCLaw-V1.1&quot;</defval>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
          <defval>&quot;Level_&quot;</defval>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
          <defval>&quot;Cell&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>write a generic plot file header to the file plotfilename/Header the plotfilename directory must already exist </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="74" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="74" bodyend="156" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="63" declcolumn="10"/>
      </memberdef>
      <member refid="group__amrex__io_1ga21e84284bac03ced14676297803deabe" kind="function"><name>WriteMultiLevelPlotfile</name></member>
      <memberdef kind="function" id="namespaceamrex_1a87ec6f46642e5c4b2b89b545500be320" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteMLMF</definition>
        <argsstring>(const std::string &amp;plotfilename, const Vector&lt; const MultiFab * &gt; &amp;mf, const Vector&lt; Geometry &gt; &amp;geom)</argsstring>
        <name>WriteMLMF</name>
        <qualifiedname>amrex::WriteMLMF</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
<para>write a plotfile to disk given: -plotfile name -vector of MultiFabs -vector of Geometrys variable names are written as &quot;Var0&quot;, &quot;Var1&quot;, etc. refinement ratio is computed from the <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> vector &quot;time&quot; and &quot;level_steps&quot; are set to zero </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>&amp;plotfilename</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>&amp;geom</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="253" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="253" bodyend="285" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="113" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ace783f22796d80958dc5a14440a432fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteMultiLevelPlotfileHeaders</definition>
        <argsstring>(const std::string &amp;plotfilename, int nlevels, const Vector&lt; const MultiFab * &gt; &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Vector&lt; Geometry &gt; &amp;geom, Real time, const Vector&lt; int &gt; &amp;level_steps, const Vector&lt; IntVect &gt; &amp;ref_ratio, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteMultiLevelPlotfileHeaders</name>
        <qualifiedname>amrex::WriteMultiLevelPlotfileHeaders</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nlevels</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>level_steps</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref_ratio</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="289" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="289" bodyend="342" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="117" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa5343920d9b5ee1307ca697274eca84a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteSingleLevelPlotfile</definition>
        <argsstring>(const std::string &amp;plotfilename, const MultiFab &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Geometry &amp;geom, Real time, int level_step, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteSingleLevelPlotfile</name>
        <qualifiedname>amrex::WriteSingleLevelPlotfile</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_step</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="345" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="345" bodyend="360" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="75" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4c6d86d16b29791709b2cd18ffdbd7e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_WriteSingleLevelPlotfile</definition>
        <argsstring>(const std::string &amp;plotfilename, const MultiFab &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Geometry &amp;geom, Real time, int level_step, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>EB_WriteSingleLevelPlotfile</name>
        <qualifiedname>amrex::EB_WriteSingleLevelPlotfile</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_step</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="365" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="365" bodyend="380" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="129" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad074a90703857dddefd0c26069f7db65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_WriteMultiLevelPlotfile</definition>
        <argsstring>(const std::string &amp;plotfilename, int nlevels, const Vector&lt; const MultiFab * &gt; &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Vector&lt; Geometry &gt; &amp;geom, Real time, const Vector&lt; int &gt; &amp;level_steps, const Vector&lt; IntVect &gt; &amp;ref_ratio, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>EB_WriteMultiLevelPlotfile</name>
        <qualifiedname>amrex::EB_WriteMultiLevelPlotfile</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nlevels</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>level_steps</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref_ratio</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" line="383" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.cpp" bodystart="383" bodyend="461" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PlotFileUtil.H" declline="140" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4c5b0d23f6faa8769390a5d0d3976f6a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>GrowthStrategy_EnumTraits</type>
        <definition>GrowthStrategy_EnumTraits amrex::amrex_get_enum_traits</definition>
        <argsstring>(GrowthStrategy)</argsstring>
        <name>amrex_get_enum_traits</name>
        <qualifiedname>amrex::amrex_get_enum_traits</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a65ab2bb30531f06fffb874d874125a5a" kindref="member">GrowthStrategy</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PODVector.H" line="250" column="64" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PODVector.H" declline="250" declcolumn="64"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aca9bb3d9f6396c046913fa2cf25799a9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t amrex::grow_podvector_capacity</definition>
        <argsstring>(GrowthStrategy strategy, std::size_t new_size, std::size_t old_capacity, std::size_t sizeof_T)</argsstring>
        <name>grow_podvector_capacity</name>
        <qualifiedname>amrex::grow_podvector_capacity</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a65ab2bb30531f06fffb874d874125a5a" kindref="member">GrowthStrategy</ref></type>
          <declname>strategy</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>new_size</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>old_capacity</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>sizeof_T</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_PODVector.H" line="268" column="24" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_PODVector.H" bodystart="268" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a440ee965188d239d328cb7577a15c42d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, Array&lt; T, 3 &gt; const &amp;a)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; T, 3 &gt; const &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Print.H" line="18" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Print.H" bodystart="18" bodyend="24"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae4bc31a09f2a634f0988666bd0b1271e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename S</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const std::pair&lt; T, S &gt; &amp;v)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const std::pair&lt; T, S &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Print.H" line="27" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Print.H" bodystart="27" bodyend="31"/>
      </memberdef>
      <member refid="group__amrex__utilities_1ga1b2c12e9a133d26ba2bd4b978a95df44" kind="function"><name>InitRandom</name></member>
      <member refid="group__amrex__utilities_1ga6a4ed5dc1eeb3e5b409eb8975c9e829b" kind="function"><name>RandomNormal</name></member>
      <member refid="group__amrex__utilities_1ga384bf7a8791d85fe1ae4153eee61d71e" kind="function"><name>Random</name></member>
      <member refid="group__amrex__utilities_1gaadec079fd8e2cdca36f7f49355e33864" kind="function"><name>RandomPoisson</name></member>
      <member refid="group__amrex__utilities_1gae9fcb4226a23365794ca117f5d901243" kind="function"><name>RandomGamma</name></member>
      <member refid="group__amrex__utilities_1ga20796a80df81ee204983811cc8a1b705" kind="function"><name>Random_int</name></member>
      <member refid="group__amrex__utilities_1ga83b723afb07da54500bc1dc47a43f636" kind="function"><name>Random_long</name></member>
      <member refid="group__amrex__utilities_1gad1b283df95b292f478597bc503170459" kind="function"><name>SaveRandomState</name></member>
      <member refid="group__amrex__utilities_1gae45a9a3a96e46d7b15173894b25134fc" kind="function"><name>RestoreRandomState</name></member>
      <member refid="group__amrex__utilities_1gaa2c1209819cd8dd79499c2b9f088120e" kind="function"><name>UniqueRandomSubset</name></member>
      <member refid="group__amrex__utilities_1ga9c394bace9eaa26498dcec51122b8237" kind="function"><name>ResetRandomSeed</name></member>
      <memberdef kind="function" id="namespaceamrex_1abce0125a244f443854b1c4a2709c5990" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::DeallocateRandomSeedDevArray</definition>
        <argsstring>()</argsstring>
        <name>DeallocateRandomSeedDevArray</name>
        <qualifiedname>amrex::DeallocateRandomSeedDevArray</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Random.cpp" line="218" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Random.cpp" bodystart="218" bodyend="249" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Random.H" declline="303" declcolumn="10"/>
      </memberdef>
      <member refid="group__amrex__utilities_1ga2cd741b1ea369e4c69c1e47048fe4225" kind="function"><name>FillRandom</name></member>
      <member refid="group__amrex__utilities_1ga9edda343dfe7f1dbbd5dcfc2095afac5" kind="function"><name>FillRandomNormal</name></member>
      <member refid="group__amrex__utilities_1gaf64f2a8b22cc7b8e0bedee5a8857b8df" kind="function"><name>Random</name></member>
      <member refid="group__amrex__utilities_1ga26393b18c423500c6a66aafaffce4a50" kind="function"><name>RandomNormal</name></member>
      <member refid="group__amrex__utilities_1ga10238f640123cd4f8c83260abcdbdc6f" kind="function"><name>RandomPoisson</name></member>
      <member refid="group__amrex__utilities_1ga66ae6f2dc9072343a29c633a57914329" kind="function"><name>RandomGamma</name></member>
      <member refid="group__amrex__utilities_1ga54799a781c0eaa0c3201f36a6b929da3" kind="function"><name>Random_int</name></member>
      <memberdef kind="function" id="namespaceamrex_1a4de5a099f5570da78f030ac07043f2b8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespaceamrex_1abbea0a87a768d8f4e8112b9cd673b124" kindref="member">randState_t</ref> *</type>
        <definition>randState_t * amrex::getRandState</definition>
        <argsstring>()</argsstring>
        <name>getRandState</name>
        <qualifiedname>amrex::getRandState</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" line="65" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" bodystart="65" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8d9232e6959ebc50c37cb0224a4dfe1e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structamrex_1_1RandomEngine" kindref="compound">RandomEngine</ref></type>
        <definition>RandomEngine amrex::getInvalidRandomEngine</definition>
        <argsstring>()</argsstring>
        <name>getInvalidRandomEngine</name>
        <qualifiedname>amrex::getInvalidRandomEngine</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" line="86" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RandomEngine.H" bodystart="86" bodyend="92"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1e3af8577a1ee3509e9bd184d2ab575a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;, const RealBox &amp;)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealBox" kindref="compound">RealBox</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Nice ASCII output. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.cpp" line="31" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.cpp" bodystart="32" bodyend="40" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.H" declline="152" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3fa033d5f7e81438c45cc3b5f6af3443" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;, RealBox &amp;)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1RealBox" kindref="compound">RealBox</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Nice ASCII input. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.cpp" line="48" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.cpp" bodystart="48" bodyend="82" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.H" declline="155" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9ad547d6295814fdf857cbec46887092" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::AlmostEqual</definition>
        <argsstring>(const RealBox &amp;box1, const RealBox &amp;box2, Real eps=0.0) noexcept</argsstring>
        <name>AlmostEqual</name>
        <qualifiedname>amrex::AlmostEqual</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealBox" kindref="compound">RealBox</ref> &amp;</type>
          <declname>box1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealBox" kindref="compound">RealBox</ref> &amp;</type>
          <declname>box2</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>eps</declname>
        </param>
        <briefdescription>
<para>Check for equality of real boxes within a certain tolerance. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.cpp" line="84" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.cpp" bodystart="84" bodyend="97" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealBox.H" declline="158" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a709ef39322d8b0d31ab1e58022109335" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsConvertible_v&lt; Real, Args... &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__</type>
        <definition>__host__ __device__ amrex::RealVectND</definition>
        <argsstring>(Real, Real, Args...) -&gt; RealVectND&lt; sizeof...(Args)+2 &gt;</argsstring>
        <name>RealVectND</name>
        <qualifiedname>amrex::RealVectND</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
        </param>
        <param>
          <type>Args...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="602" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" declline="602" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae0523d865efae22d3cdca72c35798a4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__</type>
        <definition>__host__ __device__ amrex::RealVectND</definition>
        <argsstring>(const IntVectND&lt; dim &gt; &amp;) -&gt; RealVectND&lt; dim &gt;</argsstring>
        <name>RealVectND</name>
        <qualifiedname>amrex::RealVectND</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1IntVectND" kindref="compound">IntVectND</ref>&lt; dim &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="607" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" declline="607" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9524db1799cdcd7a1ef97f21c7813aa6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__</type>
        <definition>__host__ __device__ amrex::RealVectND</definition>
        <argsstring>(const GpuArray&lt; Real, dim &gt; &amp;) -&gt; RealVectND&lt; dim &gt;</argsstring>
        <name>RealVectND</name>
        <qualifiedname>amrex::RealVectND</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1GpuArray" kindref="compound">GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref>, dim &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="612" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" declline="612" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5aa6b51a44ebd61bb50280f5664492d3" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::min</definition>
        <argsstring>(const RealVectND&lt; dim &gt; &amp;p1, const RealVectND&lt; dim &gt; &amp;p2) noexcept</argsstring>
        <name>min</name>
        <qualifiedname>amrex::min</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> that is the component-wise minimum of two argument RealVectNDs. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="825" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="825" bodyend="828"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a782e94e89c797a500f569289c9e49658" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::max</definition>
        <argsstring>(const RealVectND&lt; dim &gt; &amp;p1, const RealVectND&lt; dim &gt; &amp;p2) noexcept</argsstring>
        <name>max</name>
        <qualifiedname>amrex::max</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p1</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt; &amp;</type>
          <declname>p2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref> that is the component-wise maximum of two argument RealVectNDs. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="836" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="836" bodyend="839"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5dd2e4543d49f17274e278e5da8e07dd" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>dim</declname>
            <defname>dim</defname>
            <defval>3</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="classamrex_1_1RealVectND" kindref="compound">RealVectND</ref>&lt; dim &gt;</type>
        <definition>__host__ __device__ RealVectND&lt; dim &gt; amrex::BASISREALV</definition>
        <argsstring>(int dir) noexcept</argsstring>
        <name>BASISREALV</name>
        <qualifiedname>amrex::BASISREALV</qualifiedname>
        <param>
          <type>int</type>
          <declname>dir</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a basis vector in the given coordinate direction.<linebreak/>
 In 2-D:<linebreak/>
 BASISREALV(0) == (1.,0.); BASISREALV(1) == (0.,1.).<linebreak/>
 In 3-D:<linebreak/>
 BASISREALV(0) == (1.,0.,0.); BASISREALV(1) == (0.,1.,0.); BASISREALV(2) == (0.,0.,1.).<linebreak/>
 Note that the coordinate directions are based at zero. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" line="1008" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_RealVect.H" bodystart="1008" bodyend="1013"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4a88cd9eeb3fb0f6a9a8e4a95fb1c82c" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ps</declname>
            <defname>Ps</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; Ts... &gt; amrex::IdentityTuple</definition>
        <argsstring>(GpuTuple&lt; Ts... &gt;, ReduceOps&lt; Ps... &gt;) noexcept</argsstring>
        <name>IdentityTuple</name>
        <qualifiedname>amrex::IdentityTuple</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt;</type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref>&lt; Ps... &gt;</type>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> containing the identity element for each operation in <ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref>. For example 0, +inf and -inf for <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref> and <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref> respectively. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="1324" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="1324" bodyend="1329"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4df3450411e989f3d435c6739551a02a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ps</declname>
            <defname>Ps</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; Ts... &gt; amrex::IdentityTuple</definition>
        <argsstring>(GpuTuple&lt; Ts... &gt;, TypeList&lt; Ps... &gt;) noexcept</argsstring>
        <name>IdentityTuple</name>
        <qualifiedname>amrex::IdentityTuple</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt;</type>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ps... &gt;</type>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> containing the identity element for each ReduceOp in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>. For example 0, +inf and -inf for <ref refid="structamrex_1_1ReduceOpSum" kindref="compound">ReduceOpSum</ref>, <ref refid="structamrex_1_1ReduceOpMin" kindref="compound">ReduceOpMin</ref> and <ref refid="structamrex_1_1ReduceOpMax" kindref="compound">ReduceOpMax</ref> respectively. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" line="1338" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Reduce.H" bodystart="1338" bodyend="1343"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afff6d654eb78395e3e23d8d4dc0fc2de" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class U</type>
          </param>
          <param>
            <type>class V</type>
          </param>
          <param>
            <type>int</type>
            <declname>N1</declname>
            <defname>N1</defname>
          </param>
          <param>
            <type>int</type>
            <declname>N2</declname>
            <defname>N2</defname>
          </param>
          <param>
            <type>int</type>
            <declname>N3</declname>
            <defname>N3</defname>
          </param>
          <param>
            <type>Order</type>
            <declname>Ord</declname>
            <defname>Ord</defname>
          </param>
          <param>
            <type>int</type>
            <declname>SI</declname>
            <defname>SI</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ decltype(auto)</type>
        <definition>__host__ __device__ decltype(auto) amrex::operator*</definition>
        <argsstring>(SmallMatrix&lt; U, N1, N2, Ord, SI &gt; const &amp;lhs, SmallMatrix&lt; V, N2, N3, Ord, SI &gt; const &amp;rhs)</argsstring>
        <name>operator*</name>
        <qualifiedname>amrex::operator*</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1SmallMatrix" kindref="compound">SmallMatrix</ref>&lt; U, N1, N2, Ord, SI &gt; const &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1SmallMatrix" kindref="compound">SmallMatrix</ref>&lt; V, N2, N3, Ord, SI &gt; const &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SmallMatrix.H" line="414" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SmallMatrix.H" bodystart="414" bodyend="446"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7417ff6f05d4e8c47a7ceda2336a2472" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>int</type>
            <declname>NRows</declname>
            <defname>NRows</defname>
          </param>
          <param>
            <type>int</type>
            <declname>NCols</declname>
            <defname>NCols</defname>
          </param>
          <param>
            <type>Order</type>
            <declname>ORDER</declname>
            <defname>ORDER</defname>
          </param>
          <param>
            <type>int</type>
            <declname>SI</declname>
            <defname>SI</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, SmallMatrix&lt; T, NRows, NCols, ORDER, SI &gt; const &amp;mat)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1SmallMatrix" kindref="compound">SmallMatrix</ref>&lt; T, NRows, NCols, ORDER, SI &gt; const &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_SmallMatrix.H" line="449" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_SmallMatrix.H" bodystart="449" bodyend="460"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a67bf98d88c814ab458018afd16e64aa8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::toLower</definition>
        <argsstring>(std::string s)</argsstring>
        <name>toLower</name>
        <qualifiedname>amrex::toLower</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Converts all characters of the string into lower case based on std::locale. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" line="11" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" bodystart="11" bodyend="16" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.H" declline="11" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afb53573f5330e4753ad1b562e5dd95ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::toUpper</definition>
        <argsstring>(std::string s)</argsstring>
        <name>toUpper</name>
        <qualifiedname>amrex::toUpper</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>Converts all characters of the string into uppercase based on std::locale. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" line="18" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" bodystart="18" bodyend="23" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.H" declline="14" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3171bdd61dc2e905052d3396dcc93970" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::trim</definition>
        <argsstring>(std::string s, std::string const &amp;space)</argsstring>
        <name>trim</name>
        <qualifiedname>amrex::trim</qualifiedname>
        <param>
          <type>std::string</type>
          <declname>s</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>space</declname>
          <defval>&quot; \t&quot;</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Trim leading and trailing characters in the optional <computeroutput>space</computeroutput> argument. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" line="25" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" bodystart="25" bodyend="32" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.H" declline="18" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6e3a82e54e91d8c7543596b2c2476250" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::Concatenate</definition>
        <argsstring>(const std::string &amp;root, int num, int mindigits=5)</argsstring>
        <name>Concatenate</name>
        <qualifiedname>amrex::Concatenate</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>root</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num</declname>
        </param>
        <param>
          <type>int</type>
          <declname>mindigits</declname>
        </param>
        <briefdescription>
<para>Returns rootNNNN where NNNN == num. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" line="34" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" bodystart="34" bodyend="40" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.H" declline="21" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae905d147b84a78af7a2ccf7620bdf9b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt; std::string &gt; amrex::split</definition>
        <argsstring>(std::string const  &amp;s, std::string const  &amp;sep=&quot; \t&quot;)</argsstring>
        <name>split</name>
        <qualifiedname>amrex::split</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>sep</declname>
        </param>
        <briefdescription>
<para>Split a string using given tokens in <computeroutput>sep</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" line="42" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" bodystart="42" bodyend="52" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.H" declline="26" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a08767170498c8b365b7bd3513eb8aa77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::join</definition>
        <argsstring>(std::vector&lt; std::string &gt; const  &amp;sv, char sep)</argsstring>
        <name>join</name>
        <qualifiedname>amrex::join</qualifiedname>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>sv</declname>
        </param>
        <param>
          <type>char</type>
          <declname>sep</declname>
        </param>
        <briefdescription>
<para>Join a vector of strings with given char <computeroutput>sep</computeroutput> as delimiter. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" line="54" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" bodystart="54" bodyend="64" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.H" declline="30" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6e0cbbd3fb4987dd09b925b6941edcee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::join</definition>
        <argsstring>(std::vector&lt; std::string &gt; const  &amp;sv)</argsstring>
        <name>join</name>
        <qualifiedname>amrex::join</qualifiedname>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>sv</declname>
        </param>
        <briefdescription>
<para>Join a vector of strings without delimiter. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" line="66" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.cpp" bodystart="66" bodyend="73" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_String.H" declline="33" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad50999ff4045032bb705d04f7195b33c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class TagType</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_same_v&lt; std::decay_t&lt; decltype(std::declval&lt; TagType &gt;().box())&gt;, <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &gt;</type>
        <definition>std::enable_if_t&lt; std::is_same_v&lt; std::decay_t&lt; decltype(std::declval&lt; TagType &gt;().box())&gt;, Box &gt; amrex::ParallelFor</definition>
        <argsstring>(TagVector&lt; TagType &gt; const &amp;tv, int ncomp, F const &amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TagVector" kindref="compound">TagVector</ref>&lt; TagType &gt; const &amp;</type>
          <declname>tv</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TagParallelFor.H" line="438" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TagParallelFor.H" bodystart="438" bodyend="450"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a38eb255b13ee7ed203faecd6e21b7a79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(TagVector&lt; TagType &gt; const &amp;tv, F const &amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TagVector" kindref="compound">TagVector</ref>&lt; TagType &gt; const &amp;</type>
          <declname>tv</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TagParallelFor.H" line="454" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TagParallelFor.H" bodystart="454" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a45d9629bed7f5dd24034bd8345c128f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class TagType</type>
          </param>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_same_v&lt; std::decay_t&lt; decltype(std::declval&lt; TagType &gt;().box())&gt;, <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &gt;</type>
        <definition>std::enable_if_t&lt; std::is_same_v&lt; std::decay_t&lt; decltype(std::declval&lt; TagType &gt;().box())&gt;, Box &gt; amrex::ParallelFor</definition>
        <argsstring>(Vector&lt; TagType &gt; const &amp;tags, int ncomp, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; TagType &gt; const &amp;</type>
          <declname>tags</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TagParallelFor.H" line="482" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TagParallelFor.H" bodystart="482" bodyend="486"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8743466d78a7e4458271e4a297723573" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ParallelFor</definition>
        <argsstring>(Vector&lt; TagType &gt; const &amp;tags, F &amp;&amp;f)</argsstring>
        <name>ParallelFor</name>
        <qualifiedname>amrex::ParallelFor</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; TagType &gt; const &amp;</type>
          <declname>tags</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TagParallelFor.H" line="490" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TagParallelFor.H" bodystart="490" bodyend="494"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a214a7623a47d937b69264130556a6434" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="structamrex_1_1GpuTupleElement" kindref="compound">GpuTupleElement</ref>&lt; I, <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt; &gt;::type &amp;</type>
        <definition>__host__ __device__ constexpr GpuTupleElement&lt; I, GpuTuple&lt; Ts... &gt; &gt;::type &amp; amrex::get</definition>
        <argsstring>(GpuTuple&lt; Ts... &gt; &amp;tup) noexcept</argsstring>
        <name>get</name>
        <qualifiedname>amrex::get</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt; &amp;</type>
          <declname>tup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="186" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="186" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa54e2f7df29ce36a0fdf114d1b81614b" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="structamrex_1_1GpuTupleElement" kindref="compound">GpuTupleElement</ref>&lt; I, <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt; &gt;::type const &amp;</type>
        <definition>__host__ __device__ constexpr GpuTupleElement&lt; I, GpuTuple&lt; Ts... &gt; &gt;::type const  &amp; amrex::get</definition>
        <argsstring>(GpuTuple&lt; Ts... &gt; const &amp;tup) noexcept</argsstring>
        <name>get</name>
        <qualifiedname>amrex::get</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt; const &amp;</type>
          <declname>tup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="195" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="195" bodyend="198"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad4d56a4ba3ec21a45a129895b9db06ee" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="structamrex_1_1GpuTupleElement" kindref="compound">GpuTupleElement</ref>&lt; I, <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt; &gt;::type &amp;&amp;</type>
        <definition>__host__ __device__ constexpr GpuTupleElement&lt; I, GpuTuple&lt; Ts... &gt; &gt;::type &amp;&amp; amrex::get</definition>
        <argsstring>(GpuTuple&lt; Ts... &gt; &amp;&amp;tup) noexcept</argsstring>
        <name>get</name>
        <qualifiedname>amrex::get</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt; &amp;&amp;</type>
          <declname>tup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="204" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="204" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1da6f37dc0e166f794600bfb19a19823" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; detail::tuple_decay_t&lt; Ts &gt;... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; detail::tuple_decay_t&lt; Ts &gt;... &gt; amrex::makeTuple</definition>
        <argsstring>(Ts &amp;&amp;... args)</argsstring>
        <name>makeTuple</name>
        <qualifiedname>amrex::makeTuple</qualifiedname>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="263" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="263" bodyend="266"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af4a251de1f235d3d25f0894e7fad63aa" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TP</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr auto</type>
        <definition>__host__ __device__ constexpr auto amrex::TupleCat</definition>
        <argsstring>(TP &amp;&amp;a) -&gt; typename detail::tuple_cat_result&lt; detail::tuple_decay_t&lt; TP &gt; &gt;::type</argsstring>
        <name>TupleCat</name>
        <qualifiedname>amrex::TupleCat</qualifiedname>
        <param>
          <type>TP &amp;&amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="299" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="299" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa6358b973b8dbea161ea896413332b83" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TP1</type>
          </param>
          <param>
            <type>typename TP2</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr auto</type>
        <definition>__host__ __device__ constexpr auto amrex::TupleCat</definition>
        <argsstring>(TP1 &amp;&amp;a, TP2 &amp;&amp;b) -&gt; typename detail::tuple_cat_result&lt; detail::tuple_decay_t&lt; TP1 &gt;, detail::tuple_decay_t&lt; TP2 &gt; &gt;::type</argsstring>
        <name>TupleCat</name>
        <qualifiedname>amrex::TupleCat</qualifiedname>
        <param>
          <type>TP1 &amp;&amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>TP2 &amp;&amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="308" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="308" bodyend="317"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4c4d09ce368d97d258dff4f23e5eff58" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TP1</type>
          </param>
          <param>
            <type>typename TP2</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>TPs</declname>
            <defname>TPs</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr auto</type>
        <definition>__host__ __device__ constexpr auto amrex::TupleCat</definition>
        <argsstring>(TP1 &amp;&amp;a, TP2 &amp;&amp;b, TPs &amp;&amp;... args) -&gt; typename detail::tuple_cat_result&lt; detail::tuple_decay_t&lt; TP1 &gt;, detail::tuple_decay_t&lt; TP2 &gt;, detail::tuple_decay_t&lt; TPs &gt;... &gt;::type</argsstring>
        <name>TupleCat</name>
        <qualifiedname>amrex::TupleCat</qualifiedname>
        <param>
          <type>TP1 &amp;&amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>TP2 &amp;&amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type>TPs &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="322" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="322" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a40e0e9f52f5d59f92a96a4f90f9da734" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::size_t...</type>
            <declname>Is</declname>
            <defname>Is</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr auto</type>
        <definition>__host__ __device__ constexpr auto amrex::TupleSplit</definition>
        <argsstring>(const GpuTuple&lt; Args... &gt; &amp;tup) noexcept</argsstring>
        <name>TupleSplit</name>
        <qualifiedname>amrex::TupleSplit</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Args... &gt; &amp;</type>
          <declname>tup</declname>
        </param>
        <briefdescription>
<para>Returns a <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> of GpuTuples obtained by splitting the input <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> according to the sizes specified by the template arguments. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="387" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="387" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1878092eaf0c6569549826c181ef7b99" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename TP</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr auto</type>
        <definition>__host__ __device__ constexpr auto amrex::Apply</definition>
        <argsstring>(F &amp;&amp;f, TP &amp;&amp;t) -&gt; typename detail::apply_result&lt; F, detail::tuple_decay_t&lt; TP &gt; &gt;::type</argsstring>
        <name>Apply</name>
        <qualifiedname>amrex::Apply</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>TP &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="437" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="437" bodyend="441"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1aa203b40eab3382c762f2c558a26d00" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Args &amp;... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; Args &amp;... &gt; amrex::Tie</definition>
        <argsstring>(Args &amp;... args) noexcept</argsstring>
        <name>Tie</name>
        <qualifiedname>amrex::Tie</qualifiedname>
        <param>
          <type>Args &amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="448" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="448" bodyend="451"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a431b392c38d2857a8de0afe403834527" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts &amp;&amp;... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; Ts &amp;&amp;... &gt; amrex::ForwardAsTuple</definition>
        <argsstring>(Ts &amp;&amp;... args) noexcept</argsstring>
        <name>ForwardAsTuple</name>
        <qualifiedname>amrex::ForwardAsTuple</qualifiedname>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="458" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="458" bodyend="461"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a051e1fc6b4a04296a3a3a76e720b451e" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt;</type>
        <definition>__host__ __device__ constexpr GpuTuple&lt; Ts... &gt; amrex::MakeZeroTuple</definition>
        <argsstring>(GpuTuple&lt; Ts... &gt;) noexcept</argsstring>
        <name>MakeZeroTuple</name>
        <qualifiedname>amrex::MakeZeroTuple</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; Ts... &gt;</type>
        </param>
        <briefdescription>
<para>Return a <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> containing all zeros. Note that a default-constructed <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> can have uninitialized values. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="472" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="472" bodyend="475"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aabd9e2f1b8b5cb8db6c0342fbf626eef" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr auto</type>
        <definition>__host__ __device__ constexpr auto amrex::tupleToArray</definition>
        <argsstring>(GpuTuple&lt; T &gt; const &amp;tup)</argsstring>
        <name>tupleToArray</name>
        <qualifiedname>amrex::tupleToArray</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; T &gt; const &amp;</type>
          <declname>tup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="489" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="489" bodyend="492"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afcbe9cacf5d5df3fb9731ce2c3f378b7" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; Same&lt; T, T2, Ts... &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>__host__ __device__ constexpr auto</type>
        <definition>__host__ __device__ constexpr auto amrex::tupleToArray</definition>
        <argsstring>(GpuTuple&lt; T, T2, Ts... &gt; const &amp;tup)</argsstring>
        <name>tupleToArray</name>
        <qualifiedname>amrex::tupleToArray</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref>&lt; T, T2, Ts... &gt; const &amp;</type>
          <declname>tup</declname>
        </param>
        <briefdescription>
<para>Convert GpuTuple&lt;T,T2,Ts...&gt; to <ref refid="structamrex_1_1GpuArray" kindref="compound">GpuArray</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" line="497" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Tuple.H" bodystart="497" bodyend="500"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aca65f803ae9e0c199552d38482b6dbdc" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>constexpr void</type>
        <definition>constexpr void amrex::ForEach</definition>
        <argsstring>(TypeList&lt; Ts... &gt;, F &amp;&amp;f)</argsstring>
        <name>ForEach</name>
        <qualifiedname>amrex::ForEach</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ts... &gt;</type>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>For each type t in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>, call f(t) </para>
        </briefdescription>
        <detaileddescription>
<para>For example, instead of <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(order<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>interp&lt;1&gt;(...);</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(order<sp/>==<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>interp&lt;2&gt;(...);</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(order<sp/>==<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>interp&lt;4&gt;(...);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> we could have <programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceamrex_1aca65f803ae9e0c199552d38482b6dbdc" kindref="member">ForEach</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt;std::integral_constant&lt;int,1&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::integral_constant&lt;int,2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::integral_constant&lt;int,4&gt;&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[&amp;]<sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>order_const)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(order_const()<sp/>==<sp/>order)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>interp&lt;order_const()&gt;(...);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" line="82" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" bodystart="82" bodyend="86"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad482086094efe1bf5748ee81c759d86e" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool amrex::ForEachUntil</definition>
        <argsstring>(TypeList&lt; Ts... &gt;, F &amp;&amp;f)</argsstring>
        <name>ForEachUntil</name>
        <qualifiedname>amrex::ForEachUntil</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ts... &gt;</type>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>For each type t in <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>, call f(t) until true is returned. </para>
        </briefdescription>
        <detaileddescription>
<para>This behaves like return (f(t0) || f(t1) || f(t2) || ...). Note that shor-circuting occurs for the || operators.</para>
<para>An example, <programlisting filename=".cpp"><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AnyF<sp/>(<ref refid="classamrex_1_1Any" kindref="compound">Any</ref>&amp;<sp/>dst,<sp/><ref refid="classamrex_1_1Any" kindref="compound">Any</ref><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>src)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>dst<sp/>and<sp/>src<sp/>are<sp/>either<sp/>MultiFab<sp/>or<sp/>fMultiFab</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>tt<sp/>=<sp/><ref refid="namespaceamrex_1a9d736b217af3b87bef2bffd4dd55edff" kindref="member">CartesianProduct</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList&lt;MultiFab,fMultiFab&gt;</ref>{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TypeList&lt;MultiFab,fMultiFab&gt;{});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>r<sp/>=<sp/><ref refid="namespaceamrex_1ad482086094efe1bf5748ee81c759d86e" kindref="member">ForEachUntil</ref>(tt,<sp/>[&amp;]<sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>t)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">MF0<sp/>=<sp/><ref refid="namespaceamrex_1a11fcc5e72789252d6182a7d15233725f" kindref="member">TypeAt</ref>&lt;0,</highlight><highlight class="keyword">decltype</highlight><highlight class="normal">(t)&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">MF1<sp/>=<sp/><ref refid="namespaceamrex_1a11fcc5e72789252d6182a7d15233725f" kindref="member">TypeAt</ref>&lt;1,</highlight><highlight class="keyword">decltype</highlight><highlight class="normal">(t)&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(dst.<ref refid="classamrex_1_1Any_1a6756f5c90f3bab7334449702da7ae003" kindref="member">is</ref>&lt;MF0&gt;()<sp/>&amp;&amp;<sp/>src.<ref refid="classamrex_1_1Any_1a6756f5c90f3bab7334449702da7ae003" kindref="member">is</ref>&lt;MF1&gt;())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MF0<sp/><sp/><sp/><sp/><sp/><sp/>&amp;<sp/>dmf<sp/>=<sp/>dst.<ref refid="classamrex_1_1Any_1aec65884a36085f19e3f957fcf78d2c17" kindref="member">get</ref>&lt;MF0&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MF1<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>smf<sp/>=<sp/>src.<ref refid="classamrex_1_1Any_1aec65884a36085f19e3f957fcf78d2c17" kindref="member">get</ref>&lt;MF1&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f(dmf,<sp/>smf);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!r)<sp/>{<sp/><ref refid="namespaceamrex_1ad26f2328bf66aa9678347a6055a25431" kindref="member">amrex::Abort</ref>(</highlight><highlight class="stringliteral">&quot;Unsupported<sp/>types&quot;</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" line="119" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" bodystart="119" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a71e196fc8e75b8176182de8d994ff62a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>As</declname>
            <defname>As</defname>
          </param>
          <param>
            <type>typename...</type>
            <declname>Bs</declname>
            <defname>Bs</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto amrex::operator+</definition>
        <argsstring>(TypeList&lt; As... &gt;, TypeList&lt; Bs... &gt;)</argsstring>
        <name>operator+</name>
        <qualifiedname>amrex::operator+</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; As... &gt;</type>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Bs... &gt;</type>
        </param>
        <briefdescription>
<para>Concatenate two TypeLists. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" line="127" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" bodystart="127" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aad1bedfbf5b00ed85060a201b5e19ffb" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ls</declname>
            <defname>Ls</defname>
          </param>
          <param>
            <type>typename A</type>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto amrex::single_product</definition>
        <argsstring>(TypeList&lt; Ls... &gt;, A)</argsstring>
        <name>single_product</name>
        <qualifiedname>amrex::single_product</qualifiedname>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; Ls... &gt;</type>
        </param>
        <param>
          <type>A</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" line="132" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" bodystart="132" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a79754df2fe2ff8642af6d3a015518866" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename LLs</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>As</declname>
            <defname>As</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto amrex::operator*</definition>
        <argsstring>(LLs, TypeList&lt; As... &gt;)</argsstring>
        <name>operator*</name>
        <qualifiedname>amrex::operator*</qualifiedname>
        <param>
          <type>LLs</type>
        </param>
        <param>
          <type><ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt; As... &gt;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" line="137" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" bodystart="137" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9d736b217af3b87bef2bffd4dd55edff" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Ls</declname>
            <defname>Ls</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto amrex::CartesianProduct</definition>
        <argsstring>(Ls...)</argsstring>
        <name>CartesianProduct</name>
        <qualifiedname>amrex::CartesianProduct</qualifiedname>
        <param>
          <type>Ls...</type>
        </param>
        <briefdescription>
<para>Cartesian Product of TypeLists. </para>
        </briefdescription>
        <detaileddescription>
<para>For example, <programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="namespaceamrex_1a9d736b217af3b87bef2bffd4dd55edff" kindref="member">CartesianProduct</ref>(<ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref>&lt;std::integral_constant&lt;int,0&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::integral_constant&lt;int,1&gt;&gt;{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TypeList&lt;std::integral_constant&lt;int,2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::integral_constant&lt;int,3&gt;&gt;{});</highlight></codeline>
</programlisting> returns <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref> of <ref refid="structamrex_1_1TypeList" kindref="compound">TypeList</ref> of integral_constants {{0,2},{1,2},{0,3},{1,3}}. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" line="154" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_TypeList.H" bodystart="154" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a107cab62d5043f039671cf5b68068ddc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::is_integer</definition>
        <argsstring>(const char *str)</argsstring>
        <name>is_integer</name>
        <qualifiedname>amrex::is_integer</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>Useful C++ Utility Functions. </para>
        </briefdescription>
        <detaileddescription>
<para>Return true if argument is a non-zero length string of digits. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="44" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="35" bodyend="49" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="44" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5d64ce961cc190a21d99afb216b879d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::is_it</definition>
        <argsstring>(std::string const &amp;s, T &amp;v)</argsstring>
        <name>is_it</name>
        <qualifiedname>amrex::is_it</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>s</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Return true and store value in v if string s is type T. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="47" column="22" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="260" bodyend="270" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="47" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6ba24cf7211301279ca446ff282a0f8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const std::vector&lt; std::string &gt; &amp;</type>
        <definition>const std::vector&lt; std::string &gt; &amp; amrex::Tokenize</definition>
        <argsstring>(const std::string &amp;instr, const std::string &amp;separators)</argsstring>
        <name>Tokenize</name>
        <qualifiedname>amrex::Tokenize</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>instr</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>separators</declname>
        </param>
        <briefdescription>
<para>Splits &quot;instr&quot; into separate pieces based on &quot;separators&quot;. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="50" column="23" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="61" bodyend="113" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="50" declcolumn="23"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a913fd7ccf7cab45bc7d8e2a09ddd2824" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::UtilCreateDirectory</definition>
        <argsstring>(const std::string &amp;path, mode_t mode, bool verbose=false)</argsstring>
        <name>UtilCreateDirectory</name>
        <qualifiedname>amrex::UtilCreateDirectory</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>path</declname>
        </param>
        <param>
          <type>mode_t</type>
          <declname>mode</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>verbose</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Creates the specified directories. path may be either a full pathname or a relative pathname. It will create all the directories in the pathname, if they don&apos;t already exist, so that on successful return the pathname refers to an existing directory. Returns true or false depending upon whether or not it was successful. Also returns true if path is NULL or &quot;/&quot;. mode is the mode passed to mkdir() for any directories that must be created (for example: 0755). verbose will print out the directory creation steps. </para>
        </briefdescription>
        <detaileddescription>
<para>For example, if it is passed the string &quot;/a/b/c/d/e/f/g&quot;, it will return successfully when all the directories in the pathname exist; i.e. when the full pathname is a valid directory.</para>
<para>In a Windows environment, the path separator is a &apos;\&apos;, so that if using the example given above you must pass the string &quot;\\a\\b\\c\\d\\e\\f\\g&quot; (Note that you must escape the backslash in a character string),</para>
<para>Only the last mkdir return value is checked for success as errno may not be set to EEXIST if a directory exists but mkdir has other reasons to fail such as part of the path being a read-only filesystem (EROFS). If this function fails, it will print out an error stack. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="77" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="116" bodyend="126" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="77" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a894a812531d6362ce4ac5065c3224699" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::CreateDirectoryFailed</definition>
        <argsstring>(const std::string &amp;dir)</argsstring>
        <name>CreateDirectoryFailed</name>
        <qualifiedname>amrex::CreateDirectoryFailed</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>dir</declname>
        </param>
        <briefdescription>
<para>Output a message and abort when couldn&apos;t create the directory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="81" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="129" bodyend="134" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="81" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0dc9fca5d8d1322524d13793f5b663d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::FileOpenFailed</definition>
        <argsstring>(const std::string &amp;file)</argsstring>
        <name>FileOpenFailed</name>
        <qualifiedname>amrex::FileOpenFailed</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>file</declname>
        </param>
        <briefdescription>
<para>Output a message and abort when couldn&apos;t open the file. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="83" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="137" bodyend="142" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="83" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a51791a9a04ee140c71cee50d3615ed35" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool amrex::FileExists</definition>
        <argsstring>(const std::string &amp;filename)</argsstring>
        <name>FileExists</name>
        <qualifiedname>amrex::FileExists</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>filename</declname>
        </param>
        <briefdescription>
<para>Check if a file already exists. Return true if the filename is an existing file, directory, or link. For links, this operates on the link and not what the link points to. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="90" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="145" bodyend="148" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="90" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aebee05e08302fb03e29f4270e933239c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string amrex::UniqueString</definition>
        <argsstring>()</argsstring>
        <name>UniqueString</name>
        <qualifiedname>amrex::UniqueString</qualifiedname>
        <briefdescription>
<para>Create a (probably) unique string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="92" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="151" bodyend="164" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="92" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a832f4ad883cbc470d76cde70a099e912" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::UtilCreateCleanDirectory</definition>
        <argsstring>(const std::string &amp;path, bool callbarrier=true)</argsstring>
        <name>UtilCreateCleanDirectory</name>
        <qualifiedname>amrex::UtilCreateCleanDirectory</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>path</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>callbarrier</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Create a new directory, renaming the old one if it exists. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="94" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="167" bodyend="192" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="94" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aebce007d4152715af0cf44f3ab94d1fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::UtilCreateDirectoryDestructive</definition>
        <argsstring>(const std::string &amp;path, bool callbarrier=true)</argsstring>
        <name>UtilCreateDirectoryDestructive</name>
        <qualifiedname>amrex::UtilCreateDirectoryDestructive</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>path</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>callbarrier</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Create a new directory, removing old one if it exists. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="98" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="196" bodyend="219" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="98" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae2d0c6a2a5153df0d38d7cde07a89c73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::UtilRenameDirectoryToOld</definition>
        <argsstring>(const std::string &amp;path, bool callbarrier=true)</argsstring>
        <name>UtilRenameDirectoryToOld</name>
        <qualifiedname>amrex::UtilRenameDirectoryToOld</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>path</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>callbarrier</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Rename a current directory if it exists. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="102" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="222" bodyend="244" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="102" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afe890be0bd82650235456eabcf50e309" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::OutOfMemory</definition>
        <argsstring>()</argsstring>
        <name>OutOfMemory</name>
        <qualifiedname>amrex::OutOfMemory</qualifiedname>
        <briefdescription>
<para>Aborts after printing message indicating out-of-memory; i.e. operator new has failed. This is the &quot;supported&quot; set_new_handler() function for <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> applications. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="109" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="247" bodyend="250" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="109" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aeb571560dc9f12004d96e105ab1137e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double amrex::InvNormDist</definition>
        <argsstring>(double p)</argsstring>
        <name>InvNormDist</name>
        <qualifiedname>amrex::InvNormDist</qualifiedname>
        <param>
          <type>double</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>This function returns an approximation of the inverse cumulative standard normal distribution function. I.e., given P, it returns an approximation to the X satisfying P = Pr{Z &lt;= X} where Z is a random variable from the standard normal distribution. </para>
        </briefdescription>
        <detaileddescription>
<para>The algorithm uses a minimax approximation by rational functions and the result has a relative error whose absolute value is less than 1.15e-9.</para>
<para><simplesect kind="author"><para>Peter J. Acklam Time-stamp: 2002-06-09 18:45:44 +0200 E-mail: <ulink url="mailto:jacklam@math.uio.no">jacklam@math.uio.no</ulink> WWW URL: <ulink url="http://www.math.uio.no/~jacklam">http://www.math.uio.no/~jacklam</ulink></para>
</simplesect>
&quot;p&quot; MUST be in the open interval (0,1). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="127" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="287" bodyend="367" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="127" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0dace3a79fc48a8b02686c10363b70a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double amrex::InvNormDistBest</definition>
        <argsstring>(double p)</argsstring>
        <name>InvNormDistBest</name>
        <qualifiedname>amrex::InvNormDistBest</qualifiedname>
        <param>
          <type>double</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>This function returns an approximation of the inverse cumulative standard normal distribution function. I.e., given P, it returns an approximation to the X satisfying P = Pr{Z &lt;= X} where Z is a random variable from the standard normal distribution. </para>
        </briefdescription>
        <detaileddescription>
<para>Original FORTRAN77 version by Michael Wichura.</para>
<para>Michael Wichura, The Percentage Points of the Normal Distribution, Algorithm AS 241, Applied Statistics, Volume 37, Number 3, pages 477-484, 1988.</para>
<para>Our version is based on the C++ version by John Burkardt.</para>
<para>The algorithm uses a minimax approximation by rational functions and the result is good to roughly machine precision. This routine is roughly 30% more costly than <ref refid="namespaceamrex_1aeb571560dc9f12004d96e105ab1137e9" kindref="member">InvNormDist()</ref> above.</para>
<para>&quot;p&quot; MUST be in the open interval (0,1). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="150" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="408" bodyend="521" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="150" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a15ea4e09dbb2ff1919ec42ea7702d5aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int amrex::CRRBetweenLevels</definition>
        <argsstring>(int fromlevel, int tolevel, const Vector&lt; int &gt; &amp;refratios)</argsstring>
        <name>CRRBetweenLevels</name>
        <qualifiedname>amrex::CRRBetweenLevels</qualifiedname>
        <param>
          <type>int</type>
          <declname>fromlevel</declname>
        </param>
        <param>
          <type>int</type>
          <declname>tolevel</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>refratios</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="153" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="253" bodyend="264" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="153" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aff6b4420435f9951710a37eda411db8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;, const expect &amp;exp)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <defname>is</defname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1expect" kindref="compound">expect</ref> &amp;</type>
          <declname>exp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="157" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="528" bodyend="550" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="157" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac55f6d6246ea70d74588e5f06fd92e99" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; char &gt;</type>
        <definition>amrex::Vector&lt; char &gt; amrex::SerializeStringArray</definition>
        <argsstring>(const Vector&lt; std::string &gt; &amp;stringArray)</argsstring>
        <name>SerializeStringArray</name>
        <qualifiedname>amrex::SerializeStringArray</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>stringArray</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="192" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="857" bodyend="869" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="192" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a23045f55caabc0bec388518c4c4adecb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt;</type>
        <definition>amrex::Vector&lt; std::string &gt; amrex::UnSerializeStringArray</definition>
        <argsstring>(const Vector&lt; char &gt; &amp;charArray)</argsstring>
        <name>UnSerializeStringArray</name>
        <qualifiedname>amrex::UnSerializeStringArray</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; char &gt; &amp;</type>
          <declname>charArray</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="193" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="871" bodyend="884" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="193" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a09ef310468cc24552cfc73abfc282b72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::SyncStrings</definition>
        <argsstring>(const Vector&lt; std::string &gt; &amp;localStrings, Vector&lt; std::string &gt; &amp;syncedStrings, bool &amp;alreadySynced)</argsstring>
        <name>SyncStrings</name>
        <qualifiedname>amrex::SyncStrings</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>localStrings</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>syncedStrings</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>alreadySynced</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="194" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="695" bodyend="855" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="194" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a47858cf7af589491140828d44dca8737" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">amrex::Long</ref></type>
        <definition>amrex::Long amrex::bytesOf</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;v)</argsstring>
        <name>bytesOf</name>
        <qualifiedname>amrex::bytesOf</qualifiedname>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="205" column="29" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="355" bodyend="358" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="205" declcolumn="29"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a466107d6d3e3769fa633f982daed1256" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Key</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">amrex::Long</ref></type>
        <definition>amrex::Long amrex::bytesOf</definition>
        <argsstring>(const std::map&lt; Key, T, Compare &gt; &amp;m)</argsstring>
        <name>bytesOf</name>
        <qualifiedname>amrex::bytesOf</qualifiedname>
        <param>
          <type>const std::map&lt; Key, T, Compare &gt; &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="206" column="33" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="362" bodyend="365" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="206" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af0fd43716fb89a13154ed4c037ebe6e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::BroadcastBool</definition>
        <argsstring>(bool &amp;bBool, int myLocalId, int rootId, const MPI_Comm &amp;localComm)</argsstring>
        <name>BroadcastBool</name>
        <qualifiedname>amrex::BroadcastBool</qualifiedname>
        <param>
          <type>bool &amp;</type>
          <declname>bBool</declname>
        </param>
        <param>
          <type>int</type>
          <declname>myLocalId</declname>
        </param>
        <param>
          <type>int</type>
          <declname>rootId</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref> &amp;</type>
          <declname>localComm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="208" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="886" bodyend="898" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="208" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa60205e03d594df934b5b3afd723c764" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::BroadcastString</definition>
        <argsstring>(std::string &amp;bStr, int myLocalId, int rootId, const MPI_Comm &amp;localComm)</argsstring>
        <name>BroadcastString</name>
        <qualifiedname>amrex::BroadcastString</qualifiedname>
        <param>
          <type>std::string &amp;</type>
          <declname>bStr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>myLocalId</declname>
        </param>
        <param>
          <type>int</type>
          <declname>rootId</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref> &amp;</type>
          <declname>localComm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="210" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="901" bodyend="915" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="210" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1bfd620fc96f18d04313d70ccca85bfb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::BroadcastStringArray</definition>
        <argsstring>(Vector&lt; std::string &gt; &amp;bSA, int myLocalId, int rootId, const MPI_Comm &amp;localComm)</argsstring>
        <name>BroadcastStringArray</name>
        <qualifiedname>amrex::BroadcastStringArray</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>bSA</declname>
        </param>
        <param>
          <type>int</type>
          <declname>myLocalId</declname>
        </param>
        <param>
          <type>int</type>
          <declname>rootId</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref> &amp;</type>
          <declname>localComm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="211" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="917" bodyend="929" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="211" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8cf9dce7670dcc62897405af53fafcff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::BroadcastArray</definition>
        <argsstring>(Vector&lt; T &gt; &amp;aT, int myLocalId, int rootId, const MPI_Comm &amp;localComm)</argsstring>
        <name>BroadcastArray</name>
        <qualifiedname>amrex::BroadcastArray</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T &gt; &amp;</type>
          <declname>aT</declname>
        </param>
        <param>
          <type>int</type>
          <declname>myLocalId</declname>
        </param>
        <param>
          <type>int</type>
          <declname>rootId</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref> &amp;</type>
          <declname>localComm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="213" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="272" bodyend="286" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="213" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae0cfc6441bbe3f6e424e8a3fdd99bfe8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Sleep</definition>
        <argsstring>(double sleepsec)</argsstring>
        <name>Sleep</name>
        <qualifiedname>amrex::Sleep</qualifiedname>
        <param>
          <type>double</type>
          <declname>sleepsec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="215" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="931" bodyend="933" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="215" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6f975f843338c8eada684f0e8e2c0cb7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>double</type>
        <definition>double amrex::second</definition>
        <argsstring>() noexcept</argsstring>
        <name>second</name>
        <qualifiedname>amrex::second</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="221" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.cpp" bodystart="940" bodyend="944" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="221" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adce3325c7a4208e21f4cecc984bfb8b9" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::hash_combine</definition>
        <argsstring>(uint64_t &amp;seed, const T &amp;val) noexcept</argsstring>
        <name>hash_combine</name>
        <qualifiedname>amrex::hash_combine</qualifiedname>
        <param>
          <type>uint64_t &amp;</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="223" column="21" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="400" bodyend="403" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="223" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a72ebcf044c2dabd659e4ed5831cadc5e" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>uint64_t</type>
        <definition>uint64_t amrex::hash_vector</definition>
        <argsstring>(const Vector&lt; T &gt; &amp;vec, uint64_t seed=0xDEADBEEFDEADBEEF) noexcept</argsstring>
        <name>hash_vector</name>
        <qualifiedname>amrex::hash_vector</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>seed</declname>
          <defval>0xDEADBEEFDEADBEEF</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="224" column="25" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="407" bodyend="413" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="224" declcolumn="25"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a002a7544dd6307ca1e4e08afddb91f9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::ToString</definition>
        <argsstring>(std::ostream &amp;os, const T &amp;t, const char *symbol_begin=&quot;[&quot;, const char *symbol_delim=&quot;, &quot;, const char *symbol_end=&quot;]&quot;, const char *symbol_str=&quot;\&quot;&quot;, int limit=100)</argsstring>
        <name>ToString</name>
        <qualifiedname>amrex::ToString</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>symbol_begin</declname>
          <defval>&quot;[&quot;</defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>symbol_delim</declname>
          <defval>&quot;, &quot;</defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>symbol_end</declname>
          <defval>&quot;]&quot;</defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>symbol_str</declname>
          <defval>&quot;\&quot;&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>limit</declname>
          <defval>100</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="227" column="18" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="464" bodyend="509" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="227" declcolumn="18"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a22e0252604bf691ec2a7f8bafa5564ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string amrex::ToString</definition>
        <argsstring>(const T &amp;t, const char *symbol_begin=&quot;[&quot;, const char *symbol_delim=&quot;, &quot;, const char *symbol_end=&quot;]&quot;, const char *symbol_str=&quot;\&quot;&quot;, int limit=100, std::ostringstream ss=std::ostringstream{})</argsstring>
        <name>ToString</name>
        <qualifiedname>amrex::ToString</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>symbol_begin</declname>
          <defval>&quot;[&quot;</defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>symbol_delim</declname>
          <defval>&quot;, &quot;</defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>symbol_end</declname>
          <defval>&quot;]&quot;</defval>
        </param>
        <param>
          <type>const char *</type>
          <declname>symbol_str</declname>
          <defval>&quot;\&quot;&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>limit</declname>
          <defval>100</defval>
        </param>
        <param>
          <type>std::ostringstream</type>
          <declname>ss</declname>
          <defval>std::ostringstream{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="236" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="512" bodyend="518" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="236" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa3693a1b83f9e772f2dc72e9c18cd0ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ auto</type>
        <definition>__host__ __device__ auto amrex::callNoinline</definition>
        <argsstring>(F const &amp;f, T &amp;&amp;... arg) -&gt; decltype(std::declval&lt; F &gt;()(std::declval&lt; T &gt;()...))</argsstring>
        <name>callNoinline</name>
        <qualifiedname>amrex::callNoinline</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
<para>Call given function without inline. </para>
        </briefdescription>
        <detaileddescription>
<para>This works on lambdas, functors, normal functions. But it does not work with overloaded functions like std::sin. If needed, one could however wrap functions like std::sin inside a lambda function. It also does not work with normal functions for SYCL and one would have to wrap it inside a lambda. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" line="255" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" bodystart="522" bodyend="531" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Utility.H" declline="255" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9f6600475654838eaad331bff6121d0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename T::FABType</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T * &gt;</type>
        <definition>Vector&lt; T * &gt; amrex::GetVecOfPtrs</definition>
        <argsstring>(Vector&lt; T &gt; &amp;a)</argsstring>
        <name>GetVecOfPtrs</name>
        <qualifiedname>amrex::GetVecOfPtrs</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="64" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="64" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1cd4530f1ff191f23f734bb93594bfe2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>typename</type>
            <defval>typename T::FABType</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; T, N &gt; * &gt;</type>
        <definition>Vector&lt; Array&lt; T, N &gt; * &gt; amrex::GetVecOfPtrs</definition>
        <argsstring>(Vector&lt; Array&lt; T, N &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfPtrs</name>
        <qualifiedname>amrex::GetVecOfPtrs</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; T, N &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="73" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="73" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a75a0cde85de080ac29b7c4510da71e16" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T * &gt;</type>
        <definition>Vector&lt; T * &gt; amrex::GetVecOfPtrs</definition>
        <argsstring>(const Vector&lt; std::unique_ptr&lt; T &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfPtrs</name>
        <qualifiedname>amrex::GetVecOfPtrs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::unique_ptr&lt; T &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="82" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="82" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a51100fabe18e8030b106160d35ee8480" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename T::FABType</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const T * &gt;</type>
        <definition>Vector&lt; const T * &gt; amrex::GetVecOfConstPtrs</definition>
        <argsstring>(const Vector&lt; T &gt; &amp;a)</argsstring>
        <name>GetVecOfConstPtrs</name>
        <qualifiedname>amrex::GetVecOfConstPtrs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="93" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="93" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae373e465e7172706317ead201aa5daf1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>typename</type>
            <defval>typename T::FABType</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; T, N &gt; const * &gt;</type>
        <definition>Vector&lt; Array&lt; T, N &gt; const  * &gt; amrex::GetVecOfConstPtrs</definition>
        <argsstring>(Vector&lt; Array&lt; T, N &gt; &gt; const &amp;a)</argsstring>
        <name>GetVecOfConstPtrs</name>
        <qualifiedname>amrex::GetVecOfConstPtrs</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; T, N &gt; &gt; const &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="102" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="102" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aede68065e25b664a64f390e487cdb110" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const T * &gt;</type>
        <definition>Vector&lt; const T * &gt; amrex::GetVecOfConstPtrs</definition>
        <argsstring>(const Vector&lt; std::unique_ptr&lt; T &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfConstPtrs</name>
        <qualifiedname>amrex::GetVecOfConstPtrs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::unique_ptr&lt; T &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="111" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="111" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a757ca7d148512a0df37748eb6c3c1900" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename T::FABType</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const T * &gt;</type>
        <definition>Vector&lt; const T * &gt; amrex::GetVecOfConstPtrs</definition>
        <argsstring>(const Vector&lt; T * &gt; &amp;a)</argsstring>
        <name>GetVecOfConstPtrs</name>
        <qualifiedname>amrex::GetVecOfConstPtrs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T * &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="120" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="120" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab58a5175e344b8182c92032bfdd0c0c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T * &gt; &gt;</type>
        <definition>Vector&lt; Vector&lt; T * &gt; &gt; amrex::GetVecOfVecOfPtrs</definition>
        <argsstring>(const Vector&lt; Vector&lt; std::unique_ptr&lt; T &gt; &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfVecOfPtrs</name>
        <qualifiedname>amrex::GetVecOfVecOfPtrs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::unique_ptr&lt; T &gt; &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="128" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="128" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac8219d64a8152020148958b4d72351b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; T *, 3 &gt; &gt;</type>
        <definition>Vector&lt; std::array&lt; T *, 3 &gt; &gt; amrex::GetVecOfArrOfPtrs</definition>
        <argsstring>(const Vector&lt; std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfArrOfPtrs</name>
        <qualifiedname>amrex::GetVecOfArrOfPtrs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="141" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="141" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3de16415254c4c112847d5b4c7bc07d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; T const *, 3 &gt; &gt;</type>
        <definition>Vector&lt; std::array&lt; T const  *, 3 &gt; &gt; amrex::GetVecOfArrOfPtrsConst</definition>
        <argsstring>(const Vector&lt; std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfArrOfPtrsConst</name>
        <qualifiedname>amrex::GetVecOfArrOfPtrsConst</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="151" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="151" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac6277f5f08066a2c869792d1c56a7c06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; T const *, 3 &gt; &gt;</type>
        <definition>Vector&lt; std::array&lt; T const  *, 3 &gt; &gt; amrex::GetVecOfArrOfConstPtrs</definition>
        <argsstring>(const Vector&lt; std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfArrOfConstPtrs</name>
        <qualifiedname>amrex::GetVecOfArrOfConstPtrs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; std::unique_ptr&lt; T &gt;, 3 &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="161" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="161" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5e0ae7344fab26c3aaa99c6553e1193f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; T &gt;::value||IsBaseFab&lt; T &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; T const *, 3 &gt; &gt;</type>
        <definition>Vector&lt; std::array&lt; T const  *, 3 &gt; &gt; amrex::GetVecOfArrOfConstPtrs</definition>
        <argsstring>(const Vector&lt; std::array&lt; T, 3 &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfArrOfConstPtrs</name>
        <qualifiedname>amrex::GetVecOfArrOfConstPtrs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; T, 3 &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="173" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="173" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a980def6b8c4f7c970424c9886402bc08" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsFabArray&lt; T &gt;::value||IsBaseFab&lt; T &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; T *, 3 &gt; &gt;</type>
        <definition>Vector&lt; std::array&lt; T *, 3 &gt; &gt; amrex::GetVecOfArrOfPtrs</definition>
        <argsstring>(Vector&lt; std::array&lt; T, 3 &gt; &gt; &amp;a)</argsstring>
        <name>GetVecOfArrOfPtrs</name>
        <qualifiedname>amrex::GetVecOfArrOfPtrs</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::array&lt; T, 3 &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="185" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="185" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aabc637934b6fa1a7b0664ad3b61f0f69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::FillNull</definition>
        <argsstring>(Vector&lt; T * &gt; &amp;a)</argsstring>
        <name>FillNull</name>
        <qualifiedname>amrex::FillNull</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T * &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="197" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="197" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abc4288a3fe5ceaea66583df8f170785f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::FillNull</definition>
        <argsstring>(Vector&lt; std::unique_ptr&lt; T &gt; &gt; &amp;a)</argsstring>
        <name>FillNull</name>
        <qualifiedname>amrex::FillNull</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::unique_ptr&lt; T &gt; &gt; &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="203" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="203" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adc731523d4241d981e7279b29c5d7a6d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::RemoveDuplicates</definition>
        <argsstring>(Vector&lt; T &gt; &amp;vec)</argsstring>
        <name>RemoveDuplicates</name>
        <qualifiedname>amrex::RemoveDuplicates</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="211" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="211" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7c59b1fe9bc7b0498852cb74d7df5a76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class H</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::RemoveDuplicates</definition>
        <argsstring>(Vector&lt; T &gt; &amp;vec)</argsstring>
        <name>RemoveDuplicates</name>
        <qualifiedname>amrex::RemoveDuplicates</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; T &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" line="303" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_Vector.H" bodystart="303" bodyend="307"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aefc8755fb6847a4dc04d7de6a11bb9ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeIntData</definition>
        <argsstring>(const int *data, std::size_t size, std::ostream &amp;os, const IntDescriptor &amp;id=FPC::NativeIntDescriptor())</argsstring>
        <name>writeIntData</name>
        <qualifiedname>amrex::writeIntData</qualifiedname>
        <param>
          <type>const int *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> &amp;</type>
          <declname>id</declname>
          <defval><ref refid="classamrex_1_1FPC_1a9cad45e259106beaa8e4dc56f613bd06" kindref="member">FPC::NativeIntDescriptor</ref>()</defval>
        </param>
        <briefdescription>
<para>Functions for writing integer data to disk in a portable, self-describing manner. </para>
        </briefdescription>
        <detaileddescription>
<para>Write int data to the ostream. The arguments are a pointer to data to write, the size of the data buffer, the ostream, and an optional <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> that describes the data format to use for writing. If no <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> is provided, the data will be written using the native format for your machine. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="22" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="6" bodyend="28" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="22" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a69bf266cc5fefb0b385d84f685dd0df6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readIntData</definition>
        <argsstring>(int *data, std::size_t size, std::istream &amp;is, const IntDescriptor &amp;id)</argsstring>
        <name>readIntData</name>
        <qualifiedname>amrex::readIntData</qualifiedname>
        <param>
          <type>int *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read int data from the istream. The arguments are a pointer to data buffer to read into, the size of that buffer, the istream, and an <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> that describes the format of the data on disk. The buffer is assumed to be large enough to store &apos;size&apos; integers, and it is the user&apos;s reponsiblity to allocate this data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="30" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="30" bodyend="52" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="30" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a601aaf049a30edfae3541b7f8ae1e0fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeLongData</definition>
        <argsstring>(const Long *data, std::size_t size, std::ostream &amp;os, const IntDescriptor &amp;id=FPC::NativeLongDescriptor())</argsstring>
        <name>writeLongData</name>
        <qualifiedname>amrex::writeLongData</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> &amp;</type>
          <declname>id</declname>
          <defval><ref refid="classamrex_1_1FPC_1a6f67a43bd516bcc9547cb3b76424b2b8" kindref="member">FPC::NativeLongDescriptor</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write long data to the ostream. The arguments are a pointer to data to write, the size of the data buffer, the ostream, and an optional <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> that describes the data format to use for writing. If no <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> is provided, the data will be written using the native format for your machine. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="37" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="54" bodyend="76" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="37" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa5a1f4f1c5cbe7672f12c62b9db96746" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readLongData</definition>
        <argsstring>(Long *data, std::size_t size, std::istream &amp;is, const IntDescriptor &amp;id)</argsstring>
        <name>readLongData</name>
        <qualifiedname>amrex::readLongData</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read int data from the istream. The arguments are a pointer to data buffer to read into, the size of that buffer, the istream, and an <ref refid="classamrex_1_1IntDescriptor" kindref="compound">IntDescriptor</ref> that describes the format of the data on disk. The buffer is assumed to be large enough to store &apos;size&apos; longs, and it is the user&apos;s reponsiblity to allocate this data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="45" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="78" bodyend="100" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="45" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af9790d1f61a6d21ce4e9f92c58ac0600" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeRealData</definition>
        <argsstring>(const Real *data, std::size_t size, std::ostream &amp;os, const RealDescriptor &amp;rd=FPC::NativeRealDescriptor())</argsstring>
        <name>writeRealData</name>
        <qualifiedname>amrex::writeRealData</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> &amp;</type>
          <declname>rd</declname>
          <defval><ref refid="classamrex_1_1FPC_1ab470772000cfb5f507edc5f294383bbc" kindref="member">FPC::NativeRealDescriptor</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write Real data to the ostream. The arguments are a pointer to data to write, the size of the data buffer, the ostream, and an optional <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> that describes the data format to use for writing. If no <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> is provided, the data will be written using the native format for your machine. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="52" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="102" bodyend="106" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="52" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa6f624229959bee80f1444371bb5babc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readRealData</definition>
        <argsstring>(Real *data, std::size_t size, std::istream &amp;is, const RealDescriptor &amp;rd)</argsstring>
        <name>readRealData</name>
        <qualifiedname>amrex::readRealData</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> &amp;</type>
          <declname>rd</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read Real data from the istream. The arguments are a pointer to data buffer to read into, the size of that buffer, the istream, and a <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> that describes the format of the data on disk. The buffer is assumed to be large enough to store &apos;size&apos; Reals, and it is the user&apos;s reponsiblity to allocate this data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="60" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="108" bodyend="112" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="60" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4f9c3dd444d301063e6190234413bda4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeFloatData</definition>
        <argsstring>(const float *data, std::size_t size, std::ostream &amp;os, const RealDescriptor &amp;rd=FPC::Native32RealDescriptor())</argsstring>
        <name>writeFloatData</name>
        <qualifiedname>amrex::writeFloatData</qualifiedname>
        <param>
          <type>const float *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> &amp;</type>
          <declname>rd</declname>
          <defval><ref refid="classamrex_1_1FPC_1a56bb549e278ccc2611fd389c3d2b6bdb" kindref="member">FPC::Native32RealDescriptor</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write float data to the ostream. The arguments are a pointer to data to write, the size of the data buffer, the ostream, and an optional <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> that describes the data format to use for writing. If no <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> is provided, the data will be written using the native format for your machine. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="68" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="114" bodyend="118" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="68" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a4c085d3b27d107f62bdb36f5ecc0f326" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readFloatData</definition>
        <argsstring>(float *data, std::size_t size, std::istream &amp;is, const RealDescriptor &amp;rd)</argsstring>
        <name>readFloatData</name>
        <qualifiedname>amrex::readFloatData</qualifiedname>
        <param>
          <type>float *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> &amp;</type>
          <declname>rd</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read float data from the istream. The arguments are a pointer to data buffer to read into, the size of that buffer, the istream, and a <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> that describes the format of the data on disk. The buffer is assumed to be large enough to store &apos;size&apos; Reals, and it is the user&apos;s reponsiblity to allocate this data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="76" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="120" bodyend="124" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="76" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9cb2d187853bfabaaf7d74de8c950c25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeDoubleData</definition>
        <argsstring>(const double *data, std::size_t size, std::ostream &amp;os, const RealDescriptor &amp;rd=FPC::Native64RealDescriptor())</argsstring>
        <name>writeDoubleData</name>
        <qualifiedname>amrex::writeDoubleData</qualifiedname>
        <param>
          <type>const double *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> &amp;</type>
          <declname>rd</declname>
          <defval><ref refid="classamrex_1_1FPC_1a3e122a19b07bc732bf83c360354ef2a4" kindref="member">FPC::Native64RealDescriptor</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write double data to the ostream. The arguments are a pointer to data to write, the size of the data buffer, the ostream, and an optional <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> that describes the data format to use for writing. If no <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> is provided, the data will be written using the native format for your machine. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="84" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="126" bodyend="130" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="84" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac590394599f7ea721cf8999331d0436e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readDoubleData</definition>
        <argsstring>(double *data, std::size_t size, std::istream &amp;is, const RealDescriptor &amp;rd)</argsstring>
        <name>readDoubleData</name>
        <qualifiedname>amrex::readDoubleData</qualifiedname>
        <param>
          <type>double *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> &amp;</type>
          <declname>rd</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read double data from the istream. The arguments are a pointer to data buffer to read into, the size of that buffer, the istream, and a <ref refid="classamrex_1_1RealDescriptor" kindref="compound">RealDescriptor</ref> that describes the format of the data on disk. The buffer is assumed to be large enough to store &apos;size&apos; Reals, and it is the user&apos;s reponsiblity to allocate this data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="92" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.cpp" bodystart="132" bodyend="136" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" declline="92" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac0401938be1aa864fb878ee171a6fb14" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeData</definition>
        <argsstring>(int const *data, std::size_t size, std::ostream &amp;os)</argsstring>
        <name>writeData</name>
        <qualifiedname>amrex::writeData</qualifiedname>
        <param>
          <type>int const *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="95" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" bodystart="95" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a01a43d1a99e96ce0f348dc5659029a6e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeData</definition>
        <argsstring>(Long const *data, std::size_t size, std::ostream &amp;os)</argsstring>
        <name>writeData</name>
        <qualifiedname>amrex::writeData</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> const *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="100" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" bodystart="100" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2e3bdcedf2e665446f241d3d34cb5b31" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeData</definition>
        <argsstring>(float const *data, std::size_t size, std::ostream &amp;os)</argsstring>
        <name>writeData</name>
        <qualifiedname>amrex::writeData</qualifiedname>
        <param>
          <type>float const *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="105" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" bodystart="105" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1950e496a6aafaad04f6b147af3bd6e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::writeData</definition>
        <argsstring>(double const *data, std::size_t size, std::ostream &amp;os)</argsstring>
        <name>writeData</name>
        <qualifiedname>amrex::writeData</qualifiedname>
        <param>
          <type>double const *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="110" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" bodystart="110" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5836a4ae751b9857848ec279e0a7dc4a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readData</definition>
        <argsstring>(int *data, std::size_t size, std::istream &amp;is)</argsstring>
        <name>readData</name>
        <qualifiedname>amrex::readData</qualifiedname>
        <param>
          <type>int *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="115" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" bodystart="115" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9b9259c0e2e12b54971dac6fe224ba97" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readData</definition>
        <argsstring>(Long *data, std::size_t size, std::istream &amp;is)</argsstring>
        <name>readData</name>
        <qualifiedname>amrex::readData</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="120" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" bodystart="120" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afd3603d5627ea48a5c25919fa90482f5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readData</definition>
        <argsstring>(float *data, std::size_t size, std::istream &amp;is)</argsstring>
        <name>readData</name>
        <qualifiedname>amrex::readData</qualifiedname>
        <param>
          <type>float *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="125" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" bodystart="125" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9bed38ec3405646ecda2cfbd8b179733" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::readData</definition>
        <argsstring>(double *data, std::size_t size, std::istream &amp;is)</argsstring>
        <name>readData</name>
        <qualifiedname>amrex::readData</qualifiedname>
        <param>
          <type>double *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" line="130" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VectorIO.H" bodystart="130" bodyend="133"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af58b88f2bf12a834f4885dcf327fbeba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const VisMF::FabOnDisk &amp;fod)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1VisMF_1_1FabOnDisk" kindref="compound">VisMF::FabOnDisk</ref> &amp;</type>
          <declname>fod</declname>
        </param>
        <briefdescription>
<para>Write a FabOnDisk to an ostream in ASCII. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" line="173" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" bodystart="174" bodyend="183" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" declline="368" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abbd06906c35c69c96f95404ef3837e15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, VisMF::FabOnDisk &amp;fod)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1VisMF_1_1FabOnDisk" kindref="compound">VisMF::FabOnDisk</ref> &amp;</type>
          <declname>fod</declname>
        </param>
        <briefdescription>
<para>Read a FabOnDisk from an istream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" line="186" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" bodystart="186" bodyend="201" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" declline="370" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aadb6da61ab59ea2923bdf326e791654a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Vector&lt; VisMF::FabOnDisk &gt; &amp;fa)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="structamrex_1_1VisMF_1_1FabOnDisk" kindref="compound">VisMF::FabOnDisk</ref> &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <briefdescription>
<para>Write an Vector&lt;FabOnDisk&gt; to an ostream in ASCII. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" line="203" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" bodystart="204" bodyend="220" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" declline="372" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a35e6a4a987e55646e4f33c6827554dea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, Vector&lt; VisMF::FabOnDisk &gt; &amp;fa)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="structamrex_1_1VisMF_1_1FabOnDisk" kindref="compound">VisMF::FabOnDisk</ref> &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <briefdescription>
<para>Read an Vector&lt;FabOnDisk&gt; from an istream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" line="223" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" bodystart="223" bodyend="242" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" declline="374" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1637e435aecce22da819f6df77982d2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const VisMF::Header &amp;hd)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1VisMF_1_1Header" kindref="compound">VisMF::Header</ref> &amp;</type>
          <declname>hd</declname>
        </param>
        <briefdescription>
<para>Write a <ref refid="structamrex_1_1VisMF_1_1Header" kindref="compound">VisMF::Header</ref> to an ostream in ASCII. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" line="319" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" bodystart="320" bodyend="382" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" declline="376" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abd04f69e01ce3c15f6788670823386e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, VisMF::Header &amp;hd)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1VisMF_1_1Header" kindref="compound">VisMF::Header</ref> &amp;</type>
          <declname>hd</declname>
        </param>
        <briefdescription>
<para>Read a <ref refid="structamrex_1_1VisMF_1_1Header" kindref="compound">VisMF::Header</ref> from an istream. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" line="385" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.cpp" bodystart="385" bodyend="465" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" declline="378" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a35f8fe03ac85bb16b4594cc5822820b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_same_v&lt; FAB, <ref refid="classamrex_1_1IArrayBox" kindref="compound">IArrayBox</ref> &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_same_v&lt; FAB, IArrayBox &gt; &gt; amrex::Write</definition>
        <argsstring>(const FabArray&lt; FAB &gt; &amp;fa, const std::string &amp;name)</argsstring>
        <name>Write</name>
        <qualifiedname>amrex::Write</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Write <computeroutput>iMultiFab/FabArray&lt;<ref refid="classamrex_1_1IArrayBox" kindref="compound">IArrayBox</ref>&gt;</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>This writes an <computeroutput>iMultiFab/FabArray&lt;<ref refid="classamrex_1_1IArrayBox" kindref="compound">IArrayBox</ref>&gt;</computeroutput> to files on disk, including a clear text file NAME_H and binary files NAME_D_00000 etc.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fa</parametername>
</parameternamelist>
<parameterdescription>
<para>is the <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref> to be written. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>is the base name for the files. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" line="392" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" bodystart="392" bodyend="529"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abd0af45ba1623e2da1dc0f0832c4071b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_same_v&lt; FAB, <ref refid="classamrex_1_1IArrayBox" kindref="compound">IArrayBox</ref> &gt; &gt;</type>
        <definition>std::enable_if_t&lt; std::is_same_v&lt; FAB, IArrayBox &gt; &gt; amrex::Read</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;fa, const std::string &amp;name)</argsstring>
        <name>Read</name>
        <qualifiedname>amrex::Read</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>fa</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Read <computeroutput>iMultiFab/FabArray&lt;<ref refid="classamrex_1_1IArrayBox" kindref="compound">IArrayBox</ref>&gt;</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>This reads an <computeroutput>iMultiFab/FabArray&lt;<ref refid="classamrex_1_1IArrayBox" kindref="compound">IArrayBox</ref>&gt;</computeroutput> from disk. If it has been fully defined, the <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> on the disk must match the <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> in the given <computeroutput>iMultiFab/FabArray&lt;<ref refid="classamrex_1_1IArrayBox" kindref="compound">IArrayBox</ref>&gt;</computeroutput> object. If it is only constructed with the default constructor, the <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> on the disk will be used and a new <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> will be made. When this function is used to restart a calculation from checkpoint files, one should use a fully defined <computeroutput>iMultiFab/FabArray&lt;<ref refid="classamrex_1_1IArrayBox" kindref="compound">IArrayBox</ref>&gt;</computeroutput> except for the first one in a series of iMultiFab/MultiFab objects that share the same BoxArray/DistributionMapping. This will ensure that they share the same BoxArray/DistributionMapping after restart.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fa</parametername>
</parameternamelist>
<parameterdescription>
<para>is the <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>is the base name for the files. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" line="571" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_VisMF.H" bodystart="571" bodyend="752"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac25ebc9a1d8831acf4cd0213da8694ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const LinOpBCType &amp;t)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a8365a84c73dc019f863f57bfcb9a6435" kindref="member">LinOpBCType</ref> &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_LO_BCTYPES.cpp" line="7" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_LO_BCTYPES.cpp" bodystart="7" bodyend="71" declfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_LO_BCTYPES.H" declline="37" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a132b4ea4d490826477196f09c1c5bfb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Mask &amp;m)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Mask" kindref="compound">Mask</ref> &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_Mask.cpp" line="26" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_Mask.cpp" bodystart="27" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab44c1e3e0d41198c12065e0420b41ca0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::istream &amp;</type>
        <definition>std::istream &amp; amrex::operator&gt;&gt;</definition>
        <argsstring>(std::istream &amp;is, Mask &amp;m)</argsstring>
        <name>operator&gt;&gt;</name>
        <qualifiedname>amrex::operator&gt;&gt;</qualifiedname>
        <param>
          <type>std::istream &amp;</type>
          <declname>is</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Mask" kindref="compound">Mask</ref> &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_Mask.cpp" line="52" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Boundary/AMReX_Mask.cpp" bodystart="52" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8cb738d9f1f698007c0f56b7a0088083" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::amrex_flux_redistribute</definition>
        <argsstring>(const Box &amp;bx, Array4&lt; Real &gt; const &amp;dqdt, Array4&lt; Real const &gt; const &amp;divc, Array4&lt; Real const &gt; const &amp;wt, Array4&lt; Real const &gt; const &amp;vfrac, Array4&lt; EBCellFlag const &gt; const &amp;flag, int as_crse, Array4&lt; Real &gt; const &amp;rr_drho_crse, Array4&lt; int const &gt; const &amp;rr_flag_crse, int as_fine, Array4&lt; Real &gt; const &amp;dm_as_fine, Array4&lt; int const &gt; const &amp;levmsk, const Geometry &amp;geom, bool use_wts_in_divnc, int level_mask_not_covered, int icomp, int ncomp, Real dt)</argsstring>
        <name>amrex_flux_redistribute</name>
        <qualifiedname>amrex::amrex_flux_redistribute</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dqdt</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>divc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>wt</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>rr_drho_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>rr_flag_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dm_as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>levmsk</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_mask_not_covered</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>dt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_FluxRedistribute.cpp" line="13" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_FluxRedistribute.cpp" bodystart="13" bodyend="293"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a343494dfc1c9121c4d236ed0f774e39a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::apply_flux_redistribution</definition>
        <argsstring>(const Box &amp;bx, Array4&lt; Real &gt; const &amp;div, Array4&lt; Real const &gt; const &amp;divc, Array4&lt; Real const &gt; const &amp;wt, int icomp, int ncomp, Array4&lt; EBCellFlag const &gt; const &amp;flag_arr, Array4&lt; Real const &gt; const &amp;vfrac, const Geometry &amp;geom, bool use_wts_in_divnc)</argsstring>
        <name>apply_flux_redistribution</name>
        <qualifiedname>amrex::apply_flux_redistribution</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>div</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>divc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>wt</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag_arr</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_FluxRedistribute.cpp" line="299" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_FluxRedistribute.cpp" bodystart="299" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aecd68c74730a0886f68632b4a343682c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::apply_eb_redistribution</definition>
        <argsstring>(const Box &amp;bx, MultiFab &amp;div_mf, MultiFab &amp;divc_mf, const MultiFab &amp;weights, MFIter *mfi, int icomp, int ncomp, const EBCellFlagFab &amp;flags_fab, const MultiFab *volfrac, Box &amp;, const Geometry &amp;geom, bool use_wts_in_divnc)</argsstring>
        <name>apply_eb_redistribution</name>
        <qualifiedname>amrex::apply_eb_redistribution</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>div_mf</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>divc_mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>weights</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MFIter" kindref="compound">MFIter</ref> *</type>
          <declname>mfi</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1EBCellFlagFab" kindref="compound">EBCellFlagFab</ref> &amp;</type>
          <declname>flags_fab</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *</type>
          <declname>volfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.cpp" line="17" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.cpp" bodystart="17" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a21aae7c97802a4204649e8fb26a9c611" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::single_level_weighted_redistribute</definition>
        <argsstring>(MultiFab &amp;div_tmp_in, MultiFab &amp;div_out, const MultiFab &amp;weights, int div_comp, int ncomp, const Geometry &amp;geom, bool use_wts_in_divnc)</argsstring>
        <name>single_level_weighted_redistribute</name>
        <qualifiedname>amrex::single_level_weighted_redistribute</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>div_tmp_in</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>div_out</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>weights</declname>
        </param>
        <param>
          <type>int</type>
          <declname>div_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.cpp" line="61" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.cpp" bodystart="61" bodyend="98" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="23" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a06dd62adc2d175177f6daf327040e6c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::single_level_redistribute</definition>
        <argsstring>(MultiFab &amp;div_tmp_in, MultiFab &amp;div_out, int div_comp, int ncomp, const Geometry &amp;geom)</argsstring>
        <name>single_level_redistribute</name>
        <qualifiedname>amrex::single_level_redistribute</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>div_tmp_in</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>div_out</declname>
        </param>
        <param>
          <type>int</type>
          <declname>div_comp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.cpp" line="103" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.cpp" bodystart="103" bodyend="112" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="20" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aefd8bdd7a185cff23fc99fb94a8a17d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::apply_flux_redistribution</definition>
        <argsstring>(const amrex::Box &amp;bx, amrex::Array4&lt; amrex::Real &gt; const &amp;div, amrex::Array4&lt; amrex::Real const &gt; const &amp;divc, amrex::Array4&lt; amrex::Real const &gt; const &amp;wt, int icomp, int ncomp, amrex::Array4&lt; amrex::EBCellFlag const &gt; const &amp;flag_arr, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, const amrex::Geometry &amp;geom, bool use_wts_in_divnc)</argsstring>
        <name>apply_flux_redistribution</name>
        <qualifiedname>amrex::apply_flux_redistribution</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>div</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>divc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>wt</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">amrex::EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag_arr</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="29" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="29" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2997746786ac52f67e2d900ad628b54e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::amrex_flux_redistribute</definition>
        <argsstring>(const amrex::Box &amp;bx, amrex::Array4&lt; amrex::Real &gt; const &amp;dqdt, amrex::Array4&lt; amrex::Real const &gt; const &amp;divc, amrex::Array4&lt; amrex::Real const &gt; const &amp;wt, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; amrex::EBCellFlag const &gt; const &amp;flag, int as_crse, amrex::Array4&lt; amrex::Real &gt; const &amp;rr_drho_crse, amrex::Array4&lt; int const &gt; const &amp;rr_flag_crse, int as_fine, amrex::Array4&lt; amrex::Real &gt; const &amp;dm_as_fine, amrex::Array4&lt; int const &gt; const &amp;levmsk, const amrex::Geometry &amp;geom, bool use_wts_in_divnc, int level_mask_not_covered, int icomp, int ncomp, amrex::Real dt)</argsstring>
        <name>amrex_flux_redistribute</name>
        <qualifiedname>amrex::amrex_flux_redistribute</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>dqdt</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>divc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>wt</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">amrex::EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>rr_drho_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>rr_flag_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>dm_as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>levmsk</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_mask_not_covered</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>dt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="40" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="40" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0e0b59317b972387489d090670ab24fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ApplyRedistribution</definition>
        <argsstring>(amrex::Box const &amp;bx, int ncomp, amrex::Array4&lt; amrex::Real &gt; const &amp;dUdt_out, amrex::Array4&lt; amrex::Real &gt; const &amp;dUdt_in, amrex::Array4&lt; amrex::Real const &gt; const &amp;U_in, amrex::Array4&lt; amrex::Real &gt; const &amp;scratch, amrex::Array4&lt; amrex::EBCellFlag const &gt; const &amp;flag, amrex::Array4&lt; amrex::Real const &gt; const &amp;apx, amrex::Array4&lt; amrex::Real const &gt; const &amp;apy, amrex::Array4&lt; amrex::Real const &gt; const &amp;apz, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcx, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcy, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcz, amrex::Array4&lt; amrex::Real const &gt; const &amp;ccc, amrex::BCRec const *d_bcrec_ptr, amrex::Geometry const &amp;lev_geom, amrex::Real dt, std::string const &amp;redistribution_type, bool use_wts_in_divnc=false, int srd_max_order=2, amrex::Real target_volfrac=0.5_rt, amrex::Array4&lt; amrex::Real const &gt; const &amp;update_scale={})</argsstring>
        <name>ApplyRedistribution</name>
        <qualifiedname>amrex::ApplyRedistribution</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>dUdt_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>dUdt_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>scratch</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">amrex::EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>ccc</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>dt</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>redistribution_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>int</type>
          <declname>srd_max_order</declname>
          <defval>2</defval>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>target_volfrac</declname>
          <defval>0.5_rt</defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>update_scale</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="58" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="58" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3f8f8683a45019b95339504aef4c7f0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ApplyMLRedistribution</definition>
        <argsstring>(amrex::Box const &amp;bx, int ncomp, amrex::Array4&lt; amrex::Real &gt; const &amp;dUdt_out, amrex::Array4&lt; amrex::Real &gt; const &amp;dUdt_in, amrex::Array4&lt; amrex::Real const &gt; const &amp;U_in, amrex::Array4&lt; amrex::Real &gt; const &amp;scratch, amrex::Array4&lt; amrex::EBCellFlag const &gt; const &amp;flag, amrex::Array4&lt; amrex::Real const &gt; const &amp;apx, amrex::Array4&lt; amrex::Real const &gt; const &amp;apy, amrex::Array4&lt; amrex::Real const &gt; const &amp;apz, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcx, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcy, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcz, amrex::Array4&lt; amrex::Real const &gt; const &amp;ccc, amrex::BCRec const *d_bcrec_ptr, amrex::Geometry const &amp;lev_geom, amrex::Real dt, std::string const &amp;redistribution_type, int as_crse, amrex::Array4&lt; amrex::Real &gt; const &amp;rr_drho_crse, amrex::Array4&lt; int const &gt; const &amp;rr_flag_crse, int as_fine, amrex::Array4&lt; amrex::Real &gt; const &amp;dm_as_fine, amrex::Array4&lt; int const &gt; const &amp;levmsk, int level_mask_not_covered, amrex::Real fac_for_deltaR=1.0_rt, bool use_wts_in_divnc=false, int icomp=0, int srd_max_order=2, amrex::Real target_volfrac=0.5_rt, amrex::Array4&lt; amrex::Real const &gt; const &amp;update_scale={})</argsstring>
        <name>ApplyMLRedistribution</name>
        <qualifiedname>amrex::ApplyMLRedistribution</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>dUdt_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>dUdt_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>scratch</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">amrex::EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>ccc</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>dt</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>redistribution_type</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>rr_drho_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>rr_flag_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>dm_as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>levmsk</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_mask_not_covered</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>fac_for_deltaR</declname>
          <defval>1.0_rt</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>int</type>
          <declname>srd_max_order</declname>
          <defval>2</defval>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>target_volfrac</declname>
          <defval>0.5_rt</defval>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>update_scale</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="81" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="81" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a315b48edb351e2d406384deec70d228a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ApplyInitialRedistribution</definition>
        <argsstring>(amrex::Box const &amp;bx, int ncomp, amrex::Array4&lt; amrex::Real &gt; const &amp;U_out, amrex::Array4&lt; amrex::Real &gt; const &amp;U_in, amrex::Array4&lt; amrex::EBCellFlag const &gt; const &amp;flag, amrex::Array4&lt; amrex::Real const &gt; const &amp;apx, amrex::Array4&lt; amrex::Real const &gt; const &amp;apy, amrex::Array4&lt; amrex::Real const &gt; const &amp;apz, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcx, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcy, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcz, amrex::Array4&lt; amrex::Real const &gt; const &amp;ccc, amrex::BCRec const *d_bcrec_ptr, amrex::Geometry const &amp;geom, std::string const &amp;redistribution_type, int srd_max_order=2, amrex::Real target_volfrac=0.5_rt)</argsstring>
        <name>ApplyInitialRedistribution</name>
        <qualifiedname>amrex::ApplyInitialRedistribution</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>U_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">amrex::EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>ccc</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> const &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>redistribution_type</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srd_max_order</declname>
          <defval>2</defval>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>target_volfrac</declname>
          <defval>0.5_rt</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="113" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="113" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acd6c32c9119d102132df8b470bd35828" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::StateRedistribute</definition>
        <argsstring>(amrex::Box const &amp;bx, int ncomp, amrex::Array4&lt; amrex::Real &gt; const &amp;U_out, amrex::Array4&lt; amrex::Real &gt; const &amp;U_in, amrex::Array4&lt; amrex::EBCellFlag const &gt; const &amp;flag, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcx, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcy, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcz, amrex::Array4&lt; amrex::Real const &gt; const &amp;ccent, amrex::BCRec const *d_bcrec_ptr, amrex::Array4&lt; int const &gt; const &amp;itracker, amrex::Array4&lt; amrex::Real const &gt; const &amp;nrs, amrex::Array4&lt; amrex::Real const &gt; const &amp;alpha, amrex::Array4&lt; amrex::Real const &gt; const &amp;nbhd_vol, amrex::Array4&lt; amrex::Real const &gt; const &amp;cent_hat, amrex::Geometry const &amp;geom, int max_order=2)</argsstring>
        <name>StateRedistribute</name>
        <qualifiedname>amrex::StateRedistribute</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>U_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">amrex::EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>ccent</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>itracker</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>nrs</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>nbhd_vol</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>cent_hat</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> const &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>max_order</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="131" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="131" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad8e316a7633806e4b6d26f0842f3cb82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::MLStateRedistribute</definition>
        <argsstring>(amrex::Box const &amp;bx, int ncomp, amrex::Array4&lt; amrex::Real &gt; const &amp;U_out, amrex::Array4&lt; amrex::Real &gt; const &amp;U_in, amrex::Array4&lt; amrex::EBCellFlag const &gt; const &amp;flag, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcx, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcy, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcz, amrex::Array4&lt; amrex::Real const &gt; const &amp;ccent, amrex::BCRec const *d_bcrec_ptr, amrex::Array4&lt; int const &gt; const &amp;itracker, amrex::Array4&lt; amrex::Real const &gt; const &amp;nrs, amrex::Array4&lt; amrex::Real const &gt; const &amp;alpha, amrex::Array4&lt; amrex::Real const &gt; const &amp;nbhd_vol, amrex::Array4&lt; amrex::Real const &gt; const &amp;cent_hat, amrex::Geometry const &amp;geom, int as_crse, Array4&lt; Real &gt; const &amp;drho_as_crse, Array4&lt; int const &gt; const &amp;flag_as_crse, int as_fine, Array4&lt; Real &gt; const &amp;dm_as_fine, Array4&lt; int const &gt; const &amp;levmsk, int is_ghost_cell, amrex::Real fac_for_deltaR, int max_order=2)</argsstring>
        <name>MLStateRedistribute</name>
        <qualifiedname>amrex::MLStateRedistribute</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>U_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">amrex::EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>ccent</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>itracker</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>nrs</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>nbhd_vol</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>cent_hat</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> const &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>drho_as_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>flag_as_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dm_as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>levmsk</declname>
        </param>
        <param>
          <type>int</type>
          <declname>is_ghost_cell</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>fac_for_deltaR</declname>
        </param>
        <param>
          <type>int</type>
          <declname>max_order</declname>
          <defval>2</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="149" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="149" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adf782b114ef7fc3ea3dd5e42009836ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::MakeITracker</definition>
        <argsstring>(amrex::Box const &amp;bx, amrex::Array4&lt; amrex::Real const &gt; const &amp;apx, amrex::Array4&lt; amrex::Real const &gt; const &amp;apy, amrex::Array4&lt; amrex::Real const &gt; const &amp;apz, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; int &gt; const &amp;itracker, amrex::Geometry const &amp;geom, amrex::Real target_volfrac)</argsstring>
        <name>MakeITracker</name>
        <qualifiedname>amrex::MakeITracker</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int &gt; const &amp;</type>
          <declname>itracker</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> const &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>target_volfrac</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="175" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="175" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1415c2b7be8fa468b572da6a5b8ce2dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::MakeStateRedistUtils</definition>
        <argsstring>(amrex::Box const &amp;bx, amrex::Array4&lt; amrex::EBCellFlag const &gt; const &amp;flag, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; amrex::Real const &gt; const &amp;ccent, amrex::Array4&lt; int const &gt; const &amp;itracker, amrex::Array4&lt; amrex::Real &gt; const &amp;nrs, amrex::Array4&lt; amrex::Real &gt; const &amp;alpha, amrex::Array4&lt; amrex::Real &gt; const &amp;nbhd_vol, amrex::Array4&lt; amrex::Real &gt; const &amp;cent_hat, amrex::Geometry const &amp;geom, amrex::Real target_volfrac)</argsstring>
        <name>MakeStateRedistUtils</name>
        <qualifiedname>amrex::MakeStateRedistUtils</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">amrex::Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">amrex::EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>ccent</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>itracker</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>nrs</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>nbhd_vol</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> &gt; const &amp;</type>
          <declname>cent_hat</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">amrex::Geometry</ref> const &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>target_volfrac</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" line="184" column="10" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_Redistribution.H" declline="184" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aaefa4d8cac62bdddcc47cdc8899ed79f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ApplyRedistribution</definition>
        <argsstring>(Box const &amp;bx, int ncomp, Array4&lt; Real &gt; const &amp;dUdt_out, Array4&lt; Real &gt; const &amp;dUdt_in, Array4&lt; Real const &gt; const &amp;U_in, Array4&lt; Real &gt; const &amp;scratch, Array4&lt; EBCellFlag const &gt; const &amp;flag, Array4&lt; Real const &gt; const &amp;apx, Array4&lt; Real const &gt; const &amp;apy, Array4&lt; Real const &gt; const &amp;apz, Array4&lt; amrex::Real const &gt; const &amp;vfrac, Array4&lt; Real const &gt; const &amp;fcx, Array4&lt; Real const &gt; const &amp;fcy, Array4&lt; Real const &gt; const &amp;fcz, Array4&lt; Real const &gt; const &amp;ccc, amrex::BCRec const *d_bcrec_ptr, Geometry const &amp;lev_geom, Real dt, std::string const &amp;redistribution_type, bool use_wts_in_divnc, int srd_max_order, amrex::Real target_volfrac, Array4&lt; Real const &gt; const &amp;srd_update_scale)</argsstring>
        <name>ApplyRedistribution</name>
        <qualifiedname>amrex::ApplyRedistribution</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dUdt_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dUdt_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>scratch</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>ccc</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>dt</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>redistribution_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srd_max_order</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>target_volfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>srd_update_scale</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_RedistributionApply.cpp" line="13" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_RedistributionApply.cpp" bodystart="13" bodyend="53"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a58aa0dc758c7ecd393d806a4c857d86d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ApplyMLRedistribution</definition>
        <argsstring>(Box const &amp;bx, int ncomp, Array4&lt; Real &gt; const &amp;dUdt_out, Array4&lt; Real &gt; const &amp;dUdt_in, Array4&lt; Real const &gt; const &amp;U_in, Array4&lt; Real &gt; const &amp;scratch, Array4&lt; EBCellFlag const &gt; const &amp;flag, Array4&lt; Real const &gt; const &amp;apx, Array4&lt; Real const &gt; const &amp;apy, Array4&lt; Real const &gt; const &amp;apz, Array4&lt; amrex::Real const &gt; const &amp;vfrac, Array4&lt; Real const &gt; const &amp;fcx, Array4&lt; Real const &gt; const &amp;fcy, Array4&lt; Real const &gt; const &amp;fcz, Array4&lt; Real const &gt; const &amp;ccc, amrex::BCRec const *d_bcrec_ptr, Geometry const &amp;lev_geom, Real dt, std::string const &amp;redistribution_type, int as_crse, Array4&lt; Real &gt; const &amp;rr_drho_crse, Array4&lt; int const &gt; const &amp;rr_flag_crse, int as_fine, Array4&lt; Real &gt; const &amp;dm_as_fine, Array4&lt; int const &gt; const &amp;levmsk, int level_mask_not_covered, Real fac_for_deltaR, bool use_wts_in_divnc, int icomp, int srd_max_order, amrex::Real target_volfrac, Array4&lt; Real const &gt; const &amp;srd_update_scale)</argsstring>
        <name>ApplyMLRedistribution</name>
        <qualifiedname>amrex::ApplyMLRedistribution</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dUdt_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dUdt_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>scratch</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>ccc</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>dt</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>redistribution_type</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>rr_drho_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>rr_flag_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dm_as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>levmsk</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_mask_not_covered</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>fac_for_deltaR</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_wts_in_divnc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srd_max_order</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>target_volfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>srd_update_scale</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_RedistributionApply.cpp" line="56" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_RedistributionApply.cpp" bodystart="56" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a77da2d6e77a20b8116fe59dc6c985902" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::ApplyInitialRedistribution</definition>
        <argsstring>(Box const &amp;bx, int ncomp, Array4&lt; Real &gt; const &amp;U_out, Array4&lt; Real &gt; const &amp;U_in, Array4&lt; EBCellFlag const &gt; const &amp;flag, amrex::Array4&lt; amrex::Real const &gt; const &amp;apx, amrex::Array4&lt; amrex::Real const &gt; const &amp;apy, amrex::Array4&lt; amrex::Real const &gt; const &amp;apz, amrex::Array4&lt; amrex::Real const &gt; const &amp;vfrac, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcx, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcy, amrex::Array4&lt; amrex::Real const &gt; const &amp;fcz, amrex::Array4&lt; amrex::Real const &gt; const &amp;ccc, amrex::BCRec const *d_bcrec_ptr, Geometry const &amp;lev_geom, std::string const &amp;redistribution_type, int srd_max_order, amrex::Real target_volfrac)</argsstring>
        <name>ApplyInitialRedistribution</name>
        <qualifiedname>amrex::ApplyInitialRedistribution</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>U_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>apz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref> const &gt; const &amp;</type>
          <declname>ccc</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>redistribution_type</declname>
        </param>
        <param>
          <type>int</type>
          <declname>srd_max_order</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref></type>
          <declname>target_volfrac</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_RedistributionApply.cpp" line="232" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_RedistributionApply.cpp" bodystart="232" bodyend="313"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3f219b1b6441230fabcba77af291dfcf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::MakeITracker</definition>
        <argsstring>(Box const &amp;bx, Array4&lt; Real const &gt; const &amp;apx, Array4&lt; Real const &gt; const &amp;apy, Array4&lt; Real const &gt; const &amp;apz, Array4&lt; Real const &gt; const &amp;vfrac, Array4&lt; int &gt; const &amp;itracker, Geometry const &amp;lev_geom, Real target_volfrac)</argsstring>
        <name>MakeITracker</name>
        <qualifiedname>amrex::MakeITracker</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>apz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int &gt; const &amp;</type>
          <declname>itracker</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>target_volfrac</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_StateRedistItracker.cpp" line="228" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_StateRedistItracker.cpp" bodystart="228" bodyend="734"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac56e16be64737e115b1c3a6b26341835" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::MLStateRedistribute</definition>
        <argsstring>(Box const &amp;bx, int ncomp, Array4&lt; Real &gt; const &amp;U_out, Array4&lt; Real &gt; const &amp;U_in, Array4&lt; EBCellFlag const &gt; const &amp;flag, Array4&lt; Real const &gt; const &amp;vfrac, Array4&lt; Real const &gt; const &amp;fcx, Array4&lt; Real const &gt; const &amp;fcy, Array4&lt; Real const &gt; const &amp;fcz, Array4&lt; Real const &gt; const &amp;ccent, amrex::BCRec const *d_bcrec_ptr, Array4&lt; int const &gt; const &amp;itracker, Array4&lt; Real const &gt; const &amp;nrs, Array4&lt; Real const &gt; const &amp;alpha, Array4&lt; Real const &gt; const &amp;nbhd_vol, Array4&lt; Real const &gt; const &amp;cent_hat, Geometry const &amp;lev_geom, int as_crse, Array4&lt; Real &gt; const &amp;drho_as_crse, Array4&lt; int const &gt; const &amp;flag_as_crse, int as_fine, Array4&lt; Real &gt; const &amp;dm_as_fine, Array4&lt; int const &gt; const &amp;levmsk, int is_ghost_cell, Real fac_for_deltaR, int max_order)</argsstring>
        <name>MLStateRedistribute</name>
        <qualifiedname>amrex::MLStateRedistribute</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>U_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>ccent</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>itracker</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>nrs</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>nbhd_vol</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>cent_hat</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>drho_as_crse</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>flag_as_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>dm_as_fine</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>levmsk</declname>
        </param>
        <param>
          <type>int</type>
          <declname>is_ghost_cell</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>fac_for_deltaR</declname>
        </param>
        <param>
          <type>int</type>
          <declname>max_order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_StateRedistribute.cpp" line="13" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_StateRedistribute.cpp" bodystart="13" bodyend="376"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a341c54898b42c5df206709ab80c6d349" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::StateRedistribute</definition>
        <argsstring>(Box const &amp;bx, int ncomp, Array4&lt; Real &gt; const &amp;U_out, Array4&lt; Real &gt; const &amp;U_in, Array4&lt; EBCellFlag const &gt; const &amp;flag, Array4&lt; Real const &gt; const &amp;vfrac, Array4&lt; Real const &gt; const &amp;fcx, Array4&lt; Real const &gt; const &amp;fcy, Array4&lt; Real const &gt; const &amp;fcz, Array4&lt; Real const &gt; const &amp;ccent, amrex::BCRec const *d_bcrec_ptr, Array4&lt; int const &gt; const &amp;itracker, Array4&lt; Real const &gt; const &amp;nrs, Array4&lt; Real const &gt; const &amp;alpha, Array4&lt; Real const &gt; const &amp;nbhd_vol, Array4&lt; Real const &gt; const &amp;cent_hat, Geometry const &amp;lev_geom, int max_order)</argsstring>
        <name>StateRedistribute</name>
        <qualifiedname>amrex::StateRedistribute</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>U_out</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>U_in</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcy</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>fcz</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>ccent</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> const *</type>
          <declname>d_bcrec_ptr</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>itracker</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>nrs</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>nbhd_vol</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>cent_hat</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type>int</type>
          <declname>max_order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_StateRedistribute.cpp" line="379" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_StateRedistribute.cpp" bodystart="379" bodyend="652"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0472d1147267486256bc020afa8670d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::MakeStateRedistUtils</definition>
        <argsstring>(Box const &amp;bx, Array4&lt; EBCellFlag const &gt; const &amp;flag, Array4&lt; Real const &gt; const &amp;vfrac, Array4&lt; Real const &gt; const &amp;ccent, Array4&lt; int const &gt; const &amp;itracker, Array4&lt; Real &gt; const &amp;nrs, Array4&lt; Real &gt; const &amp;alpha, Array4&lt; Real &gt; const &amp;nbhd_vol, Array4&lt; Real &gt; const &amp;cent_hat, Geometry const &amp;lev_geom, Real target_vol)</argsstring>
        <name>MakeStateRedistUtils</name>
        <qualifiedname>amrex::MakeStateRedistUtils</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> const &amp;</type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> const &gt; const &amp;</type>
          <declname>flag</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>vfrac</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> const &gt; const &amp;</type>
          <declname>ccent</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; int const &gt; const &amp;</type>
          <declname>itracker</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>nrs</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>nbhd_vol</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">Array4</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; const &amp;</type>
          <declname>cent_hat</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>lev_geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>target_vol</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_StateRedistUtils.cpp" line="10" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_StateRedistUtils.cpp" bodystart="10" bodyend="236"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae21d913402ed0c78cccf9819ea8a69c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::FillSignedDistance</definition>
        <argsstring>(MultiFab &amp;mf, bool fluid_has_positive_sign=true)</argsstring>
        <name>FillSignedDistance</name>
        <qualifiedname>amrex::FillSignedDistance</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>fluid_has_positive_sign</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Fill <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with signed distance. </para>
        </briefdescription>
        <detaileddescription>
<para>This function fills the nodal <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with signed distance. Note that the distance is valid only if it&apos;s within a few cells to the EB. The <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> must have been built with an <ref refid="classamrex_1_1EBFArrayBoxFactory" kindref="compound">EBFArrayBoxFactory</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>is a nodal <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> built with <ref refid="classamrex_1_1EBFArrayBoxFactory" kindref="compound">EBFArrayBoxFactory</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fluid_has_positive_sign</parametername>
</parameternamelist>
<parameterdescription>
<para>determines the sign of the fluid. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_utils.cpp" line="11" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_utils.cpp" bodystart="11" bodyend="19" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_utils.H" declline="73" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae734f341bd7b27e7d150b1187c28c9ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::FillSignedDistance</definition>
        <argsstring>(MultiFab &amp;mf, EB2::Level const  &amp;ls_lev, EBFArrayBoxFactory const  &amp;eb_fac, int refratio, bool fluid_has_positive_sign=true)</argsstring>
        <name>FillSignedDistance</name>
        <qualifiedname>amrex::FillSignedDistance</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1EB2_1_1Level" kindref="compound">EB2::Level</ref> const &amp;</type>
          <declname>ls_lev</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1EBFArrayBoxFactory" kindref="compound">EBFArrayBoxFactory</ref> const &amp;</type>
          <declname>eb_fac</declname>
        </param>
        <param>
          <type>int</type>
          <declname>refratio</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>fluid_has_positive_sign</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Fill <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with signed distance. </para>
        </briefdescription>
        <detaileddescription>
<para>This function fills the nodal <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with signed distance. Note that the distance is valid only if it&apos;s within a few cells to the EB.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>is a nodal <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ls_lev</parametername>
</parameternamelist>
<parameterdescription>
<para>is an <ref refid="classamrex_1_1EB2_1_1Level" kindref="compound">EB2::Level</ref> object with an implicit function. This is at the same level as mf. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eb_fac</parametername>
</parameternamelist>
<parameterdescription>
<para>is an <ref refid="classamrex_1_1EBFArrayBoxFactory" kindref="compound">EBFArrayBoxFactory</ref> object containing EB information. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>refratio</parametername>
</parameternamelist>
<parameterdescription>
<para>is the refinement ratio of mf to eb_fac. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fluid_has_positive_sign</parametername>
</parameternamelist>
<parameterdescription>
<para>determines the sign of the fluid. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_utils.cpp" line="201" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_utils.cpp" bodystart="201" bodyend="420" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_utils.H" declline="59" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a432c3b4f5a385efd93de62c6402e2b0a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename G</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::FillImpFunc</definition>
        <argsstring>(MultiFab &amp;mf, G const &amp;gshop, Geometry const &amp;geom)</argsstring>
        <name>FillImpFunc</name>
        <qualifiedname>amrex::FillImpFunc</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>G const &amp;</type>
          <declname>gshop</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
<para>Fill <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with implicit function. </para>
        </briefdescription>
        <detaileddescription>
<para>This function fills the nodal <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> with the implicit function in GeometryShop. Note that an implicit function is not necessarily a signed distance function.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>G</parametername>
</parameternamelist>
<parameterdescription>
<para>is the GeometryShop type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>is a nodal <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>gshop</parametername>
</parameternamelist>
<parameterdescription>
<para>is a GeometryShop object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geom</parametername>
</parameternamelist>
<parameterdescription>
<para>is a <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_utils.H" line="25" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EB_utils.H" bodystart="25" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aca824ed9a83373a83533e948d2175dee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::TagCutCells</definition>
        <argsstring>(TagBoxArray &amp;tags, const MultiFab &amp;state)</argsstring>
        <name>TagCutCells</name>
        <qualifiedname>amrex::TagCutCells</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1TagBoxArray" kindref="compound">TagBoxArray</ref> &amp;</type>
          <declname>tags</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>state</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBAmrUtil.cpp" line="14" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBAmrUtil.cpp" bodystart="14" bodyend="60" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBAmrUtil.H" declline="10" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae146edcedfbd7eb8509f8c334b764d84" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::TagVolfrac</definition>
        <argsstring>(TagBoxArray &amp;tags, const MultiFab &amp;volfrac, Real tol)</argsstring>
        <name>TagVolfrac</name>
        <qualifiedname>amrex::TagVolfrac</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1TagBoxArray" kindref="compound">TagBoxArray</ref> &amp;</type>
          <declname>tags</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>volfrac</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>tol</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBAmrUtil.cpp" line="64" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBAmrUtil.cpp" bodystart="64" bodyend="85" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBAmrUtil.H" declline="12" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac45d936bf5764d4fc75c7d483c93afaa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const EBCellFlag &amp;flag)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1EBCellFlag" kindref="compound">EBCellFlag</ref> &amp;</type>
          <declname>flag</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBCellFlag.cpp" line="266" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBCellFlag.cpp" bodystart="267" bodyend="297" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBCellFlag.H" declline="355" declcolumn="1"/>
      </memberdef>
      <member refid="group__amrex__eb_1gad3c5c0681fda33ffa62120cefe254379" kind="function"><name>makeEBFabFactory</name></member>
      <member refid="group__amrex__eb_1gabf88d6f7f3077a1c5fcf27c6f0aeb031" kind="function"><name>makeEBFabFactory</name></member>
      <member refid="group__amrex__eb_1ga17973789d4563c6a83cedde4028817c6" kind="function"><name>makeEBFabFactory</name></member>
      <memberdef kind="function" id="namespaceamrex_1aa4a3bfe1c0cd2c7c8632d1f0ee21b2ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classamrex_1_1EBCellFlagFab" kindref="compound">EBCellFlagFab</ref> &amp;</type>
        <definition>const EBCellFlagFab &amp; amrex::getEBCellFlagFab</definition>
        <argsstring>(const FArrayBox &amp;fab)</argsstring>
        <name>getEBCellFlagFab</name>
        <qualifiedname>amrex::getEBCellFlagFab</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1FArrayBox" kindref="compound">FArrayBox</ref> &amp;</type>
          <declname>fab</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBFArrayBox.cpp" line="174" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBFArrayBox.cpp" bodystart="174" bodyend="179" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBFArrayBox.H" declline="74" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3baedaa2c05dc91fb1b9b36dc61e128d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_set_covered</definition>
        <argsstring>(MultiFab &amp;mf, Real val)</argsstring>
        <name>EB_set_covered</name>
        <qualifiedname>amrex::EB_set_covered</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="21" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="21" bodyend="24" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="12" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac619d99ccf677b91c436697814e9a3c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_set_covered</definition>
        <argsstring>(MultiFab &amp;mf, int icomp, int ncomp, int ngrow, Real val)</argsstring>
        <name>EB_set_covered</name>
        <qualifiedname>amrex::EB_set_covered</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="27" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="27" bodyend="60" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="13" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5d1f42bca3823efe8ae8998c9a1ae08e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_set_covered</definition>
        <argsstring>(MultiFab &amp;mf, int icomp, int ncomp, const Vector&lt; Real &gt; &amp;vals)</argsstring>
        <name>EB_set_covered</name>
        <qualifiedname>amrex::EB_set_covered</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>vals</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="63" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="63" bodyend="66" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="14" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae0a59d2ee3fb91d65cc6effb267f0a6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_set_covered</definition>
        <argsstring>(MultiFab &amp;mf, int icomp, int ncomp, int ngrow, const Vector&lt; Real &gt; &amp;a_vals)</argsstring>
        <name>EB_set_covered</name>
        <qualifiedname>amrex::EB_set_covered</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>icomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>a_vals</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="69" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="69" bodyend="106" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="15" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae059330413fce19e81d70d9e43772f65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_set_covered_faces</definition>
        <argsstring>(const Array&lt; MultiFab *, 3 &gt; &amp;umac, Real val)</argsstring>
        <name>EB_set_covered_faces</name>
        <qualifiedname>amrex::EB_set_covered_faces</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>umac</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="109" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="109" bodyend="217" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="17" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad0b076eb892b66373218120a0cef7631" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_set_covered_faces</definition>
        <argsstring>(const Array&lt; MultiFab *, 3 &gt; &amp;umac, const int scomp, const int ncomp, const Vector&lt; Real &gt; &amp;a_vals)</argsstring>
        <name>EB_set_covered_faces</name>
        <qualifiedname>amrex::EB_set_covered_faces</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>umac</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref> &gt; &amp;</type>
          <declname>a_vals</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="220" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="220" bodyend="333" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="18" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a83baea24aee17c98e8771fa6eea0822f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_down</definition>
        <argsstring>(const MultiFab &amp;S_fine, MultiFab &amp;S_crse, const MultiFab &amp;vol_fine, const MultiFab &amp;vfrac_fine, int scomp, int ncomp, const IntVect &amp;ratio)</argsstring>
        <name>EB_average_down</name>
        <qualifiedname>amrex::EB_average_down</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_crse</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>vol_fine</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>vfrac_fine</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="336" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="336" bodyend="390" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="20" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aeb1fc4ae4ef7edec76f3784f1ca78aed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_down</definition>
        <argsstring>(const MultiFab &amp;S_fine, MultiFab &amp;S_crse, int scomp, int ncomp, int ratio)</argsstring>
        <name>EB_average_down</name>
        <qualifiedname>amrex::EB_average_down</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="394" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="394" bodyend="397" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="23" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a88b5f551ff31c821df1efef0a1983c7d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_down</definition>
        <argsstring>(const MultiFab &amp;S_fine, MultiFab &amp;S_crse, int scomp, int ncomp, const IntVect &amp;ratio)</argsstring>
        <name>EB_average_down</name>
        <qualifiedname>amrex::EB_average_down</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>S_crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="400" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="400" bodyend="497" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="25" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abe6c82e21aac5e86e3c5db4258ce40a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_down_faces</definition>
        <argsstring>(const Array&lt; const MultiFab *, 3 &gt; &amp;fine, const Array&lt; MultiFab *, 3 &gt; &amp;crse, int ratio, int ngcrse)</argsstring>
        <name>EB_average_down_faces</name>
        <qualifiedname>amrex::EB_average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="500" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="500" bodyend="505" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="28" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a54cb4a5c50269a4d27a6cdb39e7c453e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_down_faces</definition>
        <argsstring>(const Array&lt; const MultiFab *, 3 &gt; &amp;fine, const Array&lt; MultiFab *, 3 &gt; &amp;crse, const IntVect &amp;ratio, int ngcrse)</argsstring>
        <name>EB_average_down_faces</name>
        <qualifiedname>amrex::EB_average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="507" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="507" bodyend="588" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="31" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad096b0d35a4894299dd43e15bd6ba067" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_down_faces</definition>
        <argsstring>(const Array&lt; const MultiFab *, 3 &gt; &amp;fine, const Array&lt; MultiFab *, 3 &gt; &amp;crse, const IntVect &amp;ratio, const Geometry &amp;crse_geom)</argsstring>
        <name>EB_average_down_faces</name>
        <qualifiedname>amrex::EB_average_down_faces</qualifiedname>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>crse_geom</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="590" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="590" bodyend="617" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="36" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae62657fb0ffcd40a902dc22f0c64906f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_down_boundaries</definition>
        <argsstring>(const MultiFab &amp;fine, MultiFab &amp;crse, int ratio, int ngcrse)</argsstring>
        <name>EB_average_down_boundaries</name>
        <qualifiedname>amrex::EB_average_down_boundaries</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="619" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="619" bodyend="623" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="40" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a58c0a1915ef06b92abe238304db2cc14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_down_boundaries</definition>
        <argsstring>(const MultiFab &amp;fine, MultiFab &amp;crse, const IntVect &amp;ratio, int ngcrse)</argsstring>
        <name>EB_average_down_boundaries</name>
        <qualifiedname>amrex::EB_average_down_boundaries</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>fine</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>crse</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>ratio</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngcrse</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="625" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="625" bodyend="678" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="42" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a14cdc71d86b76e06ce7ee6201b33e28e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_computeDivergence</definition>
        <argsstring>(MultiFab &amp;divu, const Array&lt; MultiFab const *, 3 &gt; &amp;umac, const Geometry &amp;geom, bool already_on_centroids)</argsstring>
        <name>EB_computeDivergence</name>
        <qualifiedname>amrex::EB_computeDivergence</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>divu</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const *, 3 &gt; &amp;</type>
          <declname>umac</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>already_on_centroids</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="681" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="681" bodyend="759" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="45" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac581516d42a3711120b1e43462014b9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_computeDivergence</definition>
        <argsstring>(MultiFab &amp;divu, const Array&lt; MultiFab const *, 3 &gt; &amp;umac, const Geometry &amp;geom, bool already_on_centroids, const MultiFab &amp;vel_eb)</argsstring>
        <name>EB_computeDivergence</name>
        <qualifiedname>amrex::EB_computeDivergence</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>divu</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const *, 3 &gt; &amp;</type>
          <declname>umac</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>already_on_centroids</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>vel_eb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="761" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="761" bodyend="803" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="48" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a111cb5db766e7c15e00e7da5b379797d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_average_face_to_cellcenter</definition>
        <argsstring>(MultiFab &amp;ccmf, int dcomp, const Array&lt; MultiFab const *, 3 &gt; &amp;fmf)</argsstring>
        <name>EB_average_face_to_cellcenter</name>
        <qualifiedname>amrex::EB_average_face_to_cellcenter</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>ccmf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> const *, 3 &gt; &amp;</type>
          <declname>fmf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="806" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="806" bodyend="858" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="53" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aacd5723b8bb544b8feedee372294e10c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_interp_CC_to_Centroid</definition>
        <argsstring>(MultiFab &amp;cent, const MultiFab &amp;cc, int scomp, int dcomp, int ncomp, const Geometry &amp;geom)</argsstring>
        <name>EB_interp_CC_to_Centroid</name>
        <qualifiedname>amrex::EB_interp_CC_to_Centroid</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cent</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="861" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="861" bodyend="908" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="57" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a08504c49c5cfc9f8c51abbe834877aba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_interp_CC_to_FaceCentroid</definition>
        <argsstring>(const MultiFab &amp;cc, MultiFab &amp;fc_x, MultiFab &amp;fc_y, MultiFab &amp;fc_z, int scomp, int dcomp, int ncomp, const Geometry &amp;a_geom, const Vector&lt; BCRec &gt; &amp;a_bcs)</argsstring>
        <name>EB_interp_CC_to_FaceCentroid</name>
        <qualifiedname>amrex::EB_interp_CC_to_FaceCentroid</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>cc</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>fc_x</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>fc_y</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>fc_z</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>a_geom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>a_bcs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="911" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="911" bodyend="1021" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="60" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8b4ad0f2d82ece47518642b1902472e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_interp_CellCentroid_to_FaceCentroid</definition>
        <argsstring>(const MultiFab &amp;phi_centroid, const Array&lt; MultiFab *, 3 &gt; &amp;phi_faces, int scomp, int dcomp, int nc, const Geometry &amp;geom, const amrex::Vector&lt; amrex::BCRec &gt; &amp;a_bcs)</argsstring>
        <name>EB_interp_CellCentroid_to_FaceCentroid</name>
        <qualifiedname>amrex::EB_interp_CellCentroid_to_FaceCentroid</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>phi_centroid</declname>
        </param>
        <param>
          <type>const <ref refid="group__amrex__linear__containers_1gafe930d74045516fece8591f173e57007" kindref="member">Array</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> *, 3 &gt; &amp;</type>
          <declname>phi_faces</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">amrex::Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> &gt; &amp;</type>
          <declname>a_bcs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="1024" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="1024" bodyend="1032" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="69" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1afa4184f019cdc6b48fa68be6496681b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_interp_CellCentroid_to_FaceCentroid</definition>
        <argsstring>(const MultiFab &amp;phi_centroid, const Vector&lt; MultiFab * &gt; &amp;phi_faces, int scomp, int dcomp, int nc, const Geometry &amp;geom, const amrex::Vector&lt; amrex::BCRec &gt; &amp;a_bcs)</argsstring>
        <name>EB_interp_CellCentroid_to_FaceCentroid</name>
        <qualifiedname>amrex::EB_interp_CellCentroid_to_FaceCentroid</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>phi_centroid</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>phi_faces</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nc</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">amrex::Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">amrex::BCRec</ref> &gt; &amp;</type>
          <declname>a_bcs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="1035" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="1035" bodyend="1043" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="76" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a742b0a786887c5b56b803a89c9f7d316" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::EB_interp_CellCentroid_to_FaceCentroid</definition>
        <argsstring>(const MultiFab &amp;phi_centroid, MultiFab &amp;phi_xface, MultiFab &amp;phi_yface, MultiFab &amp;phi_zface, int scomp, int dcomp, int ncomp, const Geometry &amp;a_geom, const Vector&lt; BCRec &gt; &amp;a_bcs)</argsstring>
        <name>EB_interp_CellCentroid_to_FaceCentroid</name>
        <qualifiedname>amrex::EB_interp_CellCentroid_to_FaceCentroid</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>phi_centroid</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>phi_xface</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>phi_yface</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>phi_zface</declname>
        </param>
        <param>
          <type>int</type>
          <declname>scomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>a_geom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BCRec" kindref="compound">BCRec</ref> &gt; &amp;</type>
          <declname>a_bcs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" line="1046" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.cpp" bodystart="1046" bodyend="1163" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_EBMultiFabUtil.H" declline="83" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a39109bb21761f9999a91aba81f033cac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteEBSurface</definition>
        <argsstring>(const BoxArray &amp;ba, const DistributionMapping &amp;dmap, const Geometry &amp;geom, const EBFArrayBoxFactory *ebf)</argsstring>
        <name>WriteEBSurface</name>
        <qualifiedname>amrex::WriteEBSurface</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>ba</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &amp;</type>
          <declname>dmap</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1EBFArrayBoxFactory" kindref="compound">EBFArrayBoxFactory</ref> *</type>
          <declname>ebf</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/EB/AMReX_WriteEBSurface.cpp" line="12" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_WriteEBSurface.cpp" bodystart="12" bodyend="118" declfile="/home/runner/work/amrex/amrex/Src/EB/AMReX_WriteEBSurface.H" declline="12" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8db0da70de1a3125e8b33af200a3db88" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int amrex::CreateWriteHDF5AttrDouble</definition>
        <argsstring>(hid_t loc, const char *name, hsize_t n, const double *data)</argsstring>
        <name>CreateWriteHDF5AttrDouble</name>
        <qualifiedname>amrex::CreateWriteHDF5AttrDouble</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>loc</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>hsize_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="31" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="31" bodyend="53"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a19368a040b960bd1ba5b2f39435e1c07" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int amrex::CreateWriteHDF5AttrInt</definition>
        <argsstring>(hid_t loc, const char *name, hsize_t n, const int *data)</argsstring>
        <name>CreateWriteHDF5AttrInt</name>
        <qualifiedname>amrex::CreateWriteHDF5AttrInt</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>loc</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>hsize_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="55" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="55" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aaf22588c7b0bb6c22716656d04ed0122" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int amrex::CreateWriteHDF5AttrString</definition>
        <argsstring>(hid_t loc, const char *name, const char *str)</argsstring>
        <name>CreateWriteHDF5AttrString</name>
        <qualifiedname>amrex::CreateWriteHDF5AttrString</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>loc</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="79" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="79" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac99e8f8a8b8cd43c848fd5766134e3f2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void amrex::SetHDF5fapl</definition>
        <argsstring>(hid_t fapl, MPI_Comm comm)</argsstring>
        <name>SetHDF5fapl</name>
        <qualifiedname>amrex::SetHDF5fapl</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>fapl</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref></type>
          <declname>comm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="111" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="111" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae5531ab9e11a41c67335566828817058" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void amrex::WriteGenericPlotfileHeaderHDF5</definition>
        <argsstring>(hid_t fid, int nlevels, const Vector&lt; const MultiFab * &gt; &amp;mf, const Vector&lt; BoxArray &gt; &amp;bArray, const Vector&lt; std::string &gt; &amp;varnames, const Vector&lt; Geometry &gt; &amp;geom, Real time, const Vector&lt; int &gt; &amp;level_steps, const Vector&lt; IntVect &gt; &amp;ref_ratio, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteGenericPlotfileHeaderHDF5</name>
        <qualifiedname>amrex::WriteGenericPlotfileHeaderHDF5</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>fid</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nlevels</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &gt; &amp;</type>
          <declname>bArray</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>level_steps</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref_ratio</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="149" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="149" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a35cb6e91489172228a5e86d0e274e911" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteMultiLevelPlotfileHDF5SingleDset</definition>
        <argsstring>(const std::string &amp;plotfilename, int nlevels, const Vector&lt; const MultiFab * &gt; &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Vector&lt; Geometry &gt; &amp;geom, Real time, const Vector&lt; int &gt; &amp;level_steps, const Vector&lt; IntVect &gt; &amp;ref_ratio, const std::string &amp;compression, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteMultiLevelPlotfileHDF5SingleDset</name>
        <qualifiedname>amrex::WriteMultiLevelPlotfileHDF5SingleDset</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nlevels</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>level_steps</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref_ratio</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>compression</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="334" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="334" bodyend="805" declfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.H" declline="55" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a12a28b501fcf51d721c9bfdb141a0fd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteMultiLevelPlotfileHDF5MultiDset</definition>
        <argsstring>(const std::string &amp;plotfilename, int nlevels, const Vector&lt; const MultiFab * &gt; &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Vector&lt; Geometry &gt; &amp;geom, Real time, const Vector&lt; int &gt; &amp;level_steps, const Vector&lt; IntVect &gt; &amp;ref_ratio, const std::string &amp;compression, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteMultiLevelPlotfileHDF5MultiDset</name>
        <qualifiedname>amrex::WriteMultiLevelPlotfileHDF5MultiDset</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nlevels</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>level_steps</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref_ratio</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>compression</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="807" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="807" bodyend="1280" declfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.H" declline="81" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab4091ae0cef4a267c78724116432a941" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteSingleLevelPlotfileHDF5</definition>
        <argsstring>(const std::string &amp;plotfilename, const MultiFab &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Geometry &amp;geom, Real time, int level_step, const std::string &amp;compression, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteSingleLevelPlotfileHDF5</name>
        <qualifiedname>amrex::WriteSingleLevelPlotfileHDF5</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_step</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>compression</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="1283" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="1283" bodyend="1299" declfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.H" declline="17" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa3fc410d182f902647727772313eb291" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteSingleLevelPlotfileHDF5SingleDset</definition>
        <argsstring>(const std::string &amp;plotfilename, const MultiFab &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Geometry &amp;geom, Real time, int level_step, const std::string &amp;compression, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteSingleLevelPlotfileHDF5SingleDset</name>
        <qualifiedname>amrex::WriteSingleLevelPlotfileHDF5SingleDset</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_step</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>compression</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="1302" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="1302" bodyend="1318" declfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.H" declline="43" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abd149d5130892485ad747e8152093df9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteSingleLevelPlotfileHDF5MultiDset</definition>
        <argsstring>(const std::string &amp;plotfilename, const MultiFab &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Geometry &amp;geom, Real time, int level_step, const std::string &amp;compression, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteSingleLevelPlotfileHDF5MultiDset</name>
        <qualifiedname>amrex::WriteSingleLevelPlotfileHDF5MultiDset</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level_step</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>compression</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="1321" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="1321" bodyend="1337" declfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.H" declline="69" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0aca4b49cf7b2929efe25b9bd590a49e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::WriteMultiLevelPlotfileHDF5</definition>
        <argsstring>(const std::string &amp;plotfilename, int nlevels, const Vector&lt; const MultiFab * &gt; &amp;mf, const Vector&lt; std::string &gt; &amp;varnames, const Vector&lt; Geometry &gt; &amp;geom, Real time, const Vector&lt; int &gt; &amp;level_steps, const Vector&lt; IntVect &gt; &amp;ref_ratio, const std::string &amp;compression, const std::string &amp;versionName, const std::string &amp;levelPrefix, const std::string &amp;mfPrefix, const Vector&lt; std::string &gt; &amp;extra_dirs)</argsstring>
        <name>WriteMultiLevelPlotfileHDF5</name>
        <qualifiedname>amrex::WriteMultiLevelPlotfileHDF5</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>plotfilename</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nlevels</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; const <ref refid="classamrex_1_1MultiFab" kindref="compound">MultiFab</ref> * &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>varnames</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &gt; &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref></type>
          <declname>time</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>level_steps</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &gt; &amp;</type>
          <declname>ref_ratio</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>compression</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>versionName</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>levelPrefix</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>mfPrefix</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>extra_dirs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" line="1340" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.cpp" bodystart="1340" bodyend="1357" declfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_PlotFileUtilHDF5.H" declline="29" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac367dcdbb3cb626e7e3024b1004bd4c4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int amrex::CreateWriteHDF5Attr</definition>
        <argsstring>(hid_t loc, const char *name, hsize_t n, void *data, hid_t dtype)</argsstring>
        <name>CreateWriteHDF5Attr</name>
        <qualifiedname>amrex::CreateWriteHDF5Attr</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>loc</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>hsize_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>hid_t</type>
          <declname>dtype</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" line="6" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" bodystart="6" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aaf22588c7b0bb6c22716656d04ed0122" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int amrex::CreateWriteHDF5AttrString</definition>
        <argsstring>(hid_t loc, const char *name, const char *str)</argsstring>
        <name>CreateWriteHDF5AttrString</name>
        <qualifiedname>amrex::CreateWriteHDF5AttrString</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>loc</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" line="30" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" bodystart="30" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae48f3f41e4279c59d54289d0eacdd081" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int amrex::ReadHDF5Attr</definition>
        <argsstring>(hid_t loc, const char *name, void *data, hid_t dtype)</argsstring>
        <name>ReadHDF5Attr</name>
        <qualifiedname>amrex::ReadHDF5Attr</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>loc</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>hid_t</type>
          <declname>dtype</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" line="61" column="12" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" bodystart="61" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac99e8f8a8b8cd43c848fd5766134e3f2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void amrex::SetHDF5fapl</definition>
        <argsstring>(hid_t fapl, MPI_Comm comm)</argsstring>
        <name>SetHDF5fapl</name>
        <qualifiedname>amrex::SetHDF5fapl</qualifiedname>
        <param>
          <type>hid_t</type>
          <declname>fapl</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref></type>
          <declname>comm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" line="82" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" bodystart="82" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ada4db7db2d7be0a87a6aea2f35d62ede" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::WriteHDF5ParticleDataSync</definition>
        <argsstring>(PC const &amp;pc, const std::string &amp;dir, const std::string &amp;name, const Vector&lt; int &gt; &amp;write_real_comp, const Vector&lt; int &gt; &amp;write_int_comp, const Vector&lt; std::string &gt; &amp;real_comp_names, const Vector&lt; std::string &gt; &amp;int_comp_names, const std::string &amp;compression, F &amp;&amp;f, bool is_checkpoint)</argsstring>
        <name>WriteHDF5ParticleDataSync</name>
        <qualifiedname>amrex::WriteHDF5ParticleDataSync</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>write_real_comp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>write_int_comp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>real_comp_names</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>int_comp_names</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>compression</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>is_checkpoint</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" line="117" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HDF5/AMReX_WriteBinaryParticleDataHDF5.H" bodystart="117" bodyend="479"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af5a050719637ed453c73af4d4ca48c8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="classamrex_1_1Hypre" kindref="compound">Hypre</ref> &gt;</type>
        <definition>std::unique_ptr&lt; Hypre &gt; amrex::makeHypre</definition>
        <argsstring>(const BoxArray &amp;grids, const DistributionMapping &amp;dmap, const Geometry &amp;geom, MPI_Comm comm_, Hypre::Interface interface, const iMultiFab *overset_mask)</argsstring>
        <name>makeHypre</name>
        <qualifiedname>amrex::makeHypre</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>grids</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &amp;</type>
          <declname>dmap</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref></type>
          <declname>comm_</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Hypre_1af08fbb42b4509a32e7f20a6101dfd13f" kindref="member">Hypre::Interface</ref></type>
          <declname>interface</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1iMultiFab" kindref="compound">iMultiFab</ref> *</type>
          <declname>overset_mask</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/HYPRE/AMReX_Hypre.cpp" line="12" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/HYPRE/AMReX_Hypre.cpp" bodystart="12" bodyend="25" declfile="/home/runner/work/amrex/amrex/Src/Extern/HYPRE/AMReX_Hypre.H" declline="102" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1abbd0e7692c28626659b75637c2c63528" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="classamrex_1_1PETScABecLap" kindref="compound">PETScABecLap</ref> &gt;</type>
        <definition>std::unique_ptr&lt; PETScABecLap &gt; amrex::makePetsc</definition>
        <argsstring>(const BoxArray &amp;grids, const DistributionMapping &amp;dmap, const Geometry &amp;geom, MPI_Comm comm_)</argsstring>
        <name>makePetsc</name>
        <qualifiedname>amrex::makePetsc</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1BoxArray" kindref="compound">BoxArray</ref> &amp;</type>
          <declname>grids</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1DistributionMapping" kindref="compound">DistributionMapping</ref> &amp;</type>
          <declname>dmap</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref></type>
          <declname>comm_</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Extern/PETSc/AMReX_PETSc.cpp" line="58" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Extern/PETSc/AMReX_PETSc.cpp" bodystart="58" bodyend="62" declfile="/home/runner/work/amrex/amrex/Src/Extern/PETSc/AMReX_PETSc.H" declline="83" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3eea92efd3c682f5f23770f47af7c14b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Init_FFT</definition>
        <argsstring>(MPI_Comm comm)</argsstring>
        <name>Init_FFT</name>
        <qualifiedname>amrex::Init_FFT</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1_1mpidatatypes_1a30fa228956d7a68a0c604ae5f2163db9" kindref="member">MPI_Comm</ref></type>
          <declname>comm</declname>
        </param>
        <briefdescription>
<para>Initialize <ref refid="namespaceamrex_1_1FFT" kindref="compound">FFT</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This is needed only when the user wants to use <ref refid="namespaceamrex_1_1FFT" kindref="compound">amrex::FFT</ref>, but does not want to call <ref refid="namespaceamrex_1a50b9b83c886549ba070ec27eb45df025" kindref="member">amrex::Initialize</ref> to initialize the full version of <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref>. Note that one usually only needs to call Init_FFT and Finalize_FFT once in the entire program. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/FFT/AMReX_FFT.H" line="22" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/FFT/AMReX_FFT.H" bodystart="22" bodyend="22"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a86dd685e0ef82d7a3b6a25097fe08318" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::Finalize_FFT</definition>
        <argsstring>()</argsstring>
        <name>Finalize_FFT</name>
        <qualifiedname>amrex::Finalize_FFT</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If Init_FFT is called, this should be called after all the <ref refid="namespaceamrex_1_1FFT" kindref="compound">FFT</ref> works are done. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/FFT/AMReX_FFT.H" line="29" column="17" bodyfile="/home/runner/work/amrex/amrex/Src/FFT/AMReX_FFT.H" bodystart="29" bodyend="29"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8ece6e86f96a95c27c5d2e07443fdeb3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename V1</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V1 &gt; &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsAlgVector&lt; std::decay_t&lt; V1 &gt; &gt;::value &gt; amrex::ForEach</definition>
        <argsstring>(V1 &amp;x, F const &amp;f)</argsstring>
        <name>ForEach</name>
        <qualifiedname>amrex::ForEach</qualifiedname>
        <param>
          <type>V1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" line="326" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" bodystart="326" bodyend="334"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a91b12bfdb96beb60d59572b786b862af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename V1</type>
          </param>
          <param>
            <type>typename V2</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V1 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V2 &gt; &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsAlgVector&lt; std::decay_t&lt; V1 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V2 &gt; &gt;::value &gt; amrex::ForEach</definition>
        <argsstring>(V1 &amp;x, V2 &amp;y, F const &amp;f)</argsstring>
        <name>ForEach</name>
        <qualifiedname>amrex::ForEach</qualifiedname>
        <param>
          <type>V1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>V2 &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" line="339" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" bodystart="339" bodyend="349"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a52f56f29d4e64c6ff6c7352d0b48b251" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename V1</type>
          </param>
          <param>
            <type>typename V2</type>
          </param>
          <param>
            <type>typename V3</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V1 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V2 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V3 &gt; &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsAlgVector&lt; std::decay_t&lt; V1 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V2 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V3 &gt; &gt;::value &gt; amrex::ForEach</definition>
        <argsstring>(V1 &amp;x, V2 &amp;y, V3 &amp;z, F const &amp;f)</argsstring>
        <name>ForEach</name>
        <qualifiedname>amrex::ForEach</qualifiedname>
        <param>
          <type>V1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>V2 &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>V3 &amp;</type>
          <declname>z</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" line="355" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" bodystart="355" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6e3a6ad5ecd73e19c59329f925764439" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename V1</type>
          </param>
          <param>
            <type>typename V2</type>
          </param>
          <param>
            <type>typename V3</type>
          </param>
          <param>
            <type>typename V4</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V1 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V2 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V3 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V4 &gt; &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsAlgVector&lt; std::decay_t&lt; V1 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V2 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V3 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V4 &gt; &gt;::value &gt; amrex::ForEach</definition>
        <argsstring>(V1 &amp;x, V2 &amp;y, V3 &amp;z, V4 &amp;a, F const &amp;f)</argsstring>
        <name>ForEach</name>
        <qualifiedname>amrex::ForEach</qualifiedname>
        <param>
          <type>V1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>V2 &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>V3 &amp;</type>
          <declname>z</declname>
        </param>
        <param>
          <type>V4 &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" line="374" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" bodystart="374" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af23cb5eabe40eada89f26fcea5d45cbc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename V1</type>
          </param>
          <param>
            <type>typename V2</type>
          </param>
          <param>
            <type>typename V3</type>
          </param>
          <param>
            <type>typename V4</type>
          </param>
          <param>
            <type>typename V5</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V1 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V2 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V3 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V4 &gt; &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsAlgVector" kindref="compound">IsAlgVector</ref>&lt; std::decay_t&lt; V5 &gt; &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt; IsAlgVector&lt; std::decay_t&lt; V1 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V2 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V3 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V4 &gt; &gt;::value &amp;&amp; IsAlgVector&lt; std::decay_t&lt; V5 &gt; &gt;::value &gt; amrex::ForEach</definition>
        <argsstring>(V1 &amp;x, V2 &amp;y, V3 &amp;z, V4 &amp;a, V5 &amp;b, F const &amp;f)</argsstring>
        <name>ForEach</name>
        <qualifiedname>amrex::ForEach</qualifiedname>
        <param>
          <type>V1 &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>V2 &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>V3 &amp;</type>
          <declname>z</declname>
        </param>
        <param>
          <type>V4 &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>V5 &amp;</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" line="396" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" bodystart="396" bodyend="412"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aad71029d21b80e949017215cf30d0f7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T amrex::Dot</definition>
        <argsstring>(AlgVector&lt; T &gt; const &amp;x, AlgVector&lt; T &gt; const &amp;y, bool local=false)</argsstring>
        <name>Dot</name>
        <qualifiedname>amrex::Dot</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; const &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; const &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>local</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" line="415" column="3" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" bodystart="415" bodyend="429"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8d608f0e60e86a8a8e1c1f2feae1f653" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::Axpy</definition>
        <argsstring>(AlgVector&lt; T &gt; &amp;y, T a, AlgVector&lt; T &gt; const &amp;x, bool async=false)</argsstring>
        <name>Axpy</name>
        <qualifiedname>amrex::Axpy</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; const &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>async</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" line="432" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" bodystart="432" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad1a8a2c601af00a5189517163b863d05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::LinComb</definition>
        <argsstring>(AlgVector&lt; T &gt; &amp;y, T a, AlgVector&lt; T &gt; const &amp;xa, T b, AlgVector&lt; T &gt; const &amp;xb, bool async=false)</argsstring>
        <name>LinComb</name>
        <qualifiedname>amrex::LinComb</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; const &amp;</type>
          <declname>xa</declname>
        </param>
        <param>
          <type>T</type>
          <declname>b</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; const &amp;</type>
          <declname>xb</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>async</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" line="439" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_AlgVector.H" bodystart="439" bodyend="445"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5497760fe0dddbe8b0ef6dc10521a843" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::SpMV</definition>
        <argsstring>(AlgVector&lt; T &gt; &amp;y, SpMatrix&lt; T &gt; const &amp;A, AlgVector&lt; T &gt; const &amp;x)</argsstring>
        <name>SpMV</name>
        <qualifiedname>amrex::SpMV</qualifiedname>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; &amp;</type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1SpMatrix" kindref="compound">SpMatrix</ref>&lt; T &gt; const &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1AlgVector" kindref="compound">AlgVector</ref>&lt; T &gt; const &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_SpMV.H" line="21" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/AMReX_SpMV.H" bodystart="21" bodyend="211"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a252c26c15fb6b8a071dae269722ff428" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>MLMGNormType_EnumTraits</type>
        <definition>MLMGNormType_EnumTraits amrex::amrex_get_enum_traits</definition>
        <argsstring>(MLMGNormType)</argsstring>
        <name>amrex_get_enum_traits</name>
        <qualifiedname>amrex::amrex_get_enum_traits</qualifiedname>
        <param>
          <type><ref refid="namespaceamrex_1ad6568bc5df052e827cc522b2c19fd663" kindref="member">MLMGNormType</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLMG.H" line="12" column="56" declfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_MLMG.H" declline="12" declcolumn="56"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0893f9f9967158353659d2d88292c7be" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename M</type>
          </param>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ int</type>
        <definition>__host__ __device__ int amrex::pcg_solve</definition>
        <argsstring>(T *__restrict__ x, T *__restrict__ r, M const &amp;mat, P const &amp;precond, int maxiter, T rel_tol)</argsstring>
        <name>pcg_solve</name>
        <qualifiedname>amrex::pcg_solve</qualifiedname>
        <param>
          <type>T *__restrict__</type>
          <declname>x</declname>
        </param>
        <param>
          <type>T *__restrict__</type>
          <declname>r</declname>
        </param>
        <param>
          <type>M const &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>P const &amp;</type>
          <declname>precond</declname>
        </param>
        <param>
          <type>int</type>
          <declname>maxiter</declname>
        </param>
        <param>
          <type>T</type>
          <declname>rel_tol</declname>
        </param>
        <briefdescription>
<para>Preconditioned conjugate gradient solver. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>initial guess </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>initial residual </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mat</parametername>
</parameternamelist>
<parameterdescription>
<para>matrix </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>precond</parametername>
</parameternamelist>
<parameterdescription>
<para>preconditioner </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>maxiter</parametername>
</parameternamelist>
<parameterdescription>
<para>max number of iterations </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rel_tol</parametername>
</parameternamelist>
<parameterdescription>
<para>relative tolerance </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_PCGSolver.H" line="24" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/LinearSolvers/MLMG/AMReX_PCGSolver.H" bodystart="24" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a29b0aae252a7a287f7975fa1995b0298" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>constexpr decltype(T::is_particle_tile_data)</type>
        <definition>constexpr decltype(T::is_particle_tile_data) amrex::IsParticleTileData</definition>
        <argsstring>()</argsstring>
        <name>IsParticleTileData</name>
        <qualifiedname>amrex::IsParticleTileData</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_BinIterator.H" line="13" column="20" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_BinIterator.H" bodystart="13" bodyend="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a69911bccde2f992eb93a426d24557e11" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool amrex::IsParticleTileData</definition>
        <argsstring>(Args...)</argsstring>
        <name>IsParticleTileData</name>
        <qualifiedname>amrex::IsParticleTileData</qualifiedname>
        <param>
          <type>Args...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_BinIterator.H" line="18" column="16" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_BinIterator.H" bodystart="18" bodyend="20"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa47fc757d0d25899f61d37329d2d5769" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename A</type>
          </param>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_same_v&lt; std::remove_cv_t&lt; A &gt;, std::remove_cv_t&lt; B &gt; &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::isSame</definition>
        <argsstring>(A const *pa, B const *pb)</argsstring>
        <name>isSame</name>
        <qualifiedname>amrex::isSame</qualifiedname>
        <param>
          <type>A const *</type>
          <declname>pa</declname>
        </param>
        <param>
          <type>B const *</type>
          <declname>pb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_NeighborList.H" line="234" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_NeighborList.H" bodystart="234" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6b7c84acf477ca447e34fe2b56e63ab7" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>__host__ __device__ std::uint64_t</type>
        <definition>__host__ __device__ std::uint64_t amrex::SetParticleIDandCPU</definition>
        <argsstring>(Long id, int cpu) noexcept</argsstring>
        <name>SetParticleIDandCPU</name>
        <qualifiedname>amrex::SetParticleIDandCPU</qualifiedname>
        <param>
          <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
          <declname>id</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cpu</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the idcpu value at once, based on a particle id and cpuid</para>
<para>This can be used in initialization and assignments, to avoid writing twice into the same memory bank. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" line="347" column="15" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" bodystart="347" bodyend="352"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a20c4dab0db3f6bd35eb1517789bae8ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>NReal</declname>
            <defname>NReal</defname>
          </param>
          <param>
            <type>int</type>
            <declname>NInt</declname>
            <defname>NInt</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Particle&lt; NReal, NInt &gt; &amp;p)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1Particle" kindref="compound">Particle</ref>&lt; NReal, NInt &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" line="641" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" bodystart="642" bodyend="664"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a25fb41bd9f954681587b6835058c5405" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>NReal</declname>
            <defname>NReal</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Particle&lt; NReal, 0 &gt; &amp;p)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1Particle" kindref="compound">Particle</ref>&lt; NReal, 0 &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" line="667" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" bodystart="668" bodyend="686"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa1fa1f59093db95dcc9e1b82bd31c543" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>NInt</declname>
            <defname>NInt</defname>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Particle&lt; 0, NInt &gt; &amp;p)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1Particle" kindref="compound">Particle</ref>&lt; 0, NInt &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" line="689" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" bodystart="690" bodyend="708"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab4e01d5d8e6f08b071c8621dd79c8e6a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>NReal</declname>
            <defname>NReal</defname>
            <defval>0</defval>
          </param>
          <param>
            <type>int</type>
            <declname>NInt</declname>
            <defname>NInt</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; amrex::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Particle&lt; 0, 0 &gt; &amp;p)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>amrex::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1Particle" kindref="compound">Particle</ref>&lt; 0, 0 &gt; &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" line="711" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_Particle.H" bodystart="712" bodyend="726"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a814322d519ae32014737504164a0516b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::communicateParticlesFinish</definition>
        <argsstring>(const ParticleCopyPlan &amp;plan)</argsstring>
        <name>communicateParticlesFinish</name>
        <qualifiedname>amrex::communicateParticlesFinish</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleCopyPlan" kindref="compound">ParticleCopyPlan</ref> &amp;</type>
          <declname>plan</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.cpp" line="384" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.cpp" bodystart="384" bodyend="399" declfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" declline="596" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af4c8c19cb812cdbcc34bc408577bb25c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class Buffer</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value &amp;&amp;std::is_base_of_v&lt; PolymorphicArenaAllocator&lt; typename Buffer::value_type &gt;, Buffer &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::packBuffer</definition>
        <argsstring>(const PC &amp;pc, const ParticleCopyOp &amp;op, const ParticleCopyPlan &amp;plan, Buffer &amp;snd_buffer)</argsstring>
        <name>packBuffer</name>
        <qualifiedname>amrex::packBuffer</qualifiedname>
        <param>
          <type>const PC &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleCopyOp" kindref="compound">ParticleCopyOp</ref> &amp;</type>
          <declname>op</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleCopyPlan" kindref="compound">ParticleCopyPlan</ref> &amp;</type>
          <declname>plan</declname>
        </param>
        <param>
          <type>Buffer &amp;</type>
          <declname>snd_buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" line="336" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" bodystart="336" bodyend="431"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af15f18636fe4b15834eac2c9b303fcbd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class Buffer</type>
          </param>
          <param>
            <type>class UnpackPolicy</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::unpackBuffer</definition>
        <argsstring>(PC &amp;pc, const ParticleCopyPlan &amp;plan, const Buffer &amp;snd_buffer, UnpackPolicy const &amp;policy)</argsstring>
        <name>unpackBuffer</name>
        <qualifiedname>amrex::unpackBuffer</qualifiedname>
        <param>
          <type>PC &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleCopyPlan" kindref="compound">ParticleCopyPlan</ref> &amp;</type>
          <declname>plan</declname>
        </param>
        <param>
          <type>const Buffer &amp;</type>
          <declname>snd_buffer</declname>
        </param>
        <param>
          <type>UnpackPolicy const &amp;</type>
          <declname>policy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" line="435" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" bodystart="435" bodyend="496"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1798b9b2e1585609dcc68430ad8502e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class SndBuffer</type>
          </param>
          <param>
            <type>class RcvBuffer</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::communicateParticlesStart</definition>
        <argsstring>(const PC &amp;pc, ParticleCopyPlan &amp;plan, const SndBuffer &amp;snd_buffer, RcvBuffer &amp;rcv_buffer)</argsstring>
        <name>communicateParticlesStart</name>
        <qualifiedname>amrex::communicateParticlesStart</qualifiedname>
        <param>
          <type>const PC &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1ParticleCopyPlan" kindref="compound">ParticleCopyPlan</ref> &amp;</type>
          <declname>plan</declname>
        </param>
        <param>
          <type>const SndBuffer &amp;</type>
          <declname>snd_buffer</declname>
        </param>
        <param>
          <type>RcvBuffer &amp;</type>
          <declname>rcv_buffer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" line="500" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" bodystart="500" bodyend="594"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2930ae07976c9845d80d458c323eff2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class Buffer</type>
          </param>
          <param>
            <type>class UnpackPolicy</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::unpackRemotes</definition>
        <argsstring>(PC &amp;pc, const ParticleCopyPlan &amp;plan, Buffer &amp;rcv_buffer, UnpackPolicy const &amp;policy)</argsstring>
        <name>unpackRemotes</name>
        <qualifiedname>amrex::unpackRemotes</qualifiedname>
        <param>
          <type>PC &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleCopyPlan" kindref="compound">ParticleCopyPlan</ref> &amp;</type>
          <declname>plan</declname>
        </param>
        <param>
          <type>Buffer &amp;</type>
          <declname>rcv_buffer</declname>
        </param>
        <param>
          <type>UnpackPolicy const &amp;</type>
          <declname>policy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" line="600" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleCommunication.H" bodystart="600" bodyend="671"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8fa6beab988f9b1236a6a68f659dfbeb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::ParticleToMesh</definition>
        <argsstring>(PC const &amp;pc, MF &amp;mf, int lev, F const &amp;f, bool zero_out_input=true)</argsstring>
        <name>ParticleToMesh</name>
        <qualifiedname>amrex::ParticleToMesh</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>MF &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>zero_out_input</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMesh.H" line="45" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMesh.H" bodystart="45" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a1cb9d28bd0b809a6157d7e8d2fed5f85" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class MF</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::MeshToParticle</definition>
        <argsstring>(PC &amp;pc, MF const &amp;mf, int lev, F const &amp;f)</argsstring>
        <name>MeshToParticle</name>
        <qualifiedname>amrex::MeshToParticle</qualifiedname>
        <param>
          <type>PC &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>MF const &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMesh.H" line="130" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMesh.H" bodystart="130" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab0df509765624d623f31c61fecd40158" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::CountSnds</definition>
        <argsstring>(const std::map&lt; int, Vector&lt; char &gt; &gt; &amp;not_ours, Vector&lt; Long &gt; &amp;Snds)</argsstring>
        <name>CountSnds</name>
        <qualifiedname>amrex::CountSnds</qualifiedname>
        <param>
          <type>const std::map&lt; int, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; char &gt; &gt; &amp;</type>
          <declname>not_ours</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> &gt; &amp;</type>
          <declname>Snds</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.cpp" line="11" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.cpp" bodystart="11" bodyend="23" declfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.H" declline="12" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a35dfdc6dc9e92b4e5ca271e72779f944" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::doHandShake</definition>
        <argsstring>(const std::map&lt; int, Vector&lt; char &gt; &gt; &amp;not_ours, Vector&lt; Long &gt; &amp;Snds, Vector&lt; Long &gt; &amp;Rcvs)</argsstring>
        <name>doHandShake</name>
        <qualifiedname>amrex::doHandShake</qualifiedname>
        <param>
          <type>const std::map&lt; int, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; char &gt; &gt; &amp;</type>
          <declname>not_ours</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> &gt; &amp;</type>
          <declname>Snds</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> &gt; &amp;</type>
          <declname>Rcvs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.cpp" line="25" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.cpp" bodystart="25" bodyend="48" declfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.H" declline="14" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a55d2a814fe7ad70c3e7af12cad0e7c87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref></type>
        <definition>Long amrex::doHandShakeLocal</definition>
        <argsstring>(const std::map&lt; int, Vector&lt; char &gt; &gt; &amp;not_ours, const Vector&lt; int &gt; &amp;neighbor_procs, Vector&lt; Long &gt; &amp;Snds, Vector&lt; Long &gt; &amp;Rcvs)</argsstring>
        <name>doHandShakeLocal</name>
        <qualifiedname>amrex::doHandShakeLocal</qualifiedname>
        <param>
          <type>const std::map&lt; int, <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; char &gt; &gt; &amp;</type>
          <declname>not_ours</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>neighbor_procs</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> &gt; &amp;</type>
          <declname>Snds</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="group__amrex__arithmetic__types_1gace9d72971c815f54ed3af5df4e615781" kindref="member">Long</ref> &gt; &amp;</type>
          <declname>Rcvs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.cpp" line="50" column="10" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.cpp" bodystart="50" bodyend="94" declfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleMPIUtil.H" declline="17" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad16aed2aad9694b2064fd96f14e6d0ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceSum</definition>
        <argsstring>(PC const &amp;pc, F &amp;&amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates over all particles on all levels. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Sum&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="82" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="82" bodyend="86"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a815c9e3a27fda0bb93b4c3803412cbc3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceSum</definition>
        <argsstring>(PC const &amp;pc, int lev, F &amp;&amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates only on the specified level. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Sum&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev</parametername>
</parameternamelist>
<parameterdescription>
<para>the level to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="130" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="130" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a749e21912135685c1e0dccee76160700" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceSum</definition>
        <argsstring>(PC const &amp;pc, int lev_min, int lev_max, F const &amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceSum</name>
        <qualifiedname>amrex::ReduceSum</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates from the specified lev_min to lev_max. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Sum&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_min</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_max</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>sm<sp/>=<sp/><ref refid="namespaceamrex_1aee63624c66220385d3ab86b7f68ae1c4" kindref="member">amrex::ReduceSum</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="179" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="179" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a74a996e9f3bda0e5439b1d8ad3dcbee8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceMax</definition>
        <argsstring>(PC const &amp;pc, F &amp;&amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates over all particles on all levels. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Max&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="284" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="284" bodyend="288"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0a570bc96bd20a1baa3ba4c9a2451f90" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceMax</definition>
        <argsstring>(PC const &amp;pc, int lev, F &amp;&amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates only on the specified level. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Mas&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev</parametername>
</parameternamelist>
<parameterdescription>
<para>the level to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="333" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="333" bodyend="337"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6876c3b4c5f30494ee90160379b0840d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceMax</definition>
        <argsstring>(PC const &amp;pc, int lev_min, int lev_max, F const &amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceMax</name>
        <qualifiedname>amrex::ReduceMax</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates from the specified lev_min to lev_max. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Max&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_min</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_max</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mx<sp/>=<sp/><ref refid="namespaceamrex_1a157fdc4ac63d7f4d21a5df4b4151eb28" kindref="member">amrex::ReduceMax</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="382" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="382" bodyend="445"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acc57040cbed1b6d1ff87548fb5787b09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceMin</definition>
        <argsstring>(PC const &amp;pc, F &amp;&amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates over all particles on all levels. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Min&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="488" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="488" bodyend="492"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab12e292ac9ba04a75a85b619037c4d5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceMin</definition>
        <argsstring>(PC const &amp;pc, int lev, F &amp;&amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates only on the specified level. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Min&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev</parametername>
</parameternamelist>
<parameterdescription>
<para>the level to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="536" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="536" bodyend="540"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a82424dd00536c6be9f60e1e3eb145db2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto amrex::ReduceMin</definition>
        <argsstring>(PC const &amp;pc, int lev_min, int lev_max, F const &amp;f) -&gt; decltype(particle_detail::call_f(f, typename PC::ConstPTDType(), int()))</argsstring>
        <name>ReduceMin</name>
        <qualifiedname>amrex::ReduceMin</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates from the specified lev_min to lev_max. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;Min&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_min</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_max</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.rdata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.idata(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>mn<sp/>=<sp/><ref refid="namespaceamrex_1a94a27ca9a492d6d0f17996924e1b1745" kindref="member">amrex::ReduceMin</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/><ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.rdata(0)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="585" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="585" bodyend="648"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa175f510a09bbc1252a4e1b8f3ac5250" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalAnd</definition>
        <argsstring>(PC const &amp;pc, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalAnd</name>
        <qualifiedname>amrex::ReduceLogicalAnd</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates over all particles on all levels. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;LogicalAnd&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.id(i).<ref refid="namespaceamrex_1_1particle__impl_1a33d1b5ccc695ebc30eaf322a52060a8c" kindref="member">is_valid</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="691" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="691" bodyend="694"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2e4d86e52a629511e02bff646ca60b59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalAnd</definition>
        <argsstring>(PC const &amp;pc, int lev, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalAnd</name>
        <qualifiedname>amrex::ReduceLogicalAnd</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates only on the specified level. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;LogicalAnd&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev</parametername>
</parameternamelist>
<parameterdescription>
<para>the level to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.id(i).<ref refid="namespaceamrex_1_1particle__impl_1a33d1b5ccc695ebc30eaf322a52060a8c" kindref="member">is_valid</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="738" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="738" bodyend="741"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acc20a37ec958213a9ebffccb0ef3a50b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalAnd</definition>
        <argsstring>(PC const &amp;pc, int lev_min, int lev_max, F const &amp;f)</argsstring>
        <name>ReduceLogicalAnd</name>
        <qualifiedname>amrex::ReduceLogicalAnd</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates from the specified lev_min to lev_max. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;LogicalAnd&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_min</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_max</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a3866c459fc8c798d5a19fa747a3500b5" kindref="member">amrex::ReduceLogicalAnd</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ptd.id(i).<ref refid="namespaceamrex_1_1particle__impl_1a33d1b5ccc695ebc30eaf322a52060a8c" kindref="member">is_valid</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="786" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="786" bodyend="846"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a43f13583043013b5751afe1e193cc8b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalOr</definition>
        <argsstring>(PC const &amp;pc, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalOr</name>
        <qualifiedname>amrex::ReduceLogicalOr</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates over all particles on all levels. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;LogicalOr&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!ptd.id(i).<ref refid="namespaceamrex_1_1particle__impl_1a33d1b5ccc695ebc30eaf322a52060a8c" kindref="member">is_valid</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="889" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="889" bodyend="892"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a18f76938d120a4d9891cc99e67cab771" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalOr</definition>
        <argsstring>(PC const &amp;pc, int lev, F &amp;&amp;f)</argsstring>
        <name>ReduceLogicalOr</name>
        <qualifiedname>amrex::ReduceLogicalOr</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates only on the specified level. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;LogicalOr&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev</parametername>
</parameternamelist>
<parameterdescription>
<para>the level to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!ptd.id(i).<ref refid="namespaceamrex_1_1particle__impl_1a33d1b5ccc695ebc30eaf322a52060a8c" kindref="member">is_valid</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="936" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="936" bodyend="939"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3f36471bf6b32ec7460e70b9e4a1f91d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::ReduceLogicalOr</definition>
        <argsstring>(PC const &amp;pc, int lev_min, int lev_max, F const &amp;f)</argsstring>
        <name>ReduceLogicalOr</name>
        <qualifiedname>amrex::ReduceLogicalOr</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates from the specified lev_min to lev_max. </para>
        </briefdescription>
        <detaileddescription>
<para>This version uses &quot;LogicalOr&quot; as the reduction operation. The quantity reduced over is an arbitrary function of a &quot;superparticle&quot;, which contains all the data in the particle type, whether it is stored in AoS or SoA form.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_min</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_max</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle. Example forms: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!p.id().is_valid();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rv<sp/>=<sp/><ref refid="namespaceamrex_1a86ff43c965c29ca6c76704135c773345" kindref="member">amrex::ReduceLogicalOr</ref>(pc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1aac52ee54727d35b2d0033b119a991618" kindref="member">AMREX_GPU_HOST_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!ptd.id(i).<ref refid="namespaceamrex_1_1particle__impl_1a33d1b5ccc695ebc30eaf322a52060a8c" kindref="member">is_valid</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="984" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="984" bodyend="1045"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a8d32380d1bccbedf1b24bd2c1bb7a1da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class RD</type>
          </param>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class ReduceOps</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>RD::Type</type>
        <definition>RD::Type amrex::ParticleReduce</definition>
        <argsstring>(PC const &amp;pc, F &amp;&amp;f, ReduceOps &amp;reduce_ops)</argsstring>
        <name>ParticleReduce</name>
        <qualifiedname>amrex::ParticleReduce</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref> &amp;</type>
          <declname>reduce_ops</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates over all particles on all levels. </para>
        </briefdescription>
        <detaileddescription>
<para>This version can operate on a <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> worth of data at once. It also takes an arbitrary tuple of reduction operators.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para>Unlike the other reduction functions in this file, this version does not respect the Gpu::launchRegion flag. If <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> is built with GPU support, this reduction will always be done on the device.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RD</parametername>
</parameternamelist>
<parameterdescription>
<para>an <ref refid="classamrex_1_1ReduceData" kindref="compound">amrex::ReduceData</ref> type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref> type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle, see below for example forms. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>reduce_ops</parametername>
</parameternamelist>
<parameterdescription>
<para>specifies the reduction operations for each tuple element</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Example usage: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>p.rdata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>p.rdata(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>p.idata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>p.rdata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>p.rdata(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>p.idata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>ptd.rdata(1)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>ptd.rdata(2)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>ptd.idata(1)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="1112" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="1112" bodyend="1115"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af42436c4813e6fedd6dd7a5c73581b63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class RD</type>
          </param>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class ReduceOps</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>RD::Type</type>
        <definition>RD::Type amrex::ParticleReduce</definition>
        <argsstring>(PC const &amp;pc, int lev, F &amp;&amp;f, ReduceOps &amp;reduce_ops)</argsstring>
        <name>ParticleReduce</name>
        <qualifiedname>amrex::ParticleReduce</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref> &amp;</type>
          <declname>reduce_ops</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates only on the specified level. </para>
        </briefdescription>
        <detaileddescription>
<para>This version can operate on a <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> worth of data at once. It also takes an arbitrary tuple of reduction operators.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para>Unlike the other reduction functions in this file, this version does not respect the Gpu::launchRegion flag. If <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> is built with GPU support, this reduction will always be done on the device.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RD</parametername>
</parameternamelist>
<parameterdescription>
<para>an <ref refid="classamrex_1_1ReduceData" kindref="compound">amrex::ReduceData</ref> type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref> type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev</parametername>
</parameternamelist>
<parameterdescription>
<para>the level to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle, see below for example forms. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>reduce_ops</parametername>
</parameternamelist>
<parameterdescription>
<para>specifies the reduction operations for each tuple element</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Example usage: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>p.rdata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>p.rdata(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>p.idata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>p.rdata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>p.rdata(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>p.idata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>ptd.rdata(1)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>ptd.rdata(2)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>ptd.idata(1)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="1183" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="1183" bodyend="1186"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a3762aae68593d892d48ede3cb6e317a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class RD</type>
          </param>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class ReduceOps</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>RD::Type</type>
        <definition>RD::Type amrex::ParticleReduce</definition>
        <argsstring>(PC const &amp;pc, int lev_min, int lev_max, F const &amp;f, ReduceOps &amp;reduce_ops)</argsstring>
        <name>ParticleReduce</name>
        <qualifiedname>amrex::ParticleReduce</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref> &amp;</type>
          <declname>reduce_ops</declname>
        </param>
        <briefdescription>
<para>A general reduction method for the particles in a ParticleContainer that can run on either CPUs or GPUs. This version operates from the specified lev_min to lev_max. </para>
        </briefdescription>
        <detaileddescription>
<para>This version can operate on a <ref refid="classamrex_1_1GpuTuple" kindref="compound">GpuTuple</ref> worth of data at once. It also takes an arbitrary tuple of reduction operators.</para>
<para>Note that there is no MPI reduction performed at the end of this operation. Users should manually call the MPI reduction operations described in <ref refid="namespaceamrex_1_1ParallelDescriptor" kindref="compound">ParallelDescriptor</ref> if they want that behavior.</para>
<para>Unlike the other reduction functions in this file, this version does not respect the Gpu::launchRegion flag. If <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> is built with GPU support, this reduction will always be done on the device.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RD</parametername>
</parameternamelist>
<parameterdescription>
<para>an <ref refid="classamrex_1_1ReduceData" kindref="compound">amrex::ReduceData</ref> type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername><ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classamrex_1_1ReduceOps" kindref="compound">ReduceOps</ref> type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the ParticleContainer to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_min</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_max</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum level to include </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that operates on a single particle, see below for example forms. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>reduce_ops</parametername>
</parameternamelist>
<parameterdescription>
<para>specifies the reduction operations for each tuple element</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Example usage: <programlisting filename=".cpp"><codeline><highlight class="keyword">using<sp/></highlight><highlight class="normal">PType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ParticleType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PType&amp;<sp/>p)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>p.rdata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>p.rdata(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>p.idata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">SPType<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::SuperParticleType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SPType&amp;<sp/>p)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>p.rdata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>p.rdata(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>p.idata(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">ConstPTDType<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>PC::ConstPTDType;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classamrex_1_1ReduceOps" kindref="compound">amrex::ReduceOps&lt;ReduceOpSum, ReduceOpMin, ReduceOpMax&gt;</ref><sp/>reduce_ops;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>amrex::ParticleReduce&lt;ReduceData&lt;amrex::Real,<sp/>amrex::Real,int&gt;&gt;<sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pc,<sp/>[=]<sp/><ref refid="AMReX__GpuQualifiers_8H_1a4e626ebf06898d71a9e0790877f1694f" kindref="member">AMREX_GPU_DEVICE</ref><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ConstPTDType&amp;<sp/>ptd,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/></highlight><highlight class="keyword">noexcept</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><ref refid="classamrex_1_1GpuTuple" kindref="compound">amrex::GpuTuple&lt;amrex::Real,amrex::Real,int&gt;</ref></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>a<sp/>=<sp/>ptd.rdata(1)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref><sp/>b<sp/>=<sp/>ptd.rdata(2)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>c<sp/>=<sp/>ptd.idata(1)[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{a,<sp/>b,<sp/>c};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>},<sp/>reduce_ops);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" line="1255" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleReduce.H" bodystart="1255" bodyend="1285"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a216c6e10305fbc5d67ea5f3b926a7785" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T_ParticleType</type>
          </param>
          <param>
            <type>int</type>
            <declname>NAR</declname>
            <defname>NAR</defname>
          </param>
          <param>
            <type>int</type>
            <declname>NAI</declname>
            <defname>NAI</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::copyParticle</definition>
        <argsstring>(const ParticleTileData&lt; T_ParticleType, NAR, NAI &gt; &amp;dst, const ConstParticleTileData&lt; T_ParticleType, NAR, NAI &gt; &amp;src, int src_i, int dst_i) noexcept</argsstring>
        <name>copyParticle</name>
        <qualifiedname>amrex::copyParticle</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleTileData" kindref="compound">ParticleTileData</ref>&lt; T_ParticleType, NAR, NAI &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1ConstParticleTileData" kindref="compound">ConstParticleTileData</ref>&lt; T_ParticleType, NAR, NAI &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>src_i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dst_i</declname>
        </param>
        <briefdescription>
<para>A general single particle copying routine that can run on the GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NSR</parametername>
</parameternamelist>
<parameterdescription>
<para>number of extra reals in the particle struct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NSI</parametername>
</parameternamelist>
<parameterdescription>
<para>number of extra ints in the particle struct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NAR</parametername>
</parameternamelist>
<parameterdescription>
<para>number of reals in the struct-of-arrays </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NAI</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ints in the struct-of-arrays</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_i</parametername>
</parameternamelist>
<parameterdescription>
<para>the index in the source to read from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_i</parametername>
</parameternamelist>
<parameterdescription>
<para>the index in the destination to write to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="31" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="31" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a94844d44d7cdfc2b8869c2e980c9b2e1" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T_ParticleType</type>
          </param>
          <param>
            <type>int</type>
            <declname>NAR</declname>
            <defname>NAR</defname>
          </param>
          <param>
            <type>int</type>
            <declname>NAI</declname>
            <defname>NAI</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::copyParticle</definition>
        <argsstring>(const ParticleTileData&lt; T_ParticleType, NAR, NAI &gt; &amp;dst, const ParticleTileData&lt; T_ParticleType, NAR, NAI &gt; &amp;src, int src_i, int dst_i) noexcept</argsstring>
        <name>copyParticle</name>
        <qualifiedname>amrex::copyParticle</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleTileData" kindref="compound">ParticleTileData</ref>&lt; T_ParticleType, NAR, NAI &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleTileData" kindref="compound">ParticleTileData</ref>&lt; T_ParticleType, NAR, NAI &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>src_i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dst_i</declname>
        </param>
        <briefdescription>
<para>A general single particle copying routine that can run on the GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NSR</parametername>
</parameternamelist>
<parameterdescription>
<para>number of extra reals in the particle struct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NSI</parametername>
</parameternamelist>
<parameterdescription>
<para>number of extra ints in the particle struct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NAR</parametername>
</parameternamelist>
<parameterdescription>
<para>number of reals in the struct-of-arrays </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NAI</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ints in the struct-of-arrays</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_i</parametername>
</parameternamelist>
<parameterdescription>
<para>the index in the source to read from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_i</parametername>
</parameternamelist>
<parameterdescription>
<para>the index in the destination to write to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="77" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="77" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a10d329cc09ad03a0cb6630027e6c8f2b" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T_ParticleType</type>
          </param>
          <param>
            <type>int</type>
            <declname>NAR</declname>
            <defname>NAR</defname>
          </param>
          <param>
            <type>int</type>
            <declname>NAI</declname>
            <defname>NAI</defname>
          </param>
        </templateparamlist>
        <type>__host__ __device__ void</type>
        <definition>__host__ __device__ void amrex::swapParticle</definition>
        <argsstring>(const ParticleTileData&lt; T_ParticleType, NAR, NAI &gt; &amp;dst, const ParticleTileData&lt; T_ParticleType, NAR, NAI &gt; &amp;src, int src_i, int dst_i) noexcept</argsstring>
        <name>swapParticle</name>
        <qualifiedname>amrex::swapParticle</qualifiedname>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleTileData" kindref="compound">ParticleTileData</ref>&lt; T_ParticleType, NAR, NAI &gt; &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1ParticleTileData" kindref="compound">ParticleTileData</ref>&lt; T_ParticleType, NAR, NAI &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>int</type>
          <declname>src_i</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dst_i</declname>
        </param>
        <briefdescription>
<para>A general single particle swapping routine that can run on the GPU. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>NSR</parametername>
</parameternamelist>
<parameterdescription>
<para>number of extra reals in the particle struct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NSI</parametername>
</parameternamelist>
<parameterdescription>
<para>number of extra ints in the particle struct </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NAR</parametername>
</parameternamelist>
<parameterdescription>
<para>number of reals in the struct-of-arrays </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NAI</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ints in the struct-of-arrays</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_i</parametername>
</parameternamelist>
<parameterdescription>
<para>the index in the source to read from </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_i</parametername>
</parameternamelist>
<parameterdescription>
<para>the index in the destination to write to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="119" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="119" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2c694692aaba3c4e23ab3067eab1ba44" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::copyParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src) noexcept</argsstring>
        <name>copyParticles</name>
        <qualifiedname>amrex::copyParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
<para>Copy particles from src to dst. This version copies all the particles, writing them to the beginning of dst. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="161" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="161" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aebeffed6a37edc4d909acc6ab5cbbe83" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::copyParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, Index src_start, Index dst_start, N n) noexcept</argsstring>
        <name>copyParticles</name>
        <qualifiedname>amrex::copyParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>src_start</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>dst_start</declname>
        </param>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Copy particles from src to dst. This version copies n particles starting at index src_start, writing the result starting at dst_start. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>the size type, e.g. Long</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start reading particles from src </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start writing particles to dst </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of particles to write </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="185" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="185" bodyend="197"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae03ee3a195d7ee3ebcb19d20f9fdce73" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::transformParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, F &amp;&amp;f) noexcept</argsstring>
        <name>transformParticles</name>
        <qualifiedname>amrex::transformParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Apply the function f to all the particles in src, writing the result to dst. This version does all the particles in src. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the function that will be applied to each particle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="213" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="213" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6f4df8f3df0bb529d0f348e93afdb949" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::transformParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, Index src_start, Index dst_start, N n, F const &amp;f) noexcept</argsstring>
        <name>transformParticles</name>
        <qualifiedname>amrex::transformParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>src_start</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>dst_start</declname>
        </param>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Apply the function f to particles in src, writing the result to dst. This version applies the function to n particles starting at index src_start, writing the result starting at dst_start. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>the size type, e.g. Long </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start reading particles from src </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start writing particles to dst </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of particles </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the function that will be applied to each particle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="240" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="240" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5926a5d20c4f511675c02ec18cc7c87a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile1</type>
          </param>
          <param>
            <type>typename DstTile2</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::transformParticles</definition>
        <argsstring>(DstTile1 &amp;dst1, DstTile2 &amp;dst2, const SrcTile &amp;src, F &amp;&amp;f) noexcept</argsstring>
        <name>transformParticles</name>
        <qualifiedname>amrex::transformParticles</qualifiedname>
        <param>
          <type>DstTile1 &amp;</type>
          <declname>dst1</declname>
        </param>
        <param>
          <type>DstTile2 &amp;</type>
          <declname>dst2</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Apply the function f to all the particles in src, writing the results to dst1 and dst2. This version does all the particles in src. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile1</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst1 particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DstTile2</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst2 particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst1</parametername>
</parameternamelist>
<parameterdescription>
<para>the first destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst2</parametername>
</parameternamelist>
<parameterdescription>
<para>the second destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the function that will be applied to each particle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="270" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="270" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a6c20549dd945261df4167a72c1c4dacb" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile1</type>
          </param>
          <param>
            <type>typename DstTile2</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::transformParticles</definition>
        <argsstring>(DstTile1 &amp;dst1, DstTile2 &amp;dst2, const SrcTile &amp;src, Index src_start, Index dst1_start, Index dst2_start, N n, F const &amp;f) noexcept</argsstring>
        <name>transformParticles</name>
        <qualifiedname>amrex::transformParticles</qualifiedname>
        <param>
          <type>DstTile1 &amp;</type>
          <declname>dst1</declname>
        </param>
        <param>
          <type>DstTile2 &amp;</type>
          <declname>dst2</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>src_start</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>dst1_start</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>dst2_start</declname>
        </param>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Apply the function f to particles in src, writing the results to dst1 and dst2. This version applies the function to n particles starting at index src_start, writing the result starting at dst1_start and dst2_start. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile1</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst1 particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DstTile2</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst2 particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>the size type, e.g. Long </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst1</parametername>
</parameternamelist>
<parameterdescription>
<para>the first destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst2</parametername>
</parameternamelist>
<parameterdescription>
<para>the second destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start reading particles from src </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst1_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start writing particles to dst1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst2_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start writing particles to dst2 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of particles </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the function that will be applied to each particle </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="301" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="301" bodyend="314"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a86fc8a08b6a63681e7751ac0b20bd96b" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>Index</type>
        <definition>Index amrex::filterParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, const Index *mask) noexcept</argsstring>
        <name>filterParticles</name>
        <qualifiedname>amrex::filterParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const Index *</type>
          <declname>mask</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst based on the value of mask. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the mask - 1 means copy, 0 means don&apos;t copy </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="330" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="330" bodyend="333"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0484051ab2f4dc9ebed16cb4f0ca2817" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>Index</type>
        <definition>Index amrex::filterParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, const Index *mask, Index src_start, Index dst_start, N n) noexcept</argsstring>
        <name>filterParticles</name>
        <qualifiedname>amrex::filterParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const Index *</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>src_start</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>dst_start</declname>
        </param>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst based on the value of mask. This version conditionally copies n particles starting at index src_start, writing the result starting at dst_start. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the mask - 1 means copy, 0 means don&apos;t copy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start reading particles from src </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start writing particles to dst </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of particles to apply the operation to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="354" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="354" bodyend="376"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a33445242f6db048d6f630ee51db51c66" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_pointer_v&lt; std::decay_t&lt; Pred &gt; &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::filterParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, Pred &amp;&amp;p) noexcept</argsstring>
        <name>filterParticles</name>
        <qualifiedname>amrex::filterParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst based on a predicate. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function - particles will be copied if p returns true </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="392" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="392" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a31d02dac6559bf01b7ffc7080e11b6b3" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_pointer_v&lt; std::decay_t&lt; Pred &gt; &gt;, Index &gt;</type>
            <declname>nvccfoo</declname>
            <defname>nvccfoo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>Index</type>
        <definition>Index amrex::filterParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, Pred const &amp;p, Index src_start, Index dst_start, N n) noexcept</argsstring>
        <name>filterParticles</name>
        <qualifiedname>amrex::filterParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Pred const &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>src_start</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>dst_start</declname>
        </param>
        <param>
          <type>N</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst based on a predicate. This version conditionally copies n particles starting at index src_start, writing the result starting at dst_start. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function - particles will be copied if p returns true </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start reading particles from src </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start writing particles to dst </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of particles to apply the operation to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="416" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="416" bodyend="435"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a445eaaec6b8c6d91c449c1807b12ae6f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>Index</type>
        <definition>Index amrex::filterAndTransformParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, Index *mask, F const &amp;f, Index src_start, Index dst_start) noexcept</argsstring>
        <name>filterAndTransformParticles</name>
        <qualifiedname>amrex::filterAndTransformParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Index *</type>
          <declname>mask</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>src_start</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>dst_start</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst based on the value of mask. A transformation will also be applied to the particles on copy. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>the transform function type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_start</parametername>
</parameternamelist>
<parameterdescription>
<para>starting index of source </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_start</parametername>
</parameternamelist>
<parameterdescription>
<para>starting index of destination </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the mask - 1 means copy, 0 means don&apos;t copy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>defines the transformation that will be applied to the particles on copy </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="456" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="456" bodyend="482"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af6ec82174b9e85180e43d20c64b52b26" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>Index</type>
        <definition>Index amrex::filterAndTransformParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, Index *mask, F &amp;&amp;f) noexcept</argsstring>
        <name>filterAndTransformParticles</name>
        <qualifiedname>amrex::filterAndTransformParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Index *</type>
          <declname>mask</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst based on the value of mask. A transformation will also be applied to the particles on copy. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>the transform function type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the mask - 1 means copy, 0 means don&apos;t copy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>defines the transformation that will be applied to the particles on copy </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="501" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="501" bodyend="504"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab5f493bb769f1f402add59c4dfb6df1a" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_pointer_v&lt; std::decay_t&lt; Pred &gt; &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::filterAndTransformParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, Pred &amp;&amp;p, F &amp;&amp;f) noexcept</argsstring>
        <name>filterAndTransformParticles</name>
        <qualifiedname>amrex::filterAndTransformParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst based on a predicate. A transformation will also be applied to the particles on copy. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>the transform function type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function - particles will be copied if p returns true </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>defines the transformation that will be applied to the particles on copy </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="523" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="523" bodyend="526"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5e262a7d63bd04c8d334eeaaa8eb53b4" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile1</type>
          </param>
          <param>
            <type>typename DstTile2</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>Index</type>
        <definition>Index amrex::filterAndTransformParticles</definition>
        <argsstring>(DstTile1 &amp;dst1, DstTile2 &amp;dst2, const SrcTile &amp;src, Index *mask, F const &amp;f) noexcept</argsstring>
        <name>filterAndTransformParticles</name>
        <qualifiedname>amrex::filterAndTransformParticles</qualifiedname>
        <param>
          <type>DstTile1 &amp;</type>
          <declname>dst1</declname>
        </param>
        <param>
          <type>DstTile2 &amp;</type>
          <declname>dst2</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Index *</type>
          <declname>mask</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst1 and dst2 based on the value of mask. A transformation will also be applied to the particles on copy. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile1</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst1 particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DstTile2</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst2 particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>the transform function type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst1</parametername>
</parameternamelist>
<parameterdescription>
<para>the first destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst2</parametername>
</parameternamelist>
<parameterdescription>
<para>the second destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the mask - 1 means copy, 0 means don&apos;t copy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>defines the transformation that will be applied to the particles on copy </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="547" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="547" bodyend="571"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a7d643abf32742bb6d7d758f835f8ac83" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile1</type>
          </param>
          <param>
            <type>typename DstTile2</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_pointer_v&lt; std::decay_t&lt; Pred &gt; &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::filterAndTransformParticles</definition>
        <argsstring>(DstTile1 &amp;dst1, DstTile2 &amp;dst2, const SrcTile &amp;src, Pred const &amp;p, F &amp;&amp;f) noexcept</argsstring>
        <name>filterAndTransformParticles</name>
        <qualifiedname>amrex::filterAndTransformParticles</qualifiedname>
        <param>
          <type>DstTile1 &amp;</type>
          <declname>dst1</declname>
        </param>
        <param>
          <type>DstTile2 &amp;</type>
          <declname>dst2</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Pred const &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst1 and dst2 based on a predicate. A transformation will also be applied to the particles on copy. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile1</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst1 particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DstTile2</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst2 particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>the transform function type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst1</parametername>
</parameternamelist>
<parameterdescription>
<para>the first destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst2</parametername>
</parameternamelist>
<parameterdescription>
<para>the second destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function - particles will be copied if p returns true </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>defines the transformation that will be applied to the particles on copy </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="592" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="592" bodyend="612"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acad355709025876e4bace25065cedcec" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DstTile</type>
          </param>
          <param>
            <type>typename SrcTile</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_pointer_v&lt; std::decay_t&lt; Pred &gt; &gt;, Index &gt;</type>
            <declname>nvccfoo</declname>
            <defname>nvccfoo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>Index</type>
        <definition>Index amrex::filterAndTransformParticles</definition>
        <argsstring>(DstTile &amp;dst, const SrcTile &amp;src, Pred const &amp;p, F &amp;&amp;f, Index src_start, Index dst_start) noexcept</argsstring>
        <name>filterAndTransformParticles</name>
        <qualifiedname>amrex::filterAndTransformParticles</qualifiedname>
        <param>
          <type>DstTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const SrcTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>Pred const &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>src_start</declname>
        </param>
        <param>
          <type>Index</type>
          <declname>dst_start</declname>
        </param>
        <briefdescription>
<para>Conditionally copy particles from src to dst based on a predicate. This version conditionally copies n particles starting at index src_start, writing the result starting at dst_start. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>DstTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the dst particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>SrcTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the src particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a function object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate function - particles will be copied if p returns true </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the function that will be applied to particles </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start reading particles from src </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst_start</parametername>
</parameternamelist>
<parameterdescription>
<para>the offset at which to start writing particles to dst </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="634" column="7" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="634" bodyend="654"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab75c7a4946d605a7072d64407df6a6d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PTile</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::gatherParticles</definition>
        <argsstring>(PTile &amp;dst, const PTile &amp;src, N np, const Index *inds)</argsstring>
        <name>gatherParticles</name>
        <qualifiedname>amrex::gatherParticles</qualifiedname>
        <param>
          <type>PTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const PTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>N</type>
          <declname>np</declname>
        </param>
        <param>
          <type>const Index *</type>
          <declname>inds</declname>
        </param>
        <briefdescription>
<para>Gather particles copies particles into contiguous order from an arbitrary order. Specifically, the particle at the index inds[i] in src will be copied to the index i in dst. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>the size type, e.g. Long </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>np</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of particles </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inds</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the permutation array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="674" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="674" bodyend="685"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae05ffbbcc005cc8c081b859226222c78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PTile</type>
          </param>
          <param>
            <type>typename N</type>
          </param>
          <param>
            <type>typename Index</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; Index &gt;, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::scatterParticles</definition>
        <argsstring>(PTile &amp;dst, const PTile &amp;src, N np, const Index *inds)</argsstring>
        <name>scatterParticles</name>
        <qualifiedname>amrex::scatterParticles</qualifiedname>
        <param>
          <type>PTile &amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const PTile &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>N</type>
          <declname>np</declname>
        </param>
        <param>
          <type>const Index *</type>
          <declname>inds</declname>
        </param>
        <briefdescription>
<para>Scatter particles copies particles from contiguous order into an arbitrary order. Specifically, the particle at the index i in src will be copied to the index inds[i] in dst. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PTile</parametername>
</parameternamelist>
<parameterdescription>
<para>the particle tile type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>the size type, e.g. Long </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index type, e.g. unsigned int</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the destination tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>the source tile </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>np</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of particles </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inds</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the permutation array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" line="704" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleTransformation.H" bodystart="704" bodyend="715"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad2e9cbb8f28bbbba7378ec7bf4654b89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
        <definition>IntVect amrex::computeRefFac</definition>
        <argsstring>(const ParGDBBase *a_gdb, int src_lev, int lev)</argsstring>
        <name>computeRefFac</name>
        <qualifiedname>amrex::computeRefFac</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1ParGDBBase" kindref="compound">ParGDBBase</ref> *</type>
          <declname>a_gdb</declname>
        </param>
        <param>
          <type>int</type>
          <declname>src_lev</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.cpp" line="6" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.cpp" bodystart="6" bodyend="20" declfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" declline="743" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac6d35da48f520c8ae3f429aee03601c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt;</type>
        <definition>Vector&lt; int &gt; amrex::computeNeighborProcs</definition>
        <argsstring>(const ParGDBBase *a_gdb, int ngrow)</argsstring>
        <name>computeNeighborProcs</name>
        <qualifiedname>amrex::computeNeighborProcs</qualifiedname>
        <param>
          <type>const <ref refid="classamrex_1_1ParGDBBase" kindref="compound">ParGDBBase</ref> *</type>
          <declname>a_gdb</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ngrow</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.cpp" line="22" column="8" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.cpp" bodystart="22" bodyend="66" declfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" declline="745" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1acad483c5f0e30f9cd471ad05e1920320" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleIterator&lt; Iterator &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::numParticlesOutOfRange</definition>
        <argsstring>(Iterator const &amp;pti, int nGrow)</argsstring>
        <name>numParticlesOutOfRange</name>
        <qualifiedname>amrex::numParticlesOutOfRange</qualifiedname>
        <param>
          <type>Iterator const &amp;</type>
          <declname>pti</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nGrow</declname>
        </param>
        <briefdescription>
<para>Returns the number of particles that are more than nGrow cells from the box correspond to the input iterator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>an <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> ParticleIterator</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pti</parametername>
</parameternamelist>
<parameterdescription>
<para>the iterator pointing to the current grid/tile to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nGrow</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of grow cells allowed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="34" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="34" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a76c9efa7ebf0969d1986d57f86c1882b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleIterator&lt; Iterator &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::numParticlesOutOfRange</definition>
        <argsstring>(Iterator const &amp;pti, IntVect nGrow)</argsstring>
        <name>numParticlesOutOfRange</name>
        <qualifiedname>amrex::numParticlesOutOfRange</qualifiedname>
        <param>
          <type>Iterator const &amp;</type>
          <declname>pti</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
          <declname>nGrow</declname>
        </param>
        <briefdescription>
<para>Returns the number of particles that are more than nGrow cells from the box correspond to the input iterator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>an <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> ParticleIterator</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pti</parametername>
</parameternamelist>
<parameterdescription>
<para>the iterator pointing to the current grid/tile to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nGrow</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of grow cells allowed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="52" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="52" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a9624cde7b9ad11a1692714a8a2cf4d5c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::numParticlesOutOfRange</definition>
        <argsstring>(PC const &amp;pc, int nGrow)</argsstring>
        <name>numParticlesOutOfRange</name>
        <qualifiedname>amrex::numParticlesOutOfRange</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nGrow</declname>
        </param>
        <briefdescription>
<para>Returns the number of particles that are more than nGrow cells from their assigned box. </para>
        </briefdescription>
        <detaileddescription>
<para>This version tests over all levels.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>a type of <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> particle container.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the particle container to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nGrow</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of grow cells allowed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="98" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="98" bodyend="101"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a16b2ad610aeda065996254dcb64e1210" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::numParticlesOutOfRange</definition>
        <argsstring>(PC const &amp;pc, IntVect nGrow)</argsstring>
        <name>numParticlesOutOfRange</name>
        <qualifiedname>amrex::numParticlesOutOfRange</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
          <declname>nGrow</declname>
        </param>
        <briefdescription>
<para>Returns the number of particles that are more than nGrow cells from their assigned box. </para>
        </briefdescription>
        <detaileddescription>
<para>This version tests over all levels.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>a type of <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> particle container.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the particle container to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nGrow</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of grow cells allowed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="117" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="117" bodyend="120"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af026262a284dc45b1a535e1d2c3da3d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::numParticlesOutOfRange</definition>
        <argsstring>(PC const &amp;pc, int lev_min, int lev_max, int nGrow)</argsstring>
        <name>numParticlesOutOfRange</name>
        <qualifiedname>amrex::numParticlesOutOfRange</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nGrow</declname>
        </param>
        <briefdescription>
<para>Returns the number of particles that are more than nGrow cells from their assigned box. </para>
        </briefdescription>
        <detaileddescription>
<para>This version goes over only the specified levels</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>a type of <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> particle container.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the particle container to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_min</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum level to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_max</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum level to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nGrow</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of grow cells allowed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="138" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="138" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1aa69e2d3ab61d58e37142f8ca2607da7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::numParticlesOutOfRange</definition>
        <argsstring>(PC const &amp;pc, int lev_min, int lev_max, IntVect nGrow)</argsstring>
        <name>numParticlesOutOfRange</name>
        <qualifiedname>amrex::numParticlesOutOfRange</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
          <declname>nGrow</declname>
        </param>
        <briefdescription>
<para>Returns the number of particles that are more than nGrow cells from their assigned box. </para>
        </briefdescription>
        <detaileddescription>
<para>This version goes over only the specified levels</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>PC</parametername>
</parameternamelist>
<parameterdescription>
<para>a type of <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> particle container.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>the particle container to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_min</parametername>
</parameternamelist>
<parameterdescription>
<para>the minimum level to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lev_max</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum level to test </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nGrow</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of grow cells allowed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="162" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="162" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a16d14242029243f06061d1e4f748331f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ int</type>
        <definition>__host__ __device__ int amrex::getTileIndex</definition>
        <argsstring>(const IntVect &amp;iv, const Box &amp;box, const bool a_do_tiling, const IntVect &amp;a_tile_size, Box &amp;tbx)</argsstring>
        <name>getTileIndex</name>
        <qualifiedname>amrex::getTileIndex</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>iv</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>a_do_tiling</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>a_tile_size</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>tbx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="184" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="184" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a5ab3a59d9c5c4f66d4bfd4f3f511c8a8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>__host__ __device__ int</type>
        <definition>__host__ __device__ int amrex::numTilesInBox</definition>
        <argsstring>(const Box &amp;box, const bool a_do_tiling, const IntVect &amp;a_tile_size)</argsstring>
        <name>numTilesInBox</name>
        <qualifiedname>amrex::numTilesInBox</qualifiedname>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>box</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>a_do_tiling</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref> &amp;</type>
          <declname>a_tile_size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="232" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="232" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1af56849c937022328312ec6fc10a35d9a" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
        <definition>__host__ __device__ IntVect amrex::getParticleCell</definition>
        <argsstring>(P const &amp;p, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;plo, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;dxi) noexcept</argsstring>
        <name>getParticleCell</name>
        <qualifiedname>amrex::getParticleCell</qualifiedname>
        <param>
          <type>P const &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>plo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>dxi</declname>
        </param>
        <briefdescription>
<para>Returns the cell index for a given particle using the provided lower bounds and cell sizes. </para>
        </briefdescription>
        <detaileddescription>
<para>This version indexes cells starting from 0 at the lower left corner of the provided lower bounds, i.e., it returns a local index.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>a type of <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> particle.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>the particle for which the cell index is calculated </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>plo</parametername>
</parameternamelist>
<parameterdescription>
<para>the low end of the domain </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dxi</parametername>
</parameternamelist>
<parameterdescription>
<para>cell sizes in each dimension </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="336" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="336" bodyend="345"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2f573c2b629469ce8b52bbdefbe37313" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
        <definition>__host__ __device__ IntVect amrex::getParticleCell</definition>
        <argsstring>(P const &amp;p, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;plo, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;dxi, const Box &amp;domain) noexcept</argsstring>
        <name>getParticleCell</name>
        <qualifiedname>amrex::getParticleCell</qualifiedname>
        <param>
          <type>P const &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>plo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>dxi</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
<para>Returns the cell index for a given particle using the provided lower bounds, cell sizes and global domain offset. </para>
        </briefdescription>
        <detaileddescription>
<para>This version indexes cells starting from 0 at the lower left corner of the simulation geometry, i.e., it returns a global index.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>a type of <ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> particle.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>the particle for which the cell index is calculated </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>plo</parametername>
</parameternamelist>
<parameterdescription>
<para>the low end of the domain </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dxi</parametername>
</parameternamelist>
<parameterdescription>
<para>cell sizes in each dimension </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>domain</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classamrex_1_1AMReX" kindref="compound">AMReX</ref> box in which the given particle resides </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="363" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="363" bodyend="371"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ae5e04ffcddb4c42852f7743f3d1da492" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PTD</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
        <definition>__host__ __device__ IntVect amrex::getParticleCell</definition>
        <argsstring>(PTD const &amp;ptd, int i, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;plo, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;dxi, const Box &amp;domain) noexcept</argsstring>
        <name>getParticleCell</name>
        <qualifiedname>amrex::getParticleCell</qualifiedname>
        <param>
          <type>PTD const &amp;</type>
          <declname>ptd</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>plo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>dxi</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="375" column="9" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="375" bodyend="391"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ab6a4931393d2ec5d04770f82497cf124" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ int</type>
        <definition>__host__ __device__ int amrex::getParticleGrid</definition>
        <argsstring>(P const &amp;p, amrex::Array4&lt; int &gt; const &amp;mask, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;plo, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;dxi, const Box &amp;domain) noexcept</argsstring>
        <name>getParticleGrid</name>
        <qualifiedname>amrex::getParticleGrid</qualifiedname>
        <param>
          <type>P const &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a8c21d74d3472963108631a36d5dbef0f" kindref="member">amrex::Array4</ref>&lt; int &gt; const &amp;</type>
          <declname>mask</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>plo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>dxi</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref> &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="409" column="5" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="409" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a55099b76aee88825e921746d0ec2480e" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>__host__ __device__ bool</type>
        <definition>__host__ __device__ bool amrex::enforcePeriodic</definition>
        <argsstring>(P &amp;p, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;plo, amrex::GpuArray&lt; amrex::Real, 3 &gt; const &amp;phi, amrex::GpuArray&lt; amrex::ParticleReal, 3 &gt; const &amp;rlo, amrex::GpuArray&lt; amrex::ParticleReal, 3 &gt; const &amp;rhi, amrex::GpuArray&lt; int, 3 &gt; const &amp;is_per) noexcept</argsstring>
        <name>enforcePeriodic</name>
        <qualifiedname>amrex::enforcePeriodic</qualifiedname>
        <param>
          <type>P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>plo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">amrex::Real</ref>, 3 &gt; const &amp;</type>
          <declname>phi</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">amrex::ParticleReal</ref>, 3 &gt; const &amp;</type>
          <declname>rlo</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">amrex::ParticleReal</ref>, 3 &gt; const &amp;</type>
          <declname>rhi</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1GpuArray" kindref="compound">amrex::GpuArray</ref>&lt; int, 3 &gt; const &amp;</type>
          <declname>is_per</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="421" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="421" bodyend="456"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac8c341f9e253720288265d6112c4ab9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PTile</type>
          </param>
          <param>
            <type>typename ParFunc</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::partitionParticles</definition>
        <argsstring>(PTile &amp;ptile, ParFunc const &amp;is_left)</argsstring>
        <name>partitionParticles</name>
        <qualifiedname>amrex::partitionParticles</qualifiedname>
        <param>
          <type>PTile &amp;</type>
          <declname>ptile</declname>
        </param>
        <param>
          <type>ParFunc const &amp;</type>
          <declname>is_left</declname>
        </param>
        <briefdescription>
<para>Reorders the <ref refid="structamrex_1_1ParticleTile" kindref="compound">ParticleTile</ref> into two partitions left [0, num_left-1] and right [num_left, ptile.numParticles()-1] and returns the number of particles in the left partition. </para>
        </briefdescription>
        <detaileddescription>
<para>The functor is_left [(<ref refid="structamrex_1_1ParticleTileData" kindref="compound">ParticleTileData</ref> ptd, int index) -&gt; bool] maps each particle to either the left [return true] or the right [return false] partition. It must return the same result if evaluated multiple times for the same particle.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptile</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structamrex_1_1ParticleTile" kindref="compound">ParticleTile</ref> to partition </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_left</parametername>
</parameternamelist>
<parameterdescription>
<para>functor to map particles to a partition </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="472" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="472" bodyend="571"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0faf1158bb54fdef7f76709ea803add0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PTile</type>
          </param>
          <param>
            <type>typename ParFunc</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::partitionParticles</definition>
        <argsstring>(PTile &amp;ptile, int num_left, ParFunc const &amp;is_left)</argsstring>
        <name>partitionParticles</name>
        <qualifiedname>amrex::partitionParticles</qualifiedname>
        <param>
          <type>PTile &amp;</type>
          <declname>ptile</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_left</declname>
        </param>
        <param>
          <type>ParFunc const &amp;</type>
          <declname>is_left</declname>
        </param>
        <briefdescription>
<para>Reorders the <ref refid="structamrex_1_1ParticleTile" kindref="compound">ParticleTile</ref> into two partitions left [0, num_left-1] and right [num_left, ptile.numParticles()-1]. This version of the function requires the correct amount for num_left to be passed as an input, which allows it to skip a reduction. </para>
        </briefdescription>
        <detaileddescription>
<para>The functor is_left [(<ref refid="structamrex_1_1ParticleTileData" kindref="compound">ParticleTileData</ref> ptd, int index) -&gt; bool] maps each particle to either the left [return true] or the right [return false] partition. It must return the same result if evaluated multiple times for the same particle.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptile</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structamrex_1_1ParticleTile" kindref="compound">ParticleTile</ref> to partition </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_left</parametername>
</parameternamelist>
<parameterdescription>
<para>number of particles in the left partition </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_left</parametername>
</parameternamelist>
<parameterdescription>
<para>functor to map particles to a partition </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="589" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="589" bodyend="637"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a57ef6a02e91160412bbfd6fdbba1b820" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PTile</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::removeInvalidParticles</definition>
        <argsstring>(PTile &amp;ptile)</argsstring>
        <name>removeInvalidParticles</name>
        <qualifiedname>amrex::removeInvalidParticles</qualifiedname>
        <param>
          <type>PTile &amp;</type>
          <declname>ptile</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="641" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="641" bodyend="648"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad0dd82a87ca66833b4809d6f495e399d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename PTile</type>
          </param>
          <param>
            <type>typename PLocator</type>
          </param>
          <param>
            <type>typename CellAssignor</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int amrex::partitionParticlesByDest</definition>
        <argsstring>(PTile &amp;ptile, const PLocator &amp;ploc, CellAssignor const &amp;assignor, const ParticleBufferMap &amp;pmap, const GpuArray&lt; Real, 3 &gt; &amp;plo, const GpuArray&lt; Real, 3 &gt; &amp;phi, const GpuArray&lt; ParticleReal, 3 &gt; &amp;rlo, const GpuArray&lt; ParticleReal, 3 &gt; &amp;rhi, const GpuArray&lt; int, 3 &gt; &amp;is_per, int lev, int gid, int, int lev_min, int lev_max, int nGrow, bool remove_negative)</argsstring>
        <name>partitionParticlesByDest</name>
        <qualifiedname>amrex::partitionParticlesByDest</qualifiedname>
        <param>
          <type>PTile &amp;</type>
          <declname>ptile</declname>
        </param>
        <param>
          <type>const PLocator &amp;</type>
          <declname>ploc</declname>
        </param>
        <param>
          <type>CellAssignor const &amp;</type>
          <declname>assignor</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1ParticleBufferMap" kindref="compound">ParticleBufferMap</ref> &amp;</type>
          <declname>pmap</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuArray" kindref="compound">GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref>, 3 &gt; &amp;</type>
          <declname>plo</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuArray" kindref="compound">GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga00d9113947d2ea92bbdbfe7db24d81f2" kindref="member">Real</ref>, 3 &gt; &amp;</type>
          <declname>phi</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuArray" kindref="compound">GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref>, 3 &gt; &amp;</type>
          <declname>rlo</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuArray" kindref="compound">GpuArray</ref>&lt; <ref refid="group__amrex__arithmetic__types_1ga1bb8e83c724a2a399a0129c904b4f7bd" kindref="member">ParticleReal</ref>, 3 &gt; &amp;</type>
          <declname>rhi</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1GpuArray" kindref="compound">GpuArray</ref>&lt; int, 3 &gt; &amp;</type>
          <declname>is_per</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev</declname>
        </param>
        <param>
          <type>int</type>
          <declname>gid</declname>
        </param>
        <param>
          <type>int</type>
        </param>
        <param>
          <type>int</type>
          <declname>lev_min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>lev_max</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nGrow</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>remove_negative</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="654" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="654" bodyend="717"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac8512b687a529806d0f382cf7c9eee97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC1</type>
          </param>
          <param>
            <type>class PC2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool amrex::SameIteratorsOK</definition>
        <argsstring>(const PC1 &amp;pc1, const PC2 &amp;pc2)</argsstring>
        <name>SameIteratorsOK</name>
        <qualifiedname>amrex::SameIteratorsOK</qualifiedname>
        <param>
          <type>const PC1 &amp;</type>
          <declname>pc1</declname>
        </param>
        <param>
          <type>const PC2 &amp;</type>
          <declname>pc2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="722" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="722" bodyend="731"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a2a6f51f01e9f0350a8b447ee451d0efb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::EnsureThreadSafeTiles</definition>
        <argsstring>(PC &amp;pc)</argsstring>
        <name>EnsureThreadSafeTiles</name>
        <qualifiedname>amrex::EnsureThreadSafeTiles</qualifiedname>
        <param>
          <type>PC &amp;</type>
          <declname>pc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="734" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="734" bodyend="741"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ac67c5b805cea20326010666416cd773f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class index_type</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::PermutationForDeposition</definition>
        <argsstring>(Gpu::DeviceVector&lt; index_type &gt; &amp;perm, index_type nitems, index_type nbins, F const &amp;f)</argsstring>
        <name>PermutationForDeposition</name>
        <qualifiedname>amrex::PermutationForDeposition</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1ga99e1f048890efc1c275606cb9bdc41c7" kindref="member">Gpu::DeviceVector</ref>&lt; index_type &gt; &amp;</type>
          <declname>perm</declname>
        </param>
        <param>
          <type>index_type</type>
          <declname>nitems</declname>
        </param>
        <param>
          <type>index_type</type>
          <declname>nbins</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="763" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="763" bodyend="874"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1ad434592fa38d501d9db9bfb648bb9140" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class index_type</type>
          </param>
          <param>
            <type>class PTile</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::PermutationForDeposition</definition>
        <argsstring>(Gpu::DeviceVector&lt; index_type &gt; &amp;perm, index_type nitems, const PTile &amp;ptile, Box bx, Geometry geom, const IntVect idx_type)</argsstring>
        <name>PermutationForDeposition</name>
        <qualifiedname>amrex::PermutationForDeposition</qualifiedname>
        <param>
          <type><ref refid="group__amrex__linear__containers_1ga99e1f048890efc1c275606cb9bdc41c7" kindref="member">Gpu::DeviceVector</ref>&lt; index_type &gt; &amp;</type>
          <declname>perm</declname>
        </param>
        <param>
          <type>index_type</type>
          <declname>nitems</declname>
        </param>
        <param>
          <type>const PTile &amp;</type>
          <declname>ptile</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a5e922fb76ff2eb645844783ad65d1490" kindref="member">Box</ref></type>
          <declname>bx</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref></type>
          <declname>geom</declname>
        </param>
        <param>
          <type>const <ref refid="namespaceamrex_1a95101764f5ec64cd1dd6e55614702cdb" kindref="member">IntVect</ref></type>
          <declname>idx_type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="877" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="877" bodyend="914"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a611fbb46e430a0c369b0a58770edf82f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string amrex::getDefaultCompNameReal</definition>
        <argsstring>(const int i)</argsstring>
        <name>getDefaultCompNameReal</name>
        <qualifiedname>amrex::getDefaultCompNameReal</qualifiedname>
        <param>
          <type>const int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="917" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="917" bodyend="929"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a32bc54c729de403f883a17fa3752d9fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>std::string</type>
        <definition>std::string amrex::getDefaultCompNameInt</definition>
        <argsstring>(const int i)</argsstring>
        <name>getDefaultCompNameInt</name>
        <qualifiedname>amrex::getDefaultCompNameInt</qualifiedname>
        <param>
          <type>const int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" line="932" column="13" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_ParticleUtil.H" bodystart="932" bodyend="935"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1a0ae53a1cff148618baac2e866aff997c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::WriteBinaryParticleDataSync</definition>
        <argsstring>(PC const &amp;pc, const std::string &amp;dir, const std::string &amp;name, const Vector&lt; int &gt; &amp;write_real_comp, const Vector&lt; int &gt; &amp;write_int_comp, const Vector&lt; std::string &gt; &amp;real_comp_names, const Vector&lt; std::string &gt; &amp;int_comp_names, F const &amp;f, bool is_checkpoint)</argsstring>
        <name>WriteBinaryParticleDataSync</name>
        <qualifiedname>amrex::WriteBinaryParticleDataSync</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>write_real_comp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>write_int_comp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>real_comp_names</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>int_comp_names</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1a1e470da9cdaa55f3e887edb813385d20a800618943025315f869e4e1f09471012" kindref="member">F</ref> const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>is_checkpoint</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_WriteBinaryParticleData.H" line="467" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_WriteBinaryParticleData.H" bodystart="467" bodyend="762"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1adfa45855b612cc6482e004b045247bbd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class PC</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; IsParticleContainer&lt; PC &gt;::value, int &gt;</type>
            <declname>foo</declname>
            <defname>foo</defname>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void amrex::WriteBinaryParticleDataAsync</definition>
        <argsstring>(PC const &amp;pc, const std::string &amp;dir, const std::string &amp;name, const Vector&lt; int &gt; &amp;write_real_comp, const Vector&lt; int &gt; &amp;write_int_comp, const Vector&lt; std::string &gt; &amp;real_comp_names, const Vector&lt; std::string &gt; &amp;int_comp_names, bool is_checkpoint)</argsstring>
        <name>WriteBinaryParticleDataAsync</name>
        <qualifiedname>amrex::WriteBinaryParticleDataAsync</qualifiedname>
        <param>
          <type>PC const &amp;</type>
          <declname>pc</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>dir</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>write_real_comp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; int &gt; &amp;</type>
          <declname>write_int_comp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>real_comp_names</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::string &gt; &amp;</type>
          <declname>int_comp_names</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>is_checkpoint</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Particle/AMReX_WriteBinaryParticleData.H" line="765" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Particle/AMReX_WriteBinaryParticleData.H" bodystart="765" bodyend="1145"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/runner/work/amrex/amrex/Src/Amr/AMReX_Amr.cpp" line="49" column="1"/>
  </compounddef>
</doxygen>
