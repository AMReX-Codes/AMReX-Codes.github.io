<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespaceamrex_1_1NonLocalBC" kind="namespace" language="C++">
    <compoundname>amrex::NonLocalBC</compoundname>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1HasInverseMemFn" prot="public">amrex::NonLocalBC::HasInverseMemFn</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1IsIndexMapping" prot="public">amrex::NonLocalBC::IsIndexMapping</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1MultiBlockIndexMapping" prot="public">amrex::NonLocalBC::MultiBlockIndexMapping</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData" prot="public">amrex::NonLocalBC::MultiBlockCommMetaData</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" prot="public">amrex::NonLocalBC::IsFabProjection</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1Identity" prot="public">amrex::NonLocalBC::Identity</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1MapComponents" prot="public">amrex::NonLocalBC::MapComponents</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1SwapComponents" prot="public">amrex::NonLocalBC::SwapComponents</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1SwapComponents_3_01I_00_01-1_01_4" prot="public">amrex::NonLocalBC::SwapComponents&lt; I, -1 &gt;</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1SwapComponents_3-1_00_01J_01_4" prot="public">amrex::NonLocalBC::SwapComponents&lt;-1, J &gt;</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1SwapComponents_3-1_00_01-1_01_4" prot="public">amrex::NonLocalBC::SwapComponents&lt;-1, -1 &gt;</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1CommData" prot="public">amrex::NonLocalBC::CommData</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1CommHandler" prot="public">amrex::NonLocalBC::CommHandler</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1IsDataPacking" prot="public">amrex::NonLocalBC::IsDataPacking</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1PackComponents" prot="public">amrex::NonLocalBC::PackComponents</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever" prot="public">amrex::NonLocalBC::ApplyDtosAndProjectionOnReciever</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1NoLocalCopy" prot="public">amrex::NonLocalBC::NoLocalCopy</innerclass>
    <innerclass refid="structamrex_1_1NonLocalBC_1_1DoLocalCopy" prot="public">amrex::NonLocalBC::DoLocalCopy</innerclass>
    <innernamespace refid="namespaceamrex_1_1NonLocalBC_1_1detail">amrex::NonLocalBC::detail</innernamespace>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespaceamrex_1_1NonLocalBC_1a165fdced073fa98b961fd6aaceb213d5" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>decltype(std::declval&lt; T &gt;().Inverse(std::declval&lt; Args &gt;()...))</type>
        <definition>using amrex::NonLocalBC::Inverse_t = typedef decltype(std::declval&lt;T&gt;().Inverse(std::declval&lt;Args&gt;()...))</definition>
        <argsstring></argsstring>
        <name>Inverse_t</name>
        <briefdescription>
<para>Return type of an InverseImage class member function. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="16" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="16" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1_1NonLocalBC_1adc23e3a1b040b4f68b4429a2a40e00d6" prot="public" static="no">
        <type><ref refid="structamrex_1_1NonLocalBC_1_1SwapComponents" kindref="compound">SwapComponents</ref>&lt;-1, -1 &gt;</type>
        <definition>using amrex::NonLocalBC::DynamicSwapComponents = typedef SwapComponents&lt;-1, -1&gt;</definition>
        <argsstring></argsstring>
        <name>DynamicSwapComponents</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="386" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="386" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1_1NonLocalBC_1aa9d38898e06da05aa7e4bfab9706f1f0" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>decltype(<ref refid="namespaceamrex_1_1NonLocalBC_1a5e37435a999c0eb51e29139501d7ca49" kindref="member">PrepareSendBuffers</ref>(std::declval&lt; Args &gt;()...))</type>
        <definition>using amrex::NonLocalBC::PrepareSendBuffers_t = typedef decltype(PrepareSendBuffers(std::declval&lt;Args&gt;()...))</definition>
        <argsstring></argsstring>
        <name>PrepareSendBuffers_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="464" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="464" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1_1NonLocalBC_1ac352232fe0363d175aaf2615666c8439" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>decltype(<ref refid="namespaceamrex_1_1NonLocalBC_1a101b2f07560880fda8bab055214f3222" kindref="member">PrepareRecvBuffers</ref>(std::declval&lt; Args &gt;()...))</type>
        <definition>using amrex::NonLocalBC::PrepareRecvBuffers_t = typedef decltype(PrepareRecvBuffers(std::declval&lt;Args&gt;()...))</definition>
        <argsstring></argsstring>
        <name>PrepareRecvBuffers_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="467" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="467" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1_1NonLocalBC_1a2457a717c906cb9f086a39faea4da88d" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>decltype(<ref refid="namespaceamrex_1_1NonLocalBC_1a291d1c78ece15e2eb717acc0ec36835d" kindref="member">PackSendBuffers</ref>(std::declval&lt; Args &gt;()...))</type>
        <definition>using amrex::NonLocalBC::PackSendBuffers_t = typedef decltype(PackSendBuffers(std::declval&lt;Args&gt;()...))</definition>
        <argsstring></argsstring>
        <name>PackSendBuffers_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="470" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="470" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1_1NonLocalBC_1a0050536eff7fd3244ef573e961858999" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>decltype(<ref refid="namespaceamrex_1_1NonLocalBC_1a9dad3936d4a2ede70ac57d5d2d3b6e2e" kindref="member">UnpackRecvBuffers</ref>(std::declval&lt; Args &gt;()...))</type>
        <definition>using amrex::NonLocalBC::UnpackRecvBuffers_t = typedef decltype(UnpackRecvBuffers(std::declval&lt;Args&gt;()...))</definition>
        <argsstring></argsstring>
        <name>UnpackRecvBuffers_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="473" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="473" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceamrex_1_1NonLocalBC_1a4b44aa3d7a205826948ced4323d0be80" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>decltype(<ref refid="namespaceamrex_1_1NonLocalBC_1ab719edc50f1af0377bb308024219baa3" kindref="member">LocalCopy</ref>(std::declval&lt; Args &gt;()...))</type>
        <definition>using amrex::NonLocalBC::LocalCopy_t = typedef decltype(LocalCopy(std::declval&lt;Args&gt;()...))</definition>
        <argsstring></argsstring>
        <name>LocalCopy_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="476" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="476" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespaceamrex_1_1NonLocalBC_1abb7cd050d6dd1aef7603048eeccd7ded" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="structamrex_1_1NonLocalBC_1_1Identity" kindref="compound">Identity</ref></type>
        <definition>constexpr Identity amrex::NonLocalBC::identity</definition>
        <argsstring></argsstring>
        <name>identity</name>
        <initializer>{}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="296" column="27" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="296" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1_1NonLocalBC_1a618f8d1f0b1258ad4931eb6a5ae65ebc" prot="public" static="yes" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>int</type>
            <declname>I</declname>
            <defname>I</defname>
          </param>
          <param>
            <type>int</type>
            <declname>J</declname>
            <defname>J</defname>
          </param>
        </templateparamlist>
        <type>constexpr <ref refid="structamrex_1_1NonLocalBC_1_1SwapComponents" kindref="compound">SwapComponents</ref>&lt; I, J &gt;</type>
        <definition>constexpr SwapComponents&lt;I, J&gt; amrex::NonLocalBC::swap_indices</definition>
        <argsstring></argsstring>
        <name>swap_indices</name>
        <initializer>{}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="388" column="47" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="388" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1_1NonLocalBC_1ad604544d2fd60b6d9fb7a8b75f95ffe0" prot="public" static="yes" mutable="no">
        <type>constexpr struct <ref refid="structamrex_1_1NonLocalBC_1_1NoLocalCopy" kindref="compound">amrex::NonLocalBC::NoLocalCopy</ref></type>
        <definition>constexpr struct amrex::NonLocalBC::NoLocalCopy amrex::NonLocalBC::no_local_copy</definition>
        <argsstring></argsstring>
        <name>no_local_copy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="672" column="49"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceamrex_1_1NonLocalBC_1aa0174cdbe72e2968e46f0293c2ecab73" prot="public" static="yes" mutable="no">
        <type>constexpr struct <ref refid="structamrex_1_1NonLocalBC_1_1DoLocalCopy" kindref="compound">amrex::NonLocalBC::DoLocalCopy</ref></type>
        <definition>constexpr struct amrex::NonLocalBC::DoLocalCopy amrex::NonLocalBC::do_local_copy</definition>
        <argsstring></argsstring>
        <name>do_local_copy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="673" column="49"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a303b8c034244500930c9f5ead86a22bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::NonLocalBC::PrepareCommBuffers</definition>
        <argsstring>(CommData &amp;comm, const FabArrayBase::MapOfCopyComTagContainers &amp;cctc, int n_components, std::size_t object_size, std::size_t align)</argsstring>
        <name>PrepareCommBuffers</name>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommData" kindref="compound">CommData</ref> &amp;</type>
          <declname>comm</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArrayBase_1aa36883196eb7b1d039fd1941966a4310" kindref="member">FabArrayBase::MapOfCopyComTagContainers</ref> &amp;</type>
          <declname>cctc</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>n_components</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>object_size</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>align</declname>
        </param>
        <briefdescription>
<para>Fill all class member variables of comm but the request and the stats vector. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" line="41" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" bodystart="41" bodyend="103" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="438" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a62685cb385ba3363c973d758cbb7cde8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::NonLocalBC::PostRecvs</definition>
        <argsstring>(CommData &amp;recv, int mpi_tag)</argsstring>
        <name>PostRecvs</name>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommData" kindref="compound">CommData</ref> &amp;</type>
          <declname>recv</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>mpi_tag</declname>
        </param>
        <briefdescription>
<para>Initiate all recvieves with MPI_Irecv calls associated with tag mpi_tag. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" line="105" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" bodystart="105" bodyend="119" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="442" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a5ccb53a5bfee4c68f588b17d3642c2c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void amrex::NonLocalBC::PostSends</definition>
        <argsstring>(CommData &amp;send, int mpi_tag)</argsstring>
        <name>PostSends</name>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommData" kindref="compound">CommData</ref> &amp;</type>
          <declname>send</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>mpi_tag</declname>
        </param>
        <briefdescription>
<para>Initiate all sends with MPI_Isend calls associated with tag mpi_tag. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" line="121" column="6" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" bodystart="121" bodyend="135" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="445" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1ab11bf269e7aebae89bdc5d7d178bb12f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>template <ref refid="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData" kindref="compound">MultiBlockCommMetaData</ref></type>
        <definition>template MultiBlockCommMetaData amrex::NonLocalBC::ParallelCopy</definition>
        <argsstring>(FabArray&lt; FArrayBox &gt; &amp;dest, const Box &amp;destbox, const FabArray&lt; FArrayBox &gt; &amp;src, int destcomp, int srccomp, int numcomp, const IntVect &amp;ngrow, MultiBlockIndexMapping const &amp;, Identity const &amp;)</argsstring>
        <name>ParallelCopy</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; <ref refid="classamrex_1_1FArrayBox" kindref="compound">FArrayBox</ref> &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>destbox</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; <ref refid="classamrex_1_1FArrayBox" kindref="compound">FArrayBox</ref> &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>destcomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> &amp;</type>
          <declname>ngrow</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1MultiBlockIndexMapping" kindref="compound">MultiBlockIndexMapping</ref> const &amp;</type>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1Identity" kindref="compound">Identity</ref> const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" line="138" column="33" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" declline="138" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a56d136063b9c85d97111978faff29c87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DTOS</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;::value, <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> &gt;</type>
        <definition>std::enable_if_t&lt;IsCallableR&lt;Dim3, DTOS, Dim3&gt;::value, IntVect&gt; amrex::NonLocalBC::Apply</definition>
        <argsstring>(DTOS const &amp;dtos, const IntVect &amp;iv)</argsstring>
        <name>Apply</name>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> &amp;</type>
          <declname>iv</declname>
        </param>
        <briefdescription>
<para>Applies the <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> to <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> mapping onto IntVects. </para>
        </briefdescription>
        <detaileddescription>
<para>This is used to map indices from the dest index space into the source index space.</para>
<para><ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> is being embedded in <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> by trailing zeros. <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> is being projected to <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> by dopping z for AMREX_SPACEDIM = 2 or z and y components for AMREX_SPACEDIM = 1.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">iv</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> that lives in the destination index space.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref>{dtos(<ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>{iv})} </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="102" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="102" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a7f43ddf52003ccef3fd4189be4b4e26a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DTOS</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;::value &amp;&amp;!<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="classamrex_1_1IndexType" kindref="compound">IndexType</ref>, DTOS, <ref refid="classamrex_1_1IndexType" kindref="compound">IndexType</ref> &gt;::value, <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt;</type>
        <definition>std::enable_if_t&lt;IsCallableR&lt;Dim3, DTOS, Dim3&gt;::value &amp;&amp; !IsCallableR&lt;IndexType, DTOS, IndexType&gt;::value, Box&gt; amrex::NonLocalBC::Image</definition>
        <argsstring>(DTOS const &amp;dtos, const Box &amp;box)</argsstring>
        <name>Image</name>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
<para>Applies the <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> to <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> mapping onto Boxes but does not change the index type. </para>
        </briefdescription>
        <detaileddescription>
<para>This function assumes monotonicity of dtos in each component.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">box</parametername>
</parameternamelist>
<parameterdescription>
<para>The box that lives the destination index space</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the smallest <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> in the source index space that contains images of Apply(dtos, box.smallEnd()) and Apply(dtos, box.bigEnd()). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="118" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="118" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1afc017cb71584ee0d0505c7ecf92a79de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DTOS</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="classamrex_1_1IndexType" kindref="compound">IndexType</ref>, DTOS, <ref refid="classamrex_1_1IndexType" kindref="compound">IndexType</ref> &gt;::value, <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt;</type>
        <definition>std::enable_if_t&lt;IsCallableR&lt;Dim3, DTOS, Dim3&gt;::value &amp;&amp; IsCallableR&lt;IndexType, DTOS, IndexType&gt;::value, Box&gt; amrex::NonLocalBC::Image</definition>
        <argsstring>(DTOS const &amp;dtos, const Box &amp;box)</argsstring>
        <name>Image</name>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
<para>Applies the <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> to <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> mapping onto Boxes and maps the index type. </para>
        </briefdescription>
        <detaileddescription>
<para>This function assumes monotonicity of dtos in each component.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">box</parametername>
</parameternamelist>
<parameterdescription>
<para>The box that lives the destination index space</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the smallest <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> in the source index space that contains images of Apply(dtos, box.smallEnd()) and Apply(dtos, box.bigEnd()). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="141" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="141" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a72f58b54718389e636ab3b07295eebac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DTOS</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1NonLocalBC_1_1HasInverseMemFn" kindref="compound">HasInverseMemFn</ref>&lt; DTOS &gt;::value, <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> &gt;</type>
        <definition>std::enable_if_t&lt;HasInverseMemFn&lt;DTOS&gt;::value, IntVect&gt; amrex::NonLocalBC::ApplyInverse</definition>
        <argsstring>(DTOS const &amp;dtos, const IntVect &amp;iv)</argsstring>
        <name>ApplyInverse</name>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> &amp;</type>
          <declname>iv</declname>
        </param>
        <briefdescription>
<para>Applies the <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> to <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> invserse mapping onto IntVects. </para>
        </briefdescription>
        <detaileddescription>
<para>This is used to map indices from the src index space into the dest index space.</para>
<para><ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> is being embedded in <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> by trailing zeros. <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> is being projected to <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> by dopping z for AMREX_SPACEDIM = 2 or z and y components for AMREX_SPACEDIM = 1.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">iv</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> that lives in the src index space.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref>{dtos.Inverse(<ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>{iv})} </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="163" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="163" bodyend="166"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1ab444df90b90c40442170ef5db4b0bea1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DTOS</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1NonLocalBC_1_1HasInverseMemFn" kindref="compound">HasInverseMemFn</ref>&lt; DTOS &gt;::value &amp;&amp;!<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="classamrex_1_1IndexType" kindref="compound">IndexType</ref>, DTOS, <ref refid="classamrex_1_1IndexType" kindref="compound">IndexType</ref> &gt;::value, <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt;</type>
        <definition>std::enable_if_t&lt;HasInverseMemFn&lt;DTOS&gt;::value &amp;&amp; !IsCallableR&lt;IndexType, DTOS, IndexType&gt;::value, Box&gt; amrex::NonLocalBC::InverseImage</definition>
        <argsstring>(DTOS const &amp;dtos, const Box &amp;box)</argsstring>
        <name>InverseImage</name>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
<para>Applies the inverse <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> to <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> mapping onto Boxes without changing the index type. </para>
        </briefdescription>
        <detaileddescription>
<para>This function assumes monotonicity in each component.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">box</parametername>
</parameternamelist>
<parameterdescription>
<para>The box that lives the source index space</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the smallest <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> in the destination index space that contains images of ApplyInverse(box.smallEnd()) and ApplyInverse(box.bigEnd()). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="178" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="178" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1ad979c6dbf27225b1f20a986185e2977b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename DTOS</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1NonLocalBC_1_1HasInverseMemFn" kindref="compound">HasInverseMemFn</ref>&lt; DTOS &gt;::value &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="classamrex_1_1IndexType" kindref="compound">IndexType</ref>, DTOS, <ref refid="classamrex_1_1IndexType" kindref="compound">IndexType</ref> &gt;::value, <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &gt;</type>
        <definition>std::enable_if_t&lt;HasInverseMemFn&lt;DTOS&gt;::value &amp;&amp; IsCallableR&lt;IndexType, DTOS, IndexType&gt;::value, Box&gt; amrex::NonLocalBC::InverseImage</definition>
        <argsstring>(DTOS const &amp;dtos, const Box &amp;box)</argsstring>
        <name>InverseImage</name>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
<para>Applies the inverse <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> to <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> mapping onto Boxes. </para>
        </briefdescription>
        <detaileddescription>
<para>This function assumes monotonicity in each component.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">box</parametername>
</parameternamelist>
<parameterdescription>
<para>The box that lives the source index space</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the smallest <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> in the destination index space that contains images of ApplyInverse(box.smallEnd()) and ApplyInverse(box.bigEnd()). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="193" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="193" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a3cd3a3fb3e0b792ebdb724cc5725176d" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class DTOS</type>
            <defval>Identity</defval>
          </param>
          <param>
            <type>class Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3, DTOS, Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::local_copy_cpu</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, int dcomp, int scomp, int ncomp, FabArrayBase::CopyComTagsContainer const &amp;local_tags, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{}) noexcept</argsstring>
        <name>local_copy_cpu</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArrayBase_1a9bdd65ce61ce9ee5ca52c6b387dd4800" kindref="member">FabArrayBase::CopyComTagsContainer</ref> const &amp;</type>
          <declname>local_tags</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
          <defval>DTOS{}</defval>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="493" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="493" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a4039bcfeee7e444019168686df8dfe36" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class DTOS</type>
            <defval>Identity</defval>
          </param>
          <param>
            <type>class Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3, DTOS, Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::unpack_recv_buffer_cpu</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, int dcomp, int ncomp, Vector&lt; char * &gt; const &amp;recv_data, Vector&lt; std::size_t &gt; const &amp;recv_size, Vector&lt; FabArrayBase::CopyComTagsContainer const * &gt; const &amp;recv_cctc, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{}) noexcept</argsstring>
        <name>unpack_recv_buffer_cpu</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; char * &gt; const &amp;</type>
          <declname>recv_data</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::size_t &gt; const &amp;</type>
          <declname>recv_size</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1FabArrayBase_1a9bdd65ce61ce9ee5ca52c6b387dd4800" kindref="member">FabArrayBase::CopyComTagsContainer</ref> const * &gt; const &amp;</type>
          <declname>recv_cctc</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
          <defval>DTOS{}</defval>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="499" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="499" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a4ea4e6f4775e59312efdc7e5e42788c3" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class DTOS</type>
            <defval>Identity</defval>
          </param>
          <param>
            <type>class Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3, DTOS, Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::local_copy_gpu</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, int dcomp, int scomp, int ncomp, FabArrayBase::CopyComTagsContainer const &amp;local_tags, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{}) noexcept</argsstring>
        <name>local_copy_gpu</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>dcomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArrayBase_1a9bdd65ce61ce9ee5ca52c6b387dd4800" kindref="member">FabArrayBase::CopyComTagsContainer</ref> const &amp;</type>
          <declname>local_tags</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
          <defval>DTOS{}</defval>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="507" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="507" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1ab6a98a57dd1e0440eac5dee97d79d326" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
          <param>
            <type>class DTOS</type>
            <defval>Identity</defval>
          </param>
          <param>
            <type>class Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3, DTOS, Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::unpack_recv_buffer_gpu</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, int scomp, int ncomp, Vector&lt; char * &gt; const &amp;recv_data, Vector&lt; std::size_t &gt; const &amp;recv_size, Vector&lt; FabArrayBase::CopyComTagsContainer const * &gt; const &amp;recv_cctc, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</argsstring>
        <name>unpack_recv_buffer_gpu</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; char * &gt; const &amp;</type>
          <declname>recv_data</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; std::size_t &gt; const &amp;</type>
          <declname>recv_size</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Vector" kindref="compound">Vector</ref>&lt; <ref refid="classamrex_1_1FabArrayBase_1a9bdd65ce61ce9ee5ca52c6b387dd4800" kindref="member">FabArrayBase::CopyComTagsContainer</ref> const * &gt; const &amp;</type>
          <declname>recv_cctc</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
          <defval>DTOS{}</defval>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="513" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="513" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1ab719edc50f1af0377bb308024219baa3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::LocalCopy</definition>
        <argsstring>(const PackComponents &amp;components, FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, const FabArrayBase::CopyComTagsContainer &amp;local_tags)</argsstring>
        <name>LocalCopy</name>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1PackComponents" kindref="compound">PackComponents</ref> &amp;</type>
          <declname>components</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArrayBase_1a9bdd65ce61ce9ee5ca52c6b387dd4800" kindref="member">FabArrayBase::CopyComTagsContainer</ref> &amp;</type>
          <declname>local_tags</declname>
        </param>
        <briefdescription>
<para>Dispatch local copies to the default behaviour that knows no DTOS nor projection. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="537" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="537" bodyend="549"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a5e37435a999c0eb51e29139501d7ca49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::PrepareSendBuffers</definition>
        <argsstring>(const PackComponents &amp;components, FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, CommData &amp;comm, const FabArrayBase::MapOfCopyComTagContainers &amp;cctc)</argsstring>
        <name>PrepareSendBuffers</name>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1PackComponents" kindref="compound">PackComponents</ref> &amp;</type>
          <declname>components</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommData" kindref="compound">CommData</ref> &amp;</type>
          <declname>comm</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArrayBase_1aa36883196eb7b1d039fd1941966a4310" kindref="member">FabArrayBase::MapOfCopyComTagContainers</ref> &amp;</type>
          <declname>cctc</declname>
        </param>
        <briefdescription>
<para>Calls PrepareComBuffers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="555" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="555" bodyend="560"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a101b2f07560880fda8bab055214f3222" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::PrepareRecvBuffers</definition>
        <argsstring>(const PackComponents &amp;components, FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, CommData &amp;comm, const FabArrayBase::MapOfCopyComTagContainers &amp;cctc)</argsstring>
        <name>PrepareRecvBuffers</name>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1PackComponents" kindref="compound">PackComponents</ref> &amp;</type>
          <declname>components</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommData" kindref="compound">CommData</ref> &amp;</type>
          <declname>comm</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArrayBase_1aa36883196eb7b1d039fd1941966a4310" kindref="member">FabArrayBase::MapOfCopyComTagContainers</ref> &amp;</type>
          <declname>cctc</declname>
        </param>
        <briefdescription>
<para>Calls PrepareComBuffers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="565" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="565" bodyend="570"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a291d1c78ece15e2eb717acc0ec36835d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::PackSendBuffers</definition>
        <argsstring>(const PackComponents &amp;components, const FabArray&lt; FAB &gt; &amp;src, CommData &amp;send)</argsstring>
        <name>PackSendBuffers</name>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1PackComponents" kindref="compound">PackComponents</ref> &amp;</type>
          <declname>components</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommData" kindref="compound">CommData</ref> &amp;</type>
          <declname>send</declname>
        </param>
        <briefdescription>
<para>Serializes FAB data without any knowledge of a DTOS nor a projection. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="575" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="575" bodyend="586"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a9dad3936d4a2ede70ac57d5d2d3b6e2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::UnpackRecvBuffers</definition>
        <argsstring>(const PackComponents &amp;components, FabArray&lt; FAB &gt; &amp;dest, const CommData &amp;recv)</argsstring>
        <name>UnpackRecvBuffers</name>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1PackComponents" kindref="compound">PackComponents</ref> &amp;</type>
          <declname>components</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1CommData" kindref="compound">CommData</ref> &amp;</type>
          <declname>recv</declname>
        </param>
        <briefdescription>
<para>De-serializes FAB data without any knowledge of a DTOS nor a projection. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="591" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="591" bodyend="602"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a0fa70005c1319e11f11266ae94abe4bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
          </param>
          <param>
            <type>typename FabProj</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::LocalCopy</definition>
        <argsstring>(const ApplyDtosAndProjectionOnReciever&lt; DTOS, FabProj &gt; &amp;packing, FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, const FabArrayBase::CopyComTagsContainer &amp;local_tags)</argsstring>
        <name>LocalCopy</name>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever" kindref="compound">ApplyDtosAndProjectionOnReciever</ref>&lt; DTOS, FabProj &gt; &amp;</type>
          <declname>packing</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArrayBase_1a9bdd65ce61ce9ee5ca52c6b387dd4800" kindref="member">FabArrayBase::CopyComTagsContainer</ref> &amp;</type>
          <declname>local_tags</declname>
        </param>
        <briefdescription>
<para>Do local copies of FABs using DTOS and projection. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="630" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="630" bodyend="643"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1ab1af16f3ccbf44b758a852b190bedd33" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
          </param>
          <param>
            <type>typename FabProj</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::UnpackRecvBuffers</definition>
        <argsstring>(const ApplyDtosAndProjectionOnReciever&lt; DTOS, FabProj &gt; &amp;packing, FabArray&lt; FAB &gt; &amp;dest, const CommData &amp;recv)</argsstring>
        <name>UnpackRecvBuffers</name>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1ApplyDtosAndProjectionOnReciever" kindref="compound">ApplyDtosAndProjectionOnReciever</ref>&lt; DTOS, FabProj &gt; &amp;</type>
          <declname>packing</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1NonLocalBC_1_1CommData" kindref="compound">CommData</ref> &amp;</type>
          <declname>recv</declname>
        </param>
        <briefdescription>
<para>Copy from received data in the buffer to destination FABs using DTOS and projection. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="649" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="649" bodyend="663"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a7bf19b06a9bab53ac6dea6bfa875af9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DataPacking</type>
          </param>
          <param>
            <type>typename</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
          <param>
            <type>typename</type>
            <defval>std::enable_if_t&lt;IsDataPacking&lt;DataPacking, FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a8cfb0291f150c6676f99a0b6c4578717" kindref="member">AMREX_NODISCARD</ref> <ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref></type>
        <definition>AMREX_NODISCARD CommHandler amrex::NonLocalBC::ParallelCopy_nowait</definition>
        <argsstring>(NoLocalCopy, FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, const FabArrayBase::CommMetaData &amp;cmd, const DataPacking &amp;data_packing)</argsstring>
        <name>ParallelCopy_nowait</name>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1NoLocalCopy" kindref="compound">NoLocalCopy</ref></type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type>const DataPacking &amp;</type>
          <declname>data_packing</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiate recv and send calls for MPI and immediately return without doing any work.</para>
<para>DataPacking is a customization point object to control the behaviour of packing and unpacking send or recv data buffers. It is used to perform interpolation or data transformations on either sender or receiver side.</para>
<para>This function performs a data packing on sender side and we expect a call to Parallel_finish that performs data unpacking on the receiver side.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dest</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is going to be filled with received data.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is used to fill the send buffers.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>The communication meta data object holds spatial information about FAB boxes that need to be filled and copied from.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">data_packing</parametername>
</parameternamelist>
<parameterdescription>
<para>A CPO that controls behaviour of preparing buffers and packing the source data into the send buffers.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a <ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref> object that owns context and memory buffers for the whole life time of the MPI transaction. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="701" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="701" bodyend="724"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a57dca62d2b38257c9da61d6a1f0ed9d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DataPacking</type>
          </param>
          <param>
            <type>typename</type>
            <defval>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt;</defval>
          </param>
          <param>
            <type>typename</type>
            <defval>std::enable_if_t&lt;IsDataPacking&lt;DataPacking, FAB&gt;::value&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="AMReX__Extension_8H_1a8cfb0291f150c6676f99a0b6c4578717" kindref="member">AMREX_NODISCARD</ref> <ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref></type>
        <definition>AMREX_NODISCARD CommHandler amrex::NonLocalBC::ParallelCopy_nowait</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, const FabArrayBase::CommMetaData &amp;cmd, const DataPacking &amp;data_packing)</argsstring>
        <name>ParallelCopy_nowait</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type>const DataPacking &amp;</type>
          <declname>data_packing</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiate recv and send calls for MPI and return after doing local work.</para>
<para>DataPacking is a customization point object to control the behaviour of packing and unpacking send or recv data buffers. It is used to perform interpolation or data transformations on either sender or receiver side.</para>
<para>This function performs a data packing on sender side and we expect a call to Parallel_finish that performs data unpacking on the receiver side.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dest</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is going to be filled with received data.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is used to fill the send buffers.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>The communication meta data object holds spatial information about FAB boxes that need to be filled and copied from.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">data_packing</parametername>
</parameternamelist>
<parameterdescription>
<para>A CPO that controls behaviour of preparing buffers and packing the source data into the send buffers.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a <ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref> object that owns context and memory buffers for the whole life time of the MPI transaction. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="760" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="760" bodyend="768"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a51fb0add78ab242015474585b0f7207e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DataPacking</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsDataPacking" kindref="compound">IsDataPacking</ref>&lt; DataPacking, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsDataPacking&lt;DataPacking, FAB&gt;)&gt; amrex::NonLocalBC::ParallelCopy_finish</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dest, CommHandler handler, const FabArrayBase::CommMetaData &amp;cmd, const DataPacking &amp;data_packing)</argsstring>
        <name>ParallelCopy_finish</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref></type>
          <declname>handler</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type>const DataPacking &amp;</type>
          <declname>data_packing</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Blockingly wait for all communication to be done and fill the local FABs with received data.</para>
<para>This function overload performs no local copies, i.e. from this MPI process to itself. It will block the current thread until all MPI recv and send requests are done and calls the DataPacking object to unpack the received buffers.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dest</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is going to be filled with received data.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">handler</parametername>
</parameternamelist>
<parameterdescription>
<para>This object holds all data buffers that need to be kept alive as long as the data transaction is not done.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>The communication meta data object holds spatial information about FAB boxes that need to be filled.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">data_packing</parametername>
</parameternamelist>
<parameterdescription>
<para>A CPO that controls behaviour of unpacking the received buffer to the destination <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Nothing. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="793" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="793" bodyend="818"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a7f46a71c7807b33fa3fac96c36e8d09b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DataPacking</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsDataPacking" kindref="compound">IsDataPacking</ref>&lt; DataPacking, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsDataPacking&lt;DataPacking, FAB&gt;)&gt; amrex::NonLocalBC::ParallelCopy_finish</definition>
        <argsstring>(DoLocalCopy, FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, CommHandler handler, const FabArrayBase::CommMetaData &amp;cmd, const DataPacking &amp;data_packing)</argsstring>
        <name>ParallelCopy_finish</name>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1DoLocalCopy" kindref="compound">DoLocalCopy</ref></type>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref></type>
          <declname>handler</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type>const DataPacking &amp;</type>
          <declname>data_packing</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Blockingly wait for all communication to be done and fill the local FABs with received data.</para>
<para>This function overload performs local copies, i.e. from this MPI process to itself. It will block the current thread until all MPI recv and send requests are done and calls the DataPacking object to unpack the received buffers.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dest</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is going to be filled with received data.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is used to get the data for the local copies from.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">handler</parametername>
</parameternamelist>
<parameterdescription>
<para>This object holds all data buffers that need to be kept alive as long as the data transaction is not done.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>The communication meta data object holds spatial information about FAB boxes that need to be filled.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">data_packing</parametername>
</parameternamelist>
<parameterdescription>
<para>A CPO that controls behaviour of unpacking the received data.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Nothing. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="844" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="844" bodyend="851"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a9c2fff17888a770c492a1c014fee2b73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
            <defval>Identity</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3, DTOS, Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::ParallelCopy</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, const FabArrayBase::CommMetaData &amp;cmd, SrcComp srccomp, DestComp destcomp, NumComps numcomp, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</argsstring>
        <name>ParallelCopy</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1SrcComp" kindref="compound">SrcComp</ref></type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1DestComp" kindref="compound">DestComp</ref></type>
          <declname>destcomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NumComps" kindref="compound">NumComps</ref></type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
          <defval>DTOS{}</defval>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
<para>Call ParallelCopy_nowait followed by ParallelCopy_finish, strong typed version. </para>
        </briefdescription>
        <detaileddescription>
<para>This function overload uses an already cached CommMetaData. This CommMetaData needs to be compatible with the specified DTOS and projection, otherwise undefined behaviour occurs.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dest</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is going to be filled with received data.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is used to fill the send buffers.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>The communication meta data object holds spatial information about FAB boxes that need to be filled and copied from.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">srccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The first component in src that will be copied to dest.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">destcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The first component in dest that will get written by src.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of successive components that will be copied.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dtos</parametername>
</parameternamelist>
<parameterdescription>
<para>An index mapping that maps indices from destination space to source space and from source space to destination space.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">proj</parametername>
</parameternamelist>
<parameterdescription>
<para>A transformation function that might change the data when it is being copied.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Nothing. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="879" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="879" bodyend="888"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a5984b6f2bffd16fd4a1737326e32aef0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
            <defval>Identity</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3, DTOS, Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj, FAB&gt;)&gt; amrex::NonLocalBC::ParallelCopy</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dest, const FabArray&lt; FAB &gt; &amp;src, const FabArrayBase::CommMetaData &amp;cmd, int srccomp, int destcomp, int numcomp, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</argsstring>
        <name>ParallelCopy</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>destcomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
          <defval>DTOS{}</defval>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
<para>Call ParallelCopy_nowait followed by ParallelCopy_finish. </para>
        </briefdescription>
        <detaileddescription>
<para>This function overload uses an already cached CommMetaData. This CommMetaData needs to be compatible with the specified DTOS and projection, otherwise undefined behaviour occurs.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dest</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is going to be filled with received data.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is used to fill the send buffers.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>The communication meta data object holds spatial information about FAB boxes that need to be filled and copied from.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">srccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The first component in src that will be copied to dest.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">destcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The first component in dest that will get written by src.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of successive components that will be copied.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dtos</parametername>
</parameternamelist>
<parameterdescription>
<para>An index mapping that maps indices from destination space to source space and from source space to destination space.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">proj</parametername>
</parameternamelist>
<parameterdescription>
<para>A transformation function that might change the data when it is being copied.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Nothing. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="916" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="916" bodyend="919"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1aedc887605744ff53411090ea98c15a04" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
            <defval>Identity</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsIndexMapping" kindref="compound">IsIndexMapping</ref>&lt; DTOS &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;), <ref refid="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData" kindref="compound">MultiBlockCommMetaData</ref> &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsIndexMapping&lt;DTOS&gt;) &amp;&amp; IsFabProjection&lt;Proj, FAB&gt;),MultiBlockCommMetaData&gt; amrex::NonLocalBC::ParallelCopy</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dest, const Box &amp;destbox, const FabArray&lt; FAB &gt; &amp;src, SrcComp srccomp, DestComp destcomp, NumComps numcomp, const IntVect &amp;ngrow, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</argsstring>
        <name>ParallelCopy</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>destbox</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1SrcComp" kindref="compound">SrcComp</ref></type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1DestComp" kindref="compound">DestComp</ref></type>
          <declname>destcomp</declname>
        </param>
        <param>
          <type><ref refid="structamrex_1_1NumComps" kindref="compound">NumComps</ref></type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> &amp;</type>
          <declname>ngrow</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
          <defval>DTOS{}</defval>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
<para>Call ParallelCopy_nowait followed by ParallelCopy_finish, strong typed version. </para>
        </briefdescription>
        <detaileddescription>
<para>This function constructs a new MultiCommMetaData from the given DTOS, destbox and ngrow.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dest</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is going to be filled with received data.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">destbox</parametername>
</parameternamelist>
<parameterdescription>
<para>The index box in the destination space that will be filled by data from src. The source box that describes the dependencies will be computed by the specified DTOS.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is used to fill the send buffers.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">srccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The first component in src that will be copied to dest.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">destcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The first component in dest that will get written by src.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of successive components that will be copied.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ngrow</parametername>
</parameternamelist>
<parameterdescription>
<para>The amount of ghost cells that will be taking into consideration. Note, even if destbox contains indices outside the domain we need to specify an appropriate ngrow that covers the amount of ghost cells that we want to copy.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dtos</parametername>
</parameternamelist>
<parameterdescription>
<para>An index mapping that maps indices from destination space to source space and from source space to destination space.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">proj</parametername>
</parameternamelist>
<parameterdescription>
<para>A transformation function that might change the data when it is being copied.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the CommMetaData object that can be cached for future calls to ParallelCopy. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="953" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="953" bodyend="958"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1af874a9f4652076f42120db672af7f447" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
            <defval>Identity</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsIndexMapping" kindref="compound">IsIndexMapping</ref>&lt; DTOS &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;), <ref refid="structamrex_1_1NonLocalBC_1_1MultiBlockCommMetaData" kindref="compound">MultiBlockCommMetaData</ref> &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsIndexMapping&lt;DTOS&gt;) &amp;&amp; IsFabProjection&lt;Proj, FAB&gt;),MultiBlockCommMetaData&gt; amrex::NonLocalBC::ParallelCopy</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;dest, const Box &amp;destbox, const FabArray&lt; FAB &gt; &amp;src, int srccomp, int destcomp, int numcomp, const IntVect &amp;ngrow, DTOS const &amp;dtos=DTOS{}, Proj const &amp;proj=Proj{})</argsstring>
        <name>ParallelCopy</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>destbox</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>srccomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>destcomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>numcomp</declname>
        </param>
        <param>
          <type>const <ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> &amp;</type>
          <declname>ngrow</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
          <defval>DTOS{}</defval>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
<para>Call ParallelCopy_nowait followed by ParallelCopy_finish. </para>
        </briefdescription>
        <detaileddescription>
<para>This function constructs a new MultiCommMetaData from the given DTOS, destbox and ngrow.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">dest</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is going to be filled with received data.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">destbox</parametername>
</parameternamelist>
<parameterdescription>
<para>The index box in the destination space that will be filled by data from src. The source box that describes the dependencies will be computed by the specified DTOS.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The Multifab that is used to fill the send buffers.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">srccomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The first component in src that will be copied to dest.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">destcomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The first component in dest that will get written by src.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of successive components that will be copied.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ngrow</parametername>
</parameternamelist>
<parameterdescription>
<para>The amount of ghost cells that will be taking into consideration. Note, even if destbox contains indices outside the domain we need to specify an appropriate ngrow that covers the amount of ghost cells that we want to copy.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dtos</parametername>
</parameternamelist>
<parameterdescription>
<para>An index mapping that maps indices from destination space to source space and from source space to destination space.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">proj</parametername>
</parameternamelist>
<parameterdescription>
<para>A transformation function that might change the data when it is being copied.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns the CommMetaData object that can be cached for future calls to ParallelCopy. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="992" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="992" bodyend="995"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a2d9ef1abd51b6a59a2938c4aefbe3456" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::Rotate90</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, int scomp, int ncomp, IntVect const &amp;nghost, Box const &amp;domain)</argsstring>
        <name>Rotate90</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1004" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1004" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a33354739811ccff59e69722da63a9f5c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::Rotate90</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, Box const &amp;domain)</argsstring>
        <name>Rotate90</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1008" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1008" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a35b23e1690efb2d7f63af0118739d12e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::Rotate180</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, int scomp, int ncomp, IntVect const &amp;nghost, Box const &amp;domain)</argsstring>
        <name>Rotate180</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1015" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1015" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1ad6b5ad1aeccc1b34a6874b4609654e14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::Rotate180</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, Box const &amp;domain)</argsstring>
        <name>Rotate180</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1019" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1019" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a22290d0dc38cd0254f5d14100fec970f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::FillPolar</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, int scomp, int ncomp, IntVect const &amp;nghost, Box const &amp;domain)</argsstring>
        <name>FillPolar</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1027" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1027" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a569fc178d4aad983c5bdd14a8f69127e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FAB</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;::value &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;::value&gt; amrex::NonLocalBC::FillPolar</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, Box const &amp;domain)</argsstring>
        <name>FillPolar</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Box" kindref="compound">Box</ref> const &amp;</type>
          <declname>domain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1031" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1031" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1ab1089b238bcca4ae52a70fd9bdf8518e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;), <ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref> &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3,DTOS,Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj,FAB&gt;), CommHandler&gt; amrex::NonLocalBC::FillBoundary_nowait</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, const FabArrayBase::CommMetaData &amp;cmd, int scomp, int ncomp, DTOS const &amp;dtos, Proj const &amp;proj=Proj{})</argsstring>
        <name>FillBoundary_nowait</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
<para>Start communication to fill boundary. </para>
        </briefdescription>
        <detaileddescription>
<para>This starts communication to fill ghost cells of a <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. This function is supposed to be used together with FillBoundary_finish and makeFillBoundaryMetaData as follows. <verbatim>    auto cmd = makeFillBoundaryMetaData(mf, mf.nGrowVect, geom, dtos);
    // The metadata cmd can be cached and reused on a MultiFab/FabArray with
    // the same BoxArray and DistributionMapping.
    auto handler = FillBoundary_nowait(mf, cmd, scomp, ncomp, dtos, proj);
    // Independent computation can be performed.
    FillBoundary_finish(std::move(handler), mf, cmd, scomp, ncomp, dtos, proj);
</verbatim></para>
<para>The FillBoundary capability here is more flexible than <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&apos;s FillBoundary member functions, which only fill ghost cells inside the domain and ghost cells at periodic boundaries. The FillBoundary here can be used to fill non-local domain boundaries (e.g., in spherical and cylindrical coordinates) given appropriate index and component mappings.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DTOS</parametername>
</parameternamelist>
<parameterdescription>
<para>Index mapping from destination from source. See SphThetaPhiRIndexMapping for an example. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Component mapping from source to destination. See SphThetaPhiRComponentMapping for an example.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>FabArray/MultiFab whose ghost cells need to be filled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>communication metadata. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dtos</parametername>
</parameternamelist>
<parameterdescription>
<para>index mapping. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>component mapping.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref> object needed for calling FillBoundary_finish. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1075" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1075" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1afe22ad727872227b4f95e3dad1e36814" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3,DTOS,Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj,FAB&gt;)&gt; amrex::NonLocalBC::FillBoundary_finish</definition>
        <argsstring>(CommHandler handler, FabArray&lt; FAB &gt; &amp;mf, const FabArrayBase::CommMetaData &amp;cmd, int scomp, int ncomp, DTOS const &amp;dtos, Proj const &amp;proj=Proj{})</argsstring>
        <name>FillBoundary_finish</name>
        <param>
          <type><ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref></type>
          <declname>handler</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
<para>Finish communication started by FillBoundary_nowait. </para>
        </briefdescription>
        <detaileddescription>
<para>This finishes the communication to fill ghost cells of a <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. This function is supposed to be used together with FillBoundary_nowait and makeFillBoundaryMetaData as follows. <verbatim>    auto cmd = makeFillBoundaryMetaData(mf, mf.nGrowVect, geom, dtos);
    // The metadata cmd can be cached and reused on a MultiFab/FabArray with
    // the same BoxArray and DistributionMapping.
    auto handler = FillBoundary_nowait(mf, cmd, scomp, ncomp, dtos, proj);
    // Independent computation can be performed.
    FillBoundary_finish(std::move(handler), mf, cmd, scomp, ncomp, dtos, proj);
</verbatim></para>
<para>The FillBoundary capability here is more flexible than <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&apos;s FillBoundary member functions, which only fill ghost cells inside the domain and ghost cells at periodic boundaries. The FillBoundary here can be used to fill non-local domain boundaries (e.g., in spherical and cylindrical coordinates) given appropriate index and component mappings.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DTOS</parametername>
</parameternamelist>
<parameterdescription>
<para>Index mapping from destination from source. See SphThetaPhiRIndexMapping for an example. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Component mapping from source to destination. See SphThetaPhiRComponentMapping for an example.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handler</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="structamrex_1_1NonLocalBC_1_1CommHandler" kindref="compound">CommHandler</ref> returned by FillBoundary_nowait. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>FabArray/MultiFab whose ghost cells need to be filled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>communication metadata. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dtos</parametername>
</parameternamelist>
<parameterdescription>
<para>index mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>component mapping </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1118" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1118" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1afc89a1b931348146e70b8e54e95ffd41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>Identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;) &amp;&amp;<ref refid="structamrex_1_1NonLocalBC_1_1IsFabProjection" kindref="compound">IsFabProjection</ref>&lt; Proj, FAB &gt;)&gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3,DTOS,Dim3&gt;) &amp;&amp; IsFabProjection&lt;Proj,FAB&gt;)&gt; amrex::NonLocalBC::FillBoundary</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, const FabArrayBase::CommMetaData &amp;cmd, int scomp, int ncomp, DTOS const &amp;dtos, Proj const &amp;proj=Proj{})</argsstring>
        <name>FillBoundary</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type>const <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &amp;</type>
          <declname>cmd</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>scomp</declname>
        </param>
        <param>
          <type><ref refid="namespaceamrex_1ad2e8127753e9be0ebf531435c6511937" kindref="member">int</ref></type>
          <declname>ncomp</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <param>
          <type>Proj const &amp;</type>
          <declname>proj</declname>
          <defval>Proj{}</defval>
        </param>
        <briefdescription>
<para>Fill ghost cells for FabArray/MultiFab. </para>
        </briefdescription>
        <detaileddescription>
<para>This fills ghost cells of a <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>. This function is supposed to be used together with makeFillBoundaryMetaData as follows. <verbatim>    auto cmd = makeFillBoundaryMetaData(mf, mf.nGrowVect, geom, dtos);
    // The metadata cmd can be cached and reused on a MultiFab/FabArray with
    // the same BoxArray and DistributionMapping.
    FillBoundary_finish(mf, cmd, scomp, ncomp, dtos, proj);
</verbatim></para>
<para>The FillBoundary capability here is more flexible than <ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&apos;s FillBoundary member functions, which only fill ghost cells inside the domain and ghost cells at periodic boundaries. The FillBoundary here can be used to fill non-local domain boundaries (e.g., in spherical and cylindrical coordinates) given appropriate index and component mappings.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DTOS</parametername>
</parameternamelist>
<parameterdescription>
<para>Index mapping from destination from source. See SphThetaPhiRIndexMapping for an example. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Component mapping from source to destination. See SphThetaPhiRComponentMapping for an example.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>FabArray/MultiFab whose ghost cells need to be filled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmd</parametername>
</parameternamelist>
<parameterdescription>
<para>communication metadata. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scomp</parametername>
</parameternamelist>
<parameterdescription>
<para>starting component. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ncomp</parametername>
</parameternamelist>
<parameterdescription>
<para>number of components. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dtos</parametername>
</parameternamelist>
<parameterdescription>
<para>index mapping. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>component mapping. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1158" column="1" bodyfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" bodystart="1158" bodyend="1164"/>
      </memberdef>
      <memberdef kind="function" id="namespaceamrex_1_1NonLocalBC_1a273df272494afdcf1d9275ab5ed13e77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FAB</type>
          </param>
          <param>
            <type>typename DTOS</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; <ref refid="structamrex_1_1IsBaseFab" kindref="compound">IsBaseFab</ref>&lt; FAB &gt;) &amp;&amp;<ref refid="structamrex_1_1IsCallableR" kindref="compound">IsCallableR</ref>&lt; <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref>, DTOS, <ref refid="structamrex_1_1Dim3" kindref="compound">Dim3</ref> &gt;), <ref refid="structamrex_1_1FabArrayBase_1_1CommMetaData" kindref="compound">FabArrayBase::CommMetaData</ref> &gt;</type>
        <definition>std::enable_if_t&lt;IsBaseFab&lt;FAB&gt;) &amp;&amp; IsCallableR&lt;Dim3,DTOS,Dim3&gt;), FabArrayBase::CommMetaData&gt; amrex::NonLocalBC::makeFillBoundaryMetaData</definition>
        <argsstring>(FabArray&lt; FAB &gt; &amp;mf, IntVect const &amp;nghost, Geometry const &amp;geom, DTOS const &amp;dtos)</argsstring>
        <name>makeFillBoundaryMetaData</name>
        <param>
          <type><ref refid="classamrex_1_1FabArray" kindref="compound">FabArray</ref>&lt; FAB &gt; &amp;</type>
          <declname>mf</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1IntVect" kindref="compound">IntVect</ref> const &amp;</type>
          <declname>nghost</declname>
        </param>
        <param>
          <type><ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> const &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type>DTOS const &amp;</type>
          <declname>dtos</declname>
        </param>
        <briefdescription>
<para>Make metadata for FillBoundary. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>FAB</parametername>
</parameternamelist>
<parameterdescription>
<para>MultiFab/FabArray type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>DTOS</parametername>
</parameternamelist>
<parameterdescription>
<para>Index mapping from destination from source. See SphThetaPhiRIndexMapping for an example.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mf</parametername>
</parameternamelist>
<parameterdescription>
<para>FabArray/MultiFab whose ghost cells need to be filled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nghost</parametername>
</parameternamelist>
<parameterdescription>
<para>number of ghost cells to be filled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>geom</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classamrex_1_1Geometry" kindref="compound">Geometry</ref> object that contains the domain information. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dtos</parametername>
</parameternamelist>
<parameterdescription>
<para>index mapping.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>communication metadata </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" line="1184" column="1" declfile="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.H" declline="1184" declcolumn="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/runner/work/amrex/amrex/Src/Base/AMReX_NonLocalBC.cpp" line="3" column="1"/>
  </compounddef>
</doxygen>
